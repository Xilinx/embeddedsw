<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>axicdma: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">axicdma
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Overview</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">axicdma Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the driver API for the AXI CDMA engine. For a full description of the features of the AXI CDMA engine, please refer to the hardware specification. This driver supports the following features:</p>
<ul>
<li>Simple DMA transfer</li>
<li>Scatter gather (SG) DMA transfer</li>
<li>Interrupt for error or completion of transfers</li>
<li>For SG DMA transfer:<ul>
<li>Programmable interrupt coalescing</li>
<li>Programmable delay timer counter</li>
<li>Managing the buffer descriptors (BDs)</li>
</ul>
</li>
</ul>
<p><b>Two Hardware Building Modes</b></p>
<p>The hardware can be built in two modes:</p>
<ul>
<li><b>Simple only mode</b>, in this mode, only simple transfers are supported by the hardware. The functionality is similar to the XPS Central DMA, however, the driver API to do the transfer is slightly different.</li>
<li><b>Hybrid mode</b>, in this mode, the hardware supports both the simple transfer and the SG transfer. However, only one kind of transfer can be active at a time. If an SG transfer is ongoing in the hardware, a submission of a simple transfer fails. If a simple transfer is ongoing in the hardware, a submission of an SG transfer is successful, however the SG transfer will not start until the simple transfer is done.</li>
</ul>
<p><b>Transactions</b></p>
<p>The hardware supports two types of transfers, the simple DMA transfer and the scatter gather (SG) DMA transfer.</p>
<p>A simple DMA transfer only needs source buffer address, destination buffer address and transfer length to do a DMA transfer. Only one transfer can be submitted to the hardware at a time.</p>
<p>A SG DMA transfer requires setting up a buffer descriptor (BD), which keeps the transfer information, including source buffer address, destination buffer address, and transfer length. The hardware updates the BD for the completion status of the transfer. BDs that are connected to each other can be submitted to the hardware at once, therefore, the SG DMA transfer has better performance when the application is doing multiple transfers each time.</p>
<p><b>Callback Function</b></p>
<p>Each transfer, for which the application cares about its completion, should provide with the driver its callback function. The signature of the callback function is as the following:</p>
<p>void XAxiCdma_CallBackFn(void *CallBackRef, u32 IrqMask, int *NumPtr);</p>
<p>Where the CallBackRef is a reference pointer that the application passes to the driver along with the callback function. The driver passes IrqMask to the application when it calls this callback. The NumPtr is only used in SG mode to track how many BDs still left for this callback function.</p>
<p>The callback function is set upon transfer submission:</p>
<ul>
<li><p class="startli">Simple transfer callback function setup:</p>
<p class="startli"><b>Only set the callback function if in interrupt mode.</b></p>
<p class="startli">For simple transfers, the callback function along with the callback reference pointer is passed to the driver through the submission of the simple transfer: </p>
<pre class="fragment"> XAxiCdma_SimpleTransfer(...)
</pre></li>
<li>SG transfer callback function setup: For SG transfers, the callback function and the callback reference pointer are set through the transfer submission call: <pre class="fragment"> XAxiCdma_BdRingToHw(...)
</pre></li>
</ul>
<p><b>Simple Transfers</b></p>
<p>For an application that only does one DMA transfer at a time, and the DMA engine is exclusively used by this application, simple DMA transfer is sufficient.</p>
<p>Using the simple DMA transfer has the advantage of ease of use comparing to SG DMA transfer. For an individual DMA transfer, simple DMA transfer is also faster because of simplicity in software and hardware.</p>
<p><b>Scatter Gather (SG) Transfers</b></p>
<p>For an application that has multiple DMA transfers sometimes, or the DMA engine is shared by multiple applications, using SG DMA transfer yields better performance over all applications.</p>
<p>The SG DMA transfer provides queuing of multiple transfers, therefore, it provides better performance because the hardware can continuously work on all submitted transfers without software intervention.</p>
<p>The down side of using the SG DMA transfer is that you have to manage the memory for the buffer descriptors (BD), and setup BDs for the transfers.</p>
<p><b>Interrupts</b></p>
<p>The driver handles the interrupts.</p>
<p>The completion of a transfer, that has a callback function associated with, will trigger the driver to call the callback function. The IrqMask that is passed through the callback function notifies the application about the completion status of the transfer.</p>
<p><b>Interrupt Coalescing for SG Transfers</b></p>
<p>For SG transfers, the application can program the interrupt coalescing threshold to reduce the frequency of interrupts. If the number of transfers does not match well with the interrupt coalescing threshold, the completion of the last transfer will not trigger the completion interrupt. However, after the specified delay count time, the delay interrupt will fire.</p>
<p>By default, the interrupt threshold for the hardware is one, which is one interrupt per BD completion.</p>
<p><b>Delay Interrupt for SG Transfers</b></p>
<p>Delay interrupt is to signal the application about inactivity of transfers. If the delay interrupt is enabled, the delay timer starts counting down once a transfer has started. If the interval between transfers is longer than the delay counter, the delay interrupt is fired.</p>
<p>By default, the delay counter is zero, which means the delay interrupt is disabled. To enable delay interrupt, the delay interrupt enable bit must be set and the delay counter must be set to a value between 1 to 255.</p>
<p><b>BD management for SG DMA Transfers </b></p>
<p>BD is shared by the software and the hardware. To use BD for SG DMA transfers, the application needs to use the driver API to do the following:</p>
<ul>
<li><p class="startli">Setup the BD ring:</p>
<ul>
<li>XAxiCdma_BdRingCreate(...)</li>
</ul>
<p class="startli">Note that the memory for the BD ring is allocated and is later de-allocated by the application.</p>
</li>
<li>Request BD from the BD ring, more than one BDs can be requested at once:<ul>
<li>XAxiCdma_BdRingAlloc(...)</li>
</ul>
</li>
<li>Prepare BDs for the transfer, one BD at a time:<ul>
<li>XAxiCdma_BdSetSrcBufAddr(...)</li>
<li>XAxiCdma_BdSetDstBufAddr(...)</li>
<li>XAxiCdma_BdSetLength(...)</li>
</ul>
</li>
<li>Submit all prepared BDs to the hardware:<ul>
<li>XAxiCdma_BdRingToHw(...)</li>
</ul>
</li>
<li>Upon transfer completion, the application can request completed BDs from the hardware:<ul>
<li>XAxiCdma_BdRingFromHw(...)</li>
</ul>
</li>
<li>After the application has finished using the BDs, it should free the BDs back to the free pool:<ul>
<li>XAxiCdma_BdRingFree(...)</li>
</ul>
</li>
</ul>
<p>The driver also provides API functions to get the status of a completed BD, along with get functions for other fields in the BD.</p>
<p>The following two diagrams show the correct flow of BDs:</p>
<p>The first diagram shows a complete cycle for BDs, starting from requesting the BDs to freeing the BDs. </p>
<pre></pre><pre>         <a class="el" href="group__axicdma__v4__10.html#ga27dd0cdc27b7a724533db75336c4acc6" title="This function requests number of BDs from the BD ring. ">XAxiCdma_BdRingAlloc()</a>                   <a class="el" href="group__axicdma__v4__10.html#ga3c5cd26d9fd3311c2ccfa4253c587e68" title="This function tries to enqueue the number of BDs to the hardware. ">XAxiCdma_BdRingToHw()</a>
 Free ------------------------&gt; Pre-process ----------------------&gt; Hardware
                                                                    |
  /|\                                                               |
   |   <a class="el" href="group__axicdma__v4__10.html#gab204e3f92e4edd3865ecf6b344f0b864" title="This function returns the BDs back to the free pool of the BD ring. ">XAxiCdma_BdRingFree()</a>                <a class="el" href="group__axicdma__v4__10.html#gafce6a8283bdec8b9c35169c7cd29f4dc" title="This function tries to retrieve completed BDs from the hardware. ">XAxiCdma_BdRingFromHw()</a> |
   +--------------------------- Post-process &lt;----------------------+</pre><pre> </pre><p>The second diagram shows when a DMA transfer is to be cancelled before enqueuing to the hardware, application can return the requested BDs to the free group using <a class="el" href="group__axicdma__v4__10.html#ga9be6e4072c2a17f4519ffa9f9ec3332f" title="This function tries to free the number of BDs back to the ring. ">XAxiCdma_BdRingUnAlloc()</a>. </p>
<pre></pre><pre>         <a class="el" href="group__axicdma__v4__10.html#ga9be6e4072c2a17f4519ffa9f9ec3332f" title="This function tries to free the number of BDs back to the ring. ">XAxiCdma_BdRingUnAlloc()</a>
   Free &lt;----------------------- Pre-process</pre><pre> </pre><p><b>Physical/Virtual Addresses</b></p>
<p>Addresses for the transfer buffers are physical addresses.</p>
<p>For SG transfers, the next BD pointer in a BD is also a physical address.</p>
<p>However, application's reference to a BD and to the transfer buffers are through virtual addresses.</p>
<p>The application is responsible to translate the virtual addresses of its transfer buffers to physical addresses before handing them to the driver.</p>
<p>For systems where MMU is not used, or MMU is a direct mapping, then the physical address and the virtual address are the same.</p>
<p><b>Cache Coherency</b></p>
<p>To prevent cache and memory inconsistency:</p>
<ul>
<li>Flush the transmit buffer range before the transfer</li>
<li>Invalidate the receive buffer range before passing it to the hardware and before passing it to the application</li>
</ul>
<p>For SG transfers:</p>
<ul>
<li>Flush the BDs once the preparation setup is done</li>
<li>Invalidate the memory region for BDs when BDs are retrieved from the hardware.</li>
</ul>
<p><b>BD alignment for SG Transfers</b></p>
<p>The hardware has requirement for the minimum alignment of the BDs, XAXICDMA_BD_MINIMUM_ALIGNMENT. It is OK to have an alignment larger than the required minimum alignment, however, it must be multiple of the minimum alignment. The alignment is passed into <a class="el" href="group__axicdma__v4__10.html#gab36598e09c09ffa680b6c0f207baf9f5" title="This function creates the BD ring for the driver instance. ">XAxiCdma_BdRingCreate()</a>.</p>
<p><b>Error Handling</b></p>
<p>The hardware halts upon all error conditions. The driver will reset the hardware once the error occurs.</p>
<p>The IrqMask argument in the callback function notifies the application about error conditions for the transfer.</p>
<p><b>Mutual Exclusion</b></p>
<p>The driver does not provide mutual exclusion mechanisms, it is up to the upper layer to handle this.</p>
<p><b>Hardware Defaults &amp; Exclusive Use</b></p>
<p>The hardware is in the following condition on start or after a reset:</p>
<ul>
<li>All interrupts are disabled.</li>
<li>The engine is in simple mode.</li>
<li>Interrupt coalescing counter is one.</li>
<li>Delay counter is 0.</li>
</ul>
<p>The driver has exclusive use of the hardware registers and BDs. Accessing the hardware registers or the BDs should always go through the driver API functions.</p>
<p><b>Hardware Features That User Should Be Aware of</b></p>
<p>For performance reasons, the driver does not check the submission of transfers during run time. It is the user's responsibility to submit approrpiate transfers to the hardware. The following hardware features should be considerred when submitting a transfer:</p>
<p>. Whether the hardware supports unaligned transfers, reflected through C_INCLUDE_DRE in system.mhs file. Submitting unaligned transfers while the hardware does not support it, causes errors upon transfer submission. Aligned transfer is in respect to word length, and word length is defined through the building parameter XPAR_AXI_CDMA_0_M_AXI_DATA_WIDTH.</p>
<p>. Memory range of the transfer addresses. Transfer data to executable memory can crash the system.</p>
<p>. Lite mode. To save hardware resources (drastically), you may select "lite" mode build of the hardware. However, with lite mode, the following features are <em>not</em> supported:</p>
<ul>
<li>Cross page boundary transfer. Each transfer must be restrictly inside one page; otherwise, slave error occurs.</li>
<li>Unaligned transfer.</li>
<li>Data width larger than 64 bit</li>
<li>Maximum transfer length each time is limited to data_width * burst_len</li>
</ul>
<pre>
 MODIFICATION HISTORY:</pre><pre>  . Updated the debug print on type casting to avoid warnings on u32. Cast
    u32 to (unsigned int) to use the x format.</pre><pre> Ver   Who  Date     Changes
</p>
<hr/>
<p>
 1.00a jz   07/08/10 First release
 2.01a rkv  01/25/11 Added TCL script to generate Test App code for peripheral
                       tests.
                       Replaced with "\r\n" in place on "\n\r" in printf
                       statements. Made some minor modifications for Doxygen
 2.02a srt  01/18/13 Added support for Key Hole feature (CR: 687217).
                       Updated DDR base address for IPI designs (CR 703656).
 2.03a srt  04/13/13 Removed Warnings (CR 705006).
                       Added logic to check if DDR is present in the test app
                       tcl file. (CR 700806)
 3.0   adk  19/12/13 Updated as per the New Tcl API's
 4.0     adk  27/07/15 Added support for 64-bit Addressing.
 4.1   sk   11/10/15 Used UINTPTR instead of u32 for Baseaddress CR# 867425.
                     Changed the prototype of XAxiCdma_CfgInitialize API.
 4.3   mi   09/21/16 Fixed compilation warnings.
       ms   01/22/17 Modified xil_printf statement in main function for all
            examples to ensure that "Successfully ran" and "Failed" strings
            are available in all examples. This is a fix for CR-965028.
       ms   03/17/17 Added readme.txt file in examples folder for doxygen
                     generation.
       ms   04/05/17 Modified Comment lines in functions of axicdma
                     examples to recognize it as documentation block
                     for doxygen generation of examples.
 4.10  sa   08/12/22 Updated the examples to use latest MIG cannoical define
                       i.e XPAR_MIG_0_C0_DDR4_MEMORY_MAP_BASEADDR.
 </pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
