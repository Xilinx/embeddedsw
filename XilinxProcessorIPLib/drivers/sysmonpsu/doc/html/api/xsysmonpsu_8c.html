<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>sysmonpsu: xsysmonpsu.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">sysmonpsu
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xsysmonpsu_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xsysmonpsu.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8cd0584410c0931f931aa4da1e3e151b"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, <a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr class="memdesc:a8cd0584410c0931f931aa4da1e3e151b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> device/instance.  <a href="#a8cd0584410c0931f931aa4da1e3e151b"></a><br/></td></tr>
<tr class="separator:a8cd0584410c0931f931aa4da1e3e151b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fc9daa41e50955a71e2fe7a107a0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#ad6fc9daa41e50955a71e2fe7a107a0e5">XSysMonPsu_Reset</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:ad6fc9daa41e50955a71e2fe7a107a0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the SystemMonitor.  <a href="#ad6fc9daa41e50955a71e2fe7a107a0e5"></a><br/></td></tr>
<tr class="separator:ad6fc9daa41e50955a71e2fe7a107a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1841bc7888195dd3f9381947e4f8d3"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a5e1841bc7888195dd3f9381947e4f8d3">XSysMonPsu_GetStatus</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a5e1841bc7888195dd3f9381947e4f8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the contents of the Status Register.  <a href="#a5e1841bc7888195dd3f9381947e4f8d3"></a><br/></td></tr>
<tr class="separator:a5e1841bc7888195dd3f9381947e4f8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed2a9f0fbd1be48dfd71aaeef05174f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a2ed2a9f0fbd1be48dfd71aaeef05174f">XSysMonPsu_StartAdcConversion</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:a2ed2a9f0fbd1be48dfd71aaeef05174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts the ADC conversion in the Single Channel event driven sampling mode.  <a href="#a2ed2a9f0fbd1be48dfd71aaeef05174f"></a><br/></td></tr>
<tr class="separator:a2ed2a9f0fbd1be48dfd71aaeef05174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eb6ba4c6f594b75d402cde03f6e173"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 Block)</td></tr>
<tr class="memdesc:a54eb6ba4c6f594b75d402cde03f6e173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ADC converted data for the specified channel.  <a href="#a54eb6ba4c6f594b75d402cde03f6e173"></a><br/></td></tr>
<tr class="separator:a54eb6ba4c6f594b75d402cde03f6e173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83bb4ad116f2bb1ea7676050bd74b6b"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#af83bb4ad116f2bb1ea7676050bd74b6b">XSysMonPsu_GetCalibCoefficient</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 CoeffType, u32 SysmonBlk)</td></tr>
<tr class="memdesc:af83bb4ad116f2bb1ea7676050bd74b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the calibration coefficient data for the specified parameter.  <a href="#af83bb4ad116f2bb1ea7676050bd74b6b"></a><br/></td></tr>
<tr class="separator:af83bb4ad116f2bb1ea7676050bd74b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4312c89ab0280cd7df2de940193fe32"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 MeasurementType, u32 SysmonBlk)</td></tr>
<tr class="memdesc:aa4312c89ab0280cd7df2de940193fe32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the Minimum/Maximum measurement for one of the XSM_MIN_* or XSM_MAX_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>.  <a href="#aa4312c89ab0280cd7df2de940193fe32"></a><br/></td></tr>
<tr class="separator:aa4312c89ab0280cd7df2de940193fe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711d9441ecb7c36f22b11f941d7f994b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a711d9441ecb7c36f22b11f941d7f994b">XSysMonPsu_SetAvg</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Average, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a711d9441ecb7c36f22b11f941d7f994b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the number of samples of averaging that is to be done for all the channels in both the single channel mode and sequence mode of operations.  <a href="#a711d9441ecb7c36f22b11f941d7f994b"></a><br/></td></tr>
<tr class="separator:a711d9441ecb7c36f22b11f941d7f994b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d99a653ec8c8089e8cdc9e4f400dc3"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a78d99a653ec8c8089e8cdc9e4f400dc3">XSysMonPsu_GetAvg</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a78d99a653ec8c8089e8cdc9e4f400dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the number of samples of averaging configured for all the channels in the Configuration Register 0.  <a href="#a78d99a653ec8c8089e8cdc9e4f400dc3"></a><br/></td></tr>
<tr class="separator:a78d99a653ec8c8089e8cdc9e4f400dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872e9a41818489e77fa554dd01408281"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 IncreaseAcqCycles, u32 IsEventMode, u32 IsDifferentialMode, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a872e9a41818489e77fa554dd01408281"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the given parameters in the Configuration Register 0 in the single channel mode.  <a href="#a872e9a41818489e77fa554dd01408281"></a><br/></td></tr>
<tr class="separator:a872e9a41818489e77fa554dd01408281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8ca01b6992994737213f342847662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a3ce8ca01b6992994737213f342847662">XSysMonPsu_SetAlarmEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 AlmEnableMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a3ce8ca01b6992994737213f342847662"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the alarm outputs for the specified alarms in the Configuration Registers 1:  <a href="#a3ce8ca01b6992994737213f342847662"></a><br/></td></tr>
<tr class="separator:a3ce8ca01b6992994737213f342847662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c38e475226ff1eba528d0c9b7eb9b5"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#ab1c38e475226ff1eba528d0c9b7eb9b5">XSysMonPsu_GetAlarmEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:ab1c38e475226ff1eba528d0c9b7eb9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of the alarm output enables in the Configuration Register 1.  <a href="#ab1c38e475226ff1eba528d0c9b7eb9b5"></a><br/></td></tr>
<tr class="separator:ab1c38e475226ff1eba528d0c9b7eb9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bdb4e555b2c8d47a0185862c9cb4c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#aa4bdb4e555b2c8d47a0185862c9cb4c6">XSysMonPsu_SetSequencerMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 SequencerMode, u32 SysmonBlk)</td></tr>
<tr class="memdesc:aa4bdb4e555b2c8d47a0185862c9cb4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the specified Channel Sequencer Mode in the Configuration Register 1 :  <a href="#aa4bdb4e555b2c8d47a0185862c9cb4c6"></a><br/></td></tr>
<tr class="separator:aa4bdb4e555b2c8d47a0185862c9cb4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2d5053a1406cecd4fa311525f68ce7"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a2f2d5053a1406cecd4fa311525f68ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the channel sequencer mode from the Configuration Register 1.  <a href="#a2f2d5053a1406cecd4fa311525f68ce7"></a><br/></td></tr>
<tr class="separator:a2f2d5053a1406cecd4fa311525f68ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193dbc689e9a668ef7f548920706b2a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a193dbc689e9a668ef7f548920706b2a8">XSysMonPsu_SetSequencerEvent</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 IsEventMode, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a193dbc689e9a668ef7f548920706b2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the Event mode or Continuous mode in the sequencer mode.  <a href="#a193dbc689e9a668ef7f548920706b2a8"></a><br/></td></tr>
<tr class="separator:a193dbc689e9a668ef7f548920706b2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b98e18bb6c2c8b3587e2fe2cffde8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a6a0b98e18bb6c2c8b3587e2fe2cffde8">XSysMonPsu_GetSequencerEvent</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a6a0b98e18bb6c2c8b3587e2fe2cffde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the mode of the sequencer.  <a href="#a6a0b98e18bb6c2c8b3587e2fe2cffde8"></a><br/></td></tr>
<tr class="separator:a6a0b98e18bb6c2c8b3587e2fe2cffde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4903002cdddf192acdcda4827e5b1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 SysmonBlk)</td></tr>
<tr class="memdesc:ab4903002cdddf192acdcda4827e5b1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the external mux and connects a channel to the mux.  <a href="#ab4903002cdddf192acdcda4827e5b1a6"></a><br/></td></tr>
<tr class="separator:ab4903002cdddf192acdcda4827e5b1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3ad732967594b6cc1cc314e24ae9b0"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a5e3ad732967594b6cc1cc314e24ae9b0">XSysMonPsu_GetExtenalMux</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a5e3ad732967594b6cc1cc314e24ae9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the external mux channel.  <a href="#a5e3ad732967594b6cc1cc314e24ae9b0"></a><br/></td></tr>
<tr class="separator:a5e3ad732967594b6cc1cc314e24ae9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e8fc0b9dffbe33b41ec4e6825ffc4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a11e8fc0b9dffbe33b41ec4e6825ffc4a">XSysMonPsu_SetAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Divisor, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a11e8fc0b9dffbe33b41ec4e6825ffc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the frequency of the ADCCLK by configuring the DCLK to ADCCLK ratio in the Configuration Register #2.  <a href="#a11e8fc0b9dffbe33b41ec4e6825ffc4a"></a><br/></td></tr>
<tr class="separator:a11e8fc0b9dffbe33b41ec4e6825ffc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c7d46d66608863cf7b859238e44e13"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#af6c7d46d66608863cf7b859238e44e13">XSysMonPsu_GetAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:af6c7d46d66608863cf7b859238e44e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function gets the ADCCLK divisor from the Configuration Register 2.  <a href="#af6c7d46d66608863cf7b859238e44e13"></a><br/></td></tr>
<tr class="separator:af6c7d46d66608863cf7b859238e44e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c7ebcfb5e5e7014deaabaa8f6261eb"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a15c7ebcfb5e5e7014deaabaa8f6261eb">XSysMonPsu_UpdateAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a15c7ebcfb5e5e7014deaabaa8f6261eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function update the ADCCLK divisor to the Configuration Register 2.  <a href="#a15c7ebcfb5e5e7014deaabaa8f6261eb"></a><br/></td></tr>
<tr class="separator:a15c7ebcfb5e5e7014deaabaa8f6261eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51295c525a507a8f334c97f02a84221"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#ac51295c525a507a8f334c97f02a84221">XSysMonPsu_SetSeqChEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 ChEnableMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:ac51295c525a507a8f334c97f02a84221"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the specified channels in the ADC Channel Selection Sequencer Registers.  <a href="#ac51295c525a507a8f334c97f02a84221"></a><br/></td></tr>
<tr class="separator:ac51295c525a507a8f334c97f02a84221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d0525934fbe21b46732c039f93a8b0"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a08d0525934fbe21b46732c039f93a8b0">XSysMonPsu_GetSeqChEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a08d0525934fbe21b46732c039f93a8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the channel enable bits status from the ADC Channel Selection Sequencer Registers.  <a href="#a08d0525934fbe21b46732c039f93a8b0"></a><br/></td></tr>
<tr class="separator:a08d0525934fbe21b46732c039f93a8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb114566387fa8889b913f34a7de6010"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#adb114566387fa8889b913f34a7de6010">XSysMonPsu_SetSeqAvgEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 AvgEnableChMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:adb114566387fa8889b913f34a7de6010"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the averaging for the specified channels in the ADC Channel Averaging Enable Sequencer Registers.  <a href="#adb114566387fa8889b913f34a7de6010"></a><br/></td></tr>
<tr class="separator:adb114566387fa8889b913f34a7de6010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0cf3c7c355471f81fe60d663043e7b"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#adf0cf3c7c355471f81fe60d663043e7b">XSysMonPsu_GetSeqAvgEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:adf0cf3c7c355471f81fe60d663043e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the channels for which the averaging has been enabled in the ADC Channel Averaging Enables Sequencer Registers.  <a href="#adf0cf3c7c355471f81fe60d663043e7b"></a><br/></td></tr>
<tr class="separator:adf0cf3c7c355471f81fe60d663043e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b751279110ca4a05073ae8a9b8a1a8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#ae6b751279110ca4a05073ae8a9b8a1a8">XSysMonPsu_SetSeqInputMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 InputModeChMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:ae6b751279110ca4a05073ae8a9b8a1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Analog input mode for the specified channels in the ADC Channel Analog-Input Mode Sequencer Registers.  <a href="#ae6b751279110ca4a05073ae8a9b8a1a8"></a><br/></td></tr>
<tr class="separator:ae6b751279110ca4a05073ae8a9b8a1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e597e2db96739d90195d9ad019377c4"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a2e597e2db96739d90195d9ad019377c4">XSysMonPsu_GetSeqInputMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a2e597e2db96739d90195d9ad019377c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the Analog input mode for all the channels from the ADC Channel Analog-Input Mode Sequencer Registers.  <a href="#a2e597e2db96739d90195d9ad019377c4"></a><br/></td></tr>
<tr class="separator:a2e597e2db96739d90195d9ad019377c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe5ce3d9e15f0bebdab313decf9729c"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#acfe5ce3d9e15f0bebdab313decf9729c">XSysMonPsu_SetSeqAcqTime</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 AcqCyclesChMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:acfe5ce3d9e15f0bebdab313decf9729c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the number of Acquisition cycles in the ADC Channel Acquisition Time Sequencer Registers.  <a href="#acfe5ce3d9e15f0bebdab313decf9729c"></a><br/></td></tr>
<tr class="separator:acfe5ce3d9e15f0bebdab313decf9729c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8261ca6ec1564b9066f858adbd81a85f"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a8261ca6ec1564b9066f858adbd81a85f">XSysMonPsu_GetSeqAcqTime</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a8261ca6ec1564b9066f858adbd81a85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of acquisition time from the ADC Channel Acquisition Time Sequencer Registers.  <a href="#a8261ca6ec1564b9066f858adbd81a85f"></a><br/></td></tr>
<tr class="separator:a8261ca6ec1564b9066f858adbd81a85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d436ab807a561d70339cdfe52f6f560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 AlarmThrReg, u16 Value, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a6d436ab807a561d70339cdfe52f6f560"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions sets the contents of the given Alarm Threshold Register.  <a href="#a6d436ab807a561d70339cdfe52f6f560"></a><br/></td></tr>
<tr class="separator:a6d436ab807a561d70339cdfe52f6f560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708bc2465a24743784ce6119bc05b10a"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 AlarmThrReg, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a708bc2465a24743784ce6119bc05b10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the contents of the specified Alarm Threshold Register.  <a href="#a708bc2465a24743784ce6119bc05b10a"></a><br/></td></tr>
<tr class="separator:a708bc2465a24743784ce6119bc05b10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118f51203c23bf2ed1f76d154e46ad3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#a118f51203c23bf2ed1f76d154e46ad3c">XSysMonPsu_SetPSAutoConversion</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:a118f51203c23bf2ed1f76d154e46ad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the conversion to be automatic for PS SysMon.  <a href="#a118f51203c23bf2ed1f76d154e46ad3c"></a><br/></td></tr>
<tr class="separator:a118f51203c23bf2ed1f76d154e46ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f2fde294e151e5db65822b26f11a4f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8c.html#ad9f2fde294e151e5db65822b26f11a4f">XSysMonPsu_GetMonitorStatus</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:ad9f2fde294e151e5db65822b26f11a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the AMS monitor status.  <a href="#ad9f2fde294e151e5db65822b26f11a4f"></a><br/></td></tr>
<tr class="separator:ad9f2fde294e151e5db65822b26f11a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8cd0584410c0931f931aa4da1e3e151b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> device/instance. </p>
<p>This function must be called prior to using the System Monitor device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">ConfigPtr</td><td>points to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> device configuration structure. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory address space. If the address translation is not used then the physical address is passed. Unexpected errors may occur if the address mapping is changed after this function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The user needs to first call the <a class="el" href="xsysmonpsu_8h.html#a948f08280b6195869015382d92ba8a50" title="This function looks for the device configuration based on the unique device ID.">XSysMonPsu_LookupConfig()</a> API which returns the Configuration structure pointer which is passed as a parameter to the <a class="el" href="xsysmonpsu_8c.html#a8cd0584410c0931f931aa4da1e3e151b" title="This function initializes XSysMonPsu device/instance.">XSysMonPsu_CfgInitialize()</a> API. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu___config.html#abc6dabd175ea52cdf0dbf5b32798f62d">XSysMonPsu_Config::DeviceId</a>, <a class="el" href="struct_x_sys_mon_psu___config.html#a7ff0bfe3d5f7cb06792fe7ed481711ad">XSysMonPsu_Config::InputClockMHz</a>, <a class="el" href="struct_x_sys_mon_psu.html#aa71eec0e2a0e06244feded448d359278">XSysMonPsu::IsPlAccessibleByPs</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a7c41996bf95cd7119dba302246345a9d">XSysMonPsu_IntrClear()</a>, <a class="el" href="xsysmonpsu_8h.html#a3ef44a74426b13480363747a5dedc5d0">XSysMonPsu_IntrGetStatus()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4107b908b0a66ed314fa19c9458e10dd">XSYSMONPSU_PL_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu_8c.html#ad6fc9daa41e50955a71e2fe7a107a0e5">XSysMonPsu_Reset()</a>, and <a class="el" href="xsysmonpsu_8c.html#a15c7ebcfb5e5e7014deaabaa8f6261eb">XSysMonPsu_UpdateAdcClkDivisor()</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="af6c7d46d66608863cf7b859238e44e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function gets the ADCCLK divisor from the Configuration Register 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XSysMon instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The divisor read from the Configuration Register 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5a77bafe25ef83d49e8091cbe661d974">XSYSMONPSU_CFG_REG2_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a54eb6ba4c6f594b75d402cde03f6e173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetAdcData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ADC converted data for the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number. Use the XSM_CH_* defined in the file <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>. The valid channels for PS / PL SysMon are 0 - 6, 8 - 10 and 13 - 37. For AMS, 38 - 53 channels are valid. </td></tr>
    <tr><td class="paramname">Block</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block or the AMS controller register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the ADC converted data for the specified channel. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please make sure that the proper channel number is passed. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a15ea4b9f08ee9dc44fc000384ca36e42">XSM_CH_GAINERR_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ae411c55817a64b2351271181ebdae254">XSM_CH_RESERVE1</a>, <a class="el" href="xsysmonpsu_8h.html#a7c4df26dc69ef41921c484fd3ccc006c">XSM_CH_SUPPLY3</a>, <a class="el" href="xsysmonpsu_8h.html#a2939dda6d5c6efbcf10977c6b33aa7fb">XSM_CH_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#aba50e39946a244f7565b8d15c3ffabb8">XSM_CH_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#a3fdb14478def5283880cd4d65dfaf56f">XSM_CH_SUPPLY_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ace8eebd74607658044e98c7b5ca1c0c6">XSM_CH_TEMP_REMTE</a>, <a class="el" href="xsysmonpsu_8h.html#a367867d9ef353a759eb5d33620bffed4">XSM_CH_VCC_PSLL0</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1c38e475226ff1eba528d0c9b7eb9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetAlarmEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of the alarm output enables in the Configuration Register 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is the bit-mask of the enabled alarm outputs in the Configuration Register 1. Use the masks XSYSMONPSU_CFG_REG1_ALRM_*_MASK masks defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to interpret the returned value.</dd></dl>
<p>Bit positions of 1 indicate that the alarm output is enabled. Bit positions of 0 indicate that the alarm output is disabled.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that alarms for the bit positions of 1 will be disabled and alarms for bit positions of 0 will be enabled. The enabled alarm outputs returned by this function is the negated value of the the data read from the Configuration Register 1. Upper 16 bits of return value are valid only if the channel selected is PS. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a708bc2465a24743784ce6119bc05b10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetAlarmThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>AlarmThrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the contents of the specified Alarm Threshold Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlarmThrReg</td><td>is the index of an Alarm Threshold Register to be read. Use XSM_ATR_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to specify the index. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the contents of the selected Alarm Threshold Register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9cd13eee75fe9d48b9d004652cb12e1f">XSM_ATR_SUP7_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#a9b816bc88f59e9b497fa66f336babd99">XSM_ATR_TEMP_RMTE_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#ad1eb3b0945f7c93a178c67fe0bb66d9f">XSM_ATR_TEMP_RMTE_UPPER</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a531009f056913bfecb5b591d9f91385c">XSYSMONPSU_ALRM_TEMP_UPR_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__selftest_8c.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a78d99a653ec8c8089e8cdc9e4f400dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetAvg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the number of samples of averaging configured for all the channels in the Configuration Register 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The averaging read from the Configuration Register 0 is returned. Use the XSM_AVG_* bit definitions defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> file to interpret the returned value :<ul>
<li>XSM_AVG_0_SAMPLES means no averaging</li>
<li>XSM_AVG_16_SAMPLES means 16 samples of averaging</li>
<li>XSM_AVG_64_SAMPLES means 64 samples of averaging</li>
<li>XSM_AVG_256_SAMPLES means 256 samples of averaging</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="af83bb4ad116f2bb1ea7676050bd74b6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetCalibCoefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>CoeffType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the calibration coefficient data for the specified parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">CoeffType</td><td>specifies the calibration coefficient to be read. Use XSM_CALIB_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to specify the calibration coefficient to be read. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the calibration coefficient. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a173a9675e7f812b837aab6cf61457b6d">XSM_CALIB_GAIN_ERROR_COEFF</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a2177cbc8b73be4ce1c76ba03c674e5d6">XSYSMONPSU_CAL_SUP_OFF_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a5e3ad732967594b6cc1cc314e24ae9b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetExtenalMux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the external mux channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the channel number used to connect to the external Mux. The valid channels are 0 to 6, 8 to 16, and 31 to 36..</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="aa4312c89ab0280cd7df2de940193fe32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetMinMaxMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>MeasurementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the Minimum/Maximum measurement for one of the XSM_MIN_* or XSM_MAX_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">MeasurementType</td><td>specifies the parameter for which the Minimum/Maximum measurement has to be read. Use XSM_MAX_* and XSM_MIN_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to specify the data to be read. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the maximum/minimum measurement for specified parameter. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of 16 bit data read from the device. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9e519a87a8d9330083e59826065eb259">XSM_MAX_SUPPLY6</a>, <a class="el" href="xsysmonpsu_8h.html#aa21e53b8ba182fbe4481563ed3edc772">XSM_MAX_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#acf402d972e5855885a587779aa75f802">XSM_MAX_TEMP_REMOTE</a>, <a class="el" href="xsysmonpsu_8h.html#a92681353913a769554b3a03f0a614bcb">XSM_MIN_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#af309384ae3efb40dd11f11a5e7170671">XSM_MIN_SUPPLY6</a>, <a class="el" href="xsysmonpsu_8h.html#aec0f9f1e8ad9a98083f6e399a2d8b5e5">XSM_MIN_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#acd364c7df27909c07ca9df995f4c0af7">XSM_MIN_TEMP_REMOTE</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9f2fde294e151e5db65822b26f11a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetMonitorStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the AMS monitor status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the monitor status. See XSYSMONPSU_MON_STS_*_MASK definations present in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> for knowing the status.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a621f41dbdff59725822f0dc2f29ac1e8">XSYSMONPSU_MON_STS_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a8261ca6ec1564b9066f858adbd81a85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqAcqTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of acquisition time from the ADC Channel Acquisition Time Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The acquisition time for all the channels. Use XSYSMONPSU_SEQ_ACQ* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which acquisition cycles are extended and bit mask of 0 are the channels for which acquisition cycles are not extended.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a579ce307d7e8b3d85718b47dbeaa48a2">XSYSMONPSU_SEQ_ACQ0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a7f5b375d3e31219c17cbb4dc14ae4eec">XSYSMONPSU_SEQ_ACQ1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a88183705d7e03a3d8eeee6366d09b5f5">XSYSMONPSU_SEQ_ACQ2_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="adf0cf3c7c355471f81fe60d663043e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqAvgEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the channels for which the averaging has been enabled in the ADC Channel Averaging Enables Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of averaging (enabled/disabled) for all the channels. Use XSYSMONPSU_SEQ_AVERAGE* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which averaging is enabled and bit mask of 0 are the channels for averaging is disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a26a83b449c5188602bafa2bfaa24e18c">XSYSMONPSU_SEQ_AVERAGE0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ac44a549f1306faa4359a6a48ddd17dfd">XSYSMONPSU_SEQ_AVERAGE1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a08d0525934fbe21b46732c039f93a8b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqChEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the channel enable bits status from the ADC Channel Selection Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gets the channel enable bits. Use XSYSMONPSU_SEQ_CH* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels that are enabled and bit mask of 0 are the channels that are disabled.</dd>
<dd>
None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#abf302f7a79ec4d2aee5b9756441ce71d">XSYSMONPSU_SEQ_CH0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a4c4cf4e1f8965f7095c9a7c58938555f">XSYSMONPSU_SEQ_CH1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a2e597e2db96739d90195d9ad019377c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqInputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the Analog input mode for all the channels from the ADC Channel Analog-Input Mode Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input mode for all the channels. Use XSYSMONPSU_SEQ_INPUT_MDE* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which input mode is differential/Bipolar and bit mask of 0 are the channels for which input mode is unipolar.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae709951620a41ee0f994506d3782b3e9">XSYSMONPSU_SEQ_INPUT_MDE0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#af6c54048b7704171bda202c378d50920">XSYSMONPSU_SEQ_INPUT_MDE1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a6a0b98e18bb6c2c8b3587e2fe2cffde8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_GetSequencerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the mode of the sequencer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the Sequencer mode. XSYSMONPSU_EVENT_MODE for Event mode and XSYSMONPSU_CONTINUOUS_MODE for continuous mode.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a2f2d5053a1406cecd4fa311525f68ce7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetSequencerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the channel sequencer mode from the Configuration Register 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The channel sequencer mode :<ul>
<li>XSM_SEQ_MODE_SAFE : Default safe mode</li>
<li>XSM_SEQ_MODE_ONEPASS : One pass through sequence</li>
<li>XSM_SEQ_MODE_CONTINPASS : Continuous channel sequencing</li>
<li>XSM_SEQ_MODE_SINGCHAN : Single channel/Sequencer off</li>
<li>XSM_SEQ_MODE_OLYMPUS : Olympus sampling mode</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#acfe5ce3d9e15f0bebdab313decf9729c">XSysMonPsu_SetSeqAcqTime()</a>, <a class="el" href="xsysmonpsu_8h.html#adb114566387fa8889b913f34a7de6010">XSysMonPsu_SetSeqAvgEnables()</a>, <a class="el" href="xsysmonpsu_8h.html#ac51295c525a507a8f334c97f02a84221">XSysMonPsu_SetSeqChEnables()</a>, <a class="el" href="xsysmonpsu_8h.html#ae6b751279110ca4a05073ae8a9b8a1a8">XSysMonPsu_SetSeqInputMode()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1841bc7888195dd3f9381947e4f8d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the contents of the Status Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the Status Register. Use the XSYSMONPSU_MON_STS_* constants defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a621f41dbdff59725822f0dc2f29ac1e8">XSYSMONPSU_MON_STS_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ad6fc9daa41e50955a71e2fe7a107a0e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the SystemMonitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Upon reset, all Maximum and Minimum status registers will be reset to their default values. Currently running and any averaging will restart. Refer to the device data sheet for the device status and register values after the reset. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a69b79177a69bce2ea1055e2b969a9f57">XSYSMONPSU_VP_VN_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize()</a>, and <a class="el" href="xsysmonpsu__selftest_8c.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a11e8fc0b9dffbe33b41ec4e6825ffc4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the frequency of the ADCCLK by configuring the DCLK to ADCCLK ratio in the Configuration Register #2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Divisor</td><td>is clock divisor used to derive ADCCLK from DCLK. Valid values of the divisor are PS:<ul>
<li>0 means divide by 8.</li>
<li>1,2 means divide by 2.</li>
<li>3 to 255 means divide by that value. PL:</li>
<li>0,1,2 means divide by 2.</li>
<li>3 to 255 means divide by that value. Refer to the device specification for more details. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2.<ul>
<li>There is no Assert on the minimum value of the Divisor. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5a77bafe25ef83d49e8091cbe661d974">XSYSMONPSU_CFG_REG2_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce8ca01b6992994737213f342847662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAlarmEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>AlmEnableMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the alarm outputs for the specified alarms in the Configuration Registers 1: </p>
<pre class="fragment">    - OT for Over Temperature (XSYSMONPSU_CFR_REG1_ALRM_OT_MASK)
    - ALM0 for On board Temperature (XSYSMONPSU_CFR_REG1_ALRM_TEMP_MASK)
    - ALM1 for SUPPLY1 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY1_MASK)
    - ALM2 for SUPPLY2 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY2_MASK)
            - ALM3 for SUPPLY3 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY3_MASK)
            - ALM4 for SUPPLY4 (XSYSMONPSU_CFR_REG1_ALRM__SUPPLY4_MASK)
    - ALM5 for SUPPLY5 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY5_MASK)
            - ALM6 for SUPPLY6 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY6_MASK)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlmEnableMask</td><td>is the bit-mask of the alarm outputs to be enabled in the Configuration Registers 1 and 3. Bit positions of 1 will be enabled. Bit positions of 0 will be disabled. This mask is formed by OR'ing XSYSMONPSU_CFR_REG1_ALRM_*_MASK masks defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>, but XSM_CFR_ALM_SUPPLY8_MASK to XSM_CFR_ALM_SUPPLY13_MASK are applicable only for PS. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that the alarms for bit positions of 0 will be enabled and alarms for bit positions of 1 will be disabled. The alarm outputs specified by the AlmEnableMask are negated before writing to the Configuration Register 1 because it was Disable register bits. Upper 16 bits of AlmEnableMask are applicable only for PS. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d436ab807a561d70339cdfe52f6f560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAlarmThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>AlarmThrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions sets the contents of the given Alarm Threshold Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlarmThrReg</td><td>is the index of an Alarm Threshold Register to be set. Use XSM_ATR_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to specify the index. </td></tr>
    <tr><td class="paramname">Value</td><td>is the 16-bit threshold value to write into the register. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9cd13eee75fe9d48b9d004652cb12e1f">XSM_ATR_SUP7_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#a9b816bc88f59e9b497fa66f336babd99">XSM_ATR_TEMP_RMTE_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#ad1eb3b0945f7c93a178c67fe0bb66d9f">XSM_ATR_TEMP_RMTE_UPPER</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a531009f056913bfecb5b591d9f91385c">XSYSMONPSU_ALRM_TEMP_UPR_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>, and <a class="el" href="xsysmonpsu__selftest_8c.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a711d9441ecb7c36f22b11f941d7f994b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAvg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of samples of averaging that is to be done for all the channels in both the single channel mode and sequence mode of operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Average</td><td>is the number of samples of averaging programmed to the Configuration Register 0. Use the XSM_AVG_* definitions defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> file :<ul>
<li>XSM_AVG_0_SAMPLES for no averaging</li>
<li>XSM_AVG_16_SAMPLES for 16 samples of averaging</li>
<li>XSM_AVG_64_SAMPLES for 64 samples of averaging</li>
<li>XSM_AVG_256_SAMPLES for 256 samples of averaging </li>
</ul>
</td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a2bcf68b01a8ff59237bea9b303828e4f">XSM_AVG_256_SAMPLES</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4903002cdddf192acdcda4827e5b1a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetExtenalMux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the external mux and connects a channel to the mux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number used to connect to the external Mux. The valid channels are 0 to 5 and 16 to 31. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li>
<li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a41aa90146d4e0786b8d36888e44aac34">XSM_CH_AUX_MIN</a>, <a class="el" href="xsysmonpsu_8h.html#a120bab2a7a97a74da70eef07204728fb">XSM_CH_VREFN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a118f51203c23bf2ed1f76d154e46ad3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetPSAutoConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the conversion to be automatic for PS SysMon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the auto-trigger mode, sample rate is of 1 Million samples. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="acfe5ce3d9e15f0bebdab313decf9729c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqAcqTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>AcqCyclesChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of Acquisition cycles in the ADC Channel Acquisition Time Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AcqCyclesChMask</td><td>is the bit mask of all the channels for which the number of acquisition cycles is to be extended. Use XSYSMONPSU_SEQ_ACQ* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to specify the Channel numbers. Acquisition cycles will be extended to 10 ADCCLK cycles for bit masks of 1 and will be the default 4 ADCCLK cycles for bit masks of 0. The AcqCyclesChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Acquisition Time Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Channel Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a579ce307d7e8b3d85718b47dbeaa48a2">XSYSMONPSU_SEQ_ACQ0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a7f5b375d3e31219c17cbb4dc14ae4eec">XSYSMONPSU_SEQ_ACQ1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a88183705d7e03a3d8eeee6366d09b5f5">XSYSMONPSU_SEQ_ACQ2_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="adb114566387fa8889b913f34a7de6010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqAvgEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>AvgEnableChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the averaging for the specified channels in the ADC Channel Averaging Enable Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AvgEnableChMask</td><td>is the bit mask of all the channels for which averaging is to be enabled. Use XSYSMONPSU_SEQ_AVERAGE* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to specify the Channel numbers. Averaging will be enabled for bit masks of 1 and disabled for bit mask of 0. The AvgEnableChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Averaging Enable Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Averaging Enables Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a26a83b449c5188602bafa2bfaa24e18c">XSYSMONPSU_SEQ_AVERAGE0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ac44a549f1306faa4359a6a48ddd17dfd">XSYSMONPSU_SEQ_AVERAGE1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ac51295c525a507a8f334c97f02a84221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqChEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>ChEnableMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the specified channels in the ADC Channel Selection Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">ChEnableMask</td><td>is the bit mask of all the channels to be enabled. Use XSYSMONPSU_SEQ_CH* defined in xsysmon_hw.h to specify the Channel numbers. Bit masks of 1 will be enabled and bit mask of 0 will be disabled. The ChEnableMask is a 64 bit mask that is written to the three 16 bit ADC Channel Selection Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Selection Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#abf302f7a79ec4d2aee5b9756441ce71d">XSYSMONPSU_SEQ_CH0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4c4cf4e1f8965f7095c9a7c58938555f">XSYSMONPSU_SEQ_CH1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6b751279110ca4a05073ae8a9b8a1a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqInputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>InputModeChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the Analog input mode for the specified channels in the ADC Channel Analog-Input Mode Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">InputModeChMask</td><td>is the bit mask of all the channels for which the input mode is differential mode. Use XSYSMONPSU_SEQ_INPUT_MDE* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to specify the channel numbers. Differential or Bipolar input mode will be set for bit masks of 1 and unipolar input mode for bit masks of 0. The InputModeChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Analog-Input Mode Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Analog-Input Mode Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae709951620a41ee0f994506d3782b3e9">XSYSMONPSU_SEQ_INPUT_MDE0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#af6c54048b7704171bda202c378d50920">XSYSMONPSU_SEQ_INPUT_MDE1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a193dbc689e9a668ef7f548920706b2a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetSequencerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsEventMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the Event mode or Continuous mode in the sequencer mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">IsEventMode</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the channel. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="aa4bdb4e555b2c8d47a0185862c9cb4c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetSequencerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SequencerMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the specified Channel Sequencer Mode in the Configuration Register 1 : </p>
<pre class="fragment">    - Default safe mode (XSM_SEQ_MODE_SAFE)
    - One pass through sequence (XSM_SEQ_MODE_ONEPASS)
    - Continuous channel sequencing (XSM_SEQ_MODE_CONTINPASS)
    - Single Channel/Sequencer off (XSM_SEQ_MODE_SINGCHAN)
    - Olympus sampling mode (XSM_SEQ_MODE_OYLMPUS)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SequencerMode</td><td>is the sequencer mode to be set. Use XSM_SEQ_MODE_* bits defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only one of the modes can be enabled at a time. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9fadcdd4e89cd9d96581f81dfe47dce7">XSM_SEQ_MODE_OYLMPUS</a>, <a class="el" href="xsysmonpsu_8h.html#a3c4487fa8b08f41c807433ef456abc75">XSM_SEQ_MODE_SINGCHAN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a872e9a41818489e77fa554dd01408281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSingleChParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IncreaseAcqCycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsEventMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsDifferentialMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the given parameters in the Configuration Register 0 in the single channel mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number for conversion. The valid channels are 0 - 6, 8 - 10, 13 - 37. </td></tr>
    <tr><td class="paramname">IncreaseAcqCycles</td><td>is a boolean parameter which specifies whether the Acquisition time for the external channels has to be increased to 10 ADCCLK cycles (specify TRUE) or remain at the default 4 ADCCLK cycles (specify FALSE). This parameter is only valid for the external channels. </td></tr>
    <tr><td class="paramname">IsEventMode</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the given channel. </td></tr>
    <tr><td class="paramname">IsDifferentialMode</td><td>is a boolean parameter which specifies unipolar(specify FALSE) or differential mode (specify TRUE) for the analog inputs. The input mode is only valid for the external channels. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li>
<li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The number of samples for the averaging for all the channels is set by using the function XSysMonPsu_SetAvg.</li>
<li>The calibration of the device is done by doing a ADC conversion on the calibration channel(channel 8). The input parameters IncreaseAcqCycles, IsDifferentialMode and IsEventMode are not valid for this channel. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a41aa90146d4e0786b8d36888e44aac34">XSM_CH_AUX_MIN</a>, <a class="el" href="xsysmonpsu_8h.html#a15ea4b9f08ee9dc44fc000384ca36e42">XSM_CH_GAINERR_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ae411c55817a64b2351271181ebdae254">XSM_CH_RESERVE1</a>, <a class="el" href="xsysmonpsu_8h.html#a7c4df26dc69ef41921c484fd3ccc006c">XSM_CH_SUPPLY3</a>, <a class="el" href="xsysmonpsu_8h.html#a2939dda6d5c6efbcf10977c6b33aa7fb">XSM_CH_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#a3fdb14478def5283880cd4d65dfaf56f">XSM_CH_SUPPLY_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ace8eebd74607658044e98c7b5ca1c0c6">XSM_CH_TEMP_REMTE</a>, <a class="el" href="xsysmonpsu_8h.html#a367867d9ef353a759eb5d33620bffed4">XSM_CH_VCC_PSLL0</a>, <a class="el" href="xsysmonpsu_8h.html#af9c81d9f5fa3d80cad2b374c84117840">XSM_CH_VPVN</a>, <a class="el" href="xsysmonpsu_8h.html#a3c4487fa8b08f41c807433ef456abc75">XSM_SEQ_MODE_SINGCHAN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ed2a9f0fbd1be48dfd71aaeef05174f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_StartAdcConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts the ADC conversion in the Single Channel event driven sampling mode. </p>
<p>The EOC bit in Status Register will be set once the conversion is finished. Refer to the device specification for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default state of the CONVST bit is a logic 0. The conversion is started when the CONVST bit is set to 1 from 0. This bit is self-clearing so that the next conversion can be started by setting this bit. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a15c7ebcfb5e5e7014deaabaa8f6261eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_UpdateAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function update the ADCCLK divisor to the Configuration Register 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XSysMon instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The divisor update the Configuration Register 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu___config.html#a7ff0bfe3d5f7cb06792fe7ed481711ad">XSysMonPsu_Config::InputClockMHz</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5a77bafe25ef83d49e8091cbe661d974">XSYSMONPSU_CFG_REG2_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
