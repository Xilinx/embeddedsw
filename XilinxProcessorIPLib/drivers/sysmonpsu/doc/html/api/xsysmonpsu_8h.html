<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>sysmonpsu: xsysmonpsu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">sysmonpsu
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xsysmonpsu_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xsysmonpsu.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for a device.  <a href="struct_x_sys_mon_psu___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The XSysmonPsu driver instance data.  <a href="struct_x_sys_mon_psu.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a380d87507652a19d453b20e6d7655d65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a380d87507652a19d453b20e6d7655d65">XSysMonPsu_RawToTemperature_OnChip</a>(AdcData)&#160;&#160;&#160;((((float)(AdcData)/65536.0f)/0.00196342531f ) - 280.2309f)</td></tr>
<tr class="memdesc:a380d87507652a19d453b20e6d7655d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts System Monitor Raw Data to Temperature(centigrades) for On-Chip Sensors.  <a href="#a380d87507652a19d453b20e6d7655d65"></a><br/></td></tr>
<tr class="separator:a380d87507652a19d453b20e6d7655d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab3e135004e7d5995a827caa045883e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a9ab3e135004e7d5995a827caa045883e">XSysMonPsu_RawToTemperature_ExternalRef</a>(AdcData)&#160;&#160;&#160;((((float)(AdcData)/65536.0f)/0.00197008621f ) - 279.4266f)</td></tr>
<tr class="memdesc:a9ab3e135004e7d5995a827caa045883e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts System Monitor Raw Data to Temperature(centigrades) for external reference.  <a href="#a9ab3e135004e7d5995a827caa045883e"></a><br/></td></tr>
<tr class="separator:a9ab3e135004e7d5995a827caa045883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce87fd508744ddc0de0c9954f71e1f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a8ce87fd508744ddc0de0c9954f71e1f7">XSysMonPsu_VpVnRawToVoltage</a>(AdcData)&#160;&#160;&#160;((((float)(AdcData))* (1.0f))/65536.0f)</td></tr>
<tr class="memdesc:a8ce87fd508744ddc0de0c9954f71e1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts System Monitor Raw Data to Voltage(volts) for VpVn supply.  <a href="#a8ce87fd508744ddc0de0c9954f71e1f7"></a><br/></td></tr>
<tr class="separator:a8ce87fd508744ddc0de0c9954f71e1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6667f0fcc65dda4a7af897b2924143c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af6667f0fcc65dda4a7af897b2924143c">XSysMonPsu_RawToVoltage</a>(AdcData)&#160;&#160;&#160;((((float)(AdcData))* (3.0f))/65536.0f)</td></tr>
<tr class="memdesc:af6667f0fcc65dda4a7af897b2924143c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts System Monitor Raw Data to Voltage(volts) other than VCCO_PSIO supply.  <a href="#af6667f0fcc65dda4a7af897b2924143c"></a><br/></td></tr>
<tr class="separator:af6667f0fcc65dda4a7af897b2924143c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74fd43c8a038933bc2580837b95cee4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ad74fd43c8a038933bc2580837b95cee4">XSysMonPsu_VccopsioRawToVoltage</a>(AdcData)&#160;&#160;&#160;((((float)(AdcData))* (6.0f))/65536.0f)</td></tr>
<tr class="memdesc:ad74fd43c8a038933bc2580837b95cee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts System Monitor Raw Data to Voltage(volts) for VCCO_PSIO supply.  <a href="#ad74fd43c8a038933bc2580837b95cee4"></a><br/></td></tr>
<tr class="separator:ad74fd43c8a038933bc2580837b95cee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977b419288fae23364d46bc87d6976ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a977b419288fae23364d46bc87d6976ce">XSysMonPsu_TemperatureToRaw_OnChip</a>(Temperature)&#160;&#160;&#160;((s32)(((Temperature) + 280.2309f)*65536.0f*0.00196342531f))</td></tr>
<tr class="memdesc:a977b419288fae23364d46bc87d6976ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts Temperature in centigrades to System Monitor Raw Data for On-Chip Sensors.  <a href="#a977b419288fae23364d46bc87d6976ce"></a><br/></td></tr>
<tr class="separator:a977b419288fae23364d46bc87d6976ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b32ba6617a306fd1f12c7d34151722"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a50b32ba6617a306fd1f12c7d34151722">XSysMonPsu_TemperatureToRaw_ExternalRef</a>(Temperature)&#160;&#160;&#160;((s32)(((Temperature) + 279.4266f)*65536.0f*0.00197008621f))</td></tr>
<tr class="memdesc:a50b32ba6617a306fd1f12c7d34151722"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts Temperature in centigrades to System Monitor Raw Data for external reference.  <a href="#a50b32ba6617a306fd1f12c7d34151722"></a><br/></td></tr>
<tr class="separator:a50b32ba6617a306fd1f12c7d34151722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986f164c3c1f811ea27713adf9dace4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a986f164c3c1f811ea27713adf9dace4c">XSysMonPsu_VoltageToRaw</a>(Voltage)&#160;&#160;&#160;((s32)((Voltage)*65536.0f/3.0f))</td></tr>
<tr class="memdesc:a986f164c3c1f811ea27713adf9dace4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts Voltage in Volts to System Monitor Raw Data other than VCCO_PSIO supply.  <a href="#a986f164c3c1f811ea27713adf9dace4c"></a><br/></td></tr>
<tr class="separator:a986f164c3c1f811ea27713adf9dace4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b960d7be1902cbefc489cc0ae4ec95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a05b960d7be1902cbefc489cc0ae4ec95">XSysMonPsu_VccopsioVoltageToRaw</a>(Voltage)&#160;&#160;&#160;((s32)((Voltage)*65536.0f/6.0f))</td></tr>
<tr class="memdesc:a05b960d7be1902cbefc489cc0ae4ec95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro converts Voltage in Volts to System Monitor Raw Data for VCCO_PSIO supply.  <a href="#a05b960d7be1902cbefc489cc0ae4ec95"></a><br/></td></tr>
<tr class="separator:a05b960d7be1902cbefc489cc0ae4ec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for the different channels.</div></td></tr>
<tr class="memitem:af2f79c54dddbdf090934f80f315b2e60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af2f79c54dddbdf090934f80f315b2e60">XSM_CH_TEMP</a>&#160;&#160;&#160;0x0U</td></tr>
<tr class="memdesc:af2f79c54dddbdf090934f80f315b2e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">On Chip Temperature.  <a href="#af2f79c54dddbdf090934f80f315b2e60"></a><br/></td></tr>
<tr class="separator:af2f79c54dddbdf090934f80f315b2e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b564ae32085a3fc51c452d1babe46db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a0b564ae32085a3fc51c452d1babe46db">XSM_CH_SUPPLY1</a>&#160;&#160;&#160;0x1U</td></tr>
<tr class="memdesc:a0b564ae32085a3fc51c452d1babe46db"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY1 VCC_PSINTLP.  <a href="#a0b564ae32085a3fc51c452d1babe46db"></a><br/></td></tr>
<tr class="separator:a0b564ae32085a3fc51c452d1babe46db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fb0fe44e342aad8c2d19d1f435284a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a80fb0fe44e342aad8c2d19d1f435284a">XSM_CH_SUPPLY2</a>&#160;&#160;&#160;0x2U</td></tr>
<tr class="memdesc:a80fb0fe44e342aad8c2d19d1f435284a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY2 VCC_PSINTFP.  <a href="#a80fb0fe44e342aad8c2d19d1f435284a"></a><br/></td></tr>
<tr class="separator:a80fb0fe44e342aad8c2d19d1f435284a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c81d9f5fa3d80cad2b374c84117840"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af9c81d9f5fa3d80cad2b374c84117840">XSM_CH_VPVN</a>&#160;&#160;&#160;0x3U</td></tr>
<tr class="memdesc:af9c81d9f5fa3d80cad2b374c84117840"><td class="mdescLeft">&#160;</td><td class="mdescRight">VP/VN Dedicated analog inputs.  <a href="#af9c81d9f5fa3d80cad2b374c84117840"></a><br/></td></tr>
<tr class="separator:af9c81d9f5fa3d80cad2b374c84117840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676a91c5452aa7ec285794dc3ee13d4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a676a91c5452aa7ec285794dc3ee13d4b">XSM_CH_VREFP</a>&#160;&#160;&#160;0x4U</td></tr>
<tr class="memdesc:a676a91c5452aa7ec285794dc3ee13d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">VREFP.  <a href="#a676a91c5452aa7ec285794dc3ee13d4b"></a><br/></td></tr>
<tr class="separator:a676a91c5452aa7ec285794dc3ee13d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120bab2a7a97a74da70eef07204728fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a120bab2a7a97a74da70eef07204728fb">XSM_CH_VREFN</a>&#160;&#160;&#160;0x5U</td></tr>
<tr class="memdesc:a120bab2a7a97a74da70eef07204728fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">VREFN.  <a href="#a120bab2a7a97a74da70eef07204728fb"></a><br/></td></tr>
<tr class="separator:a120bab2a7a97a74da70eef07204728fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4df26dc69ef41921c484fd3ccc006c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7c4df26dc69ef41921c484fd3ccc006c">XSM_CH_SUPPLY3</a>&#160;&#160;&#160;0x6U</td></tr>
<tr class="memdesc:a7c4df26dc69ef41921c484fd3ccc006c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY3 VCC_PSAUX.  <a href="#a7c4df26dc69ef41921c484fd3ccc006c"></a><br/></td></tr>
<tr class="separator:a7c4df26dc69ef41921c484fd3ccc006c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdb14478def5283880cd4d65dfaf56f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3fdb14478def5283880cd4d65dfaf56f">XSM_CH_SUPPLY_CALIB</a>&#160;&#160;&#160;0x08U</td></tr>
<tr class="memdesc:a3fdb14478def5283880cd4d65dfaf56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply Calib Data Reg.  <a href="#a3fdb14478def5283880cd4d65dfaf56f"></a><br/></td></tr>
<tr class="separator:a3fdb14478def5283880cd4d65dfaf56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802955d06a498aca0909e488caee528c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a802955d06a498aca0909e488caee528c">XSM_CH_ADC_CALIB</a>&#160;&#160;&#160;0x09U</td></tr>
<tr class="memdesc:a802955d06a498aca0909e488caee528c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADC Offset Channel Reg.  <a href="#a802955d06a498aca0909e488caee528c"></a><br/></td></tr>
<tr class="separator:a802955d06a498aca0909e488caee528c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ea4b9f08ee9dc44fc000384ca36e42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a15ea4b9f08ee9dc44fc000384ca36e42">XSM_CH_GAINERR_CALIB</a>&#160;&#160;&#160;0x0AU</td></tr>
<tr class="memdesc:a15ea4b9f08ee9dc44fc000384ca36e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gain Error Channel Reg.  <a href="#a15ea4b9f08ee9dc44fc000384ca36e42"></a><br/></td></tr>
<tr class="separator:a15ea4b9f08ee9dc44fc000384ca36e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2939dda6d5c6efbcf10977c6b33aa7fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2939dda6d5c6efbcf10977c6b33aa7fb">XSM_CH_SUPPLY4</a>&#160;&#160;&#160;0x0DU</td></tr>
<tr class="memdesc:a2939dda6d5c6efbcf10977c6b33aa7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY4 VCC_PSDDR_504.  <a href="#a2939dda6d5c6efbcf10977c6b33aa7fb"></a><br/></td></tr>
<tr class="separator:a2939dda6d5c6efbcf10977c6b33aa7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3880806109f07b635bb02c599fced14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aa3880806109f07b635bb02c599fced14">XSM_CH_SUPPLY5</a>&#160;&#160;&#160;0x0EU</td></tr>
<tr class="memdesc:aa3880806109f07b635bb02c599fced14"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY5 VCC_PSIO3_503.  <a href="#aa3880806109f07b635bb02c599fced14"></a><br/></td></tr>
<tr class="separator:aa3880806109f07b635bb02c599fced14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afc3f01bbea8bc4f94435b5cd5e1915"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a4afc3f01bbea8bc4f94435b5cd5e1915">XSM_CH_SUPPLY6</a>&#160;&#160;&#160;0x0FU</td></tr>
<tr class="memdesc:a4afc3f01bbea8bc4f94435b5cd5e1915"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY6 VCC_PSIO0_500.  <a href="#a4afc3f01bbea8bc4f94435b5cd5e1915"></a><br/></td></tr>
<tr class="separator:a4afc3f01bbea8bc4f94435b5cd5e1915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aa90146d4e0786b8d36888e44aac34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a41aa90146d4e0786b8d36888e44aac34">XSM_CH_AUX_MIN</a>&#160;&#160;&#160;16U</td></tr>
<tr class="memdesc:a41aa90146d4e0786b8d36888e44aac34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel number for 1st Aux Channel.  <a href="#a41aa90146d4e0786b8d36888e44aac34"></a><br/></td></tr>
<tr class="separator:a41aa90146d4e0786b8d36888e44aac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c007df4d1c481557120435619b4ff5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>&#160;&#160;&#160;31U</td></tr>
<tr class="memdesc:ae8c007df4d1c481557120435619b4ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel number for Last Aux channel.  <a href="#ae8c007df4d1c481557120435619b4ff5"></a><br/></td></tr>
<tr class="separator:ae8c007df4d1c481557120435619b4ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba50e39946a244f7565b8d15c3ffabb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aba50e39946a244f7565b8d15c3ffabb8">XSM_CH_SUPPLY7</a>&#160;&#160;&#160;32U</td></tr>
<tr class="memdesc:aba50e39946a244f7565b8d15c3ffabb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY7 VCC_PSIO1_501.  <a href="#aba50e39946a244f7565b8d15c3ffabb8"></a><br/></td></tr>
<tr class="separator:aba50e39946a244f7565b8d15c3ffabb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf08790ddd9d8b02768583c3f250636"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aadf08790ddd9d8b02768583c3f250636">XSM_CH_SUPPLY8</a>&#160;&#160;&#160;33U</td></tr>
<tr class="memdesc:aadf08790ddd9d8b02768583c3f250636"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY8 VCC_PSIO2_502.  <a href="#aadf08790ddd9d8b02768583c3f250636"></a><br/></td></tr>
<tr class="separator:aadf08790ddd9d8b02768583c3f250636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8c7547ed4d7e1652b7e078bc6230ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7d8c7547ed4d7e1652b7e078bc6230ad">XSM_CH_SUPPLY9</a>&#160;&#160;&#160;34U</td></tr>
<tr class="memdesc:a7d8c7547ed4d7e1652b7e078bc6230ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY9 PS_MGTRAVCC.  <a href="#a7d8c7547ed4d7e1652b7e078bc6230ad"></a><br/></td></tr>
<tr class="separator:a7d8c7547ed4d7e1652b7e078bc6230ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39654f20bba10aa6e1cd7985fe75ea70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a39654f20bba10aa6e1cd7985fe75ea70">XSM_CH_SUPPLY10</a>&#160;&#160;&#160;35U</td></tr>
<tr class="memdesc:a39654f20bba10aa6e1cd7985fe75ea70"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUPPLY10 PS_MGTRAVTT.  <a href="#a39654f20bba10aa6e1cd7985fe75ea70"></a><br/></td></tr>
<tr class="separator:a39654f20bba10aa6e1cd7985fe75ea70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dbddc6ab704c05c513e9d3957167a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a69dbddc6ab704c05c513e9d3957167a9">XSM_CH_VCCAMS</a>&#160;&#160;&#160;36U</td></tr>
<tr class="memdesc:a69dbddc6ab704c05c513e9d3957167a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCCAMS.  <a href="#a69dbddc6ab704c05c513e9d3957167a9"></a><br/></td></tr>
<tr class="separator:a69dbddc6ab704c05c513e9d3957167a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8eebd74607658044e98c7b5ca1c0c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ace8eebd74607658044e98c7b5ca1c0c6">XSM_CH_TEMP_REMTE</a>&#160;&#160;&#160;37U</td></tr>
<tr class="memdesc:ace8eebd74607658044e98c7b5ca1c0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature Remote.  <a href="#ace8eebd74607658044e98c7b5ca1c0c6"></a><br/></td></tr>
<tr class="separator:ace8eebd74607658044e98c7b5ca1c0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367867d9ef353a759eb5d33620bffed4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a367867d9ef353a759eb5d33620bffed4">XSM_CH_VCC_PSLL0</a>&#160;&#160;&#160;48U</td></tr>
<tr class="memdesc:a367867d9ef353a759eb5d33620bffed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCC_PSLL0.  <a href="#a367867d9ef353a759eb5d33620bffed4"></a><br/></td></tr>
<tr class="separator:a367867d9ef353a759eb5d33620bffed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87dfb4207793ed9043629c32488aa7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a8b87dfb4207793ed9043629c32488aa7">XSM_CH_VCC_PSLL3</a>&#160;&#160;&#160;51U</td></tr>
<tr class="memdesc:a8b87dfb4207793ed9043629c32488aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCC_PSLL3.  <a href="#a8b87dfb4207793ed9043629c32488aa7"></a><br/></td></tr>
<tr class="separator:a8b87dfb4207793ed9043629c32488aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715e29a748cdd1b301bec9ac17c4c7f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a715e29a748cdd1b301bec9ac17c4c7f4">XSM_CH_VCCINT</a>&#160;&#160;&#160;54U</td></tr>
<tr class="memdesc:a715e29a748cdd1b301bec9ac17c4c7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCCINT.  <a href="#a715e29a748cdd1b301bec9ac17c4c7f4"></a><br/></td></tr>
<tr class="separator:a715e29a748cdd1b301bec9ac17c4c7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c791d8747031b6e7fdc85cac810241a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3c791d8747031b6e7fdc85cac810241a">XSM_CH_VCCBRAM</a>&#160;&#160;&#160;55U</td></tr>
<tr class="memdesc:a3c791d8747031b6e7fdc85cac810241a"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCCBRAM.  <a href="#a3c791d8747031b6e7fdc85cac810241a"></a><br/></td></tr>
<tr class="separator:a3c791d8747031b6e7fdc85cac810241a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6a2517306958c69f3259057d3649a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a1c6a2517306958c69f3259057d3649a9">XSM_CH_VCCAUX</a>&#160;&#160;&#160;56U</td></tr>
<tr class="memdesc:a1c6a2517306958c69f3259057d3649a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCCAUX.  <a href="#a1c6a2517306958c69f3259057d3649a9"></a><br/></td></tr>
<tr class="separator:a1c6a2517306958c69f3259057d3649a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432956207f2e1b259f9d320739b5d286"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a432956207f2e1b259f9d320739b5d286">XSM_CH_VCC_PSDDRPLL</a>&#160;&#160;&#160;57U</td></tr>
<tr class="memdesc:a432956207f2e1b259f9d320739b5d286"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCC_PSDDRPLL.  <a href="#a432956207f2e1b259f9d320739b5d286"></a><br/></td></tr>
<tr class="separator:a432956207f2e1b259f9d320739b5d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2526be2a1f3319c068088aade1c73eb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2526be2a1f3319c068088aade1c73eb2">XSM_CH_DDRPHY_VREF</a>&#160;&#160;&#160;58U</td></tr>
<tr class="memdesc:a2526be2a1f3319c068088aade1c73eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DDRPHY_VREF.  <a href="#a2526be2a1f3319c068088aade1c73eb2"></a><br/></td></tr>
<tr class="separator:a2526be2a1f3319c068088aade1c73eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae411c55817a64b2351271181ebdae254"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ae411c55817a64b2351271181ebdae254">XSM_CH_RESERVE1</a>&#160;&#160;&#160;63U</td></tr>
<tr class="memdesc:ae411c55817a64b2351271181ebdae254"><td class="mdescLeft">&#160;</td><td class="mdescRight">PSGT_AT0.  <a href="#ae411c55817a64b2351271181ebdae254"></a><br/></td></tr>
<tr class="separator:ae411c55817a64b2351271181ebdae254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for reading the Calibration Coefficient Data.</div></td></tr>
<tr class="memitem:a6152ac28d736b4e0d1e214f3377fd1e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a6152ac28d736b4e0d1e214f3377fd1e9">XSM_CALIB_SUPPLY_OFFSET_COEFF</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:a6152ac28d736b4e0d1e214f3377fd1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply Offset Calib Coefficient.  <a href="#a6152ac28d736b4e0d1e214f3377fd1e9"></a><br/></td></tr>
<tr class="separator:a6152ac28d736b4e0d1e214f3377fd1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dbdfce05bdc719f09f56e36ac154b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a47dbdfce05bdc719f09f56e36ac154b1">XSM_CALIB_ADC_OFFSET_COEFF</a>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:a47dbdfce05bdc719f09f56e36ac154b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADC Offset Calib Coefficient.  <a href="#a47dbdfce05bdc719f09f56e36ac154b1"></a><br/></td></tr>
<tr class="separator:a47dbdfce05bdc719f09f56e36ac154b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a9675e7f812b837aab6cf61457b6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a173a9675e7f812b837aab6cf61457b6d">XSM_CALIB_GAIN_ERROR_COEFF</a>&#160;&#160;&#160;2U</td></tr>
<tr class="memdesc:a173a9675e7f812b837aab6cf61457b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gain Error Calib Coefficient.  <a href="#a173a9675e7f812b837aab6cf61457b6d"></a><br/></td></tr>
<tr class="separator:a173a9675e7f812b837aab6cf61457b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for reading the Minimum/Maximum Measurement Data.</div></td></tr>
<tr class="memitem:a35d9814abedb2943f4a84ecff66351e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a35d9814abedb2943f4a84ecff66351e5">XSM_MAX_TEMP</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:a35d9814abedb2943f4a84ecff66351e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Temperature Data.  <a href="#a35d9814abedb2943f4a84ecff66351e5"></a><br/></td></tr>
<tr class="separator:a35d9814abedb2943f4a84ecff66351e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1b4304d1e781bd7a9908718620c0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2ab1b4304d1e781bd7a9908718620c0b">XSM_MAX_SUPPLY1</a>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:a2ab1b4304d1e781bd7a9908718620c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY1 Data.  <a href="#a2ab1b4304d1e781bd7a9908718620c0b"></a><br/></td></tr>
<tr class="separator:a2ab1b4304d1e781bd7a9908718620c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e17f28a5b5e02447d0674120e5a9257"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a1e17f28a5b5e02447d0674120e5a9257">XSM_MAX_SUPPLY2</a>&#160;&#160;&#160;2U</td></tr>
<tr class="memdesc:a1e17f28a5b5e02447d0674120e5a9257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY2 Data.  <a href="#a1e17f28a5b5e02447d0674120e5a9257"></a><br/></td></tr>
<tr class="separator:a1e17f28a5b5e02447d0674120e5a9257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc0e390c18e733d61a5bec32f8f806f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a4cc0e390c18e733d61a5bec32f8f806f">XSM_MAX_SUPPLY3</a>&#160;&#160;&#160;3U</td></tr>
<tr class="memdesc:a4cc0e390c18e733d61a5bec32f8f806f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY3 Data.  <a href="#a4cc0e390c18e733d61a5bec32f8f806f"></a><br/></td></tr>
<tr class="separator:a4cc0e390c18e733d61a5bec32f8f806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3acf3098ee563aa1cc3e35555d4e801"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af3acf3098ee563aa1cc3e35555d4e801">XSM_MIN_TEMP</a>&#160;&#160;&#160;4U</td></tr>
<tr class="memdesc:af3acf3098ee563aa1cc3e35555d4e801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum Temperature Data.  <a href="#af3acf3098ee563aa1cc3e35555d4e801"></a><br/></td></tr>
<tr class="separator:af3acf3098ee563aa1cc3e35555d4e801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda48741be11b7a96ece33a3f67dbd74"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#acda48741be11b7a96ece33a3f67dbd74">XSM_MIN_SUPPLY1</a>&#160;&#160;&#160;5U</td></tr>
<tr class="memdesc:acda48741be11b7a96ece33a3f67dbd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY1 Data.  <a href="#acda48741be11b7a96ece33a3f67dbd74"></a><br/></td></tr>
<tr class="separator:acda48741be11b7a96ece33a3f67dbd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0e0664dcc3a6fb227157d1e49ce255"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a9b0e0664dcc3a6fb227157d1e49ce255">XSM_MIN_SUPPLY2</a>&#160;&#160;&#160;6U</td></tr>
<tr class="memdesc:a9b0e0664dcc3a6fb227157d1e49ce255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY2 Data.  <a href="#a9b0e0664dcc3a6fb227157d1e49ce255"></a><br/></td></tr>
<tr class="separator:a9b0e0664dcc3a6fb227157d1e49ce255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae90b5125c90a5ecf98415c05e493a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a4ae90b5125c90a5ecf98415c05e493a2">XSM_MIN_SUPPLY3</a>&#160;&#160;&#160;7U</td></tr>
<tr class="memdesc:a4ae90b5125c90a5ecf98415c05e493a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY3 Data.  <a href="#a4ae90b5125c90a5ecf98415c05e493a2"></a><br/></td></tr>
<tr class="separator:a4ae90b5125c90a5ecf98415c05e493a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ef6de7f4d6dd4bcc55ea7f7e0d5f66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ab4ef6de7f4d6dd4bcc55ea7f7e0d5f66">XSM_MAX_SUPPLY4</a>&#160;&#160;&#160;8U</td></tr>
<tr class="memdesc:ab4ef6de7f4d6dd4bcc55ea7f7e0d5f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY4 Data.  <a href="#ab4ef6de7f4d6dd4bcc55ea7f7e0d5f66"></a><br/></td></tr>
<tr class="separator:ab4ef6de7f4d6dd4bcc55ea7f7e0d5f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94baf233cff0eac2a5aa299a05a7937"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af94baf233cff0eac2a5aa299a05a7937">XSM_MAX_SUPPLY5</a>&#160;&#160;&#160;9U</td></tr>
<tr class="memdesc:af94baf233cff0eac2a5aa299a05a7937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY5 Data.  <a href="#af94baf233cff0eac2a5aa299a05a7937"></a><br/></td></tr>
<tr class="separator:af94baf233cff0eac2a5aa299a05a7937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e519a87a8d9330083e59826065eb259"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a9e519a87a8d9330083e59826065eb259">XSM_MAX_SUPPLY6</a>&#160;&#160;&#160;0xAU</td></tr>
<tr class="memdesc:a9e519a87a8d9330083e59826065eb259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY6 Data.  <a href="#a9e519a87a8d9330083e59826065eb259"></a><br/></td></tr>
<tr class="separator:a9e519a87a8d9330083e59826065eb259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92681353913a769554b3a03f0a614bcb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a92681353913a769554b3a03f0a614bcb">XSM_MIN_SUPPLY4</a>&#160;&#160;&#160;0xCU</td></tr>
<tr class="memdesc:a92681353913a769554b3a03f0a614bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY4 Data.  <a href="#a92681353913a769554b3a03f0a614bcb"></a><br/></td></tr>
<tr class="separator:a92681353913a769554b3a03f0a614bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685eed612478874918c1d2ae77ae93e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a685eed612478874918c1d2ae77ae93e1">XSM_MIN_SUPPLY5</a>&#160;&#160;&#160;0xDU</td></tr>
<tr class="memdesc:a685eed612478874918c1d2ae77ae93e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY5 Data.  <a href="#a685eed612478874918c1d2ae77ae93e1"></a><br/></td></tr>
<tr class="separator:a685eed612478874918c1d2ae77ae93e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af309384ae3efb40dd11f11a5e7170671"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af309384ae3efb40dd11f11a5e7170671">XSM_MIN_SUPPLY6</a>&#160;&#160;&#160;0xEU</td></tr>
<tr class="memdesc:af309384ae3efb40dd11f11a5e7170671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY6 Data.  <a href="#af309384ae3efb40dd11f11a5e7170671"></a><br/></td></tr>
<tr class="separator:af309384ae3efb40dd11f11a5e7170671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21e53b8ba182fbe4481563ed3edc772"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aa21e53b8ba182fbe4481563ed3edc772">XSM_MAX_SUPPLY7</a>&#160;&#160;&#160;0x80U</td></tr>
<tr class="memdesc:aa21e53b8ba182fbe4481563ed3edc772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY7 Data.  <a href="#aa21e53b8ba182fbe4481563ed3edc772"></a><br/></td></tr>
<tr class="separator:aa21e53b8ba182fbe4481563ed3edc772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8253f7661c72912e98b88d128fcb50b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ae8253f7661c72912e98b88d128fcb50b">XSM_MAX_SUPPLY8</a>&#160;&#160;&#160;0x81U</td></tr>
<tr class="memdesc:ae8253f7661c72912e98b88d128fcb50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY8 Data.  <a href="#ae8253f7661c72912e98b88d128fcb50b"></a><br/></td></tr>
<tr class="separator:ae8253f7661c72912e98b88d128fcb50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d3f6c621f7d737ce7697947a8f39d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ad5d3f6c621f7d737ce7697947a8f39d5">XSM_MAX_SUPPLY9</a>&#160;&#160;&#160;0x82U</td></tr>
<tr class="memdesc:ad5d3f6c621f7d737ce7697947a8f39d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY9 Data.  <a href="#ad5d3f6c621f7d737ce7697947a8f39d5"></a><br/></td></tr>
<tr class="separator:ad5d3f6c621f7d737ce7697947a8f39d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad452144ae98a77893ab4056e341b47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a4ad452144ae98a77893ab4056e341b47">XSM_MAX_SUPPLY10</a>&#160;&#160;&#160;0x83U</td></tr>
<tr class="memdesc:a4ad452144ae98a77893ab4056e341b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum SUPPLY10 Data.  <a href="#a4ad452144ae98a77893ab4056e341b47"></a><br/></td></tr>
<tr class="separator:a4ad452144ae98a77893ab4056e341b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592a7d4901c3adeae9b0e28be37c8484"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a592a7d4901c3adeae9b0e28be37c8484">XSM_MAX_VCCAMS</a>&#160;&#160;&#160;0x84U</td></tr>
<tr class="memdesc:a592a7d4901c3adeae9b0e28be37c8484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum VCCAMS Data.  <a href="#a592a7d4901c3adeae9b0e28be37c8484"></a><br/></td></tr>
<tr class="separator:a592a7d4901c3adeae9b0e28be37c8484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf402d972e5855885a587779aa75f802"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#acf402d972e5855885a587779aa75f802">XSM_MAX_TEMP_REMOTE</a>&#160;&#160;&#160;0x85U</td></tr>
<tr class="memdesc:acf402d972e5855885a587779aa75f802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Remote Temperature Data.  <a href="#acf402d972e5855885a587779aa75f802"></a><br/></td></tr>
<tr class="separator:acf402d972e5855885a587779aa75f802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0f9f1e8ad9a98083f6e399a2d8b5e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aec0f9f1e8ad9a98083f6e399a2d8b5e5">XSM_MIN_SUPPLY7</a>&#160;&#160;&#160;0x88U</td></tr>
<tr class="memdesc:aec0f9f1e8ad9a98083f6e399a2d8b5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY7 Data.  <a href="#aec0f9f1e8ad9a98083f6e399a2d8b5e5"></a><br/></td></tr>
<tr class="separator:aec0f9f1e8ad9a98083f6e399a2d8b5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139cbe1dcb71891e7681ca57d9fc7b86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a139cbe1dcb71891e7681ca57d9fc7b86">XSM_MIN_SUPPLY8</a>&#160;&#160;&#160;0x89U</td></tr>
<tr class="memdesc:a139cbe1dcb71891e7681ca57d9fc7b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY8 Data.  <a href="#a139cbe1dcb71891e7681ca57d9fc7b86"></a><br/></td></tr>
<tr class="separator:a139cbe1dcb71891e7681ca57d9fc7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b172c8397ed0cbb59ed58a0b5265194"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7b172c8397ed0cbb59ed58a0b5265194">XSM_MIN_SUPPLY9</a>&#160;&#160;&#160;0x8AU</td></tr>
<tr class="memdesc:a7b172c8397ed0cbb59ed58a0b5265194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY9 Data.  <a href="#a7b172c8397ed0cbb59ed58a0b5265194"></a><br/></td></tr>
<tr class="separator:a7b172c8397ed0cbb59ed58a0b5265194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74372e940f4e159070de88166b07a344"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a74372e940f4e159070de88166b07a344">XSM_MIN_SUPPLY10</a>&#160;&#160;&#160;0x8BU</td></tr>
<tr class="memdesc:a74372e940f4e159070de88166b07a344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum SUPPLY10 Data.  <a href="#a74372e940f4e159070de88166b07a344"></a><br/></td></tr>
<tr class="separator:a74372e940f4e159070de88166b07a344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d4d25ec322db4f763a371168dcccf0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ac3d4d25ec322db4f763a371168dcccf0">XSM_MIN_VCCAMS</a>&#160;&#160;&#160;0x8CU</td></tr>
<tr class="memdesc:ac3d4d25ec322db4f763a371168dcccf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum VCCAMS Data.  <a href="#ac3d4d25ec322db4f763a371168dcccf0"></a><br/></td></tr>
<tr class="separator:ac3d4d25ec322db4f763a371168dcccf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd364c7df27909c07ca9df995f4c0af7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#acd364c7df27909c07ca9df995f4c0af7">XSM_MIN_TEMP_REMOTE</a>&#160;&#160;&#160;0x8DU</td></tr>
<tr class="memdesc:acd364c7df27909c07ca9df995f4c0af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum Remote Temperature Data.  <a href="#acd364c7df27909c07ca9df995f4c0af7"></a><br/></td></tr>
<tr class="separator:acd364c7df27909c07ca9df995f4c0af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Averaging to be done for the channels.</div></td></tr>
<tr class="memitem:a81e97c4d54cab391a4c816f2bb666a63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a81e97c4d54cab391a4c816f2bb666a63">XSM_AVG_0_SAMPLES</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:a81e97c4d54cab391a4c816f2bb666a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">No Averaging.  <a href="#a81e97c4d54cab391a4c816f2bb666a63"></a><br/></td></tr>
<tr class="separator:a81e97c4d54cab391a4c816f2bb666a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd77d90e7456614726390476f3636c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7cd77d90e7456614726390476f3636c8">XSM_AVG_16_SAMPLES</a>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:a7cd77d90e7456614726390476f3636c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average 16 samples.  <a href="#a7cd77d90e7456614726390476f3636c8"></a><br/></td></tr>
<tr class="separator:a7cd77d90e7456614726390476f3636c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eabcd0f343d52159cce69aad462c37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a30eabcd0f343d52159cce69aad462c37">XSM_AVG_64_SAMPLES</a>&#160;&#160;&#160;2U</td></tr>
<tr class="memdesc:a30eabcd0f343d52159cce69aad462c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average 64 samples.  <a href="#a30eabcd0f343d52159cce69aad462c37"></a><br/></td></tr>
<tr class="separator:a30eabcd0f343d52159cce69aad462c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcf68b01a8ff59237bea9b303828e4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2bcf68b01a8ff59237bea9b303828e4f">XSM_AVG_256_SAMPLES</a>&#160;&#160;&#160;3U</td></tr>
<tr class="memdesc:a2bcf68b01a8ff59237bea9b303828e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average 256 samples.  <a href="#a2bcf68b01a8ff59237bea9b303828e4f"></a><br/></td></tr>
<tr class="separator:a2bcf68b01a8ff59237bea9b303828e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Channel Sequencer Modes of operation.</div></td></tr>
<tr class="memitem:a223c74befcd8a6710ea7a7acbaf41636"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:a223c74befcd8a6710ea7a7acbaf41636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Safe Mode.  <a href="#a223c74befcd8a6710ea7a7acbaf41636"></a><br/></td></tr>
<tr class="separator:a223c74befcd8a6710ea7a7acbaf41636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5917a2edc464012891450744a15a0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#abd5917a2edc464012891450744a15a0c">XSM_SEQ_MODE_ONEPASS</a>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:abd5917a2edc464012891450744a15a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Onepass through Sequencer.  <a href="#abd5917a2edc464012891450744a15a0c"></a><br/></td></tr>
<tr class="separator:abd5917a2edc464012891450744a15a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090e870886f3ed8d58efc57c763772f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a090e870886f3ed8d58efc57c763772f2">XSM_SEQ_MODE_CONTINPASS</a>&#160;&#160;&#160;2U</td></tr>
<tr class="memdesc:a090e870886f3ed8d58efc57c763772f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continuous Cycling Seqquencer.  <a href="#a090e870886f3ed8d58efc57c763772f2"></a><br/></td></tr>
<tr class="separator:a090e870886f3ed8d58efc57c763772f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4487fa8b08f41c807433ef456abc75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3c4487fa8b08f41c807433ef456abc75">XSM_SEQ_MODE_SINGCHAN</a>&#160;&#160;&#160;3U</td></tr>
<tr class="memdesc:a3c4487fa8b08f41c807433ef456abc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single channel - No Sequencing.  <a href="#a3c4487fa8b08f41c807433ef456abc75"></a><br/></td></tr>
<tr class="separator:a3c4487fa8b08f41c807433ef456abc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadcdd4e89cd9d96581f81dfe47dce7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a9fadcdd4e89cd9d96581f81dfe47dce7">XSM_SEQ_MODE_OYLMPUS</a>&#160;&#160;&#160;6U</td></tr>
<tr class="memdesc:a9fadcdd4e89cd9d96581f81dfe47dce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Olympus mode.  <a href="#a9fadcdd4e89cd9d96581f81dfe47dce7"></a><br/></td></tr>
<tr class="separator:a9fadcdd4e89cd9d96581f81dfe47dce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Clock Divisor values range.</div></td></tr>
<tr class="memitem:a6f0bef0dfd3704d427564bf705a7f9ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a6f0bef0dfd3704d427564bf705a7f9ee">XSM_CLK_DIV_MIN</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:a6f0bef0dfd3704d427564bf705a7f9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum Clock Divisor value.  <a href="#a6f0bef0dfd3704d427564bf705a7f9ee"></a><br/></td></tr>
<tr class="separator:a6f0bef0dfd3704d427564bf705a7f9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca34d11f97f4410add9157f7d03d2af4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aca34d11f97f4410add9157f7d03d2af4">XSM_CLK_DIV_MAX</a>&#160;&#160;&#160;255U</td></tr>
<tr class="memdesc:aca34d11f97f4410add9157f7d03d2af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Clock Divisor value.  <a href="#aca34d11f97f4410add9157f7d03d2af4"></a><br/></td></tr>
<tr class="separator:aca34d11f97f4410add9157f7d03d2af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Alarm Threshold(Limit) Register (ATR) indexes.</div></td></tr>
<tr class="memitem:a7e041ad6a624c7014aad8803d2f9667a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7e041ad6a624c7014aad8803d2f9667a">XSM_ATR_TEMP_UPPER</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:a7e041ad6a624c7014aad8803d2f9667a"><td class="mdescLeft">&#160;</td><td class="mdescRight">High user Temperature limit.  <a href="#a7e041ad6a624c7014aad8803d2f9667a"></a><br/></td></tr>
<tr class="separator:a7e041ad6a624c7014aad8803d2f9667a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220ecdeca017ceb88fcb61fcc0f20253"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a220ecdeca017ceb88fcb61fcc0f20253">XSM_ATR_SUP1_UPPER</a>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:a220ecdeca017ceb88fcb61fcc0f20253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply1 high voltage limit.  <a href="#a220ecdeca017ceb88fcb61fcc0f20253"></a><br/></td></tr>
<tr class="separator:a220ecdeca017ceb88fcb61fcc0f20253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8435336cfcb347810a70af56f310bd67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a8435336cfcb347810a70af56f310bd67">XSM_ATR_SUP2_UPPER</a>&#160;&#160;&#160;2U</td></tr>
<tr class="memdesc:a8435336cfcb347810a70af56f310bd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply2 high voltage limit.  <a href="#a8435336cfcb347810a70af56f310bd67"></a><br/></td></tr>
<tr class="separator:a8435336cfcb347810a70af56f310bd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2f92bee99f2e78c2418bb237763ab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aca2f92bee99f2e78c2418bb237763ab4">XSM_ATR_OT_UPPER</a>&#160;&#160;&#160;3U</td></tr>
<tr class="memdesc:aca2f92bee99f2e78c2418bb237763ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper Over Temperature limit.  <a href="#aca2f92bee99f2e78c2418bb237763ab4"></a><br/></td></tr>
<tr class="separator:aca2f92bee99f2e78c2418bb237763ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138ea63ae47cd1478f188045792a5aef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a138ea63ae47cd1478f188045792a5aef">XSM_ATR_TEMP_LOWER</a>&#160;&#160;&#160;4U</td></tr>
<tr class="memdesc:a138ea63ae47cd1478f188045792a5aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low user Temperature.  <a href="#a138ea63ae47cd1478f188045792a5aef"></a><br/></td></tr>
<tr class="separator:a138ea63ae47cd1478f188045792a5aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfa93eff75396bbfad602d8586995d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a6dfa93eff75396bbfad602d8586995d7">XSM_ATR_SUP1_LOWER</a>&#160;&#160;&#160;5U</td></tr>
<tr class="memdesc:a6dfa93eff75396bbfad602d8586995d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suuply1 low voltage limit.  <a href="#a6dfa93eff75396bbfad602d8586995d7"></a><br/></td></tr>
<tr class="separator:a6dfa93eff75396bbfad602d8586995d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b3d8137af325fe8d91c4a1c2d8ee98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af2b3d8137af325fe8d91c4a1c2d8ee98">XSM_ATR_SUP2_LOWER</a>&#160;&#160;&#160;6U</td></tr>
<tr class="memdesc:af2b3d8137af325fe8d91c4a1c2d8ee98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply2 low voltage limit.  <a href="#af2b3d8137af325fe8d91c4a1c2d8ee98"></a><br/></td></tr>
<tr class="separator:af2b3d8137af325fe8d91c4a1c2d8ee98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c17894e2b8cc575bc8192c2ede7f019"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3c17894e2b8cc575bc8192c2ede7f019">XSM_ATR_OT_LOWER</a>&#160;&#160;&#160;7U</td></tr>
<tr class="memdesc:a3c17894e2b8cc575bc8192c2ede7f019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower Over Temperature limit.  <a href="#a3c17894e2b8cc575bc8192c2ede7f019"></a><br/></td></tr>
<tr class="separator:a3c17894e2b8cc575bc8192c2ede7f019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fa91d71bb7459ec43600876c0ad4be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a58fa91d71bb7459ec43600876c0ad4be">XSM_ATR_SUP3_UPPER</a>&#160;&#160;&#160;8U</td></tr>
<tr class="memdesc:a58fa91d71bb7459ec43600876c0ad4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply3 high voltage limit.  <a href="#a58fa91d71bb7459ec43600876c0ad4be"></a><br/></td></tr>
<tr class="separator:a58fa91d71bb7459ec43600876c0ad4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bd95d4a9b4adf4d32a0a3be256a6c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a52bd95d4a9b4adf4d32a0a3be256a6c0">XSM_ATR_SUP4_UPPER</a>&#160;&#160;&#160;9U</td></tr>
<tr class="memdesc:a52bd95d4a9b4adf4d32a0a3be256a6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply4 high voltage limit.  <a href="#a52bd95d4a9b4adf4d32a0a3be256a6c0"></a><br/></td></tr>
<tr class="separator:a52bd95d4a9b4adf4d32a0a3be256a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe102c2c4b1420b0994523817e71e14c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#afe102c2c4b1420b0994523817e71e14c">XSM_ATR_SUP5_UPPER</a>&#160;&#160;&#160;0xAU</td></tr>
<tr class="memdesc:afe102c2c4b1420b0994523817e71e14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply5 high voltage limit.  <a href="#afe102c2c4b1420b0994523817e71e14c"></a><br/></td></tr>
<tr class="separator:afe102c2c4b1420b0994523817e71e14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83e730e268431827c2476b071e98708"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ab83e730e268431827c2476b071e98708">XSM_ATR_SUP6_UPPER</a>&#160;&#160;&#160;0xBU</td></tr>
<tr class="memdesc:ab83e730e268431827c2476b071e98708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply6 high voltage limit.  <a href="#ab83e730e268431827c2476b071e98708"></a><br/></td></tr>
<tr class="separator:ab83e730e268431827c2476b071e98708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b01f56ee33bf0ed6e0d42cac33cb50f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a5b01f56ee33bf0ed6e0d42cac33cb50f">XSM_ATR_SUP3_LOWER</a>&#160;&#160;&#160;0xCU</td></tr>
<tr class="memdesc:a5b01f56ee33bf0ed6e0d42cac33cb50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply3 low voltage limit.  <a href="#a5b01f56ee33bf0ed6e0d42cac33cb50f"></a><br/></td></tr>
<tr class="separator:a5b01f56ee33bf0ed6e0d42cac33cb50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970695f46a5c360347d0241132e66a15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a970695f46a5c360347d0241132e66a15">XSM_ATR_SUP4_LOWER</a>&#160;&#160;&#160;0xDU</td></tr>
<tr class="memdesc:a970695f46a5c360347d0241132e66a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply4 low voltage limit.  <a href="#a970695f46a5c360347d0241132e66a15"></a><br/></td></tr>
<tr class="separator:a970695f46a5c360347d0241132e66a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f380b3303cda01b3b9d7ac319485c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ad5f380b3303cda01b3b9d7ac319485c3">XSM_ATR_SUP5_LOWER</a>&#160;&#160;&#160;0xEU</td></tr>
<tr class="memdesc:ad5f380b3303cda01b3b9d7ac319485c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply5 low voltage limit.  <a href="#ad5f380b3303cda01b3b9d7ac319485c3"></a><br/></td></tr>
<tr class="separator:ad5f380b3303cda01b3b9d7ac319485c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d07244310934945baa3160cb52809df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7d07244310934945baa3160cb52809df">XSM_ATR_SUP6_LOWER</a>&#160;&#160;&#160;0xFU</td></tr>
<tr class="memdesc:a7d07244310934945baa3160cb52809df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply6 low voltage limit.  <a href="#a7d07244310934945baa3160cb52809df"></a><br/></td></tr>
<tr class="separator:a7d07244310934945baa3160cb52809df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cd72cf7f17d1a282951a12e141ea8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af8cd72cf7f17d1a282951a12e141ea8d">XSM_ATR_SUP7_UPPER</a>&#160;&#160;&#160;0x10U</td></tr>
<tr class="memdesc:af8cd72cf7f17d1a282951a12e141ea8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply7 high voltage limit.  <a href="#af8cd72cf7f17d1a282951a12e141ea8d"></a><br/></td></tr>
<tr class="separator:af8cd72cf7f17d1a282951a12e141ea8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf3eaff26d3b2df6c0bb2b78ff454d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3bf3eaff26d3b2df6c0bb2b78ff454d2">XSM_ATR_SUP8_UPPER</a>&#160;&#160;&#160;0x11U</td></tr>
<tr class="memdesc:a3bf3eaff26d3b2df6c0bb2b78ff454d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply8 high voltage limit.  <a href="#a3bf3eaff26d3b2df6c0bb2b78ff454d2"></a><br/></td></tr>
<tr class="separator:a3bf3eaff26d3b2df6c0bb2b78ff454d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a5f33197223d36588ac2414674c391"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a62a5f33197223d36588ac2414674c391">XSM_ATR_SUP9_UPPER</a>&#160;&#160;&#160;0x12U</td></tr>
<tr class="memdesc:a62a5f33197223d36588ac2414674c391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply9 high voltage limit.  <a href="#a62a5f33197223d36588ac2414674c391"></a><br/></td></tr>
<tr class="separator:a62a5f33197223d36588ac2414674c391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e518f2b534c43f92efa7c1e605f46ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a6e518f2b534c43f92efa7c1e605f46ba">XSM_ATR_SUP10_UPPER</a>&#160;&#160;&#160;0x13U</td></tr>
<tr class="memdesc:a6e518f2b534c43f92efa7c1e605f46ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply10 high voltage limit.  <a href="#a6e518f2b534c43f92efa7c1e605f46ba"></a><br/></td></tr>
<tr class="separator:a6e518f2b534c43f92efa7c1e605f46ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb02464e70f858c8c3cde15456e1d9ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aeb02464e70f858c8c3cde15456e1d9ec">XSM_ATR_VCCAMS_UPPER</a>&#160;&#160;&#160;0x14U</td></tr>
<tr class="memdesc:aeb02464e70f858c8c3cde15456e1d9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCCAMS high voltage limit.  <a href="#aeb02464e70f858c8c3cde15456e1d9ec"></a><br/></td></tr>
<tr class="separator:aeb02464e70f858c8c3cde15456e1d9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eb3b0945f7c93a178c67fe0bb66d9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ad1eb3b0945f7c93a178c67fe0bb66d9f">XSM_ATR_TEMP_RMTE_UPPER</a>&#160;&#160;&#160;0x15U</td></tr>
<tr class="memdesc:ad1eb3b0945f7c93a178c67fe0bb66d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">High remote Temperature limit.  <a href="#ad1eb3b0945f7c93a178c67fe0bb66d9f"></a><br/></td></tr>
<tr class="separator:ad1eb3b0945f7c93a178c67fe0bb66d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd13eee75fe9d48b9d004652cb12e1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a9cd13eee75fe9d48b9d004652cb12e1f">XSM_ATR_SUP7_LOWER</a>&#160;&#160;&#160;0x18U</td></tr>
<tr class="memdesc:a9cd13eee75fe9d48b9d004652cb12e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply7 low voltage limit.  <a href="#a9cd13eee75fe9d48b9d004652cb12e1f"></a><br/></td></tr>
<tr class="separator:a9cd13eee75fe9d48b9d004652cb12e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9886bb5d8f5e9c7ab14da5d66106b77e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a9886bb5d8f5e9c7ab14da5d66106b77e">XSM_ATR_SUP8_LOWER</a>&#160;&#160;&#160;0x19U</td></tr>
<tr class="memdesc:a9886bb5d8f5e9c7ab14da5d66106b77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply8 low voltage limit.  <a href="#a9886bb5d8f5e9c7ab14da5d66106b77e"></a><br/></td></tr>
<tr class="separator:a9886bb5d8f5e9c7ab14da5d66106b77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9f70508a6fc65111524555a8cbab63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3c9f70508a6fc65111524555a8cbab63">XSM_ATR_SUP9_LOWER</a>&#160;&#160;&#160;0x1AU</td></tr>
<tr class="memdesc:a3c9f70508a6fc65111524555a8cbab63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply9 low voltage limit.  <a href="#a3c9f70508a6fc65111524555a8cbab63"></a><br/></td></tr>
<tr class="separator:a3c9f70508a6fc65111524555a8cbab63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d16bad767fc1c4e8f02dd606efbe742"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7d16bad767fc1c4e8f02dd606efbe742">XSM_ATR_SUP10_LOWER</a>&#160;&#160;&#160;0x1BU</td></tr>
<tr class="memdesc:a7d16bad767fc1c4e8f02dd606efbe742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply10 low voltage limit.  <a href="#a7d16bad767fc1c4e8f02dd606efbe742"></a><br/></td></tr>
<tr class="separator:a7d16bad767fc1c4e8f02dd606efbe742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3c58830b92f1368d828cc30d6fcfd9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a0f3c58830b92f1368d828cc30d6fcfd9">XSM_ATR_VCCAMS_LOWER</a>&#160;&#160;&#160;0x1CU</td></tr>
<tr class="memdesc:a0f3c58830b92f1368d828cc30d6fcfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCCAMS low voltage limit.  <a href="#a0f3c58830b92f1368d828cc30d6fcfd9"></a><br/></td></tr>
<tr class="separator:a0f3c58830b92f1368d828cc30d6fcfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b816bc88f59e9b497fa66f336babd99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a9b816bc88f59e9b497fa66f336babd99">XSM_ATR_TEMP_RMTE_LOWER</a>&#160;&#160;&#160;0x1DU</td></tr>
<tr class="memdesc:a9b816bc88f59e9b497fa66f336babd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low remote Temperature limit.  <a href="#a9b816bc88f59e9b497fa66f336babd99"></a><br/></td></tr>
<tr class="separator:a9b816bc88f59e9b497fa66f336babd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Alarm masks for channels in Configuration registers 1</div></td></tr>
<tr class="memitem:aa05b5c4679a807629e4478ac21c07bba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aa05b5c4679a807629e4478ac21c07bba">XSM_CFR_ALM_SUPPLY13_MASK</a>&#160;&#160;&#160;0x200000</td></tr>
<tr class="memdesc:aa05b5c4679a807629e4478ac21c07bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 6 - SUPPLY6.  <a href="#aa05b5c4679a807629e4478ac21c07bba"></a><br/></td></tr>
<tr class="separator:aa05b5c4679a807629e4478ac21c07bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b254ba9b0fa4a16cb8c85d09e1d4d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a40b254ba9b0fa4a16cb8c85d09e1d4d9">XSM_CFR_ALM_SUPPLY12_MASK</a>&#160;&#160;&#160;0x100000</td></tr>
<tr class="memdesc:a40b254ba9b0fa4a16cb8c85d09e1d4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 6 - SUPPLY6.  <a href="#a40b254ba9b0fa4a16cb8c85d09e1d4d9"></a><br/></td></tr>
<tr class="separator:a40b254ba9b0fa4a16cb8c85d09e1d4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c6bb5bcc7fa47a0098c1324cda1f27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a14c6bb5bcc7fa47a0098c1324cda1f27">XSM_CFR_ALM_SUPPLY11_MASK</a>&#160;&#160;&#160;0x080000</td></tr>
<tr class="memdesc:a14c6bb5bcc7fa47a0098c1324cda1f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 6 - SUPPLY6.  <a href="#a14c6bb5bcc7fa47a0098c1324cda1f27"></a><br/></td></tr>
<tr class="separator:a14c6bb5bcc7fa47a0098c1324cda1f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce2b0d52d92328019e103dd3205c820"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7ce2b0d52d92328019e103dd3205c820">XSM_CFR_ALM_SUPPLY10_MASK</a>&#160;&#160;&#160;0x040000</td></tr>
<tr class="memdesc:a7ce2b0d52d92328019e103dd3205c820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 6 - SUPPLY6.  <a href="#a7ce2b0d52d92328019e103dd3205c820"></a><br/></td></tr>
<tr class="separator:a7ce2b0d52d92328019e103dd3205c820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ce336fba61a108bd9b56dad419de6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ac0ce336fba61a108bd9b56dad419de6e">XSM_CFR_ALM_SUPPLY9_MASK</a>&#160;&#160;&#160;0x020000</td></tr>
<tr class="memdesc:ac0ce336fba61a108bd9b56dad419de6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 6 - SUPPLY6.  <a href="#ac0ce336fba61a108bd9b56dad419de6e"></a><br/></td></tr>
<tr class="separator:ac0ce336fba61a108bd9b56dad419de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f1ab5ec444d4210083808046e4d779"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a78f1ab5ec444d4210083808046e4d779">XSM_CFR_ALM_SUPPLY8_MASK</a>&#160;&#160;&#160;0x010000</td></tr>
<tr class="memdesc:a78f1ab5ec444d4210083808046e4d779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 6 - SUPPLY6.  <a href="#a78f1ab5ec444d4210083808046e4d779"></a><br/></td></tr>
<tr class="separator:a78f1ab5ec444d4210083808046e4d779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2543cfe1cfcfe989d7e361b9365e185"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ab2543cfe1cfcfe989d7e361b9365e185">XSM_CFR_ALM_SUPPLY6_MASK</a>&#160;&#160;&#160;0x0800</td></tr>
<tr class="memdesc:ab2543cfe1cfcfe989d7e361b9365e185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 6 - SUPPLY6.  <a href="#ab2543cfe1cfcfe989d7e361b9365e185"></a><br/></td></tr>
<tr class="separator:ab2543cfe1cfcfe989d7e361b9365e185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd6b739fd7953414edc24e672d3ec38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a8bd6b739fd7953414edc24e672d3ec38">XSM_CFR_ALM_SUPPLY5_MASK</a>&#160;&#160;&#160;0x0400</td></tr>
<tr class="memdesc:a8bd6b739fd7953414edc24e672d3ec38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 5 - SUPPLY5.  <a href="#a8bd6b739fd7953414edc24e672d3ec38"></a><br/></td></tr>
<tr class="separator:a8bd6b739fd7953414edc24e672d3ec38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faf17a94077f5b556fbfab9ad1d3f79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a4faf17a94077f5b556fbfab9ad1d3f79">XSM_CFR_ALM_SUPPLY4_MASK</a>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:a4faf17a94077f5b556fbfab9ad1d3f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 4 - SUPPLY4.  <a href="#a4faf17a94077f5b556fbfab9ad1d3f79"></a><br/></td></tr>
<tr class="separator:a4faf17a94077f5b556fbfab9ad1d3f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5468b12d45def4d7b462ac5a735c1605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a5468b12d45def4d7b462ac5a735c1605">XSM_CFR_ALM_SUPPLY3_MASK</a>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a5468b12d45def4d7b462ac5a735c1605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 3 - SUPPLY3.  <a href="#a5468b12d45def4d7b462ac5a735c1605"></a><br/></td></tr>
<tr class="separator:a5468b12d45def4d7b462ac5a735c1605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae990f0790723d434fe1948753771d62e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ae990f0790723d434fe1948753771d62e">XSM_CFR_ALM_SUPPLY2_MASK</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:ae990f0790723d434fe1948753771d62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 2 - SUPPLY2.  <a href="#ae990f0790723d434fe1948753771d62e"></a><br/></td></tr>
<tr class="separator:ae990f0790723d434fe1948753771d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf617c1e2104003abbd7cec9a69411f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#adf617c1e2104003abbd7cec9a69411f7">XSM_CFR_ALM_SUPPLY1_MASK</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:adf617c1e2104003abbd7cec9a69411f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 1 - SUPPLY1.  <a href="#adf617c1e2104003abbd7cec9a69411f7"></a><br/></td></tr>
<tr class="separator:adf617c1e2104003abbd7cec9a69411f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ff380ea74c831bcf39a5c46652d056"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a69ff380ea74c831bcf39a5c46652d056">XSM_CFR_ALM_TEMP_MASK</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a69ff380ea74c831bcf39a5c46652d056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm 0 - Temperature.  <a href="#a69ff380ea74c831bcf39a5c46652d056"></a><br/></td></tr>
<tr class="separator:a69ff380ea74c831bcf39a5c46652d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e30d664f1f3cc61bf0728c28633221a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a1e30d664f1f3cc61bf0728c28633221a">XSM_CFR_ALM_OT_MASK</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a1e30d664f1f3cc61bf0728c28633221a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Over Temperature Alarm.  <a href="#a1e30d664f1f3cc61bf0728c28633221a"></a><br/></td></tr>
<tr class="separator:a1e30d664f1f3cc61bf0728c28633221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a14abd273c5da859d91988eca63d0414c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a14abd273c5da859d91988eca63d0414c">XSysMonPsu_Handler</a> )(void *CallBackRef)</td></tr>
<tr class="memdesc:a14abd273c5da859d91988eca63d0414c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data type defines a handler that an application defines to communicate with interrupt system to retrieve state information about an application.  <a href="#a14abd273c5da859d91988eca63d0414c"></a><br/></td></tr>
<tr class="separator:a14abd273c5da859d91988eca63d0414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8cd0584410c0931f931aa4da1e3e151b"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, <a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr class="memdesc:a8cd0584410c0931f931aa4da1e3e151b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> device/instance.  <a href="#a8cd0584410c0931f931aa4da1e3e151b"></a><br/></td></tr>
<tr class="separator:a8cd0584410c0931f931aa4da1e3e151b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fc9daa41e50955a71e2fe7a107a0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ad6fc9daa41e50955a71e2fe7a107a0e5">XSysMonPsu_Reset</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:ad6fc9daa41e50955a71e2fe7a107a0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the SystemMonitor.  <a href="#ad6fc9daa41e50955a71e2fe7a107a0e5"></a><br/></td></tr>
<tr class="separator:ad6fc9daa41e50955a71e2fe7a107a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1841bc7888195dd3f9381947e4f8d3"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a5e1841bc7888195dd3f9381947e4f8d3">XSysMonPsu_GetStatus</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a5e1841bc7888195dd3f9381947e4f8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the contents of the Status Register.  <a href="#a5e1841bc7888195dd3f9381947e4f8d3"></a><br/></td></tr>
<tr class="separator:a5e1841bc7888195dd3f9381947e4f8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed2a9f0fbd1be48dfd71aaeef05174f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2ed2a9f0fbd1be48dfd71aaeef05174f">XSysMonPsu_StartAdcConversion</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:a2ed2a9f0fbd1be48dfd71aaeef05174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts the ADC conversion in the Single Channel event driven sampling mode.  <a href="#a2ed2a9f0fbd1be48dfd71aaeef05174f"></a><br/></td></tr>
<tr class="separator:a2ed2a9f0fbd1be48dfd71aaeef05174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eb6ba4c6f594b75d402cde03f6e173"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 Block)</td></tr>
<tr class="memdesc:a54eb6ba4c6f594b75d402cde03f6e173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ADC converted data for the specified channel.  <a href="#a54eb6ba4c6f594b75d402cde03f6e173"></a><br/></td></tr>
<tr class="separator:a54eb6ba4c6f594b75d402cde03f6e173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83bb4ad116f2bb1ea7676050bd74b6b"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af83bb4ad116f2bb1ea7676050bd74b6b">XSysMonPsu_GetCalibCoefficient</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 CoeffType, u32 SysmonBlk)</td></tr>
<tr class="memdesc:af83bb4ad116f2bb1ea7676050bd74b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the calibration coefficient data for the specified parameter.  <a href="#af83bb4ad116f2bb1ea7676050bd74b6b"></a><br/></td></tr>
<tr class="separator:af83bb4ad116f2bb1ea7676050bd74b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4312c89ab0280cd7df2de940193fe32"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 MeasurementType, u32 SysmonBlk)</td></tr>
<tr class="memdesc:aa4312c89ab0280cd7df2de940193fe32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the Minimum/Maximum measurement for one of the XSM_MIN_* or XSM_MAX_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>.  <a href="#aa4312c89ab0280cd7df2de940193fe32"></a><br/></td></tr>
<tr class="separator:aa4312c89ab0280cd7df2de940193fe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711d9441ecb7c36f22b11f941d7f994b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a711d9441ecb7c36f22b11f941d7f994b">XSysMonPsu_SetAvg</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Average, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a711d9441ecb7c36f22b11f941d7f994b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the number of samples of averaging that is to be done for all the channels in both the single channel mode and sequence mode of operations.  <a href="#a711d9441ecb7c36f22b11f941d7f994b"></a><br/></td></tr>
<tr class="separator:a711d9441ecb7c36f22b11f941d7f994b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d99a653ec8c8089e8cdc9e4f400dc3"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a78d99a653ec8c8089e8cdc9e4f400dc3">XSysMonPsu_GetAvg</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a78d99a653ec8c8089e8cdc9e4f400dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the number of samples of averaging configured for all the channels in the Configuration Register 0.  <a href="#a78d99a653ec8c8089e8cdc9e4f400dc3"></a><br/></td></tr>
<tr class="separator:a78d99a653ec8c8089e8cdc9e4f400dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872e9a41818489e77fa554dd01408281"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 IncreaseAcqCycles, u32 IsEventMode, u32 IsDifferentialMode, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a872e9a41818489e77fa554dd01408281"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the given parameters in the Configuration Register 0 in the single channel mode.  <a href="#a872e9a41818489e77fa554dd01408281"></a><br/></td></tr>
<tr class="separator:a872e9a41818489e77fa554dd01408281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8ca01b6992994737213f342847662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3ce8ca01b6992994737213f342847662">XSysMonPsu_SetAlarmEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 AlmEnableMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a3ce8ca01b6992994737213f342847662"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the alarm outputs for the specified alarms in the Configuration Registers 1:  <a href="#a3ce8ca01b6992994737213f342847662"></a><br/></td></tr>
<tr class="separator:a3ce8ca01b6992994737213f342847662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c38e475226ff1eba528d0c9b7eb9b5"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ab1c38e475226ff1eba528d0c9b7eb9b5">XSysMonPsu_GetAlarmEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:ab1c38e475226ff1eba528d0c9b7eb9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of the alarm output enables in the Configuration Register 1.  <a href="#ab1c38e475226ff1eba528d0c9b7eb9b5"></a><br/></td></tr>
<tr class="separator:ab1c38e475226ff1eba528d0c9b7eb9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bdb4e555b2c8d47a0185862c9cb4c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#aa4bdb4e555b2c8d47a0185862c9cb4c6">XSysMonPsu_SetSequencerMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 SequencerMode, u32 SysmonBlk)</td></tr>
<tr class="memdesc:aa4bdb4e555b2c8d47a0185862c9cb4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the specified Channel Sequencer Mode in the Configuration Register 1 :  <a href="#aa4bdb4e555b2c8d47a0185862c9cb4c6"></a><br/></td></tr>
<tr class="separator:aa4bdb4e555b2c8d47a0185862c9cb4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2d5053a1406cecd4fa311525f68ce7"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a2f2d5053a1406cecd4fa311525f68ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the channel sequencer mode from the Configuration Register 1.  <a href="#a2f2d5053a1406cecd4fa311525f68ce7"></a><br/></td></tr>
<tr class="separator:a2f2d5053a1406cecd4fa311525f68ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193dbc689e9a668ef7f548920706b2a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a193dbc689e9a668ef7f548920706b2a8">XSysMonPsu_SetSequencerEvent</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 IsEventMode, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a193dbc689e9a668ef7f548920706b2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the Event mode or Continuous mode in the sequencer mode.  <a href="#a193dbc689e9a668ef7f548920706b2a8"></a><br/></td></tr>
<tr class="separator:a193dbc689e9a668ef7f548920706b2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b98e18bb6c2c8b3587e2fe2cffde8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a6a0b98e18bb6c2c8b3587e2fe2cffde8">XSysMonPsu_GetSequencerEvent</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a6a0b98e18bb6c2c8b3587e2fe2cffde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the mode of the sequencer.  <a href="#a6a0b98e18bb6c2c8b3587e2fe2cffde8"></a><br/></td></tr>
<tr class="separator:a6a0b98e18bb6c2c8b3587e2fe2cffde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4903002cdddf192acdcda4827e5b1a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Channel, u32 SysmonBlk)</td></tr>
<tr class="memdesc:ab4903002cdddf192acdcda4827e5b1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the external mux and connects a channel to the mux.  <a href="#ab4903002cdddf192acdcda4827e5b1a6"></a><br/></td></tr>
<tr class="separator:ab4903002cdddf192acdcda4827e5b1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3ad732967594b6cc1cc314e24ae9b0"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a5e3ad732967594b6cc1cc314e24ae9b0">XSysMonPsu_GetExtenalMux</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a5e3ad732967594b6cc1cc314e24ae9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the external mux channel.  <a href="#a5e3ad732967594b6cc1cc314e24ae9b0"></a><br/></td></tr>
<tr class="separator:a5e3ad732967594b6cc1cc314e24ae9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e8fc0b9dffbe33b41ec4e6825ffc4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a11e8fc0b9dffbe33b41ec4e6825ffc4a">XSysMonPsu_SetAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 Divisor, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a11e8fc0b9dffbe33b41ec4e6825ffc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the frequency of the ADCCLK by configuring the DCLK to ADCCLK ratio in the Configuration Register #2.  <a href="#a11e8fc0b9dffbe33b41ec4e6825ffc4a"></a><br/></td></tr>
<tr class="separator:a11e8fc0b9dffbe33b41ec4e6825ffc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c7d46d66608863cf7b859238e44e13"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#af6c7d46d66608863cf7b859238e44e13">XSysMonPsu_GetAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:af6c7d46d66608863cf7b859238e44e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function gets the ADCCLK divisor from the Configuration Register 2.  <a href="#af6c7d46d66608863cf7b859238e44e13"></a><br/></td></tr>
<tr class="separator:af6c7d46d66608863cf7b859238e44e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c7ebcfb5e5e7014deaabaa8f6261eb"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a15c7ebcfb5e5e7014deaabaa8f6261eb">XSysMonPsu_UpdateAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a15c7ebcfb5e5e7014deaabaa8f6261eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function update the ADCCLK divisor to the Configuration Register 2.  <a href="#a15c7ebcfb5e5e7014deaabaa8f6261eb"></a><br/></td></tr>
<tr class="separator:a15c7ebcfb5e5e7014deaabaa8f6261eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51295c525a507a8f334c97f02a84221"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ac51295c525a507a8f334c97f02a84221">XSysMonPsu_SetSeqChEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 ChEnableMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:ac51295c525a507a8f334c97f02a84221"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the specified channels in the ADC Channel Selection Sequencer Registers.  <a href="#ac51295c525a507a8f334c97f02a84221"></a><br/></td></tr>
<tr class="separator:ac51295c525a507a8f334c97f02a84221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0cf3c7c355471f81fe60d663043e7b"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#adf0cf3c7c355471f81fe60d663043e7b">XSysMonPsu_GetSeqAvgEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:adf0cf3c7c355471f81fe60d663043e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the channels for which the averaging has been enabled in the ADC Channel Averaging Enables Sequencer Registers.  <a href="#adf0cf3c7c355471f81fe60d663043e7b"></a><br/></td></tr>
<tr class="separator:adf0cf3c7c355471f81fe60d663043e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d0525934fbe21b46732c039f93a8b0"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a08d0525934fbe21b46732c039f93a8b0">XSysMonPsu_GetSeqChEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a08d0525934fbe21b46732c039f93a8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the channel enable bits status from the ADC Channel Selection Sequencer Registers.  <a href="#a08d0525934fbe21b46732c039f93a8b0"></a><br/></td></tr>
<tr class="separator:a08d0525934fbe21b46732c039f93a8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb114566387fa8889b913f34a7de6010"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#adb114566387fa8889b913f34a7de6010">XSysMonPsu_SetSeqAvgEnables</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 AvgEnableChMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:adb114566387fa8889b913f34a7de6010"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the averaging for the specified channels in the ADC Channel Averaging Enable Sequencer Registers.  <a href="#adb114566387fa8889b913f34a7de6010"></a><br/></td></tr>
<tr class="separator:adb114566387fa8889b913f34a7de6010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b751279110ca4a05073ae8a9b8a1a8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ae6b751279110ca4a05073ae8a9b8a1a8">XSysMonPsu_SetSeqInputMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 InputModeChMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:ae6b751279110ca4a05073ae8a9b8a1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Analog input mode for the specified channels in the ADC Channel Analog-Input Mode Sequencer Registers.  <a href="#ae6b751279110ca4a05073ae8a9b8a1a8"></a><br/></td></tr>
<tr class="separator:ae6b751279110ca4a05073ae8a9b8a1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e597e2db96739d90195d9ad019377c4"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a2e597e2db96739d90195d9ad019377c4">XSysMonPsu_GetSeqInputMode</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a2e597e2db96739d90195d9ad019377c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the Analog input mode for all the channels from the ADC Channel Analog-Input Mode Sequencer Registers.  <a href="#a2e597e2db96739d90195d9ad019377c4"></a><br/></td></tr>
<tr class="separator:a2e597e2db96739d90195d9ad019377c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe5ce3d9e15f0bebdab313decf9729c"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#acfe5ce3d9e15f0bebdab313decf9729c">XSysMonPsu_SetSeqAcqTime</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 AcqCyclesChMask, u32 SysmonBlk)</td></tr>
<tr class="memdesc:acfe5ce3d9e15f0bebdab313decf9729c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the number of Acquisition cycles in the ADC Channel Acquisition Time Sequencer Registers.  <a href="#acfe5ce3d9e15f0bebdab313decf9729c"></a><br/></td></tr>
<tr class="separator:acfe5ce3d9e15f0bebdab313decf9729c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8261ca6ec1564b9066f858adbd81a85f"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a8261ca6ec1564b9066f858adbd81a85f">XSysMonPsu_GetSeqAcqTime</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a8261ca6ec1564b9066f858adbd81a85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status of acquisition time from the ADC Channel Acquisition Time Sequencer Registers.  <a href="#a8261ca6ec1564b9066f858adbd81a85f"></a><br/></td></tr>
<tr class="separator:a8261ca6ec1564b9066f858adbd81a85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d436ab807a561d70339cdfe52f6f560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 AlarmThrReg, u16 Value, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a6d436ab807a561d70339cdfe52f6f560"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions sets the contents of the given Alarm Threshold Register.  <a href="#a6d436ab807a561d70339cdfe52f6f560"></a><br/></td></tr>
<tr class="separator:a6d436ab807a561d70339cdfe52f6f560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708bc2465a24743784ce6119bc05b10a"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u8 AlarmThrReg, u32 SysmonBlk)</td></tr>
<tr class="memdesc:a708bc2465a24743784ce6119bc05b10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the contents of the specified Alarm Threshold Register.  <a href="#a708bc2465a24743784ce6119bc05b10a"></a><br/></td></tr>
<tr class="separator:a708bc2465a24743784ce6119bc05b10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118f51203c23bf2ed1f76d154e46ad3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a118f51203c23bf2ed1f76d154e46ad3c">XSysMonPsu_SetPSAutoConversion</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:a118f51203c23bf2ed1f76d154e46ad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the conversion to be automatic for PS SysMon.  <a href="#a118f51203c23bf2ed1f76d154e46ad3c"></a><br/></td></tr>
<tr class="separator:a118f51203c23bf2ed1f76d154e46ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f2fde294e151e5db65822b26f11a4f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#ad9f2fde294e151e5db65822b26f11a4f">XSysMonPsu_GetMonitorStatus</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:ad9f2fde294e151e5db65822b26f11a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the AMS monitor status.  <a href="#ad9f2fde294e151e5db65822b26f11a4f"></a><br/></td></tr>
<tr class="separator:ad9f2fde294e151e5db65822b26f11a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97be122426bd5302e93b45ba5a3fc8ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a97be122426bd5302e93b45ba5a3fc8ec">XSysMonPsu_IntrEnable</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 Mask)</td></tr>
<tr class="memdesc:a97be122426bd5302e93b45ba5a3fc8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the specified interrupts in the device.  <a href="#a97be122426bd5302e93b45ba5a3fc8ec"></a><br/></td></tr>
<tr class="separator:a97be122426bd5302e93b45ba5a3fc8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f581ea48eb8d57c2fab2dcaefdeccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a95f581ea48eb8d57c2fab2dcaefdeccd">XSysMonPsu_IntrDisable</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 Mask)</td></tr>
<tr class="memdesc:a95f581ea48eb8d57c2fab2dcaefdeccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the specified interrupts in the device.  <a href="#a95f581ea48eb8d57c2fab2dcaefdeccd"></a><br/></td></tr>
<tr class="separator:a95f581ea48eb8d57c2fab2dcaefdeccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b39afe5e1c62f44a320311d74e2402"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a78b39afe5e1c62f44a320311d74e2402">XSysMonPsu_IntrGetEnabled</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:a78b39afe5e1c62f44a320311d74e2402"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the enabled interrupts read from the Interrupt Enable Register (IER).  <a href="#a78b39afe5e1c62f44a320311d74e2402"></a><br/></td></tr>
<tr class="separator:a78b39afe5e1c62f44a320311d74e2402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef44a74426b13480363747a5dedc5d0"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a3ef44a74426b13480363747a5dedc5d0">XSysMonPsu_IntrGetStatus</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:a3ef44a74426b13480363747a5dedc5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the interrupt status read from Interrupt Status Register(ISR).  <a href="#a3ef44a74426b13480363747a5dedc5d0"></a><br/></td></tr>
<tr class="separator:a3ef44a74426b13480363747a5dedc5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c41996bf95cd7119dba302246345a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a7c41996bf95cd7119dba302246345a9d">XSysMonPsu_IntrClear</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr, u64 Mask)</td></tr>
<tr class="memdesc:a7c41996bf95cd7119dba302246345a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the specified interrupts in the Interrupt Status Register (ISR).  <a href="#a7c41996bf95cd7119dba302246345a9d"></a><br/></td></tr>
<tr class="separator:a7c41996bf95cd7119dba302246345a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d8d59cc35fe4151b51b5bbafdca2ca"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest</a> (<a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *InstancePtr)</td></tr>
<tr class="memdesc:a39d8d59cc35fe4151b51b5bbafdca2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a self-test on the driver/device.  <a href="#a39d8d59cc35fe4151b51b5bbafdca2ca"></a><br/></td></tr>
<tr class="separator:a39d8d59cc35fe4151b51b5bbafdca2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948f08280b6195869015382d92ba8a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmonpsu_8h.html#a948f08280b6195869015382d92ba8a50">XSysMonPsu_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:a948f08280b6195869015382d92ba8a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for the device configuration based on the unique device ID.  <a href="#a948f08280b6195869015382d92ba8a50"></a><br/></td></tr>
<tr class="separator:a948f08280b6195869015382d92ba8a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3c17894e2b8cc575bc8192c2ede7f019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_OT_LOWER&#160;&#160;&#160;7U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower Over Temperature limit. </p>

</div>
</div>
<a class="anchor" id="aca2f92bee99f2e78c2418bb237763ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_OT_UPPER&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper Over Temperature limit. </p>

</div>
</div>
<a class="anchor" id="a7d16bad767fc1c4e8f02dd606efbe742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP10_LOWER&#160;&#160;&#160;0x1BU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply10 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a6e518f2b534c43f92efa7c1e605f46ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP10_UPPER&#160;&#160;&#160;0x13U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply10 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a6dfa93eff75396bbfad602d8586995d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP1_LOWER&#160;&#160;&#160;5U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suuply1 low voltage limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a220ecdeca017ceb88fcb61fcc0f20253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP1_UPPER&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply1 high voltage limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>, and <a class="el" href="xsysmonpsu__selftest_8c.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="af2b3d8137af325fe8d91c4a1c2d8ee98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP2_LOWER&#160;&#160;&#160;6U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply2 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a8435336cfcb347810a70af56f310bd67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP2_UPPER&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply2 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a5b01f56ee33bf0ed6e0d42cac33cb50f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP3_LOWER&#160;&#160;&#160;0xCU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply3 low voltage limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a58fa91d71bb7459ec43600876c0ad4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP3_UPPER&#160;&#160;&#160;8U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply3 high voltage limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a970695f46a5c360347d0241132e66a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP4_LOWER&#160;&#160;&#160;0xDU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply4 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a52bd95d4a9b4adf4d32a0a3be256a6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP4_UPPER&#160;&#160;&#160;9U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply4 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="ad5f380b3303cda01b3b9d7ac319485c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP5_LOWER&#160;&#160;&#160;0xEU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply5 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="afe102c2c4b1420b0994523817e71e14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP5_UPPER&#160;&#160;&#160;0xAU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply5 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a7d07244310934945baa3160cb52809df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP6_LOWER&#160;&#160;&#160;0xFU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply6 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="ab83e730e268431827c2476b071e98708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP6_UPPER&#160;&#160;&#160;0xBU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply6 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a9cd13eee75fe9d48b9d004652cb12e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP7_LOWER&#160;&#160;&#160;0x18U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply7 low voltage limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold()</a>, and <a class="el" href="xsysmonpsu_8h.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="af8cd72cf7f17d1a282951a12e141ea8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP7_UPPER&#160;&#160;&#160;0x10U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply7 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a9886bb5d8f5e9c7ab14da5d66106b77e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP8_LOWER&#160;&#160;&#160;0x19U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply8 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a3bf3eaff26d3b2df6c0bb2b78ff454d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP8_UPPER&#160;&#160;&#160;0x11U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply8 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a3c9f70508a6fc65111524555a8cbab63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP9_LOWER&#160;&#160;&#160;0x1AU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply9 low voltage limit. </p>

</div>
</div>
<a class="anchor" id="a62a5f33197223d36588ac2414674c391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_SUP9_UPPER&#160;&#160;&#160;0x12U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply9 high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a138ea63ae47cd1478f188045792a5aef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_LOWER&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low user Temperature. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b816bc88f59e9b497fa66f336babd99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_RMTE_LOWER&#160;&#160;&#160;0x1DU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low remote Temperature limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold()</a>, and <a class="el" href="xsysmonpsu_8h.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1eb3b0945f7c93a178c67fe0bb66d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_RMTE_UPPER&#160;&#160;&#160;0x15U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High remote Temperature limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold()</a>, and <a class="el" href="xsysmonpsu_8h.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e041ad6a624c7014aad8803d2f9667a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_UPPER&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High user Temperature limit. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f3c58830b92f1368d828cc30d6fcfd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCAMS_LOWER&#160;&#160;&#160;0x1CU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCAMS low voltage limit. </p>

</div>
</div>
<a class="anchor" id="aeb02464e70f858c8c3cde15456e1d9ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCAMS_UPPER&#160;&#160;&#160;0x14U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCAMS high voltage limit. </p>

</div>
</div>
<a class="anchor" id="a81e97c4d54cab391a4c816f2bb666a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_0_SAMPLES&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No Averaging. </p>

</div>
</div>
<a class="anchor" id="a7cd77d90e7456614726390476f3636c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_16_SAMPLES&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average 16 samples. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__low__level__example_8c.html#a9e7072b7a66ba79e4b21e515b11fa04f">SysMonPsuLowLevelExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a2bcf68b01a8ff59237bea9b303828e4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_256_SAMPLES&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average 256 samples. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a711d9441ecb7c36f22b11f941d7f994b">XSysMonPsu_SetAvg()</a>.</p>

</div>
</div>
<a class="anchor" id="a30eabcd0f343d52159cce69aad462c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_64_SAMPLES&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average 64 samples. </p>

</div>
</div>
<a class="anchor" id="a47dbdfce05bdc719f09f56e36ac154b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_ADC_OFFSET_COEFF&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADC Offset Calib Coefficient. </p>

</div>
</div>
<a class="anchor" id="a173a9675e7f812b837aab6cf61457b6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_GAIN_ERROR_COEFF&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gain Error Calib Coefficient. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#af83bb4ad116f2bb1ea7676050bd74b6b">XSysMonPsu_GetCalibCoefficient()</a>.</p>

</div>
</div>
<a class="anchor" id="a6152ac28d736b4e0d1e214f3377fd1e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_SUPPLY_OFFSET_COEFF&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply Offset Calib Coefficient. </p>

</div>
</div>
<a class="anchor" id="a1e30d664f1f3cc61bf0728c28633221a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_OT_MASK&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Over Temperature Alarm. </p>

</div>
</div>
<a class="anchor" id="a7ce2b0d52d92328019e103dd3205c820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY10_MASK&#160;&#160;&#160;0x040000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="a14c6bb5bcc7fa47a0098c1324cda1f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY11_MASK&#160;&#160;&#160;0x080000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="a40b254ba9b0fa4a16cb8c85d09e1d4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY12_MASK&#160;&#160;&#160;0x100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="aa05b5c4679a807629e4478ac21c07bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY13_MASK&#160;&#160;&#160;0x200000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="adf617c1e2104003abbd7cec9a69411f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY1_MASK&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 1 - SUPPLY1. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ae990f0790723d434fe1948753771d62e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY2_MASK&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 2 - SUPPLY2. </p>

</div>
</div>
<a class="anchor" id="a5468b12d45def4d7b462ac5a735c1605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY3_MASK&#160;&#160;&#160;0x0100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 3 - SUPPLY3. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a4faf17a94077f5b556fbfab9ad1d3f79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY4_MASK&#160;&#160;&#160;0x0200</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 4 - SUPPLY4. </p>

</div>
</div>
<a class="anchor" id="a8bd6b739fd7953414edc24e672d3ec38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY5_MASK&#160;&#160;&#160;0x0400</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 5 - SUPPLY5. </p>

</div>
</div>
<a class="anchor" id="ab2543cfe1cfcfe989d7e361b9365e185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY6_MASK&#160;&#160;&#160;0x0800</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="a78f1ab5ec444d4210083808046e4d779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY8_MASK&#160;&#160;&#160;0x010000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="ac0ce336fba61a108bd9b56dad419de6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_SUPPLY9_MASK&#160;&#160;&#160;0x020000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 6 - SUPPLY6. </p>

</div>
</div>
<a class="anchor" id="a69ff380ea74c831bcf39a5c46652d056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CFR_ALM_TEMP_MASK&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alarm 0 - Temperature. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a802955d06a498aca0909e488caee528c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_ADC_CALIB&#160;&#160;&#160;0x09U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADC Offset Channel Reg. </p>

</div>
</div>
<a class="anchor" id="ae8c007df4d1c481557120435619b4ff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_AUX_MAX&#160;&#160;&#160;31U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Channel number for Last Aux channel. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, <a class="el" href="xsysmonpsu_8h.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a41aa90146d4e0786b8d36888e44aac34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_AUX_MIN&#160;&#160;&#160;16U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Channel number for 1st Aux Channel. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a2526be2a1f3319c068088aade1c73eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_DDRPHY_VREF&#160;&#160;&#160;58U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DDRPHY_VREF. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a15ea4b9f08ee9dc44fc000384ca36e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_GAINERR_CALIB&#160;&#160;&#160;0x0AU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gain Error Channel Reg. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="ae411c55817a64b2351271181ebdae254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_RESERVE1&#160;&#160;&#160;63U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PSGT_AT0. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b564ae32085a3fc51c452d1babe46db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY1&#160;&#160;&#160;0x1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY1 VCC_PSINTLP. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a39654f20bba10aa6e1cd7985fe75ea70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY10&#160;&#160;&#160;35U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY10 PS_MGTRAVTT. </p>

</div>
</div>
<a class="anchor" id="a80fb0fe44e342aad8c2d19d1f435284a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY2&#160;&#160;&#160;0x2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY2 VCC_PSINTFP. </p>

</div>
</div>
<a class="anchor" id="a7c4df26dc69ef41921c484fd3ccc006c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY3&#160;&#160;&#160;0x6U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY3 VCC_PSAUX. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a2939dda6d5c6efbcf10977c6b33aa7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY4&#160;&#160;&#160;0x0DU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY4 VCC_PSDDR_504. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3880806109f07b635bb02c599fced14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY5&#160;&#160;&#160;0x0EU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY5 VCC_PSIO3_503. </p>

</div>
</div>
<a class="anchor" id="a4afc3f01bbea8bc4f94435b5cd5e1915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY6&#160;&#160;&#160;0x0FU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY6 VCC_PSIO0_500. </p>

</div>
</div>
<a class="anchor" id="aba50e39946a244f7565b8d15c3ffabb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY7&#160;&#160;&#160;32U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY7 VCC_PSIO1_501. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>.</p>

</div>
</div>
<a class="anchor" id="aadf08790ddd9d8b02768583c3f250636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY8&#160;&#160;&#160;33U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY8 VCC_PSIO2_502. </p>

</div>
</div>
<a class="anchor" id="a7d8c7547ed4d7e1652b7e078bc6230ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY9&#160;&#160;&#160;34U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SUPPLY9 PS_MGTRAVCC. </p>

</div>
</div>
<a class="anchor" id="a3fdb14478def5283880cd4d65dfaf56f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY_CALIB&#160;&#160;&#160;0x08U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply Calib Data Reg. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="af2f79c54dddbdf090934f80f315b2e60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_TEMP&#160;&#160;&#160;0x0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On Chip Temperature. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ace8eebd74607658044e98c7b5ca1c0c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_TEMP_REMTE&#160;&#160;&#160;37U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Temperature Remote. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a432956207f2e1b259f9d320739b5d286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSDDRPLL&#160;&#160;&#160;57U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSDDRPLL. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a367867d9ef353a759eb5d33620bffed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSLL0&#160;&#160;&#160;48U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSLL0. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu_8h.html#a54eb6ba4c6f594b75d402cde03f6e173">XSysMonPsu_GetAdcData()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b87dfb4207793ed9043629c32488aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCC_PSLL3&#160;&#160;&#160;51U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCC_PSLL3. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a69dbddc6ab704c05c513e9d3957167a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCAMS&#160;&#160;&#160;36U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCAMS. </p>

</div>
</div>
<a class="anchor" id="a1c6a2517306958c69f3259057d3649a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCAUX&#160;&#160;&#160;56U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCAUX. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c791d8747031b6e7fdc85cac810241a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCBRAM&#160;&#160;&#160;55U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCBRAM. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a715e29a748cdd1b301bec9ac17c4c7f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCINT&#160;&#160;&#160;54U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VCCINT. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>.</p>

</div>
</div>
<a class="anchor" id="af9c81d9f5fa3d80cad2b374c84117840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VPVN&#160;&#160;&#160;0x3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VP/VN Dedicated analog inputs. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a120bab2a7a97a74da70eef07204728fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VREFN&#160;&#160;&#160;0x5U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VREFN. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#ab4903002cdddf192acdcda4827e5b1a6">XSysMonPsu_SetExtenalMux()</a>.</p>

</div>
</div>
<a class="anchor" id="a676a91c5452aa7ec285794dc3ee13d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VREFP&#160;&#160;&#160;0x4U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VREFP. </p>

</div>
</div>
<a class="anchor" id="aca34d11f97f4410add9157f7d03d2af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CLK_DIV_MAX&#160;&#160;&#160;255U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum Clock Divisor value. </p>

</div>
</div>
<a class="anchor" id="a6f0bef0dfd3704d427564bf705a7f9ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CLK_DIV_MIN&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum Clock Divisor value. </p>

</div>
</div>
<a class="anchor" id="a2ab1b4304d1e781bd7a9908718620c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY1&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY1 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ad452144ae98a77893ab4056e341b47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY10&#160;&#160;&#160;0x83U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY10 Data. </p>

</div>
</div>
<a class="anchor" id="a1e17f28a5b5e02447d0674120e5a9257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY2&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY2 Data. </p>

</div>
</div>
<a class="anchor" id="a4cc0e390c18e733d61a5bec32f8f806f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY3&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY3 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4ef6de7f4d6dd4bcc55ea7f7e0d5f66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY4&#160;&#160;&#160;8U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY4 Data. </p>

</div>
</div>
<a class="anchor" id="af94baf233cff0eac2a5aa299a05a7937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY5&#160;&#160;&#160;9U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY5 Data. </p>

</div>
</div>
<a class="anchor" id="a9e519a87a8d9330083e59826065eb259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY6&#160;&#160;&#160;0xAU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY6 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="aa21e53b8ba182fbe4481563ed3edc772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY7&#160;&#160;&#160;0x80U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY7 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8253f7661c72912e98b88d128fcb50b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY8&#160;&#160;&#160;0x81U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY8 Data. </p>

</div>
</div>
<a class="anchor" id="ad5d3f6c621f7d737ce7697947a8f39d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_SUPPLY9&#160;&#160;&#160;0x82U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum SUPPLY9 Data. </p>

</div>
</div>
<a class="anchor" id="a35d9814abedb2943f4a84ecff66351e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_TEMP&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum Temperature Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="acf402d972e5855885a587779aa75f802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_TEMP_REMOTE&#160;&#160;&#160;0x85U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum Remote Temperature Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="a592a7d4901c3adeae9b0e28be37c8484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VCCAMS&#160;&#160;&#160;0x84U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum VCCAMS Data. </p>

</div>
</div>
<a class="anchor" id="acda48741be11b7a96ece33a3f67dbd74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY1&#160;&#160;&#160;5U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY1 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a74372e940f4e159070de88166b07a344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY10&#160;&#160;&#160;0x8BU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY10 Data. </p>

</div>
</div>
<a class="anchor" id="a9b0e0664dcc3a6fb227157d1e49ce255"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY2&#160;&#160;&#160;6U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY2 Data. </p>

</div>
</div>
<a class="anchor" id="a4ae90b5125c90a5ecf98415c05e493a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY3&#160;&#160;&#160;7U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY3 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a92681353913a769554b3a03f0a614bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY4&#160;&#160;&#160;0xCU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY4 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="a685eed612478874918c1d2ae77ae93e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY5&#160;&#160;&#160;0xDU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY5 Data. </p>

</div>
</div>
<a class="anchor" id="af309384ae3efb40dd11f11a5e7170671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY6&#160;&#160;&#160;0xEU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY6 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="aec0f9f1e8ad9a98083f6e399a2d8b5e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY7&#160;&#160;&#160;0x88U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY7 Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="a139cbe1dcb71891e7681ca57d9fc7b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY8&#160;&#160;&#160;0x89U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY8 Data. </p>

</div>
</div>
<a class="anchor" id="a7b172c8397ed0cbb59ed58a0b5265194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_SUPPLY9&#160;&#160;&#160;0x8AU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum SUPPLY9 Data. </p>

</div>
</div>
<a class="anchor" id="af3acf3098ee563aa1cc3e35555d4e801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_TEMP&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum Temperature Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="acd364c7df27909c07ca9df995f4c0af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_TEMP_REMOTE&#160;&#160;&#160;0x8DU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum Remote Temperature Data. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4312c89ab0280cd7df2de940193fe32">XSysMonPsu_GetMinMaxMeasurement()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3d4d25ec322db4f763a371168dcccf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VCCAMS&#160;&#160;&#160;0x8CU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum VCCAMS Data. </p>

</div>
</div>
<a class="anchor" id="a090e870886f3ed8d58efc57c763772f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_CONTINPASS&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continuous Cycling Seqquencer. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__low__level__example_8c.html#a9e7072b7a66ba79e4b21e515b11fa04f">SysMonPsuLowLevelExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="abd5917a2edc464012891450744a15a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_ONEPASS&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Onepass through Sequencer. </p>

</div>
</div>
<a class="anchor" id="a9fadcdd4e89cd9d96581f81dfe47dce7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_OYLMPUS&#160;&#160;&#160;6U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Olympus mode. </p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#aa4bdb4e555b2c8d47a0185862c9cb4c6">XSysMonPsu_SetSequencerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="a223c74befcd8a6710ea7a7acbaf41636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_SAFE&#160;&#160;&#160;0U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Safe Mode. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__low__level__example_8c.html#a9e7072b7a66ba79e4b21e515b11fa04f">SysMonPsuLowLevelExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, <a class="el" href="xsysmonpsu_8h.html#acfe5ce3d9e15f0bebdab313decf9729c">XSysMonPsu_SetSeqAcqTime()</a>, <a class="el" href="xsysmonpsu_8h.html#adb114566387fa8889b913f34a7de6010">XSysMonPsu_SetSeqAvgEnables()</a>, <a class="el" href="xsysmonpsu_8h.html#ac51295c525a507a8f334c97f02a84221">XSysMonPsu_SetSeqChEnables()</a>, and <a class="el" href="xsysmonpsu_8h.html#ae6b751279110ca4a05073ae8a9b8a1a8">XSysMonPsu_SetSeqInputMode()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c4487fa8b08f41c807433ef456abc75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_SINGCHAN&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single channel - No Sequencing. </p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>, <a class="el" href="xsysmonpsu_8h.html#aa4bdb4e555b2c8d47a0185862c9cb4c6">XSysMonPsu_SetSequencerMode()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab3e135004e7d5995a827caa045883e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_RawToTemperature_ExternalRef</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AdcData</td><td>)</td>
          <td>&#160;&#160;&#160;((((float)(AdcData)/65536.0f)/0.00197008621f ) - 279.4266f)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts System Monitor Raw Data to Temperature(centigrades) for external reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdcData</td><td>is the SysMon Raw ADC Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Temperature in centigrades.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: float XSysMon_RawToTemperature_ExternalRef(u32 AdcData) </dd></dl>

</div>
</div>
<a class="anchor" id="a380d87507652a19d453b20e6d7655d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_RawToTemperature_OnChip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AdcData</td><td>)</td>
          <td>&#160;&#160;&#160;((((float)(AdcData)/65536.0f)/0.00196342531f ) - 280.2309f)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts System Monitor Raw Data to Temperature(centigrades) for On-Chip Sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdcData</td><td>is the SysMon Raw ADC Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Temperature in centigrades.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: float XSysMon_RawToTemperature_OnChip(u32 AdcData) </dd></dl>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="af6667f0fcc65dda4a7af897b2924143c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_RawToVoltage</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AdcData</td><td>)</td>
          <td>&#160;&#160;&#160;((((float)(AdcData))* (3.0f))/65536.0f)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts System Monitor Raw Data to Voltage(volts) other than VCCO_PSIO supply. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdcData</td><td>is the System Monitor ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Voltage in volts.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: float XSysMon_RawToVoltage(u32 AdcData) </dd></dl>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a50b32ba6617a306fd1f12c7d34151722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_TemperatureToRaw_ExternalRef</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Temperature</td><td>)</td>
          <td>&#160;&#160;&#160;((s32)(((Temperature) + 279.4266f)*65536.0f*0.00197008621f))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts Temperature in centigrades to System Monitor Raw Data for external reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Temperature</td><td>is the Temperature in centigrades to be converted to System Monitor ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The System Monitor ADC Raw Data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: int XSysMon_TemperatureToRaw_ExternalRef(float Temperature) </dd></dl>

</div>
</div>
<a class="anchor" id="a977b419288fae23364d46bc87d6976ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_TemperatureToRaw_OnChip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Temperature</td><td>)</td>
          <td>&#160;&#160;&#160;((s32)(((Temperature) + 280.2309f)*65536.0f*0.00196342531f))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts Temperature in centigrades to System Monitor Raw Data for On-Chip Sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Temperature</td><td>is the Temperature in centigrades to be converted to System Monitor ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The System Monitor ADC Raw Data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: int XSysMon_TemperatureToRaw_OnChip(float Temperature) </dd></dl>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ad74fd43c8a038933bc2580837b95cee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_VccopsioRawToVoltage</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AdcData</td><td>)</td>
          <td>&#160;&#160;&#160;((((float)(AdcData))* (6.0f))/65536.0f)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts System Monitor Raw Data to Voltage(volts) for VCCO_PSIO supply. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdcData</td><td>is the System Monitor ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Voltage in volts.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: float XSysMon_RawToVoltage(u32 AdcData) </dd></dl>

</div>
</div>
<a class="anchor" id="a05b960d7be1902cbefc489cc0ae4ec95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_VccopsioVoltageToRaw</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Voltage</td><td>)</td>
          <td>&#160;&#160;&#160;((s32)((Voltage)*65536.0f/6.0f))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts Voltage in Volts to System Monitor Raw Data for VCCO_PSIO supply. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Voltage</td><td>is the Voltage in volts to be converted to System Monitor/ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The System Monitor ADC Raw Data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: int XSysMon_VoltageToRaw(float Voltage) </dd></dl>

</div>
</div>
<a class="anchor" id="a986f164c3c1f811ea27713adf9dace4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_VoltageToRaw</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Voltage</td><td>)</td>
          <td>&#160;&#160;&#160;((s32)((Voltage)*65536.0f/3.0f))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts Voltage in Volts to System Monitor Raw Data other than VCCO_PSIO supply. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Voltage</td><td>is the Voltage in volts to be converted to System Monitor/ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The System Monitor ADC Raw Data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: int XSysMon_VoltageToRaw(float Voltage) </dd></dl>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ce87fd508744ddc0de0c9954f71e1f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMonPsu_VpVnRawToVoltage</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AdcData</td><td>)</td>
          <td>&#160;&#160;&#160;((((float)(AdcData))* (1.0f))/65536.0f)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro converts System Monitor Raw Data to Voltage(volts) for VpVn supply. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdcData</td><td>is the System Monitor ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Voltage in volts.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: float XSysMon_VpVnRawToVoltage(u32 AdcData) </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a14abd273c5da859d91988eca63d0414c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XSysMonPsu_Handler)(void *CallBackRef)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This data type defines a handler that an application defines to communicate with interrupt system to retrieve state information about an application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is a callback reference passed in by the upper layer when setting the handler, and is passed back to the upper layer when the handler is called. It is used to find the device driver instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8cd0584410c0931f931aa4da1e3e151b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> device/instance. </p>
<p>This function must be called prior to using the System Monitor device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">ConfigPtr</td><td>points to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> device configuration structure. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory address space. If the address translation is not used then the physical address is passed. Unexpected errors may occur if the address mapping is changed after this function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The user needs to first call the <a class="el" href="xsysmonpsu_8h.html#a948f08280b6195869015382d92ba8a50" title="This function looks for the device configuration based on the unique device ID.">XSysMonPsu_LookupConfig()</a> API which returns the Configuration structure pointer which is passed as a parameter to the <a class="el" href="xsysmonpsu_8c.html#a8cd0584410c0931f931aa4da1e3e151b" title="This function initializes XSysMonPsu device/instance.">XSysMonPsu_CfgInitialize()</a> API. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu___config.html#abc6dabd175ea52cdf0dbf5b32798f62d">XSysMonPsu_Config::DeviceId</a>, <a class="el" href="struct_x_sys_mon_psu___config.html#a7ff0bfe3d5f7cb06792fe7ed481711ad">XSysMonPsu_Config::InputClockMHz</a>, <a class="el" href="struct_x_sys_mon_psu.html#aa71eec0e2a0e06244feded448d359278">XSysMonPsu::IsPlAccessibleByPs</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a7c41996bf95cd7119dba302246345a9d">XSysMonPsu_IntrClear()</a>, <a class="el" href="xsysmonpsu_8h.html#a3ef44a74426b13480363747a5dedc5d0">XSysMonPsu_IntrGetStatus()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4107b908b0a66ed314fa19c9458e10dd">XSYSMONPSU_PL_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu_8c.html#ad6fc9daa41e50955a71e2fe7a107a0e5">XSysMonPsu_Reset()</a>, and <a class="el" href="xsysmonpsu_8c.html#a15c7ebcfb5e5e7014deaabaa8f6261eb">XSysMonPsu_UpdateAdcClkDivisor()</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="af6c7d46d66608863cf7b859238e44e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function gets the ADCCLK divisor from the Configuration Register 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XSysMon instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The divisor read from the Configuration Register 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5a77bafe25ef83d49e8091cbe661d974">XSYSMONPSU_CFG_REG2_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a54eb6ba4c6f594b75d402cde03f6e173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetAdcData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ADC converted data for the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number. Use the XSM_CH_* defined in the file <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>. The valid channels for PS / PL SysMon are 0 - 6, 8 - 10 and 13 - 37. For AMS, 38 - 53 channels are valid. </td></tr>
    <tr><td class="paramname">Block</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block or the AMS controller register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the ADC converted data for the specified channel. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please make sure that the proper channel number is passed. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a15ea4b9f08ee9dc44fc000384ca36e42">XSM_CH_GAINERR_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ae411c55817a64b2351271181ebdae254">XSM_CH_RESERVE1</a>, <a class="el" href="xsysmonpsu_8h.html#a7c4df26dc69ef41921c484fd3ccc006c">XSM_CH_SUPPLY3</a>, <a class="el" href="xsysmonpsu_8h.html#a2939dda6d5c6efbcf10977c6b33aa7fb">XSM_CH_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#aba50e39946a244f7565b8d15c3ffabb8">XSM_CH_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#a3fdb14478def5283880cd4d65dfaf56f">XSM_CH_SUPPLY_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ace8eebd74607658044e98c7b5ca1c0c6">XSM_CH_TEMP_REMTE</a>, <a class="el" href="xsysmonpsu_8h.html#a367867d9ef353a759eb5d33620bffed4">XSM_CH_VCC_PSLL0</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1c38e475226ff1eba528d0c9b7eb9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetAlarmEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of the alarm output enables in the Configuration Register 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is the bit-mask of the enabled alarm outputs in the Configuration Register 1. Use the masks XSYSMONPSU_CFG_REG1_ALRM_*_MASK masks defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to interpret the returned value.</dd></dl>
<p>Bit positions of 1 indicate that the alarm output is enabled. Bit positions of 0 indicate that the alarm output is disabled.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that alarms for the bit positions of 1 will be disabled and alarms for bit positions of 0 will be enabled. The enabled alarm outputs returned by this function is the negated value of the the data read from the Configuration Register 1. Upper 16 bits of return value are valid only if the channel selected is PS. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a708bc2465a24743784ce6119bc05b10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetAlarmThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>AlarmThrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the contents of the specified Alarm Threshold Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlarmThrReg</td><td>is the index of an Alarm Threshold Register to be read. Use XSM_ATR_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to specify the index. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the contents of the selected Alarm Threshold Register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9cd13eee75fe9d48b9d004652cb12e1f">XSM_ATR_SUP7_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#a9b816bc88f59e9b497fa66f336babd99">XSM_ATR_TEMP_RMTE_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#ad1eb3b0945f7c93a178c67fe0bb66d9f">XSM_ATR_TEMP_RMTE_UPPER</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a531009f056913bfecb5b591d9f91385c">XSYSMONPSU_ALRM_TEMP_UPR_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__selftest_8c.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a78d99a653ec8c8089e8cdc9e4f400dc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetAvg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the number of samples of averaging configured for all the channels in the Configuration Register 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The averaging read from the Configuration Register 0 is returned. Use the XSM_AVG_* bit definitions defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> file to interpret the returned value :<ul>
<li>XSM_AVG_0_SAMPLES means no averaging</li>
<li>XSM_AVG_16_SAMPLES means 16 samples of averaging</li>
<li>XSM_AVG_64_SAMPLES means 64 samples of averaging</li>
<li>XSM_AVG_256_SAMPLES means 256 samples of averaging</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="af83bb4ad116f2bb1ea7676050bd74b6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetCalibCoefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>CoeffType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the calibration coefficient data for the specified parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">CoeffType</td><td>specifies the calibration coefficient to be read. Use XSM_CALIB_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to specify the calibration coefficient to be read. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the calibration coefficient. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a173a9675e7f812b837aab6cf61457b6d">XSM_CALIB_GAIN_ERROR_COEFF</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a2177cbc8b73be4ce1c76ba03c674e5d6">XSYSMONPSU_CAL_SUP_OFF_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a5e3ad732967594b6cc1cc314e24ae9b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetExtenalMux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the external mux channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the channel number used to connect to the external Mux. The valid channels are 0 to 6, 8 to 16, and 31 to 36..</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="aa4312c89ab0280cd7df2de940193fe32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMonPsu_GetMinMaxMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>MeasurementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the Minimum/Maximum measurement for one of the XSM_MIN_* or XSM_MAX_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">MeasurementType</td><td>specifies the parameter for which the Minimum/Maximum measurement has to be read. Use XSM_MAX_* and XSM_MIN_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to specify the data to be read. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit value representing the maximum/minimum measurement for specified parameter. The System Monitor device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of 16 bit data read from the device. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9e519a87a8d9330083e59826065eb259">XSM_MAX_SUPPLY6</a>, <a class="el" href="xsysmonpsu_8h.html#aa21e53b8ba182fbe4481563ed3edc772">XSM_MAX_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#acf402d972e5855885a587779aa75f802">XSM_MAX_TEMP_REMOTE</a>, <a class="el" href="xsysmonpsu_8h.html#a92681353913a769554b3a03f0a614bcb">XSM_MIN_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#af309384ae3efb40dd11f11a5e7170671">XSM_MIN_SUPPLY6</a>, <a class="el" href="xsysmonpsu_8h.html#aec0f9f1e8ad9a98083f6e399a2d8b5e5">XSM_MIN_SUPPLY7</a>, <a class="el" href="xsysmonpsu_8h.html#acd364c7df27909c07ca9df995f4c0af7">XSM_MIN_TEMP_REMOTE</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9f2fde294e151e5db65822b26f11a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetMonitorStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the AMS monitor status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the monitor status. See XSYSMONPSU_MON_STS_*_MASK definations present in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> for knowing the status.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a621f41dbdff59725822f0dc2f29ac1e8">XSYSMONPSU_MON_STS_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a8261ca6ec1564b9066f858adbd81a85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqAcqTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status of acquisition time from the ADC Channel Acquisition Time Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The acquisition time for all the channels. Use XSYSMONPSU_SEQ_ACQ* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which acquisition cycles are extended and bit mask of 0 are the channels for which acquisition cycles are not extended.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a579ce307d7e8b3d85718b47dbeaa48a2">XSYSMONPSU_SEQ_ACQ0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a7f5b375d3e31219c17cbb4dc14ae4eec">XSYSMONPSU_SEQ_ACQ1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a88183705d7e03a3d8eeee6366d09b5f5">XSYSMONPSU_SEQ_ACQ2_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="adf0cf3c7c355471f81fe60d663043e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqAvgEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the channels for which the averaging has been enabled in the ADC Channel Averaging Enables Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of averaging (enabled/disabled) for all the channels. Use XSYSMONPSU_SEQ_AVERAGE* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which averaging is enabled and bit mask of 0 are the channels for averaging is disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a26a83b449c5188602bafa2bfaa24e18c">XSYSMONPSU_SEQ_AVERAGE0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ac44a549f1306faa4359a6a48ddd17dfd">XSYSMONPSU_SEQ_AVERAGE1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a08d0525934fbe21b46732c039f93a8b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqChEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the channel enable bits status from the ADC Channel Selection Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gets the channel enable bits. Use XSYSMONPSU_SEQ_CH* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels that are enabled and bit mask of 0 are the channels that are disabled.</dd>
<dd>
None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#abf302f7a79ec4d2aee5b9756441ce71d">XSYSMONPSU_SEQ_CH0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a4c4cf4e1f8965f7095c9a7c58938555f">XSYSMONPSU_SEQ_CH1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a2e597e2db96739d90195d9ad019377c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_GetSeqInputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the Analog input mode for all the channels from the ADC Channel Analog-Input Mode Sequencer Registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input mode for all the channels. Use XSYSMONPSU_SEQ_INPUT_MDE* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which input mode is differential/Bipolar and bit mask of 0 are the channels for which input mode is unipolar.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae709951620a41ee0f994506d3782b3e9">XSYSMONPSU_SEQ_INPUT_MDE0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#af6c54048b7704171bda202c378d50920">XSYSMONPSU_SEQ_INPUT_MDE1_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a6a0b98e18bb6c2c8b3587e2fe2cffde8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_GetSequencerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the mode of the sequencer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the Sequencer mode. XSYSMONPSU_EVENT_MODE for Event mode and XSYSMONPSU_CONTINUOUS_MODE for continuous mode.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a2f2d5053a1406cecd4fa311525f68ce7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_GetSequencerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the channel sequencer mode from the Configuration Register 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The channel sequencer mode :<ul>
<li>XSM_SEQ_MODE_SAFE : Default safe mode</li>
<li>XSM_SEQ_MODE_ONEPASS : One pass through sequence</li>
<li>XSM_SEQ_MODE_CONTINPASS : Continuous channel sequencing</li>
<li>XSM_SEQ_MODE_SINGCHAN : Single channel/Sequencer off</li>
<li>XSM_SEQ_MODE_OLYMPUS : Olympus sampling mode</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#acfe5ce3d9e15f0bebdab313decf9729c">XSysMonPsu_SetSeqAcqTime()</a>, <a class="el" href="xsysmonpsu_8h.html#adb114566387fa8889b913f34a7de6010">XSysMonPsu_SetSeqAvgEnables()</a>, <a class="el" href="xsysmonpsu_8h.html#ac51295c525a507a8f334c97f02a84221">XSysMonPsu_SetSeqChEnables()</a>, <a class="el" href="xsysmonpsu_8h.html#ae6b751279110ca4a05073ae8a9b8a1a8">XSysMonPsu_SetSeqInputMode()</a>, and <a class="el" href="xsysmonpsu_8h.html#a872e9a41818489e77fa554dd01408281">XSysMonPsu_SetSingleChParams()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1841bc7888195dd3f9381947e4f8d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMonPsu_GetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the contents of the Status Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the Status Register. Use the XSYSMONPSU_MON_STS_* constants defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a621f41dbdff59725822f0dc2f29ac1e8">XSYSMONPSU_MON_STS_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a7c41996bf95cd7119dba302246345a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_IntrClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the specified interrupts in the Interrupt Status Register (ISR). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 64 bit-mask of the interrupts to be cleared. Bit positions of 1 will be cleared. Bit positions of 0 will not change the previous interrupt status. This mask is formed by OR'ing the XSYSMONPSU_ISR_0_* and XSYSMONPSU_ISR_1_* bits which are defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a83ea9d678f45ad885e86555b51d308cd">XSYSMONPSU_ISR_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4f60260a330cb9d25d5ff40a293442c5">XSYSMONPSU_ISR_1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>, and <a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a95f581ea48eb8d57c2fab2dcaefdeccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the specified interrupts in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 64 bit-mask of the interrupts to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSYSMONPSU_IDR_0_* and XSYSMONPSU_IDR_1_* bits defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#aa5fe21686201b6560cc6e5745371e4e5">XSYSMONPSU_IDR_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#aa47d1e0081286ed2c4afba303e81ff81">XSYSMONPSU_IDR_1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a97be122426bd5302e93b45ba5a3fc8ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the specified interrupts in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 64 bit-mask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSYSMONPSU_IER_0_* and XSYSMONPSU_IER_1_* bits defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ac651706d7049befe6bcade8d0bf057fc">XSYSMONPSU_IER_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ab7f6d9bc9435dc7fb5d7eb1876745d77">XSYSMONPSU_IER_1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a78b39afe5e1c62f44a320311d74e2402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_IntrGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the enabled interrupts read from the Interrupt Enable Register (IER). </p>
<p>Use the XSYSMONPSU_IER_0_* and XSYSMONPSU_IER_1_* constants defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the returned value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit value representing the contents of the Interrupt Mask Registers (IMR1 IMR0).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5e842a49b82a192506f90c1223dd2464">XSYSMONPSU_IMR_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a9ecf8b14de802966a7dced05b4335e00">XSYSMONPSU_IMR_1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a3ef44a74426b13480363747a5dedc5d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMonPsu_IntrGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the interrupt status read from Interrupt Status Register(ISR). </p>
<p>Use the XSYSMONPSU_ISR_0_* and XSYSMONPSU_ISR_1_ constants defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to interpret the returned value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit value representing the contents of the Interrupt Status Registers (ISR1 ISR0).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a83ea9d678f45ad885e86555b51d308cd">XSYSMONPSU_ISR_0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4f60260a330cb9d25d5ff40a293442c5">XSYSMONPSU_ISR_1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>, and <a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a948f08280b6195869015382d92ba8a50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_sys_mon_psu___config.html">XSysMonPsu_Config</a>* XSysMonPsu_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function looks for the device configuration based on the unique device ID. </p>
<p>The table XSysmonPsu_ConfigTable[] contains the configuration information for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ad6fc9daa41e50955a71e2fe7a107a0e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the SystemMonitor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Upon reset, all Maximum and Minimum status registers will be reset to their default values. Currently running and any averaging will restart. Refer to the device data sheet for the device status and register values after the reset. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a69b79177a69bce2ea1055e2b969a9f57">XSYSMONPSU_VP_VN_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize()</a>, and <a class="el" href="xsysmonpsu__selftest_8c.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a39d8d59cc35fe4151b51b5bbafdca2ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a self-test on the driver/device. </p>
<p>The test</p>
<ul>
<li>Resets the device,</li>
<li>Writes a value into the Alarm Threshold register and reads it back for comparison.</li>
<li>Resets the device again.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the value read from the Alarm Threshold register is the same as the value written.</li>
<li>XST_FAILURE Otherwise</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a destructive test in that resets of the device are performed. Refer to the device specification for the device status after the reset operation. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a220ecdeca017ceb88fcb61fcc0f20253">XSM_ATR_SUP1_UPPER</a>, <a class="el" href="xsysmonpsu_8c.html#a708bc2465a24743784ce6119bc05b10a">XSysMonPsu_GetAlarmThreshold()</a>, <a class="el" href="xsysmonpsu_8c.html#ad6fc9daa41e50955a71e2fe7a107a0e5">XSysMonPsu_Reset()</a>, and <a class="el" href="xsysmonpsu_8c.html#a6d436ab807a561d70339cdfe52f6f560">XSysMonPsu_SetAlarmThreshold()</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a11e8fc0b9dffbe33b41ec4e6825ffc4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the frequency of the ADCCLK by configuring the DCLK to ADCCLK ratio in the Configuration Register #2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Divisor</td><td>is clock divisor used to derive ADCCLK from DCLK. Valid values of the divisor are PS:<ul>
<li>0 means divide by 8.</li>
<li>1,2 means divide by 2.</li>
<li>3 to 255 means divide by that value. PL:</li>
<li>0,1,2 means divide by 2.</li>
<li>3 to 255 means divide by that value. Refer to the device specification for more details. </li>
</ul>
</td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2.<ul>
<li>There is no Assert on the minimum value of the Divisor. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5a77bafe25ef83d49e8091cbe661d974">XSYSMONPSU_CFG_REG2_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce8ca01b6992994737213f342847662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAlarmEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>AlmEnableMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the alarm outputs for the specified alarms in the Configuration Registers 1: </p>
<pre class="fragment">    - OT for Over Temperature (XSYSMONPSU_CFR_REG1_ALRM_OT_MASK)
    - ALM0 for On board Temperature (XSYSMONPSU_CFR_REG1_ALRM_TEMP_MASK)
    - ALM1 for SUPPLY1 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY1_MASK)
    - ALM2 for SUPPLY2 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY2_MASK)
            - ALM3 for SUPPLY3 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY3_MASK)
            - ALM4 for SUPPLY4 (XSYSMONPSU_CFR_REG1_ALRM__SUPPLY4_MASK)
    - ALM5 for SUPPLY5 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY5_MASK)
            - ALM6 for SUPPLY6 (XSYSMONPSU_CFR_REG1_ALRM_SUPPLY6_MASK)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlmEnableMask</td><td>is the bit-mask of the alarm outputs to be enabled in the Configuration Registers 1 and 3. Bit positions of 1 will be enabled. Bit positions of 0 will be disabled. This mask is formed by OR'ing XSYSMONPSU_CFR_REG1_ALRM_*_MASK masks defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>, but XSM_CFR_ALM_SUPPLY8_MASK to XSM_CFR_ALM_SUPPLY13_MASK are applicable only for PS. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that the alarms for bit positions of 0 will be enabled and alarms for bit positions of 1 will be disabled. The alarm outputs specified by the AlmEnableMask are negated before writing to the Configuration Register 1 because it was Disable register bits. Upper 16 bits of AlmEnableMask are applicable only for PS. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d436ab807a561d70339cdfe52f6f560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAlarmThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>AlarmThrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions sets the contents of the given Alarm Threshold Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AlarmThrReg</td><td>is the index of an Alarm Threshold Register to be set. Use XSM_ATR_* constants defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> to specify the index. </td></tr>
    <tr><td class="paramname">Value</td><td>is the 16-bit threshold value to write into the register. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9cd13eee75fe9d48b9d004652cb12e1f">XSM_ATR_SUP7_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#a9b816bc88f59e9b497fa66f336babd99">XSM_ATR_TEMP_RMTE_LOWER</a>, <a class="el" href="xsysmonpsu_8h.html#ad1eb3b0945f7c93a178c67fe0bb66d9f">XSM_ATR_TEMP_RMTE_UPPER</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a531009f056913bfecb5b591d9f91385c">XSYSMONPSU_ALRM_TEMP_UPR_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>, and <a class="el" href="xsysmonpsu__selftest_8c.html#a39d8d59cc35fe4151b51b5bbafdca2ca">XSysMonPsu_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="a711d9441ecb7c36f22b11f941d7f994b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetAvg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of samples of averaging that is to be done for all the channels in both the single channel mode and sequence mode of operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Average</td><td>is the number of samples of averaging programmed to the Configuration Register 0. Use the XSM_AVG_* definitions defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a> file :<ul>
<li>XSM_AVG_0_SAMPLES for no averaging</li>
<li>XSM_AVG_16_SAMPLES for 16 samples of averaging</li>
<li>XSM_AVG_64_SAMPLES for 64 samples of averaging</li>
<li>XSM_AVG_256_SAMPLES for 256 samples of averaging </li>
</ul>
</td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a2bcf68b01a8ff59237bea9b303828e4f">XSM_AVG_256_SAMPLES</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4903002cdddf192acdcda4827e5b1a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetExtenalMux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the external mux and connects a channel to the mux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number used to connect to the external Mux. The valid channels are 0 to 5 and 16 to 31. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li>
<li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a41aa90146d4e0786b8d36888e44aac34">XSM_CH_AUX_MIN</a>, <a class="el" href="xsysmonpsu_8h.html#a120bab2a7a97a74da70eef07204728fb">XSM_CH_VREFN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a118f51203c23bf2ed1f76d154e46ad3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetPSAutoConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the conversion to be automatic for PS SysMon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the auto-trigger mode, sample rate is of 1 Million samples. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="acfe5ce3d9e15f0bebdab313decf9729c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqAcqTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>AcqCyclesChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the number of Acquisition cycles in the ADC Channel Acquisition Time Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AcqCyclesChMask</td><td>is the bit mask of all the channels for which the number of acquisition cycles is to be extended. Use XSYSMONPSU_SEQ_ACQ* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to specify the Channel numbers. Acquisition cycles will be extended to 10 ADCCLK cycles for bit masks of 1 and will be the default 4 ADCCLK cycles for bit masks of 0. The AcqCyclesChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Acquisition Time Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Channel Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a579ce307d7e8b3d85718b47dbeaa48a2">XSYSMONPSU_SEQ_ACQ0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a7f5b375d3e31219c17cbb4dc14ae4eec">XSYSMONPSU_SEQ_ACQ1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a88183705d7e03a3d8eeee6366d09b5f5">XSYSMONPSU_SEQ_ACQ2_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="adb114566387fa8889b913f34a7de6010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqAvgEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>AvgEnableChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the averaging for the specified channels in the ADC Channel Averaging Enable Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">AvgEnableChMask</td><td>is the bit mask of all the channels for which averaging is to be enabled. Use XSYSMONPSU_SEQ_AVERAGE* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to specify the Channel numbers. Averaging will be enabled for bit masks of 1 and disabled for bit mask of 0. The AvgEnableChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Averaging Enable Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Averaging Enables Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a26a83b449c5188602bafa2bfaa24e18c">XSYSMONPSU_SEQ_AVERAGE0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ac44a549f1306faa4359a6a48ddd17dfd">XSYSMONPSU_SEQ_AVERAGE1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ac51295c525a507a8f334c97f02a84221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqChEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>ChEnableMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the specified channels in the ADC Channel Selection Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">ChEnableMask</td><td>is the bit mask of all the channels to be enabled. Use XSYSMONPSU_SEQ_CH* defined in xsysmon_hw.h to specify the Channel numbers. Bit masks of 1 will be enabled and bit mask of 0 will be disabled. The ChEnableMask is a 64 bit mask that is written to the three 16 bit ADC Channel Selection Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Selection Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#abf302f7a79ec4d2aee5b9756441ce71d">XSYSMONPSU_SEQ_CH0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a4c4cf4e1f8965f7095c9a7c58938555f">XSYSMONPSU_SEQ_CH1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ae6b751279110ca4a05073ae8a9b8a1a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSeqInputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>InputModeChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the Analog input mode for the specified channels in the ADC Channel Analog-Input Mode Sequencer Registers. </p>
<p>The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">InputModeChMask</td><td>is the bit mask of all the channels for which the input mode is differential mode. Use XSYSMONPSU_SEQ_INPUT_MDE* defined in <a class="el" href="xsysmonpsu__hw_8h.html">xsysmonpsu_hw.h</a> to specify the channel numbers. Differential or Bipolar input mode will be set for bit masks of 1 and unipolar input mode for bit masks of 0. The InputModeChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Analog-Input Mode Sequencer Registers. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Analog-Input Mode Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae709951620a41ee0f994506d3782b3e9">XSYSMONPSU_SEQ_INPUT_MDE0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#af6c54048b7704171bda202c378d50920">XSYSMONPSU_SEQ_INPUT_MDE1_OFFSET</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, and <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a193dbc689e9a668ef7f548920706b2a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetSequencerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsEventMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the Event mode or Continuous mode in the sequencer mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">IsEventMode</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the channel. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="aa4bdb4e555b2c8d47a0185862c9cb4c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_SetSequencerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SequencerMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the specified Channel Sequencer Mode in the Configuration Register 1 : </p>
<pre class="fragment">    - Default safe mode (XSM_SEQ_MODE_SAFE)
    - One pass through sequence (XSM_SEQ_MODE_ONEPASS)
    - Continuous channel sequencing (XSM_SEQ_MODE_CONTINPASS)
    - Single Channel/Sequencer off (XSM_SEQ_MODE_SINGCHAN)
    - Olympus sampling mode (XSM_SEQ_MODE_OYLMPUS)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">SequencerMode</td><td>is the sequencer mode to be set. Use XSM_SEQ_MODE_* bits defined in <a class="el" href="xsysmonpsu_8h.html">xsysmonpsu.h</a>. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only one of the modes can be enabled at a time. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#a9fadcdd4e89cd9d96581f81dfe47dce7">XSM_SEQ_MODE_OYLMPUS</a>, <a class="el" href="xsysmonpsu_8h.html#a3c4487fa8b08f41c807433ef456abc75">XSM_SEQ_MODE_SINGCHAN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acd26481ffd9f4c26a41779246aa2cf8a">XSYSMONPSU_CFG_REG1_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, <a class="el" href="xsysmonpsu__intr__example_8c.html#a7d6d2900e5e52331b7837e6962527998">SysMonPsuIntrExample()</a>, <a class="el" href="xsysmonpsu__polled__example_8c.html#ab7bffb94efc79e4cb24275177d2674fe">SysMonPsuPolledPrintfExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a872e9a41818489e77fa554dd01408281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSysMonPsu_SetSingleChParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IncreaseAcqCycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsEventMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IsDifferentialMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the given parameters in the Configuration Register 0 in the single channel mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance. </td></tr>
    <tr><td class="paramname">Channel</td><td>is the channel number for conversion. The valid channels are 0 - 6, 8 - 10, 13 - 37. </td></tr>
    <tr><td class="paramname">IncreaseAcqCycles</td><td>is a boolean parameter which specifies whether the Acquisition time for the external channels has to be increased to 10 ADCCLK cycles (specify TRUE) or remain at the default 4 ADCCLK cycles (specify FALSE). This parameter is only valid for the external channels. </td></tr>
    <tr><td class="paramname">IsEventMode</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the given channel. </td></tr>
    <tr><td class="paramname">IsDifferentialMode</td><td>is a boolean parameter which specifies unipolar(specify FALSE) or differential mode (specify TRUE) for the analog inputs. The input mode is only valid for the external channels. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li>
<li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The number of samples for the averaging for all the channels is set by using the function XSysMonPsu_SetAvg.</li>
<li>The calibration of the device is done by doing a ADC conversion on the calibration channel(channel 8). The input parameters IncreaseAcqCycles, IsDifferentialMode and IsEventMode are not valid for this channel. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>, <a class="el" href="xsysmonpsu_8h.html#a41aa90146d4e0786b8d36888e44aac34">XSM_CH_AUX_MIN</a>, <a class="el" href="xsysmonpsu_8h.html#a15ea4b9f08ee9dc44fc000384ca36e42">XSM_CH_GAINERR_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ae411c55817a64b2351271181ebdae254">XSM_CH_RESERVE1</a>, <a class="el" href="xsysmonpsu_8h.html#a7c4df26dc69ef41921c484fd3ccc006c">XSM_CH_SUPPLY3</a>, <a class="el" href="xsysmonpsu_8h.html#a2939dda6d5c6efbcf10977c6b33aa7fb">XSM_CH_SUPPLY4</a>, <a class="el" href="xsysmonpsu_8h.html#a3fdb14478def5283880cd4d65dfaf56f">XSM_CH_SUPPLY_CALIB</a>, <a class="el" href="xsysmonpsu_8h.html#ace8eebd74607658044e98c7b5ca1c0c6">XSM_CH_TEMP_REMTE</a>, <a class="el" href="xsysmonpsu_8h.html#a367867d9ef353a759eb5d33620bffed4">XSM_CH_VCC_PSLL0</a>, <a class="el" href="xsysmonpsu_8h.html#af9c81d9f5fa3d80cad2b374c84117840">XSM_CH_VPVN</a>, <a class="el" href="xsysmonpsu_8h.html#a3c4487fa8b08f41c807433ef456abc75">XSM_SEQ_MODE_SINGCHAN</a>, <a class="el" href="xsysmonpsu__hw_8h.html#acc78e04e37a1d847fc610a978356adc1">XSYSMONPSU_CFG_REG0_OFFSET</a>, <a class="el" href="xsysmonpsu_8c.html#a2f2d5053a1406cecd4fa311525f68ce7">XSysMonPsu_GetSequencerMode()</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu__ams__example_8c.html#a6e50715ab0def63d0fa4ad6ce47fcb3b">SysMonPsuAMSExample()</a>, and <a class="el" href="xsysmonpsu__single__ch__intr__example_8c.html#a88c399487d95b544d35a1bfdf6d296fe">SysMonPsuSingleChannelIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ed2a9f0fbd1be48dfd71aaeef05174f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMonPsu_StartAdcConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts the ADC conversion in the Single Channel event driven sampling mode. </p>
<p>The EOC bit in Status Register will be set once the conversion is finished. Refer to the device specification for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon_psu.html" title="The XSysmonPsu driver instance data.">XSysMonPsu</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default state of the CONVST bit is a logic 0. The conversion is started when the CONVST bit is set to 1 from 0. This bit is self-clearing so that the next conversion can be started by setting this bit. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu.html#ae4e48efa3298714b2e190f2dbfc9566a">XSysMonPsu::IsReady</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5652827d8f6d892c11c0a1a5aa03217d">XSYSMONPSU_PS_SYSMON_CSTS_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a15c7ebcfb5e5e7014deaabaa8f6261eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMonPsu_UpdateAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon_psu.html">XSysMonPsu</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SysmonBlk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function update the ADCCLK divisor to the Configuration Register 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XSysMon instance. </td></tr>
    <tr><td class="paramname">SysmonBlk</td><td>is the value that tells whether it is for PS Sysmon block or PL Sysmon block register region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The divisor update the Configuration Register 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2. </dd></dl>

<p>References <a class="el" href="struct_x_sys_mon_psu___config.html#a8b2fb5ceb1c132536b320f0b317bb1c6">XSysMonPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_sys_mon_psu.html#a37b1b3b387db33d8aedcbe611b27e45b">XSysMonPsu::Config</a>, <a class="el" href="struct_x_sys_mon_psu___config.html#a7ff0bfe3d5f7cb06792fe7ed481711ad">XSysMonPsu_Config::InputClockMHz</a>, <a class="el" href="xsysmonpsu__hw_8h.html#a5a77bafe25ef83d49e8091cbe661d974">XSYSMONPSU_CFG_REG2_OFFSET</a>, <a class="el" href="xsysmonpsu__hw_8h.html#ae9106d31caad5928fff1fc352968f9c1">XSysmonPsu_ReadReg</a>, and <a class="el" href="xsysmonpsu__hw_8h.html#a918c709fe6f8486844b998136fdb2310">XSysmonPsu_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xsysmonpsu_8h.html#a8cd0584410c0931f931aa4da1e3e151b">XSysMonPsu_CfgInitialize()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
