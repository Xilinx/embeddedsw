<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>prc: xprc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">prc
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xprc_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xprc.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_prc.html">XPrc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_prc.html" title="The XPrc instance data structure. ">XPrc</a> instance data structure.  <a href="struct_x_prc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf28b7a33ca4cf58e128c968df5e54ecf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaf28b7a33ca4cf58e128c968df5e54ecf">XPrc_GetNumberOfVsms</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.NumberOfVsms</td></tr>
<tr class="memdesc:gaf28b7a33ca4cf58e128c968df5e54ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the Number of Virtual Socket Managers.  <a href="group__prc__v1__1.html#gaf28b7a33ca4cf58e128c968df5e54ecf">More...</a><br /></td></tr>
<tr class="separator:gaf28b7a33ca4cf58e128c968df5e54ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1ba0ea47e542e19fca3f0244a971c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga0d1ba0ea47e542e19fca3f0244a971c8">XPrc_GetRequiresClearBitstreams</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.RequiresClearBitstreams</td></tr>
<tr class="memdesc:ga0d1ba0ea47e542e19fca3f0244a971c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to find if Clearing Bitstreams are required.  <a href="group__prc__v1__1.html#ga0d1ba0ea47e542e19fca3f0244a971c8">More...</a><br /></td></tr>
<tr class="separator:ga0d1ba0ea47e542e19fca3f0244a971c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036bab97ecd418d314282b3f05dc74cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga036bab97ecd418d314282b3f05dc74cc">XPrc_GetCpArbitrationProtocol</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Cp_Arbitration_Protocol</td></tr>
<tr class="memdesc:ga036bab97ecd418d314282b3f05dc74cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the CAP Arbitration protocol.  <a href="group__prc__v1__1.html#ga036bab97ecd418d314282b3f05dc74cc">More...</a><br /></td></tr>
<tr class="separator:ga036bab97ecd418d314282b3f05dc74cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14572ab0ecab45887d78cd61d85fa2ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga14572ab0ecab45887d78cd61d85fa2ae">XPrc_GetHasAxiLiteIf</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Has_Axi_Lite_If</td></tr>
<tr class="memdesc:ga14572ab0ecab45887d78cd61d85fa2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to discover if the AXI4-Lite register interface is enabled or disabled.  <a href="group__prc__v1__1.html#ga14572ab0ecab45887d78cd61d85fa2ae">More...</a><br /></td></tr>
<tr class="separator:ga14572ab0ecab45887d78cd61d85fa2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77a378698d58fc4e86831835f648715e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga77a378698d58fc4e86831835f648715e">XPrc_GetResetActiveLevel</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Reset_Active_Level</td></tr>
<tr class="memdesc:ga77a378698d58fc4e86831835f648715e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to discover if the core's reset is active low (0) or active high (1).  <a href="group__prc__v1__1.html#ga77a378698d58fc4e86831835f648715e">More...</a><br /></td></tr>
<tr class="separator:ga77a378698d58fc4e86831835f648715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f7e9536727c3732b6318e430c5fa70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gad4f7e9536727c3732b6318e430c5fa70">XPrc_GetCpFifoDepth</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Cp_Fifo_Depth</td></tr>
<tr class="memdesc:gad4f7e9536727c3732b6318e430c5fa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the depth of FIFO in the fetch path.  <a href="group__prc__v1__1.html#gad4f7e9536727c3732b6318e430c5fa70">More...</a><br /></td></tr>
<tr class="separator:gad4f7e9536727c3732b6318e430c5fa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57f7a5c77fc1e5ee8496336bfd399fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gab57f7a5c77fc1e5ee8496336bfd399fc">XPrc_GetCpFifoType</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Cp_Fifo_Type</td></tr>
<tr class="memdesc:gab57f7a5c77fc1e5ee8496336bfd399fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the type of the FIFO in the fetch path.  <a href="group__prc__v1__1.html#gab57f7a5c77fc1e5ee8496336bfd399fc">More...</a><br /></td></tr>
<tr class="separator:gab57f7a5c77fc1e5ee8496336bfd399fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97681331f2b86503116b57b4cebd2d7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga97681331f2b86503116b57b4cebd2d7a">XPrc_GetCpFamily</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Cp_Family</td></tr>
<tr class="memdesc:ga97681331f2b86503116b57b4cebd2d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the family type of the device being managed.  <a href="group__prc__v1__1.html#ga97681331f2b86503116b57b4cebd2d7a">More...</a><br /></td></tr>
<tr class="separator:ga97681331f2b86503116b57b4cebd2d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949e933319a77af6c12f0ace1b158786"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga949e933319a77af6c12f0ace1b158786">XPrc_GetCdcStages</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Cdc_Stages</td></tr>
<tr class="memdesc:ga949e933319a77af6c12f0ace1b158786"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the number of synchronization stages used when crossing between clock domains.  <a href="group__prc__v1__1.html#ga949e933319a77af6c12f0ace1b158786">More...</a><br /></td></tr>
<tr class="separator:ga949e933319a77af6c12f0ace1b158786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3f8c49b7a3b3c99bfb50c4efea8cb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga5f3f8c49b7a3b3c99bfb50c4efea8cb2">XPrc_GetCpCompression</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Cp_Compression</td></tr>
<tr class="memdesc:ga5f3f8c49b7a3b3c99bfb50c4efea8cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro tells the PRC whether partial bitstreams are compressed or not.  <a href="group__prc__v1__1.html#ga5f3f8c49b7a3b3c99bfb50c4efea8cb2">More...</a><br /></td></tr>
<tr class="separator:ga5f3f8c49b7a3b3c99bfb50c4efea8cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50aa5032cdcaeca063861ce9721b7d63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga50aa5032cdcaeca063861ce9721b7d63">XPrc_GetRegVsmMsb</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.RegVsmMsb</td></tr>
<tr class="memdesc:ga50aa5032cdcaeca063861ce9721b7d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the Virtual Socket Manager Select MSB.  <a href="group__prc__v1__1.html#ga50aa5032cdcaeca063861ce9721b7d63">More...</a><br /></td></tr>
<tr class="separator:ga50aa5032cdcaeca063861ce9721b7d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79f83ccdcd88c5c44446334c7c7dc728"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga79f83ccdcd88c5c44446334c7c7dc728">XPrc_GetRegVsmLsb</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.RegVsmLsb</td></tr>
<tr class="memdesc:ga79f83ccdcd88c5c44446334c7c7dc728"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the Virtual Socket Manager Select LSB.  <a href="group__prc__v1__1.html#ga79f83ccdcd88c5c44446334c7c7dc728">More...</a><br /></td></tr>
<tr class="separator:ga79f83ccdcd88c5c44446334c7c7dc728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b7a63136678123d91ce528b51df0f60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga6b7a63136678123d91ce528b51df0f60">XPrc_GetRegBankMsb</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.RegBankMsb</td></tr>
<tr class="memdesc:ga6b7a63136678123d91ce528b51df0f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the Bank Select MSB.  <a href="group__prc__v1__1.html#ga6b7a63136678123d91ce528b51df0f60">More...</a><br /></td></tr>
<tr class="separator:ga6b7a63136678123d91ce528b51df0f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9512ae02edf1bd546341c96096aa5586"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga9512ae02edf1bd546341c96096aa5586">XPrc_GetRegBankLsb</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.RegBankLsb</td></tr>
<tr class="memdesc:ga9512ae02edf1bd546341c96096aa5586"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the Bank Select LSB.  <a href="group__prc__v1__1.html#ga9512ae02edf1bd546341c96096aa5586">More...</a><br /></td></tr>
<tr class="separator:ga9512ae02edf1bd546341c96096aa5586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b3c078f983cdd88610c062f2eff5fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga68b3c078f983cdd88610c062f2eff5fb">XPrc_GetRegSelectMsb</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.RegSelectMsb</td></tr>
<tr class="memdesc:ga68b3c078f983cdd88610c062f2eff5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the Register Select MSB.  <a href="group__prc__v1__1.html#ga68b3c078f983cdd88610c062f2eff5fb">More...</a><br /></td></tr>
<tr class="separator:ga68b3c078f983cdd88610c062f2eff5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga461feb94666a0571a0f50f2bcd983c13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga461feb94666a0571a0f50f2bcd983c13">XPrc_GetRegSelectLsb</a>(InstancePtr)&#160;&#160;&#160;(InstancePtr)-&gt;Config.RegSelectLsb</td></tr>
<tr class="memdesc:ga461feb94666a0571a0f50f2bcd983c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the Register Select LSB.  <a href="group__prc__v1__1.html#ga461feb94666a0571a0f50f2bcd983c13">More...</a><br /></td></tr>
<tr class="separator:ga461feb94666a0571a0f50f2bcd983c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d39e24052e6887d4e0e7ed776d9cd67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga9d39e24052e6887d4e0e7ed776d9cd67">XPrc_GetNumRms</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.NumberOfRms[VsmId]</td></tr>
<tr class="memdesc:ga9d39e24052e6887d4e0e7ed776d9cd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is used to get the number of Reconfigurable Modules in a VSM.  <a href="group__prc__v1__1.html#ga9d39e24052e6887d4e0e7ed776d9cd67">More...</a><br /></td></tr>
<tr class="separator:ga9d39e24052e6887d4e0e7ed776d9cd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4775c570e83214c75ca9203731b42da0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga4775c570e83214c75ca9203731b42da0">XPrc_GetNumRmsAllocated</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.NumberOfRmsAllocated[VsmId]</td></tr>
<tr class="memdesc:ga4775c570e83214c75ca9203731b42da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the number of Reconfigurable Modules that have been allocated in this VSM.  <a href="group__prc__v1__1.html#ga4775c570e83214c75ca9203731b42da0">More...</a><br /></td></tr>
<tr class="separator:ga4775c570e83214c75ca9203731b42da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8787446c84897dd756ab88f2b44adfe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gab8787446c84897dd756ab88f2b44adfe">XPrc_GetStartInShutdown</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Start_In_Shutdown[VsmId]</td></tr>
<tr class="memdesc:gab8787446c84897dd756ab88f2b44adfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns if the VSM starts in the Shutdown state.  <a href="group__prc__v1__1.html#gab8787446c84897dd756ab88f2b44adfe">More...</a><br /></td></tr>
<tr class="separator:gab8787446c84897dd756ab88f2b44adfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21071ccece439ee68cb2874f99983d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gad21071ccece439ee68cb2874f99983d8">XPrc_GetNumTriggersAllocated</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.No_Of_Triggers_Allocated[VsmId]</td></tr>
<tr class="memdesc:gad21071ccece439ee68cb2874f99983d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the number of triggers that the Virtual Socket Manager has.  <a href="group__prc__v1__1.html#gad21071ccece439ee68cb2874f99983d8">More...</a><br /></td></tr>
<tr class="separator:gad21071ccece439ee68cb2874f99983d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12076534ecd784922faa0a8b2e417a20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga12076534ecd784922faa0a8b2e417a20">XPrc_GetShutdownOnError</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Shutdown_On_Error[VsmId]</td></tr>
<tr class="memdesc:ga12076534ecd784922faa0a8b2e417a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns whether the VSM will enter the shutdown state if an error is detected.  <a href="group__prc__v1__1.html#ga12076534ecd784922faa0a8b2e417a20">More...</a><br /></td></tr>
<tr class="separator:ga12076534ecd784922faa0a8b2e417a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea4fc7d3365e1ae3a715a8fd211bd0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga5ea4fc7d3365e1ae3a715a8fd211bd0a">XPrc_GetHasPorRm</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Has_Por_Rm[VsmId]</td></tr>
<tr class="memdesc:ga5ea4fc7d3365e1ae3a715a8fd211bd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns whether the VSM contains an RM in the initial configuration bitstream.  <a href="group__prc__v1__1.html#ga5ea4fc7d3365e1ae3a715a8fd211bd0a">More...</a><br /></td></tr>
<tr class="separator:ga5ea4fc7d3365e1ae3a715a8fd211bd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7f0e00688efecaf1358b1663e948f95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaf7f0e00688efecaf1358b1663e948f95">XPrc_GetPorRm</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Por_Rm[VsmId]</td></tr>
<tr class="memdesc:gaf7f0e00688efecaf1358b1663e948f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the RM in the initial configuration bitstream for this VSM.  <a href="group__prc__v1__1.html#gaf7f0e00688efecaf1358b1663e948f95">More...</a><br /></td></tr>
<tr class="separator:gaf7f0e00688efecaf1358b1663e948f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3487869a229ca6fab164122023bde806"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga3487869a229ca6fab164122023bde806">XPrc_GetHasAxisStatus</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Has_Axis_Status[VsmId]</td></tr>
<tr class="memdesc:ga3487869a229ca6fab164122023bde806"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns 1 if the AXI4-Stream Status Channel is enabled for this VSM, and 0 if it's disabled.  <a href="group__prc__v1__1.html#ga3487869a229ca6fab164122023bde806">More...</a><br /></td></tr>
<tr class="separator:ga3487869a229ca6fab164122023bde806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9bbdbfc00559258c5340c84f95c91f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaf9bbdbfc00559258c5340c84f95c91f8">XPrc_GetHasAxisControl</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Has_Axis_Control[VsmId]</td></tr>
<tr class="memdesc:gaf9bbdbfc00559258c5340c84f95c91f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns 1 if the AXI4-Stream Control Channel is enabled for this VSM, and 0 if it's disabled.  <a href="group__prc__v1__1.html#gaf9bbdbfc00559258c5340c84f95c91f8">More...</a><br /></td></tr>
<tr class="separator:gaf9bbdbfc00559258c5340c84f95c91f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b8206f1a71748a9ba5a20221779f66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga69b8206f1a71748a9ba5a20221779f66">XPrc_GetSkipRmStartupAfterReset</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Skip_Rm_Startup_After_Reset[VsmId]</td></tr>
<tr class="memdesc:ga69b8206f1a71748a9ba5a20221779f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns whether the VSM will skip the Reconfigurable Module startup steps after a reset.  <a href="group__prc__v1__1.html#ga69b8206f1a71748a9ba5a20221779f66">More...</a><br /></td></tr>
<tr class="separator:ga69b8206f1a71748a9ba5a20221779f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1f98795d57eed9f8b76ebd54acc13a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga5d1f98795d57eed9f8b76ebd54acc13a">XPrc_GetNumHwTriggers</a>(InstancePtr,  VsmId)&#160;&#160;&#160;(InstancePtr)-&gt;Config.Num_Hw_Triggers[VsmId]</td></tr>
<tr class="memdesc:ga5d1f98795d57eed9f8b76ebd54acc13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro returns the number of hardware triggers that the VSM has.  <a href="group__prc__v1__1.html#ga5d1f98795d57eed9f8b76ebd54acc13a">More...</a><br /></td></tr>
<tr class="separator:ga5d1f98795d57eed9f8b76ebd54acc13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Please define XPRC_DEBUG macro to get debug prints of the driver and</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>define XPRC_DEBUG_CORE to get debug prints of the core. </p>
</div></td></tr>
<tr class="memitem:ga2e4db1e3938f6cbb8fea8a9af7dd25b9"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XPRC_DEBUG_GENERAL</b>&#160;&#160;&#160;(0x00000001)</td></tr>
<tr class="separator:ga2e4db1e3938f6cbb8fea8a9af7dd25b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75c92f89bf3e00748f353f15323b2a25"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>xprc_dbg_current_types</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga75c92f89bf3e00748f353f15323b2a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf34e0335e5532c82e448cc4ffc64c3b3"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>xprc_dbgcore_current_types</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gaf34e0335e5532c82e448cc4ffc64c3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07db086b6faa6c8621ab9999aa8e4e2"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>xprc_printf</b>(type, ...)</td></tr>
<tr class="separator:gae07db086b6faa6c8621ab9999aa8e4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8359d3116a62c28e9129d072ef3c7f7b"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>xprc_core_printf</b>(type, ...)</td></tr>
<tr class="separator:ga8359d3116a62c28e9129d072ef3c7f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual Socket Manager Registers</div></td></tr>
<tr class="memitem:ga96e312c1c3219ffacb7bc4b6ae91ae08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga96e312c1c3219ffacb7bc4b6ae91ae08">XPRC_MAX_NUMBER_OF_VSMS</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="memdesc:ga96e312c1c3219ffacb7bc4b6ae91ae08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Number Of Vsms.  <a href="group__prc__v1__1.html#ga96e312c1c3219ffacb7bc4b6ae91ae08">More...</a><br /></td></tr>
<tr class="separator:ga96e312c1c3219ffacb7bc4b6ae91ae08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061706fc7e396de786d35e7dc6e8616c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga061706fc7e396de786d35e7dc6e8616c">XPRC_VSM_NUM_GENERAL_REGISTERS</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:ga061706fc7e396de786d35e7dc6e8616c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number Of General registers.  <a href="group__prc__v1__1.html#ga061706fc7e396de786d35e7dc6e8616c">More...</a><br /></td></tr>
<tr class="separator:ga061706fc7e396de786d35e7dc6e8616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae569b3f37960fb719050fbeac8feeb8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gae569b3f37960fb719050fbeac8feeb8a">XPRC_VSM_REGISTERS_PER_TRIGGER</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gae569b3f37960fb719050fbeac8feeb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers per Trigger.  <a href="group__prc__v1__1.html#gae569b3f37960fb719050fbeac8feeb8a">More...</a><br /></td></tr>
<tr class="separator:gae569b3f37960fb719050fbeac8feeb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187866cb7a2196549673c155fd8da712"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga187866cb7a2196549673c155fd8da712">XPRC_VSM_REGISTERS_PER_RM</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:ga187866cb7a2196549673c155fd8da712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers per Rm.  <a href="group__prc__v1__1.html#ga187866cb7a2196549673c155fd8da712">More...</a><br /></td></tr>
<tr class="separator:ga187866cb7a2196549673c155fd8da712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf496dd878d4a180f24c1e9b6da79b2c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaf496dd878d4a180f24c1e9b6da79b2c5">XPRC_VSM_REGISTERS_PER_BS</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:gaf496dd878d4a180f24c1e9b6da79b2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers per Bs.  <a href="group__prc__v1__1.html#gaf496dd878d4a180f24c1e9b6da79b2c5">More...</a><br /></td></tr>
<tr class="separator:gaf496dd878d4a180f24c1e9b6da79b2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Control Registers</div></td></tr>
<tr class="memitem:gada47152f33eac349c3fc17734b31ded8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gada47152f33eac349c3fc17734b31ded8">XPRC_CR_VS_FULL</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gada47152f33eac349c3fc17734b31ded8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Socket In Full State.  <a href="group__prc__v1__1.html#gada47152f33eac349c3fc17734b31ded8">More...</a><br /></td></tr>
<tr class="separator:gada47152f33eac349c3fc17734b31ded8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf221d2761b3cb2f71b51c4029711e83e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaf221d2761b3cb2f71b51c4029711e83e">XPRC_CR_VS_EMPTY</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaf221d2761b3cb2f71b51c4029711e83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Socket In Empty State.  <a href="group__prc__v1__1.html#gaf221d2761b3cb2f71b51c4029711e83e">More...</a><br /></td></tr>
<tr class="separator:gaf221d2761b3cb2f71b51c4029711e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb059c5be023c12d486a7feccc00eb1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gafb059c5be023c12d486a7feccc00eb1e">XPRC_CR_DEFAULT_BYTE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gafb059c5be023c12d486a7feccc00eb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte field Information for Control register Commands.  <a href="group__prc__v1__1.html#gafb059c5be023c12d486a7feccc00eb1e">More...</a><br /></td></tr>
<tr class="separator:gafb059c5be023c12d486a7feccc00eb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5346393630cac26838b9e6e86bfe9984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga5346393630cac26838b9e6e86bfe9984">XPRC_CR_DEFAULT_HALFWORD</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga5346393630cac26838b9e6e86bfe9984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halfword field information for Control register Commands.  <a href="group__prc__v1__1.html#ga5346393630cac26838b9e6e86bfe9984">More...</a><br /></td></tr>
<tr class="separator:ga5346393630cac26838b9e6e86bfe9984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Status Registers</div></td></tr>
<tr class="memitem:gacfa4be5f200596fc47238acd5c1dda3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gacfa4be5f200596fc47238acd5c1dda3d">XPRC_SR_SHUTDOWN_ON</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gacfa4be5f200596fc47238acd5c1dda3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vsm In Shutdown State.  <a href="group__prc__v1__1.html#gacfa4be5f200596fc47238acd5c1dda3d">More...</a><br /></td></tr>
<tr class="separator:gacfa4be5f200596fc47238acd5c1dda3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5e1c3f6d9880e9249fe69e083f95c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga1c5e1c3f6d9880e9249fe69e083f95c5">XPRC_SR_SHUTDOWN_OFF</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga1c5e1c3f6d9880e9249fe69e083f95c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vsm not In Shutdown State.  <a href="group__prc__v1__1.html#ga1c5e1c3f6d9880e9249fe69e083f95c5">More...</a><br /></td></tr>
<tr class="separator:ga1c5e1c3f6d9880e9249fe69e083f95c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Software Trigger Registers</div></td></tr>
<tr class="memitem:ga68500090fce37412d50582e2f231658c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga68500090fce37412d50582e2f231658c">XPRC_SW_TRIGGER_PENDING</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga68500090fce37412d50582e2f231658c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software Trigger is Pending.  <a href="group__prc__v1__1.html#ga68500090fce37412d50582e2f231658c">More...</a><br /></td></tr>
<tr class="separator:ga68500090fce37412d50582e2f231658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7ae2c1bca51424c3d3f830c4f79f7fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gac7ae2c1bca51424c3d3f830c4f79f7fb">XPRC_NO_SW_TRIGGER_PENDING</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gac7ae2c1bca51424c3d3f830c4f79f7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software Trigger is not Pending.  <a href="group__prc__v1__1.html#gac7ae2c1bca51424c3d3f830c4f79f7fb">More...</a><br /></td></tr>
<tr class="separator:gac7ae2c1bca51424c3d3f830c4f79f7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">RM Control Registers</div></td></tr>
<tr class="memitem:gaea2229a863c23460d5b61bcfc77cdfcd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaea2229a863c23460d5b61bcfc77cdfcd">XPRC_RM_CR_MAX_RESETDURATION</a>&#160;&#160;&#160;(256)</td></tr>
<tr class="memdesc:gaea2229a863c23460d5b61bcfc77cdfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum Number of Reset duration.  <a href="group__prc__v1__1.html#gaea2229a863c23460d5b61bcfc77cdfcd">More...</a><br /></td></tr>
<tr class="separator:gaea2229a863c23460d5b61bcfc77cdfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Register Table Row</div></td></tr>
<tr class="memitem:ga6c522b80606106ece0005cfd76eb8bac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga6c522b80606106ece0005cfd76eb8bac">XPRC_REG_TABLE_ROW</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga6c522b80606106ece0005cfd76eb8bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register Table Row.  <a href="group__prc__v1__1.html#ga6c522b80606106ece0005cfd76eb8bac">More...</a><br /></td></tr>
<tr class="separator:ga6c522b80606106ece0005cfd76eb8bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cp_Fifo_Type</div></td></tr>
<tr class="memitem:gaaab37c7083e64e3ed375c24806cebe0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaaab37c7083e64e3ed375c24806cebe0c">CP_FIFO_TYPE_LUTRAM</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaaab37c7083e64e3ed375c24806cebe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fifo Value for Lutram.  <a href="group__prc__v1__1.html#gaaab37c7083e64e3ed375c24806cebe0c">More...</a><br /></td></tr>
<tr class="separator:gaaab37c7083e64e3ed375c24806cebe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a06e365802436f80d9e0e9bf847d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga56a06e365802436f80d9e0e9bf847d84">CP_FIFO_TYPE_BLOCKRAM</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga56a06e365802436f80d9e0e9bf847d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fifo Value for Blockram.  <a href="group__prc__v1__1.html#ga56a06e365802436f80d9e0e9bf847d84">More...</a><br /></td></tr>
<tr class="separator:ga56a06e365802436f80d9e0e9bf847d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga61ee29cca9dae9f18fb9a635f5c0a4b2"><td class="memItemLeft" align="right" valign="top">XPrc_Config *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga61ee29cca9dae9f18fb9a635f5c0a4b2">XPrc_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:ga61ee29cca9dae9f18fb9a635f5c0a4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Looks for the device configuration based on the unique device ID.  <a href="group__prc__v1__1.html#ga61ee29cca9dae9f18fb9a635f5c0a4b2">More...</a><br /></td></tr>
<tr class="separator:ga61ee29cca9dae9f18fb9a635f5c0a4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860a4c5ba01881e1547b8150affa7c0d"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga860a4c5ba01881e1547b8150affa7c0d">XPrc_CfgInitialize</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, XPrc_Config *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr class="memdesc:ga860a4c5ba01881e1547b8150affa7c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes a PRC instance.  <a href="group__prc__v1__1.html#ga860a4c5ba01881e1547b8150affa7c0d">More...</a><br /></td></tr>
<tr class="separator:ga860a4c5ba01881e1547b8150affa7c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae7427d46695146ebd8bb1cae333ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga8ae7427d46695146ebd8bb1cae333ad7">XPrc_SendShutdownCommand</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId)</td></tr>
<tr class="memdesc:ga8ae7427d46695146ebd8bb1cae333ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function instructs the Virtual Socket Manager to enter the shutdown state.  <a href="group__prc__v1__1.html#ga8ae7427d46695146ebd8bb1cae333ad7">More...</a><br /></td></tr>
<tr class="separator:ga8ae7427d46695146ebd8bb1cae333ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf496a0a03c16a90c4579f5eb9346289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gabf496a0a03c16a90c4579f5eb9346289">XPrc_SendRestartWithNoStatusCommand</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId)</td></tr>
<tr class="memdesc:gabf496a0a03c16a90c4579f5eb9346289"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to restart a Virtual Socket Manager in shutdown if the Virtual Socket has not been modified during shutdown.  <a href="group__prc__v1__1.html#gabf496a0a03c16a90c4579f5eb9346289">More...</a><br /></td></tr>
<tr class="separator:gabf496a0a03c16a90c4579f5eb9346289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1aadeb2cbc8b0ea416b86f6a722112d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaf1aadeb2cbc8b0ea416b86f6a722112d">XPrc_SendRestartWithStatusCommand</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u8 Full, u16 RmId)</td></tr>
<tr class="memdesc:gaf1aadeb2cbc8b0ea416b86f6a722112d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to restart a Virtual Socket Manager in shutdown if the Virtual Socket has been modified during shutdown.  <a href="group__prc__v1__1.html#gaf1aadeb2cbc8b0ea416b86f6a722112d">More...</a><br /></td></tr>
<tr class="separator:gaf1aadeb2cbc8b0ea416b86f6a722112d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab034fcd298e89f9ba4c45d4a0dc01258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gab034fcd298e89f9ba4c45d4a0dc01258">XPrc_SendProceedCommand</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId)</td></tr>
<tr class="memdesc:gab034fcd298e89f9ba4c45d4a0dc01258"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function instructs the Virtual Socket Manager to proceed with processing the Reconfigurable Module.  <a href="group__prc__v1__1.html#gab034fcd298e89f9ba4c45d4a0dc01258">More...</a><br /></td></tr>
<tr class="separator:gab034fcd298e89f9ba4c45d4a0dc01258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad837665803c2971d369e832f4d4bd764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gad837665803c2971d369e832f4d4bd764">XPrc_SendUserControlCommand</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u8 Rm_Shutdown_Req, u8 Rm_Decouple, u8 Sw_Shutdown_Req, u8 Sw_Startup_Req, u8 Rm_Reset)</td></tr>
<tr class="memdesc:gad837665803c2971d369e832f4d4bd764"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set the values of Rm_Shutdown_Req, Rm_Decouple, Sw_Shutdown_Req, Sw_Startup_Req, Rm_Reset signals.  <a href="group__prc__v1__1.html#gad837665803c2971d369e832f4d4bd764">More...</a><br /></td></tr>
<tr class="separator:gad837665803c2971d369e832f4d4bd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1352d5c7fa50ff03c099da95d1f6d368"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga1352d5c7fa50ff03c099da95d1f6d368">XPrc_ReadStatusReg</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId)</td></tr>
<tr class="memdesc:ga1352d5c7fa50ff03c099da95d1f6d368"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the VSM's Status Register.  <a href="group__prc__v1__1.html#ga1352d5c7fa50ff03c099da95d1f6d368">More...</a><br /></td></tr>
<tr class="separator:ga1352d5c7fa50ff03c099da95d1f6d368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169cd249e2ebac1ec7aaa31c6be22ec0"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga169cd249e2ebac1ec7aaa31c6be22ec0">XPrc_IsVsmInShutdown</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u32 VsmIdOrStatus)</td></tr>
<tr class="memdesc:ga169cd249e2ebac1ec7aaa31c6be22ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to identify whether a VSM is in the Shutdown state or not.  <a href="group__prc__v1__1.html#ga169cd249e2ebac1ec7aaa31c6be22ec0">More...</a><br /></td></tr>
<tr class="separator:ga169cd249e2ebac1ec7aaa31c6be22ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16cd7447ee658a590b4e84fbcdd655fd"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga16cd7447ee658a590b4e84fbcdd655fd">XPrc_GetVsmState</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u32 VsmIdOrStatus)</td></tr>
<tr class="memdesc:ga16cd7447ee658a590b4e84fbcdd655fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get a VSM's state.  <a href="group__prc__v1__1.html#ga16cd7447ee658a590b4e84fbcdd655fd">More...</a><br /></td></tr>
<tr class="separator:ga16cd7447ee658a590b4e84fbcdd655fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3861c91efd431128e1bf9bd20f1fa9e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gad3861c91efd431128e1bf9bd20f1fa9e">XPrc_GetVsmErrorStatus</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u32 VsmIdOrStatus)</td></tr>
<tr class="memdesc:gad3861c91efd431128e1bf9bd20f1fa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get a VSM's Error Status.  <a href="group__prc__v1__1.html#gad3861c91efd431128e1bf9bd20f1fa9e">More...</a><br /></td></tr>
<tr class="separator:gad3861c91efd431128e1bf9bd20f1fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90981b900ba7f2e8db1eae4f5d1a8eae"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga90981b900ba7f2e8db1eae4f5d1a8eae">XPrc_GetRmIdFromStatus</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u32 VsmIdOrStatus)</td></tr>
<tr class="memdesc:ga90981b900ba7f2e8db1eae4f5d1a8eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to extract the identifier of a Reconfigurable Module from a VSM's status register.  <a href="group__prc__v1__1.html#ga90981b900ba7f2e8db1eae4f5d1a8eae">More...</a><br /></td></tr>
<tr class="separator:ga90981b900ba7f2e8db1eae4f5d1a8eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d547d05931dc7104a1c99ac832a84fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga6d547d05931dc7104a1c99ac832a84fb">XPrc_SendSwTrigger</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 TriggerId)</td></tr>
<tr class="memdesc:ga6d547d05931dc7104a1c99ac832a84fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends a software trigger to a Virtual Socket Manager.  <a href="group__prc__v1__1.html#ga6d547d05931dc7104a1c99ac832a84fb">More...</a><br /></td></tr>
<tr class="separator:ga6d547d05931dc7104a1c99ac832a84fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8e49096fb637345e7d26b56abdea3a"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gabf8e49096fb637345e7d26b56abdea3a">XPrc_IsSwTriggerPending</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 *TriggerId)</td></tr>
<tr class="memdesc:gabf8e49096fb637345e7d26b56abdea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to find out if there is a Software Trigger pending in a VSM.  <a href="group__prc__v1__1.html#gabf8e49096fb637345e7d26b56abdea3a">More...</a><br /></td></tr>
<tr class="separator:gabf8e49096fb637345e7d26b56abdea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc3b273ffd5f67fbdfc7f57d7929b45b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gabc3b273ffd5f67fbdfc7f57d7929b45b">XPrc_SetTriggerToRmMapping</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 TriggerId, u16 RmId)</td></tr>
<tr class="memdesc:gabc3b273ffd5f67fbdfc7f57d7929b45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set a Trigger to Reconfigurable Module mapping in a Virtual Socket Manager.  <a href="group__prc__v1__1.html#gabc3b273ffd5f67fbdfc7f57d7929b45b">More...</a><br /></td></tr>
<tr class="separator:gabc3b273ffd5f67fbdfc7f57d7929b45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga715f096ec7bc1c5eaac8395444fcd03f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga715f096ec7bc1c5eaac8395444fcd03f">XPrc_GetTriggerToRmMapping</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 TriggerId)</td></tr>
<tr class="memdesc:ga715f096ec7bc1c5eaac8395444fcd03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets a Trigger to Reconfigurable Module mapping in a Virtual Socket Manager.  <a href="group__prc__v1__1.html#ga715f096ec7bc1c5eaac8395444fcd03f">More...</a><br /></td></tr>
<tr class="separator:ga715f096ec7bc1c5eaac8395444fcd03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa73a0de6152ced50f55b50533135d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gafa73a0de6152ced50f55b50533135d0d">XPrc_SetRmBsIndex</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 RmId, u16 BsIndex)</td></tr>
<tr class="memdesc:gafa73a0de6152ced50f55b50533135d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the BS_INDEX field in the RM_BS_INDEX register to specify which row of the Bitstream Information tables holds the partial bitstream for the Reconfigurable Module in the Virtual Socket Manager.  <a href="group__prc__v1__1.html#gafa73a0de6152ced50f55b50533135d0d">More...</a><br /></td></tr>
<tr class="separator:gafa73a0de6152ced50f55b50533135d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b724988773a1fdf54a84325e020b51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga84b724988773a1fdf54a84325e020b51">XPrc_SetRmClearingBsIndex</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 RmId, u16 ClearingBsIndex)</td></tr>
<tr class="memdesc:ga84b724988773a1fdf54a84325e020b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set the CLEAR_BS_INDEX field in the RM_BS_INDEX register to specify which row of the BS Information tables holds the clearing bitstream for the Reconfigurable Module in the Virtual Socket Manager.  <a href="group__prc__v1__1.html#ga84b724988773a1fdf54a84325e020b51">More...</a><br /></td></tr>
<tr class="separator:ga84b724988773a1fdf54a84325e020b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4328f5b970ea41269486688d36c71330"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga4328f5b970ea41269486688d36c71330">XPrc_GetRmBsIndex</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 RmId)</td></tr>
<tr class="memdesc:ga4328f5b970ea41269486688d36c71330"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the BS_INDEX field from the RM_BS_INDEX register for the Reconfigurable Module in the Virtual Socket Manager.  <a href="group__prc__v1__1.html#ga4328f5b970ea41269486688d36c71330">More...</a><br /></td></tr>
<tr class="separator:ga4328f5b970ea41269486688d36c71330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d9eb3af06c1eb952ac109f395feed75"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga1d9eb3af06c1eb952ac109f395feed75">XPrc_GetRmClearingBsIndex</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 RmId)</td></tr>
<tr class="memdesc:ga1d9eb3af06c1eb952ac109f395feed75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the CLEAR_BS_INDEX field from the RM_BS_INDEX register for the Reconfigurable Module in the Virtual Socket Manager.  <a href="group__prc__v1__1.html#ga1d9eb3af06c1eb952ac109f395feed75">More...</a><br /></td></tr>
<tr class="separator:ga1d9eb3af06c1eb952ac109f395feed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c36e7ac22439e68a49baf08a07cfc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaa3c36e7ac22439e68a49baf08a07cfc8">XPrc_SetRmControl</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 RmId, u8 ShutdownRequired, u8 StartupRequired, u8 ResetRequired, u8 ResetDuration)</td></tr>
<tr class="memdesc:gaa3c36e7ac22439e68a49baf08a07cfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set the control information for Reconfigurable Module.  <a href="group__prc__v1__1.html#gaa3c36e7ac22439e68a49baf08a07cfc8">More...</a><br /></td></tr>
<tr class="separator:gaa3c36e7ac22439e68a49baf08a07cfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae04635e1799c1fff8a1bf0acd7f10e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga4ae04635e1799c1fff8a1bf0acd7f10e">XPrc_GetRmControl</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 RmId, u8 *ShutdownRequired, u8 *StartupRequired, u8 *ResetRequired, u8 *ResetDuration)</td></tr>
<tr class="memdesc:ga4ae04635e1799c1fff8a1bf0acd7f10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the control information for Reconfigurable Module.  <a href="group__prc__v1__1.html#ga4ae04635e1799c1fff8a1bf0acd7f10e">More...</a><br /></td></tr>
<tr class="separator:ga4ae04635e1799c1fff8a1bf0acd7f10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab956d1c5dcfea3a937b2d13cdbe7ea40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gab956d1c5dcfea3a937b2d13cdbe7ea40">XPrc_SetBsId</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 BsIndex, u16 BsId)</td></tr>
<tr class="memdesc:gab956d1c5dcfea3a937b2d13cdbe7ea40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Bitstream Identifier.  <a href="group__prc__v1__1.html#gab956d1c5dcfea3a937b2d13cdbe7ea40">More...</a><br /></td></tr>
<tr class="separator:gab956d1c5dcfea3a937b2d13cdbe7ea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e1c547c5d110ec0e5fb28721398547"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaa1e1c547c5d110ec0e5fb28721398547">XPrc_GetBsId</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 BsIndex)</td></tr>
<tr class="memdesc:gaa1e1c547c5d110ec0e5fb28721398547"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the Bitstream Identifier.  <a href="group__prc__v1__1.html#gaa1e1c547c5d110ec0e5fb28721398547">More...</a><br /></td></tr>
<tr class="separator:gaa1e1c547c5d110ec0e5fb28721398547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ae77f041ca0822956e93f2c4841384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga77ae77f041ca0822956e93f2c4841384">XPrc_SetBsSize</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 BsIndex, u32 BsSize)</td></tr>
<tr class="memdesc:ga77ae77f041ca0822956e93f2c4841384"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Bitstream size in bytes.  <a href="group__prc__v1__1.html#ga77ae77f041ca0822956e93f2c4841384">More...</a><br /></td></tr>
<tr class="separator:ga77ae77f041ca0822956e93f2c4841384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ab1e4290b46abb79a99627c2f85d41"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga23ab1e4290b46abb79a99627c2f85d41">XPrc_GetBsSize</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 BsIndex)</td></tr>
<tr class="memdesc:ga23ab1e4290b46abb79a99627c2f85d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the Bitstream size in bytes.  <a href="group__prc__v1__1.html#ga23ab1e4290b46abb79a99627c2f85d41">More...</a><br /></td></tr>
<tr class="separator:ga23ab1e4290b46abb79a99627c2f85d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ef8c25b6a68047e74a6d30d215ebf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga66ef8c25b6a68047e74a6d30d215ebf9">XPrc_SetBsAddress</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 BsIndex, u32 BsAddress)</td></tr>
<tr class="memdesc:ga66ef8c25b6a68047e74a6d30d215ebf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Address of the Bitstream.  <a href="group__prc__v1__1.html#ga66ef8c25b6a68047e74a6d30d215ebf9">More...</a><br /></td></tr>
<tr class="separator:ga66ef8c25b6a68047e74a6d30d215ebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74079c4b27f1c4dc1a7947911b7682d1"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga74079c4b27f1c4dc1a7947911b7682d1">XPrc_GetBsAddress</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u16 VsmId, u16 BsIndex)</td></tr>
<tr class="memdesc:ga74079c4b27f1c4dc1a7947911b7682d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the Address of the Bitstream.  <a href="group__prc__v1__1.html#ga74079c4b27f1c4dc1a7947911b7682d1">More...</a><br /></td></tr>
<tr class="separator:ga74079c4b27f1c4dc1a7947911b7682d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fd82200fe71d1518e59cb6ff84e395"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaf1fd82200fe71d1518e59cb6ff84e395">XPrc_GetRegisterAddress</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u32 VsmId, u8 RegisterType, u16 TableRow)</td></tr>
<tr class="memdesc:gaf1fd82200fe71d1518e59cb6ff84e395"><td class="mdescLeft">&#160;</td><td class="mdescRight">The register offsets for the PRC are dynamic.  <a href="group__prc__v1__1.html#gaf1fd82200fe71d1518e59cb6ff84e395">More...</a><br /></td></tr>
<tr class="separator:gaf1fd82200fe71d1518e59cb6ff84e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284cb34c70c7bcdcd8c94f6843184b33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#ga284cb34c70c7bcdcd8c94f6843184b33">XPrc_PrintVsmStatus</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr, u32 VsmIdOrStatus, char *Prefix)</td></tr>
<tr class="memdesc:ga284cb34c70c7bcdcd8c94f6843184b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to Print the VSM Status.  <a href="group__prc__v1__1.html#ga284cb34c70c7bcdcd8c94f6843184b33">More...</a><br /></td></tr>
<tr class="separator:ga284cb34c70c7bcdcd8c94f6843184b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf15c985cf911548b53252824dc933313"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prc__v1__1.html#gaf15c985cf911548b53252824dc933313">XPrc_SelfTest</a> (<a class="el" href="struct_x_prc.html">XPrc</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaf15c985cf911548b53252824dc933313"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function runs a self-test on the PRC driver.  <a href="group__prc__v1__1.html#gaf15c985cf911548b53252824dc933313">More...</a><br /></td></tr>
<tr class="separator:gaf15c985cf911548b53252824dc933313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
