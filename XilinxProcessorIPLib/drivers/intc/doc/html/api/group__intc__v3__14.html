<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>intc: Intc_v3_14</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">intc
   </div>
   <div id="projectbrief">Xilinx Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__intc__v3__14.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Intc_v3_14</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for the device.  <a href="struct_x_intc___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_intc.html">XIntc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> driver instance data.  <a href="struct_x_intc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf2aeec4bbc6e0c5ca2268e5d7c7dd5ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaf2aeec4bbc6e0c5ca2268e5d7c7dd5ce">XIntc_MasterEnable</a>(BaseAddress)</td></tr>
<tr class="memdesc:gaf2aeec4bbc6e0c5ca2268e5d7c7dd5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable all interrupts in the Master Enable register of the interrupt controller.  <a href="#gaf2aeec4bbc6e0c5ca2268e5d7c7dd5ce"></a><br/></td></tr>
<tr class="separator:gaf2aeec4bbc6e0c5ca2268e5d7c7dd5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93be82188a607b0a13a13a96c5787bb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga93be82188a607b0a13a13a96c5787bb6">XIntc_MasterDisable</a>(BaseAddress)&#160;&#160;&#160;XIntc_Out32((BaseAddress) + XIN_MER_OFFSET, 0)</td></tr>
<tr class="memdesc:ga93be82188a607b0a13a13a96c5787bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable all interrupts in the Master Enable register of the interrupt controller.  <a href="#ga93be82188a607b0a13a13a96c5787bb6"></a><br/></td></tr>
<tr class="separator:ga93be82188a607b0a13a13a96c5787bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35ec3b9b658f26d989b19783954683e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gad35ec3b9b658f26d989b19783954683e">XIntc_EnableIntr</a>(BaseAddress, EnableMask)&#160;&#160;&#160;XIntc_Out32((BaseAddress) + XIN_IER_OFFSET, (EnableMask))</td></tr>
<tr class="memdesc:gad35ec3b9b658f26d989b19783954683e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable specific interrupt(s) in the interrupt controller.  <a href="#gad35ec3b9b658f26d989b19783954683e"></a><br/></td></tr>
<tr class="separator:gad35ec3b9b658f26d989b19783954683e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df77bd3561a105f1d6b1837762db956"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga5df77bd3561a105f1d6b1837762db956">XIntc_DisableIntr</a>(BaseAddress, DisableMask)&#160;&#160;&#160;XIntc_Out32((BaseAddress) + XIN_IER_OFFSET, ~(DisableMask))</td></tr>
<tr class="memdesc:ga5df77bd3561a105f1d6b1837762db956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable specific interrupt(s) in the interrupt controller.  <a href="#ga5df77bd3561a105f1d6b1837762db956"></a><br/></td></tr>
<tr class="separator:ga5df77bd3561a105f1d6b1837762db956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f699042980f8453713171959183fc49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga4f699042980f8453713171959183fc49">XIntc_AckIntr</a>(BaseAddress, AckMask)&#160;&#160;&#160;XIntc_Out32((BaseAddress) + XIN_IAR_OFFSET, (AckMask))</td></tr>
<tr class="memdesc:ga4f699042980f8453713171959183fc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge specific interrupt(s) in the interrupt controller.  <a href="#ga4f699042980f8453713171959183fc49"></a><br/></td></tr>
<tr class="separator:ga4f699042980f8453713171959183fc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c828dcbbdc3441c8abaded5cda888b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga13c828dcbbdc3441c8abaded5cda888b">XIntc_GetIntrStatus</a>(BaseAddress)</td></tr>
<tr class="memdesc:ga13c828dcbbdc3441c8abaded5cda888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interrupt status from the interrupt controller which indicates which interrupts are active and enabled.  <a href="#ga13c828dcbbdc3441c8abaded5cda888b"></a><br/></td></tr>
<tr class="separator:ga13c828dcbbdc3441c8abaded5cda888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa7adc53d40c41e1a714ef8857329043d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaa7adc53d40c41e1a714ef8857329043d">XIntc_Initialize</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr class="memdesc:gaa7adc53d40c41e1a714ef8857329043d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a specific interrupt controller instance/driver.  <a href="#gaa7adc53d40c41e1a714ef8857329043d"></a><br/></td></tr>
<tr class="separator:gaa7adc53d40c41e1a714ef8857329043d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863eb58a3ae9419c7ac5da7c9fa9cb50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga863eb58a3ae9419c7ac5da7c9fa9cb50">XIntc_Start</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Mode)</td></tr>
<tr class="memdesc:ga863eb58a3ae9419c7ac5da7c9fa9cb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the interrupt controller by enabling the output from the controller to the processor.  <a href="#ga863eb58a3ae9419c7ac5da7c9fa9cb50"></a><br/></td></tr>
<tr class="separator:ga863eb58a3ae9419c7ac5da7c9fa9cb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafabb05cf2e5b62031524a33d1f88f405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gafabb05cf2e5b62031524a33d1f88f405">XIntc_Stop</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr)</td></tr>
<tr class="memdesc:gafabb05cf2e5b62031524a33d1f88f405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the interrupt controller by disabling the output from the controller so that no interrupts will be caused by the interrupt controller.  <a href="#gafabb05cf2e5b62031524a33d1f88f405"></a><br/></td></tr>
<tr class="separator:gafabb05cf2e5b62031524a33d1f88f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee9ec5873a764994d64b4da35a110084"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaee9ec5873a764994d64b4da35a110084">XIntc_Connect</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id, XInterruptHandler Handler, void *CallBackRef)</td></tr>
<tr class="memdesc:gaee9ec5873a764994d64b4da35a110084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized.  <a href="#gaee9ec5873a764994d64b4da35a110084"></a><br/></td></tr>
<tr class="separator:gaee9ec5873a764994d64b4da35a110084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7caaeb26b6b264fffefbd32f90f855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga8f7caaeb26b6b264fffefbd32f90f855">XIntc_Disconnect</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga8f7caaeb26b6b264fffefbd32f90f855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the interrupt table with the Null Handler and NULL arguments at the location pointed at by the Id.  <a href="#ga8f7caaeb26b6b264fffefbd32f90f855"></a><br/></td></tr>
<tr class="separator:ga8f7caaeb26b6b264fffefbd32f90f855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f59192d3b3ba2e2283a264677577b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gac7f59192d3b3ba2e2283a264677577b8">XIntc_Enable</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:gac7f59192d3b3ba2e2283a264677577b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the interrupt source provided as the argument Id.  <a href="#gac7f59192d3b3ba2e2283a264677577b8"></a><br/></td></tr>
<tr class="separator:gac7f59192d3b3ba2e2283a264677577b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea44ec361097925f2994558d402988ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaea44ec361097925f2994558d402988ab">XIntc_Disable</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:gaea44ec361097925f2994558d402988ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the interrupt source provided as the argument Id such that the interrupt controller will not cause interrupts for the specified Id.  <a href="#gaea44ec361097925f2994558d402988ab"></a><br/></td></tr>
<tr class="separator:gaea44ec361097925f2994558d402988ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8604653ac3a24bbb49c5fecb6a9ebfc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga8604653ac3a24bbb49c5fecb6a9ebfc7">XIntc_Acknowledge</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga8604653ac3a24bbb49c5fecb6a9ebfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledges the interrupt source provided as the argument Id.  <a href="#ga8604653ac3a24bbb49c5fecb6a9ebfc7"></a><br/></td></tr>
<tr class="separator:ga8604653ac3a24bbb49c5fecb6a9ebfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2cc8909b69948e755ea649998cd2e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:gaac2cc8909b69948e755ea649998cd2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the device configuration based on the unique device ID.  <a href="#gaac2cc8909b69948e755ea649998cd2e1"></a><br/></td></tr>
<tr class="separator:gaac2cc8909b69948e755ea649998cd2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a344d15b12b8acd82cd4c49a020d74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga24a344d15b12b8acd82cd4c49a020d74">XIntc_ConnectFastHandler</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id, XFastInterruptHandler Handler)</td></tr>
<tr class="memdesc:ga24a344d15b12b8acd82cd4c49a020d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized.In Cascade mode, connects handler to corresponding Slave controller IVAR/IVEAR register depending on the Id and sets all interrupt sources of the Slave controller as fast interrupts.  <a href="#ga24a344d15b12b8acd82cd4c49a020d74"></a><br/></td></tr>
<tr class="separator:ga24a344d15b12b8acd82cd4c49a020d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881154092f4f8cd5e29a71b284f7b2ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga881154092f4f8cd5e29a71b284f7b2ae">XIntc_SetNormalIntrMode</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga881154092f4f8cd5e29a71b284f7b2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the normal interrupt mode for the specified interrupt in the Interrupt Mode Register.  <a href="#ga881154092f4f8cd5e29a71b284f7b2ae"></a><br/></td></tr>
<tr class="separator:ga881154092f4f8cd5e29a71b284f7b2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb4ea6d2f66a5b3ca32b12ec68bc151"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga7eb4ea6d2f66a5b3ca32b12ec68bc151">XIntc_TriggerSwIntr</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga7eb4ea6d2f66a5b3ca32b12ec68bc151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows software to trigger software interrupt.  <a href="#ga7eb4ea6d2f66a5b3ca32b12ec68bc151"></a><br/></td></tr>
<tr class="separator:ga7eb4ea6d2f66a5b3ca32b12ec68bc151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635187ed756cee70b4b4051560cbd7bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga635187ed756cee70b4b4051560cbd7bc">XIntc_InterruptHandler</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga635187ed756cee70b4b4051560cbd7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for the driver used when there can be no argument passed to the handler.  <a href="#ga635187ed756cee70b4b4051560cbd7bc"></a><br/></td></tr>
<tr class="separator:ga635187ed756cee70b4b4051560cbd7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0d32716f082a51a751df84312c7d56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga1f0d32716f082a51a751df84312c7d56">XIntc_SetOptions</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u32 Options)</td></tr>
<tr class="memdesc:ga1f0d32716f082a51a751df84312c7d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the options for the interrupt controller driver.  <a href="#ga1f0d32716f082a51a751df84312c7d56"></a><br/></td></tr>
<tr class="separator:ga1f0d32716f082a51a751df84312c7d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fdbe96b1db87f0c78e68da8bc767a69"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga6fdbe96b1db87f0c78e68da8bc767a69">XIntc_GetOptions</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga6fdbe96b1db87f0c78e68da8bc767a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently set options.  <a href="#ga6fdbe96b1db87f0c78e68da8bc767a69"></a><br/></td></tr>
<tr class="separator:ga6fdbe96b1db87f0c78e68da8bc767a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9a9a16180b363930d21bc94dfe71147"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaf9a9a16180b363930d21bc94dfe71147">XIntc_SelfTest</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaf9a9a16180b363930d21bc94dfe71147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a self-test on the driver/device.  <a href="#gaf9a9a16180b363930d21bc94dfe71147"></a><br/></td></tr>
<tr class="separator:gaf9a9a16180b363930d21bc94dfe71147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17972363ab5a1a8f5f1d135c5b3c22c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga17972363ab5a1a8f5f1d135c5b3c22c7">XIntc_SimulateIntr</a> (<a class="el" href="struct_x_intc.html">XIntc</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga17972363ab5a1a8f5f1d135c5b3c22c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows software to simulate an interrupt in the interrupt controller.  <a href="#ga17972363ab5a1a8f5f1d135c5b3c22c7"></a><br/></td></tr>
<tr class="separator:ga17972363ab5a1a8f5f1d135c5b3c22c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace91a1aeaf1a88e1b769decb4ac4a818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler</a> (void *DeviceId)</td></tr>
<tr class="memdesc:gace91a1aeaf1a88e1b769decb4ac4a818"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the primary interrupt handler for the driver.  <a href="#gace91a1aeaf1a88e1b769decb4ac4a818"></a><br/></td></tr>
<tr class="separator:gace91a1aeaf1a88e1b769decb4ac4a818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf090e932e35ede6c8cffe76e785de835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaf090e932e35ede6c8cffe76e785de835">XIntc_SetIntrSvcOption</a> (UINTPTR BaseAddress, int Option)</td></tr>
<tr class="memdesc:gaf090e932e35ede6c8cffe76e785de835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the interrupt service option, which can configure the driver so that it services only a single interrupt at a time when an interrupt occurs, or services all pending interrupts when an interrupt occurs.  <a href="#gaf090e932e35ede6c8cffe76e785de835"></a><br/></td></tr>
<tr class="separator:gaf090e932e35ede6c8cffe76e785de835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd1d34885340943143c8fd2f98a3963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga4bd1d34885340943143c8fd2f98a3963">XIntc_RegisterHandler</a> (UINTPTR BaseAddress, int InterruptId, XInterruptHandler Handler, void *CallBackRef)</td></tr>
<tr class="memdesc:ga4bd1d34885340943143c8fd2f98a3963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a handler function for a specific interrupt ID.  <a href="#ga4bd1d34885340943143c8fd2f98a3963"></a><br/></td></tr>
<tr class="separator:ga4bd1d34885340943143c8fd2f98a3963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999a50f24a9ac9a4a2623d950978f1bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga999a50f24a9ac9a4a2623d950978f1bb">XIntc_RegisterFastHandler</a> (UINTPTR BaseAddress, u8 Id, XFastInterruptHandler FastHandler)</td></tr>
<tr class="memdesc:ga999a50f24a9ac9a4a2623d950978f1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a fast handler function for a specific interrupt ID.  <a href="#ga999a50f24a9ac9a4a2623d950978f1bb"></a><br/></td></tr>
<tr class="separator:ga999a50f24a9ac9a4a2623d950978f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2187e69fdc39ef945a992d2602d0c1c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga2187e69fdc39ef945a992d2602d0c1c1">XIntc_ConfigTable</a> [XPAR_XINTC_NUM_INSTANCES]</td></tr>
<tr class="memdesc:ga2187e69fdc39ef945a992d2602d0c1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each intc device in the system.  <a href="#ga2187e69fdc39ef945a992d2602d0c1c1"></a><br/></td></tr>
<tr class="separator:ga2187e69fdc39ef945a992d2602d0c1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afbe6b28aa729c753744cba40ecf5b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga6afbe6b28aa729c753744cba40ecf5b3">XIntc_ConfigTable</a> []</td></tr>
<tr class="memdesc:ga6afbe6b28aa729c753744cba40ecf5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each intc device in the system.  <a href="#ga6afbe6b28aa729c753744cba40ecf5b3"></a><br/></td></tr>
<tr class="separator:ga6afbe6b28aa729c753744cba40ecf5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Configuration options</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp50f33d14f129e4548c1c270fd6725a78"></a>These options are used in <a class="el" href="group__intc__v3__14.html#ga1f0d32716f082a51a751df84312c7d56" title="Set the options for the interrupt controller driver.">XIntc_SetOptions()</a> to configure the device. </p>
</td></tr>
<tr class="memitem:gaf4bce8e2035f391b702686e49c66c839"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaf4bce8e2035f391b702686e49c66c839">XIN_SVC_SGL_ISR_OPTION</a>&#160;&#160;&#160;1UL</td></tr>
<tr class="separator:gaf4bce8e2035f391b702686e49c66c839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad043237f658e83b2e8718ddddab12545"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad043237f658e83b2e8718ddddab12545"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XIN_SVC_ALL_ISRS_OPTION</b>&#160;&#160;&#160;2UL</td></tr>
<tr class="separator:gad043237f658e83b2e8718ddddab12545"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Start modes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2d7bf383fe0e07a1b3b2b96df842c92b"></a>One of these values is passed to <a class="el" href="group__intc__v3__14.html#ga863eb58a3ae9419c7ac5da7c9fa9cb50" title="Starts the interrupt controller by enabling the output from the controller to the processor...">XIntc_Start()</a> to start the device. </p>
</td></tr>
<tr class="memitem:gaefd5527cecdc1a6444b624d1e1a2514f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#gaefd5527cecdc1a6444b624d1e1a2514f">XIN_SIMULATION_MODE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaefd5527cecdc1a6444b624d1e1a2514f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulation only mode, no hardware interrupts recognized.  <a href="#gaefd5527cecdc1a6444b624d1e1a2514f"></a><br/></td></tr>
<tr class="separator:gaefd5527cecdc1a6444b624d1e1a2514f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56b4aa3cb483ea5c882e2e36a4800af2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intc__v3__14.html#ga56b4aa3cb483ea5c882e2e36a4800af2">XIN_REAL_MODE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga56b4aa3cb483ea5c882e2e36a4800af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real mode, no simulation allowed, hardware interrupts recognized.  <a href="#ga56b4aa3cb483ea5c882e2e36a4800af2"></a><br/></td></tr>
<tr class="separator:ga56b4aa3cb483ea5c882e2e36a4800af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Masks to specify Interrupt Controller Mode</h2></td></tr>
<tr class="memitem:ga6787fa567536384f6133b8ce90cf22f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6787fa567536384f6133b8ce90cf22f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XIN_INTC_NOCASCADE</b>&#160;&#160;&#160;0	/* Normal - No Cascade Mode */</td></tr>
<tr class="separator:ga6787fa567536384f6133b8ce90cf22f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c8fd384185ceae0a8abe0cd8d4c638"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8c8fd384185ceae0a8abe0cd8d4c638"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XIN_INTC_PRIMARY</b>&#160;&#160;&#160;1	/* Master/Primary controller */</td></tr>
<tr class="separator:gad8c8fd384185ceae0a8abe0cd8d4c638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bc775ed0e234d9b069700f4825cd7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35bc775ed0e234d9b069700f4825cd7d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XIN_INTC_SECONDARY</b>&#160;&#160;&#160;2	/* Secondary Slave Controllers */</td></tr>
<tr class="separator:ga35bc775ed0e234d9b069700f4825cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3805fe4c0c209acc349242d75600646b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3805fe4c0c209acc349242d75600646b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XIN_INTC_LAST</b>&#160;&#160;&#160;3	/* Last Slave Controller */</td></tr>
<tr class="separator:ga3805fe4c0c209acc349242d75600646b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mask to specify maximum number of interrupt sources per controller</h2></td></tr>
<tr class="memitem:ga842aea1f6663265412f5618f102e8f18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga842aea1f6663265412f5618f102e8f18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XIN_CONTROLLER_MAX_INTRS</b></td></tr>
<tr class="separator:ga842aea1f6663265412f5618f102e8f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6cfdfe9914f029b5a88d014400188e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9d6cfdfe9914f029b5a88d014400188e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XINTC_STANDARD_VECTOR_ADDRESS_WIDTH</b>&#160;&#160;&#160;32U</td></tr>
<tr class="separator:ga9d6cfdfe9914f029b5a88d014400188e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga56b4aa3cb483ea5c882e2e36a4800af2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_REAL_MODE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real mode, no simulation allowed, hardware interrupts recognized. </p>

<p>Referenced by <a class="el" href="xintc__tapp__example_8c.html#a297705047f75055bf7856596d7313614">IntcInterruptSetup()</a>, and <a class="el" href="group__intc__v3__14.html#ga863eb58a3ae9419c7ac5da7c9fa9cb50">XIntc_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="gaefd5527cecdc1a6444b624d1e1a2514f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_SIMULATION_MODE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulation only mode, no hardware interrupts recognized. </p>

<p>Referenced by <a class="el" href="xintc__example_8c.html#aaea6614590c6c6eedade935ae1c1a26c">SetUpInterruptSystem()</a>, and <a class="el" href="group__intc__v3__14.html#ga863eb58a3ae9419c7ac5da7c9fa9cb50">XIntc_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4bce8e2035f391b702686e49c66c839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_SVC_SGL_ISR_OPTION&#160;&#160;&#160;1UL</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
XIN_SVC_SGL_ISR_OPTION  Service the highest priority pending interrupt
                        and then return.
XIN_SVC_ALL_ISRS_OPTION Service all of the pending interrupts and then
                        return.
</pre> 
<p>Referenced by <a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a>, <a class="el" href="group__intc__v3__14.html#gaa7adc53d40c41e1a714ef8857329043d">XIntc_Initialize()</a>, and <a class="el" href="group__intc__v3__14.html#ga1f0d32716f082a51a751df84312c7d56">XIntc_SetOptions()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f699042980f8453713171959183fc49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_AckIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AckMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XIntc_Out32((BaseAddress) + XIN_IAR_OFFSET, (AckMask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge specific interrupt(s) in the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">AckMask</td><td>is the 32-bit value to write to the acknowledge register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will acknowledge interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__intc__v3__14.html#ga4f699042980f8453713171959183fc49" title="Acknowledge specific interrupt(s) in the interrupt controller.">XIntc_AckIntr(u32 BaseAddress, u32 AckMask)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5df77bd3561a105f1d6b1837762db956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_DisableIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DisableMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XIntc_Out32((BaseAddress) + XIN_IER_OFFSET, ~(DisableMask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable specific interrupt(s) in the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">DisableMask</td><td>is the 32-bit value to write to the enable register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will disable interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__intc__v3__14.html#ga5df77bd3561a105f1d6b1837762db956" title="Disable specific interrupt(s) in the interrupt controller.">XIntc_DisableIntr(u32 BaseAddress, u32 DisableMask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="gad35ec3b9b658f26d989b19783954683e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_EnableIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EnableMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XIntc_Out32((BaseAddress) + XIN_IER_OFFSET, (EnableMask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable specific interrupt(s) in the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">EnableMask</td><td>is the 32-bit value to write to the enable register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will enable interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__intc__v3__14.html#gad35ec3b9b658f26d989b19783954683e" title="Enable specific interrupt(s) in the interrupt controller.">XIntc_EnableIntr(u32 BaseAddress, u32 EnableMask)</a>; </dd></dl>

<p>Referenced by <a class="el" href="xintc__low__level__example_8c.html#a83f2cbdf0d928c5fb6401e2abd071b56">IntcLowLevelExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga13c828dcbbdc3441c8abaded5cda888b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_GetIntrStatus</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(XIntc_In32((BaseAddress) + XIN_ISR_OFFSET) &amp; \</div>
<div class="line">        XIntc_In32((BaseAddress) + XIN_IER_OFFSET))</div>
</div><!-- fragment -->
<p>Get the interrupt status from the interrupt controller which indicates which interrupts are active and enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit contents of the interrupt status register. Each bit corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Bits which are set indicate an active interrupt which is also enabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__intc__v3__14.html#ga13c828dcbbdc3441c8abaded5cda888b" title="Get the interrupt status from the interrupt controller which indicates which interrupts are active an...">XIntc_GetIntrStatus(u32 BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga93be82188a607b0a13a13a96c5787bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_MasterDisable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;XIntc_Out32((BaseAddress) + XIN_MER_OFFSET, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable all interrupts in the Master Enable register of the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__intc__v3__14.html#ga93be82188a607b0a13a13a96c5787bb6" title="Disable all interrupts in the Master Enable register of the interrupt controller.">XIntc_MasterDisable(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2aeec4bbc6e0c5ca2268e5d7c7dd5ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_MasterEnable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">XIntc_Out32((BaseAddress) + XIN_MER_OFFSET, \</div>
<div class="line">        XIN_INT_MASTER_ENABLE_MASK | XIN_INT_HARDWARE_ENABLE_MASK)</div>
</div><!-- fragment -->
<p>Enable all interrupts in the Master Enable register of the interrupt controller. </p>
<p>The interrupt controller defaults to all interrupts disabled from reset such that this macro must be used to enable interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__intc__v3__14.html#gaf2aeec4bbc6e0c5ca2268e5d7c7dd5ce" title="Enable all interrupts in the Master Enable register of the interrupt controller.">XIntc_MasterEnable(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8604653ac3a24bbb49c5fecb6a9ebfc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Acknowledge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledges the interrupt source provided as the argument Id. </p>
<p>When the interrupt is acknowledged, it causes the interrupt controller to clear its interrupt condition.In Cascade mode, acknowledges corresponding interrupt source of Slave controllers depending on the Id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="gaee9ec5873a764994d64b4da35a110084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XInterruptHandler&#160;</td>
          <td class="paramname"><em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized. </p>
<p>The argument provided in this call as the Callbackref is used as the argument for the handler when it is called. In Cascade mode, connects handler to Slave controller handler table depending on the interrupt Id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt. </td></tr>
    <tr><td class="paramname">Handler</td><td>to the handler for that interrupt. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the callback reference, usually the instance pointer of the connecting driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><pre class="fragment">            - XST_SUCCESS if the handler was connected correctly.
</pre></dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>WARNING: The handler provided as an argument will overwrite any handler that was previously connected. </p>

<p>References <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc___config.html#af62197288a9019af6084a1675844e1ca">XIntc_Config::HandlerTable</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="xintc__example_8c.html#aaea6614590c6c6eedade935ae1c1a26c">SetUpInterruptSystem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga24a344d15b12b8acd82cd4c49a020d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_ConnectFastHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XFastInterruptHandler&#160;</td>
          <td class="paramname"><em>Handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized.In Cascade mode, connects handler to corresponding Slave controller IVAR/IVEAR register depending on the Id and sets all interrupt sources of the Slave controller as fast interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt. </td></tr>
    <tr><td class="paramname">Handler</td><td>for specified interrupt id. It must be declared with "fast_interrupt" attribute. e.g. static void MyHandler(void) <b>attribute</b> ((fast_interrupt));</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Slave controllers in Cascade Mode should have all as Fast interrupts or Normal interrupts, mixed interrupts are not supported</dd></dl>
<p>WARNING: The handler provided as an argument will overwrite any handler that was previously connected. </p>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc___config.html#ac894d2be382d08d83821c1672615d4d4">XIntc_Config::FastIntr</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, <a class="el" href="struct_x_intc___config.html#a630c8585f41eea348ae0d6d134b0ad8f">XIntc_Config::VectorAddrWidth</a>, <a class="el" href="group__intc__v3__14.html#gaea44ec361097925f2994558d402988ab">XIntc_Disable()</a>, <a class="el" href="group__intc__v3__14.html#gac7f59192d3b3ba2e2283a264677577b8">XIntc_Enable()</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="gace91a1aeaf1a88e1b769decb4ac4a818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_DeviceInterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the primary interrupt handler for the driver. </p>
<p>It must be connected to the interrupt source such that is called when an interrupt of the interrupt controller is active. It will resolve which interrupts are active and enabled and call the appropriate interrupt handler. It uses the AckBeforeService flag in the configuration data to determine when to acknowledge the interrupt. Highest priority interrupts are serviced first. This function assumes that an interrupt vector table has been previously initialized.It does not verify that entries in the table are valid before calling an interrupt handler. In Cascade mode this function calls XIntc_CascadeHandler to handle interrupts of Master and Slave controllers. This functions also handles interrupts nesting by saving and restoring link register of Microblaze and Interrupt Level register of interrupt controller properly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the zero-based device ID defined in xparameters.h of the interrupting interrupt controller. It is used as a direct index into the configuration data, which contains the vector table for the interrupt controller. Note that even though the argument is a void pointer, the value is not a pointer but the actual device ID. The void pointer type is necessary to meet the XInterruptHandler typedef for interrupt handlers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For nested interrupts, this function saves microblaze r14 register on entry and restores on exit. This is required since compiler does not support nesting. This function enables Microblaze interrupts after blocking further interrupts from the current interrupt number and interrupts below current interrupt priority by writing to Interrupt Level Register of INTC on entry. On exit, it disables microblaze interrupts and restores ILR register default value(0xFFFFFFFF)back. It is recommended to increase STACK_SIZE in linker script for nested interrupts. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a172cd1cd58904502d6f3cec734db1d6b">XIntc_Config::AckBeforeService</a>, <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc___config.html#ac894d2be382d08d83821c1672615d4d4">XIntc_Config::FastIntr</a>, <a class="el" href="struct_x_intc___config.html#af62197288a9019af6084a1675844e1ca">XIntc_Config::HandlerTable</a>, <a class="el" href="struct_x_intc___config.html#ae54682e47e6e506a52c7b6da6314a29a">XIntc_Config::IntcType</a>, <a class="el" href="struct_x_intc___config.html#a6e2fc4f937193eb9e665a2e66af97db2">XIntc_Config::NumberofIntrs</a>, <a class="el" href="struct_x_intc___config.html#a85d5d557aa6619757848d754ca096552">XIntc_Config::NumberofSwIntrs</a>, <a class="el" href="struct_x_intc___config.html#ac3efdbf93e34b88aedead2e7ca44cee1">XIntc_Config::Options</a>, <a class="el" href="group__intc__v3__14.html#gaf4bce8e2035f391b702686e49c66c839">XIN_SVC_SGL_ISR_OPTION</a>, <a class="el" href="group__intc__v3__14.html#ga4f699042980f8453713171959183fc49">XIntc_AckIntr</a>, <a class="el" href="group__intc__v3__14.html#ga2187e69fdc39ef945a992d2602d0c1c1">XIntc_ConfigTable</a>, and <a class="el" href="group__intc__v3__14.html#ga13c828dcbbdc3441c8abaded5cda888b">XIntc_GetIntrStatus</a>.</p>

<p>Referenced by <a class="el" href="xintc__tapp__example_8c.html#a297705047f75055bf7856596d7313614">IntcInterruptSetup()</a>, <a class="el" href="xintc__low__level__example_8c.html#a0838d944ebf56cbdfce4d481eab585e8">SetupInterruptSystem()</a>, and <a class="el" href="group__intc__v3__14.html#ga635187ed756cee70b4b4051560cbd7bc">XIntc_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaea44ec361097925f2994558d402988ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the interrupt source provided as the argument Id such that the interrupt controller will not cause interrupts for the specified Id. </p>
<p>The interrupt controller will continue to hold an interrupt condition for the Id, but will not cause an interrupt.In Cascade mode, disables corresponding interrupt of Slave controllers depending on the Id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="group__intc__v3__14.html#ga24a344d15b12b8acd82cd4c49a020d74">XIntc_ConnectFastHandler()</a>, and <a class="el" href="group__intc__v3__14.html#ga881154092f4f8cd5e29a71b284f7b2ae">XIntc_SetNormalIntrMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f7caaeb26b6b264fffefbd32f90f855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the interrupt table with the Null Handler and NULL arguments at the location pointed at by the Id. </p>
<p>This effectively disconnects that interrupt source from any handler. The interrupt is disabled also. In Cascade mode, disconnects handler from Slave controller handler table depending on the interrupt Id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc___config.html#af62197288a9019af6084a1675844e1ca">XIntc_Config::HandlerTable</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="gac7f59192d3b3ba2e2283a264677577b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the interrupt source provided as the argument Id. </p>
<p>Any pending interrupt condition for the specified Id will occur after this function is called. In Cascade mode, enables corresponding interrupt of Slave controllers depending on the Id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="xintc__example_8c.html#aaea6614590c6c6eedade935ae1c1a26c">SetUpInterruptSystem()</a>, <a class="el" href="group__intc__v3__14.html#ga24a344d15b12b8acd82cd4c49a020d74">XIntc_ConnectFastHandler()</a>, and <a class="el" href="group__intc__v3__14.html#ga881154092f4f8cd5e29a71b284f7b2ae">XIntc_SetNormalIntrMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6fdbe96b1db87f0c78e68da8bc767a69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIntc_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the currently set options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The currently set options. The options are described in <a class="el" href="xintc_8h.html">xintc.h</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, and <a class="el" href="struct_x_intc___config.html#ac3efdbf93e34b88aedead2e7ca44cee1">XIntc_Config::Options</a>.</p>

</div>
</div>
<a class="anchor" id="gaa7adc53d40c41e1a714ef8857329043d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a specific interrupt controller instance/driver. </p>
<p>The initialization entails: </p>
<pre class="fragment">  - Initialize fields of the XIntc structure
  - Initial vector table with stub function calls
  - All interrupt sources are disabled
  - Interrupt output is disabled
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">DeviceId</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started</li>
<li>XST_DEVICE_NOT_FOUND if device configuration information was not found for a device with the supplied device ID.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In Cascade mode this function calls XIntc_InitializeSlaves to initialize Slave Interrupt controllers. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc___config.html#ac894d2be382d08d83821c1672615d4d4">XIntc_Config::FastIntr</a>, <a class="el" href="struct_x_intc___config.html#af62197288a9019af6084a1675844e1ca">XIntc_Config::HandlerTable</a>, <a class="el" href="struct_x_intc___config.html#ae54682e47e6e506a52c7b6da6314a29a">XIntc_Config::IntcType</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, <a class="el" href="struct_x_intc.html#a3e45bbc3ed1e84a8d708c25c23fa252e">XIntc::IsStarted</a>, <a class="el" href="struct_x_intc___config.html#a6e2fc4f937193eb9e665a2e66af97db2">XIntc_Config::NumberofIntrs</a>, <a class="el" href="struct_x_intc___config.html#a85d5d557aa6619757848d754ca096552">XIntc_Config::NumberofSwIntrs</a>, <a class="el" href="struct_x_intc___config.html#ac3efdbf93e34b88aedead2e7ca44cee1">XIntc_Config::Options</a>, <a class="el" href="struct_x_intc___config.html#a630c8585f41eea348ae0d6d134b0ad8f">XIntc_Config::VectorAddrWidth</a>, <a class="el" href="group__intc__v3__14.html#gaf4bce8e2035f391b702686e49c66c839">XIN_SVC_SGL_ISR_OPTION</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="xintc__example_8c.html#a0421d50fd0512f77fa5f1e6f7abb8603">IntcExample()</a>, <a class="el" href="xintc__tapp__example_8c.html#a297705047f75055bf7856596d7313614">IntcInterruptSetup()</a>, and <a class="el" href="xintc__tapp__example_8c.html#a056a4f4a2347a1eb9d379d191b30735b">IntcSelfTestExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga635187ed756cee70b4b4051560cbd7bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler for the driver used when there can be no argument passed to the handler. </p>
<p>This function is provided mostly for backward compatibility. The user should use <a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818" title="This function is the primary interrupt handler for the driver.">XIntc_DeviceInterruptHandler()</a>, defined in <a class="el" href="xintc__l_8c.html">xintc_l.c</a>, if possible.</p>
<p>The user must connect this function to the interrupt system such that it is called whenever the devices which are connected to it cause an interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The constant XPAR_INTC_SINGLE_DEVICE_ID must be defined for this handler to be included in the driver compilation.</p>
<p>The interrupt handler for the driver. This function is provided mostly for backward compatibility. The user should use <a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818" title="This function is the primary interrupt handler for the driver.">XIntc_DeviceInterruptHandler()</a>, defined in <a class="el" href="xintc__l_8c.html">xintc_l.c</a> when possible and pass the device ID of the interrupt controller device as its argument.</p>
<p>The user must connect this function to the interrupt system such that it is called whenever the devices which are connected to it cause an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc___config.html#a1d58e4660c1f0727b1b29497b050cc2c">XIntc_Config::DeviceId</a>, and <a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a>.</p>

<p>Referenced by <a class="el" href="xintc__example_8c.html#aaea6614590c6c6eedade935ae1c1a26c">SetUpInterruptSystem()</a>.</p>

</div>
</div>
<a class="anchor" id="gaac2cc8909b69948e755ea649998cd2e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a> * XIntc_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the device configuration based on the unique device ID. </p>
<p>A table contains the configuration info for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the unique identifier for a device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> configuration structure for the specified device, or NULL if the device was not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__intc__v3__14.html#ga2187e69fdc39ef945a992d2602d0c1c1">XIntc_ConfigTable</a>.</p>

<p>Referenced by <a class="el" href="group__intc__v3__14.html#ga8604653ac3a24bbb49c5fecb6a9ebfc7">XIntc_Acknowledge()</a>, <a class="el" href="group__intc__v3__14.html#gaee9ec5873a764994d64b4da35a110084">XIntc_Connect()</a>, <a class="el" href="group__intc__v3__14.html#ga24a344d15b12b8acd82cd4c49a020d74">XIntc_ConnectFastHandler()</a>, <a class="el" href="group__intc__v3__14.html#gaea44ec361097925f2994558d402988ab">XIntc_Disable()</a>, <a class="el" href="group__intc__v3__14.html#ga8f7caaeb26b6b264fffefbd32f90f855">XIntc_Disconnect()</a>, <a class="el" href="group__intc__v3__14.html#gac7f59192d3b3ba2e2283a264677577b8">XIntc_Enable()</a>, <a class="el" href="group__intc__v3__14.html#gaa7adc53d40c41e1a714ef8857329043d">XIntc_Initialize()</a>, <a class="el" href="group__intc__v3__14.html#ga999a50f24a9ac9a4a2623d950978f1bb">XIntc_RegisterFastHandler()</a>, <a class="el" href="group__intc__v3__14.html#ga4bd1d34885340943143c8fd2f98a3963">XIntc_RegisterHandler()</a>, <a class="el" href="group__intc__v3__14.html#gaf090e932e35ede6c8cffe76e785de835">XIntc_SetIntrSvcOption()</a>, <a class="el" href="group__intc__v3__14.html#ga881154092f4f8cd5e29a71b284f7b2ae">XIntc_SetNormalIntrMode()</a>, <a class="el" href="group__intc__v3__14.html#ga1f0d32716f082a51a751df84312c7d56">XIntc_SetOptions()</a>, <a class="el" href="group__intc__v3__14.html#ga17972363ab5a1a8f5f1d135c5b3c22c7">XIntc_SimulateIntr()</a>, <a class="el" href="group__intc__v3__14.html#ga863eb58a3ae9419c7ac5da7c9fa9cb50">XIntc_Start()</a>, and <a class="el" href="group__intc__v3__14.html#ga7eb4ea6d2f66a5b3ca32b12ec68bc151">XIntc_TriggerSwIntr()</a>.</p>

</div>
</div>
<a class="anchor" id="ga999a50f24a9ac9a4a2623d950978f1bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_RegisterFastHandler </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XFastInterruptHandler&#160;</td>
          <td class="paramname"><em>FastHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a fast handler function for a specific interrupt ID. </p>
<p>The handler function will be called when an interrupt occurs for the given interrupt ID. In Cascade mode Interrupt Id is used to set Handler for corresponding Slave Controller</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the interrupt controller whose vector table will be modified. </td></tr>
    <tr><td class="paramname">InterruptId</td><td>is the interrupt ID to be associated with the input handler. </td></tr>
    <tr><td class="paramname">FastHandler</td><td>is the function pointer that will be called when interrupt occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Note that this function has no effect if the input base address is invalid. </p>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc___config.html#a630c8585f41eea348ae0d6d134b0ad8f">XIntc_Config::VectorAddrWidth</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4bd1d34885340943143c8fd2f98a3963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_RegisterHandler </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>InterruptId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XInterruptHandler&#160;</td>
          <td class="paramname"><em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a handler function for a specific interrupt ID. </p>
<p>The vector table of the interrupt controller is updated, overwriting any previous handler. The handler function will be called when an interrupt occurs for the given interrupt ID.</p>
<p>This function can also be used to remove a handler from the vector table by passing in the XIntc_DefaultHandler() as the handler and NULL as the callback reference. In Cascade mode Interrupt Id is used to set Handler for corresponding Slave Controller</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the interrupt controller whose vector table will be modified. </td></tr>
    <tr><td class="paramname">InterruptId</td><td>is the interrupt ID to be associated with the input handler. </td></tr>
    <tr><td class="paramname">Handler</td><td>is the function pointer that will be added to the vector table for the given interrupt ID. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the argument that will be passed to the new handler function when it is called. This is user-specific.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function has no effect if the input base address is invalid. Following fields in <a class="el" href="struct_x_intc___config.html" title="This typedef contains configuration information for the device.">XIntc_Config</a> impacts interrupt handling,</p>
<ol type="1">
<li>AckBeforeService: If 1, primary interrupt handler acks interrupt before servicing it, else it would ack interrupt after servicing it (after calling interrupt ID specific handler)</li>
<li>Options: XIN_SVC_SGL_ISR_OPTION - primary interrupt handler services the highest priority pending interrupt and return XIN_SVC_ALL_ISRS_OPTION - primary interrupt handler services all of the pending interrupts and then return </li>
</ol>

<p>References <a class="el" href="struct_x_intc___config.html#af62197288a9019af6084a1675844e1ca">XIntc_Config::HandlerTable</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="xintc__low__level__example_8c.html#a83f2cbdf0d928c5fb6401e2abd071b56">IntcLowLevelExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9a9a16180b363930d21bc94dfe71147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a self-test on the driver/device. </p>
<p>This is a destructive test.</p>
<p>This involves forcing interrupts into the controller and verifying that they are recognized and can be acknowledged. This test will not succeed if the interrupt controller has been started in real mode such that interrupts cannot be forced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if self-test is successful.</li>
<li>XST_INTC_FAIL_SELFTEST if the Interrupt controller fails the self-test. It will fail the self test if the device has previously been started in real mode.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, and <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>.</p>

<p>Referenced by <a class="el" href="xintc__example_8c.html#a0421d50fd0512f77fa5f1e6f7abb8603">IntcExample()</a>, <a class="el" href="xintc__tapp__example_8c.html#a297705047f75055bf7856596d7313614">IntcInterruptSetup()</a>, and <a class="el" href="xintc__tapp__example_8c.html#a056a4f4a2347a1eb9d379d191b30735b">IntcSelfTestExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf090e932e35ede6c8cffe76e785de835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_SetIntrSvcOption </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the interrupt service option, which can configure the driver so that it services only a single interrupt at a time when an interrupt occurs, or services all pending interrupts when an interrupt occurs. </p>
<p>The default behavior when using the driver interface given in <a class="el" href="xintc_8h.html">xintc.h</a> file is to service only a single interrupt, whereas the default behavior when using the driver interface given in this file is to service all outstanding interrupts when an interrupt occurs. In Cascade mode same Option is set to Slave controllers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the unique identifier for a device. </td></tr>
    <tr><td class="paramname">Option</td><td>is XIN_SVC_SGL_ISR_OPTION if you want only a single interrupt serviced when an interrupt occurs, or XIN_SVC_ALL_ISRS_OPTION if you want all pending interrupts serviced when an interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Note that this function has no effect if the input base address is invalid. </p>

<p>References <a class="el" href="struct_x_intc___config.html#ae54682e47e6e506a52c7b6da6314a29a">XIntc_Config::IntcType</a>, <a class="el" href="struct_x_intc___config.html#ac3efdbf93e34b88aedead2e7ca44cee1">XIntc_Config::Options</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="ga881154092f4f8cd5e29a71b284f7b2ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_SetNormalIntrMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the normal interrupt mode for the specified interrupt in the Interrupt Mode Register. </p>
<p>In Cascade mode disconnects handler from corresponding Slave controller IVAR/IVEAR register depending on the Id and sets all interrupt sources of the Slave controller as normal interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Slave controllers in Cascade Mode should have all as Fast interrupts or Normal interrupts, mixed interrupts are not supported </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc___config.html#ac894d2be382d08d83821c1672615d4d4">XIntc_Config::FastIntr</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, <a class="el" href="struct_x_intc___config.html#a630c8585f41eea348ae0d6d134b0ad8f">XIntc_Config::VectorAddrWidth</a>, <a class="el" href="group__intc__v3__14.html#gaea44ec361097925f2994558d402988ab">XIntc_Disable()</a>, <a class="el" href="group__intc__v3__14.html#gac7f59192d3b3ba2e2283a264677577b8">XIntc_Enable()</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f0d32716f082a51a751df84312c7d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the options for the interrupt controller driver. </p>
<p>In Cascade mode same Option is set to Slave controllers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Options</td><td>to be set. The available options are described in <a class="el" href="xintc_8h.html">xintc.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully</li>
<li>XST_INVALID_PARAM if the specified option was not valid</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc___config.html#ae54682e47e6e506a52c7b6da6314a29a">XIntc_Config::IntcType</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, <a class="el" href="struct_x_intc___config.html#ac3efdbf93e34b88aedead2e7ca44cee1">XIntc_Config::Options</a>, <a class="el" href="group__intc__v3__14.html#gaf4bce8e2035f391b702686e49c66c839">XIN_SVC_SGL_ISR_OPTION</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="ga17972363ab5a1a8f5f1d135c5b3c22c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_SimulateIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows software to simulate an interrupt in the interrupt controller. </p>
<p>This function will only be successful when the interrupt controller has been started in simulation mode. Once it has been started in real mode, interrupts cannot be simulated. A simulated interrupt allows the interrupt controller to be tested without any device to drive an interrupt input signal into it. In Cascade mode writes to ISR of appropriate Slave controller depending on Id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>is the interrupt ID for which to simulate an interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful</li>
</ul>
</dd></dl>
<ul>
<li>XST_FAILURE if the interrupt could not be simulated because the interrupt controller is or has previously been in real mode.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="xintc__example_8c.html#a0421d50fd0512f77fa5f1e6f7abb8603">IntcExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga863eb58a3ae9419c7ac5da7c9fa9cb50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the interrupt controller by enabling the output from the controller to the processor. </p>
<p>Interrupts may be generated by the interrupt controller after this function is called.</p>
<p>It is necessary for the caller to connect the interrupt handler of this component to the proper interrupt source. This function also starts Slave controllers in Cascade mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Mode</td><td>determines if software is allowed to simulate interrupts or real interrupts are allowed to occur. Note that these modes are mutually exclusive. The interrupt controller hardware resets in a mode that allows software to simulate interrupts until this mode is exited. It cannot be reentered once it has been exited.</td></tr>
  </table>
  </dd>
</dl>
<p>One of the following values should be used for the mode.</p>
<ul>
<li>XIN_SIMULATION_MODE enables simulation of interrupts only</li>
<li>XIN_REAL_MODE enables hardware interrupts only</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the device was started successfully</li>
<li>XST_FAILURE if simulation mode was specified and it could not be set because real mode has already been entered.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Must be called after <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> initialization is completed. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#ac76bb1d794c122fdb86f8e72a9ed22fd">XIntc::CfgPtr</a>, <a class="el" href="struct_x_intc___config.html#ae54682e47e6e506a52c7b6da6314a29a">XIntc_Config::IntcType</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, <a class="el" href="struct_x_intc.html#a3e45bbc3ed1e84a8d708c25c23fa252e">XIntc::IsStarted</a>, <a class="el" href="group__intc__v3__14.html#ga56b4aa3cb483ea5c882e2e36a4800af2">XIN_REAL_MODE</a>, <a class="el" href="group__intc__v3__14.html#gaefd5527cecdc1a6444b624d1e1a2514f">XIN_SIMULATION_MODE</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="xintc__tapp__example_8c.html#a297705047f75055bf7856596d7313614">IntcInterruptSetup()</a>, and <a class="el" href="xintc__example_8c.html#aaea6614590c6c6eedade935ae1c1a26c">SetUpInterruptSystem()</a>.</p>

</div>
</div>
<a class="anchor" id="gafabb05cf2e5b62031524a33d1f88f405"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the interrupt controller by disabling the output from the controller so that no interrupts will be caused by the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, and <a class="el" href="struct_x_intc.html#a3e45bbc3ed1e84a8d708c25c23fa252e">XIntc::IsStarted</a>.</p>

</div>
</div>
<a class="anchor" id="ga7eb4ea6d2f66a5b3ca32b12ec68bc151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIntc_TriggerSwIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_intc.html">XIntc</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows software to trigger software interrupt. </p>
<p>This function will only be successful when the interrupt controller has been configured with software interrupt in HW design</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>is the interrupt ID to be triggered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful</li>
</ul>
</dd></dl>
<ul>
<li>XST_FAILURE if the instance pointer is invalid if interrupt id does not belongs to software interrupt</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>HW design must have software interrupts and interrupt id passed should be of software interrupt type. Interrupt id's for software interrupts for specific HW design can be found in xparameters.h file. </dd></dl>

<p>References <a class="el" href="struct_x_intc___config.html#a7fb04e1e5139ccfcd9475847c67c35af">XIntc_Config::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a36bcdd89bd3afdb96bbee08989c886c0">XIntc::BaseAddress</a>, <a class="el" href="struct_x_intc.html#a277e8f00e1f6eb05f8097c676e826b62">XIntc::IsReady</a>, <a class="el" href="struct_x_intc___config.html#a6e2fc4f937193eb9e665a2e66af97db2">XIntc_Config::NumberofIntrs</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga6afbe6b28aa729c753744cba40ecf5b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a> XIntc_ConfigTable[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This table contains configuration information for each intc device in the system. </p>
<p>The <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> driver must know when to acknowledge the interrupt. The entry which specifies this as a bit mask where each bit corresponds to a specific interrupt. A bit set indicates to ack it before servicing it. Generally, acknowledge before service is used when the interrupt signal is edge-sensitive, and after when the signal is level-sensitive.</p>
<p>Refer to the <a class="el" href="struct_x_intc___config.html" title="This typedef contains configuration information for the device.">XIntc_Config</a> data structure in <a class="el" href="xintc_8h.html">xintc.h</a> for details on how this table should be initialized. </p>

<p>Referenced by <a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2187e69fdc39ef945a992d2602d0c1c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_intc___config.html">XIntc_Config</a> XIntc_ConfigTable[XPAR_XINTC_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        {</div>
<div class="line">         XPAR_INTC_0_DEVICE_ID, </div>
<div class="line">         XPAR_INTC_0_BASEADDR,  </div>
<div class="line">         XPAR_INTC_0_ACK_BEFORE,        </div>
<div class="line">         0                      </div>
<div class="line">         }</div>
<div class="line">        ,</div>
<div class="line">        {</div>
<div class="line">         XPAR_INTC_1_DEVICE_ID, </div>
<div class="line">         XPAR_INTC_1_BASEADDR,  </div>
<div class="line">         XPAR_INTC_1_ACK_BEFORE,        </div>
<div class="line">         0                      </div>
<div class="line">         }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This table contains configuration information for each intc device in the system. </p>
<p>The <a class="el" href="struct_x_intc.html" title="The XIntc driver instance data.">XIntc</a> driver must know when to acknowledge the interrupt. The entry which specifies this as a bit mask where each bit corresponds to a specific interrupt. A bit set indicates to ack it before servicing it. Generally, acknowledge before service is used when the interrupt signal is edge-sensitive, and after when the signal is level-sensitive.</p>
<p>Refer to the <a class="el" href="struct_x_intc___config.html" title="This typedef contains configuration information for the device.">XIntc_Config</a> data structure in <a class="el" href="xintc_8h.html">xintc.h</a> for details on how this table should be initialized. </p>

<p>Referenced by <a class="el" href="group__intc__v3__14.html#gace91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a>, and <a class="el" href="group__intc__v3__14.html#gaac2cc8909b69948e755ea649998cd2e1">XIntc_LookupConfig()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
