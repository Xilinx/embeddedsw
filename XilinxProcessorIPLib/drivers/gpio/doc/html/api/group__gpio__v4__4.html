<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>gpio: Gpio_v4_4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">gpio
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__gpio__v4__4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Gpio_v4_4</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for the device.  <a href="struct_x_gpio___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_gpio.html">XGpio</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> driver instance data.  <a href="struct_x_gpio.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2cd75ed11bd48af96704b073fa65ef22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>(BaseAddress, RegOffset, Data)&#160;&#160;&#160;XGpio_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td></tr>
<tr class="memdesc:ga2cd75ed11bd48af96704b073fa65ef22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a GPIO register.  <a href="#ga2cd75ed11bd48af96704b073fa65ef22"></a><br/></td></tr>
<tr class="separator:ga2cd75ed11bd48af96704b073fa65ef22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7199da4092b92413af00c613c8cffa57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>(BaseAddress, RegOffset)&#160;&#160;&#160;XGpio_In32((BaseAddress) + (RegOffset))</td></tr>
<tr class="memdesc:ga7199da4092b92413af00c613c8cffa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a GPIO register.  <a href="#ga7199da4092b92413af00c613c8cffa57"></a><br/></td></tr>
<tr class="separator:ga7199da4092b92413af00c613c8cffa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf76e70c9ddd0dc3966123c09646d880c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gaf76e70c9ddd0dc3966123c09646d880c">XGpio_CfgInitialize</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, <a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> *Config, UINTPTR EffectiveAddr)</td></tr>
<tr class="memdesc:gaf76e70c9ddd0dc3966123c09646d880c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance provided by the caller based on the given configuration data.  <a href="#gaf76e70c9ddd0dc3966123c09646d880c"></a><br/></td></tr>
<tr class="separator:gaf76e70c9ddd0dc3966123c09646d880c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee6bcad28382ef5ecd336887647c238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gabee6bcad28382ef5ecd336887647c238">XGpio_SetDataDirection</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel, u32 DirectionMask)</td></tr>
<tr class="memdesc:gabee6bcad28382ef5ecd336887647c238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input/output direction of all discrete signals for the specified GPIO channel.  <a href="#gabee6bcad28382ef5ecd336887647c238"></a><br/></td></tr>
<tr class="separator:gabee6bcad28382ef5ecd336887647c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77090853c15dc3d72e2bfbc66e635ada"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga77090853c15dc3d72e2bfbc66e635ada">XGpio_GetDataDirection</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel)</td></tr>
<tr class="memdesc:ga77090853c15dc3d72e2bfbc66e635ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the input/output direction of all discrete signals for the specified GPIO channel.  <a href="#ga77090853c15dc3d72e2bfbc66e635ada"></a><br/></td></tr>
<tr class="separator:ga77090853c15dc3d72e2bfbc66e635ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed95c58f21d567fca624f9f51cb25e20"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gaed95c58f21d567fca624f9f51cb25e20">XGpio_DiscreteRead</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel)</td></tr>
<tr class="memdesc:gaed95c58f21d567fca624f9f51cb25e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read state of discretes for the specified GPIO channnel.  <a href="#gaed95c58f21d567fca624f9f51cb25e20"></a><br/></td></tr>
<tr class="separator:gaed95c58f21d567fca624f9f51cb25e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6965e5986a770e5e9d62d0ea4e56636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gab6965e5986a770e5e9d62d0ea4e56636">XGpio_DiscreteWrite</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel, u32 Data)</td></tr>
<tr class="memdesc:gab6965e5986a770e5e9d62d0ea4e56636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to discretes register for the specified GPIO channel.  <a href="#gab6965e5986a770e5e9d62d0ea4e56636"></a><br/></td></tr>
<tr class="separator:gab6965e5986a770e5e9d62d0ea4e56636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080482882d1f60cbd84b8e4ea856560c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga080482882d1f60cbd84b8e4ea856560c">XGpio_Initialize</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr class="memdesc:ga080482882d1f60cbd84b8e4ea856560c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance provided by the caller based on the given DeviceID.  <a href="#ga080482882d1f60cbd84b8e4ea856560c"></a><br/></td></tr>
<tr class="separator:ga080482882d1f60cbd84b8e4ea856560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b208ffd7b19c2176d459223bc63ea14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga3b208ffd7b19c2176d459223bc63ea14">XGpio_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:ga3b208ffd7b19c2176d459223bc63ea14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the device configuration based on the unique device ID.  <a href="#ga3b208ffd7b19c2176d459223bc63ea14"></a><br/></td></tr>
<tr class="separator:ga3b208ffd7b19c2176d459223bc63ea14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f2cea7ef78412c03c7ebdba87b7cdd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga8f2cea7ef78412c03c7ebdba87b7cdd4">XGpio_DiscreteSet</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel, u32 Mask)</td></tr>
<tr class="memdesc:ga8f2cea7ef78412c03c7ebdba87b7cdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output discrete(s) to logic 1 for the specified GPIO channel.  <a href="#ga8f2cea7ef78412c03c7ebdba87b7cdd4"></a><br/></td></tr>
<tr class="separator:ga8f2cea7ef78412c03c7ebdba87b7cdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae430718af9f347c91be42aad580b216c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gae430718af9f347c91be42aad580b216c">XGpio_DiscreteClear</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel, u32 Mask)</td></tr>
<tr class="memdesc:gae430718af9f347c91be42aad580b216c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output discrete(s) to logic 0 for the specified GPIO channel.  <a href="#gae430718af9f347c91be42aad580b216c"></a><br/></td></tr>
<tr class="separator:gae430718af9f347c91be42aad580b216c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf01e2f4d8e75fa4922a5d92798be7b25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gaf01e2f4d8e75fa4922a5d92798be7b25">XGpio_SelfTest</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaf01e2f4d8e75fa4922a5d92798be7b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a self-test on the driver/device.  <a href="#gaf01e2f4d8e75fa4922a5d92798be7b25"></a><br/></td></tr>
<tr class="separator:gaf01e2f4d8e75fa4922a5d92798be7b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga116bf1509220aa688f76f80501eb0d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga116bf1509220aa688f76f80501eb0d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the interrupt output signal.  <a href="#ga116bf1509220aa688f76f80501eb0d9e"></a><br/></td></tr>
<tr class="separator:ga116bf1509220aa688f76f80501eb0d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6241d0ae28815c258bb89a61ce0a6366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga6241d0ae28815c258bb89a61ce0a6366">XGpio_InterruptGlobalDisable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga6241d0ae28815c258bb89a61ce0a6366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the interrupt output signal.  <a href="#ga6241d0ae28815c258bb89a61ce0a6366"></a><br/></td></tr>
<tr class="separator:ga6241d0ae28815c258bb89a61ce0a6366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b62394f65ecbb6566d91412616509c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gaa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:gaa5b62394f65ecbb6566d91412616509c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupts.  <a href="#gaa5b62394f65ecbb6566d91412616509c"></a><br/></td></tr>
<tr class="separator:gaa5b62394f65ecbb6566d91412616509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c295f935fdc4e37c9f958b3652fbf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga21c295f935fdc4e37c9f958b3652fbf6">XGpio_InterruptDisable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:ga21c295f935fdc4e37c9f958b3652fbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts.  <a href="#ga21c295f935fdc4e37c9f958b3652fbf6"></a><br/></td></tr>
<tr class="separator:ga21c295f935fdc4e37c9f958b3652fbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5138b55159f8b2387f5cf16079b40bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga5138b55159f8b2387f5cf16079b40bbe">XGpio_InterruptClear</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:ga5138b55159f8b2387f5cf16079b40bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending interrupts with the provided mask.  <a href="#ga5138b55159f8b2387f5cf16079b40bbe"></a><br/></td></tr>
<tr class="separator:ga5138b55159f8b2387f5cf16079b40bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5e23001aa3d35febe4859270ede71e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga1e5e23001aa3d35febe4859270ede71e">XGpio_InterruptGetEnabled</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga1e5e23001aa3d35febe4859270ede71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt enable mask.  <a href="#ga1e5e23001aa3d35febe4859270ede71e"></a><br/></td></tr>
<tr class="separator:ga1e5e23001aa3d35febe4859270ede71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b0fa50ff962243ea284a4a767fe01e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga95b0fa50ff962243ea284a4a767fe01e">XGpio_InterruptGetStatus</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga95b0fa50ff962243ea284a4a767fe01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of interrupt signals.  <a href="#ga95b0fa50ff962243ea284a4a767fe01e"></a><br/></td></tr>
<tr class="separator:ga95b0fa50ff962243ea284a4a767fe01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae056125811a82e494e01d590523fdd00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gae056125811a82e494e01d590523fdd00">XGpio_ConfigTable</a> []</td></tr>
<tr class="memdesc:gae056125811a82e494e01d590523fdd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each GPIO device in the system.  <a href="#gae056125811a82e494e01d590523fdd00"></a><br/></td></tr>
<tr class="separator:gae056125811a82e494e01d590523fdd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Registers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa9682ea50df45368189078864618a7cd"></a>Register offsets for this device. </p>
</td></tr>
<tr class="memitem:ga1712704f3a009d03d0b3201c90259793"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga1712704f3a009d03d0b3201c90259793">XGPIO_DATA_OFFSET</a>&#160;&#160;&#160;0x0</td></tr>
<tr class="memdesc:ga1712704f3a009d03d0b3201c90259793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data register for 1st channel.  <a href="#ga1712704f3a009d03d0b3201c90259793"></a><br/></td></tr>
<tr class="separator:ga1712704f3a009d03d0b3201c90259793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcefd582c52e56dc7c438a72dfa95546"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gafcefd582c52e56dc7c438a72dfa95546">XGPIO_TRI_OFFSET</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:gafcefd582c52e56dc7c438a72dfa95546"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O direction reg for 1st channel.  <a href="#gafcefd582c52e56dc7c438a72dfa95546"></a><br/></td></tr>
<tr class="separator:gafcefd582c52e56dc7c438a72dfa95546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae85b884d1fb9ac4c874dd597b1a049b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gae85b884d1fb9ac4c874dd597b1a049b6">XGPIO_DATA2_OFFSET</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="memdesc:gae85b884d1fb9ac4c874dd597b1a049b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data register for 2nd channel.  <a href="#gae85b884d1fb9ac4c874dd597b1a049b6"></a><br/></td></tr>
<tr class="separator:gae85b884d1fb9ac4c874dd597b1a049b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac881efa0580f36e99ab03230b26ca2e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#gac881efa0580f36e99ab03230b26ca2e2">XGPIO_TRI2_OFFSET</a>&#160;&#160;&#160;0xC</td></tr>
<tr class="memdesc:gac881efa0580f36e99ab03230b26ca2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O direction reg for 2nd channel.  <a href="#gac881efa0580f36e99ab03230b26ca2e2"></a><br/></td></tr>
<tr class="separator:gac881efa0580f36e99ab03230b26ca2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389241f63fd0ce9af2c1f6dc0f69dcb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga389241f63fd0ce9af2c1f6dc0f69dcb3">XGPIO_GIE_OFFSET</a>&#160;&#160;&#160;0x11C</td></tr>
<tr class="memdesc:ga389241f63fd0ce9af2c1f6dc0f69dcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Glogal interrupt enable register.  <a href="#ga389241f63fd0ce9af2c1f6dc0f69dcb3"></a><br/></td></tr>
<tr class="separator:ga389241f63fd0ce9af2c1f6dc0f69dcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cbde8210cb1476b67ca87eccacbc2ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga6cbde8210cb1476b67ca87eccacbc2ed">XGPIO_ISR_OFFSET</a>&#160;&#160;&#160;0x120</td></tr>
<tr class="memdesc:ga6cbde8210cb1476b67ca87eccacbc2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt status register.  <a href="#ga6cbde8210cb1476b67ca87eccacbc2ed"></a><br/></td></tr>
<tr class="separator:ga6cbde8210cb1476b67ca87eccacbc2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f62e4ffa9e47cd55133c583134f4f57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga4f62e4ffa9e47cd55133c583134f4f57">XGPIO_IER_OFFSET</a>&#160;&#160;&#160;0x128</td></tr>
<tr class="memdesc:ga4f62e4ffa9e47cd55133c583134f4f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt enable register.  <a href="#ga4f62e4ffa9e47cd55133c583134f4f57"></a><br/></td></tr>
<tr class="separator:ga4f62e4ffa9e47cd55133c583134f4f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interrupt Status and Enable Register bitmaps and masks</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp06e64022f503ac170140e995ad29c0ba"></a>Bit definitions for the interrupt status register and interrupt enable registers. </p>
</td></tr>
<tr class="memitem:ga421755999f173a708b8254bb9cdc9b62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga421755999f173a708b8254bb9cdc9b62">XGPIO_IR_MASK</a>&#160;&#160;&#160;0x3</td></tr>
<tr class="memdesc:ga421755999f173a708b8254bb9cdc9b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of all bits.  <a href="#ga421755999f173a708b8254bb9cdc9b62"></a><br/></td></tr>
<tr class="separator:ga421755999f173a708b8254bb9cdc9b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216177d9cad31a8fa22c4114c754f3ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga216177d9cad31a8fa22c4114c754f3ae">XGPIO_IR_CH1_MASK</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:ga216177d9cad31a8fa22c4114c754f3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for the 1st channel.  <a href="#ga216177d9cad31a8fa22c4114c754f3ae"></a><br/></td></tr>
<tr class="separator:ga216177d9cad31a8fa22c4114c754f3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga202cdf1a14179cd31df27346a55dced4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpio__v4__4.html#ga202cdf1a14179cd31df27346a55dced4">XGPIO_IR_CH2_MASK</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:ga202cdf1a14179cd31df27346a55dced4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for the 2nd channel.  <a href="#ga202cdf1a14179cd31df27346a55dced4"></a><br/></td></tr>
<tr class="separator:ga202cdf1a14179cd31df27346a55dced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Global Interrupt Enable Register bitmaps and masks</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9bafa1a56ce4e46ddc3ab04a997552dd"></a>Bit definitions for the Global Interrupt Enable register </p>
</td></tr>
<tr class="memitem:ga0b576e472f8ad06f166d9107de3b0348"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b576e472f8ad06f166d9107de3b0348"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIO_GIE_GINTR_ENABLE_MASK</b>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="separator:ga0b576e472f8ad06f166d9107de3b0348"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gae85b884d1fb9ac4c874dd597b1a049b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_DATA2_OFFSET&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data register for 2nd channel. </p>

</div>
</div>
<a class="anchor" id="ga1712704f3a009d03d0b3201c90259793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_DATA_OFFSET&#160;&#160;&#160;0x0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data register for 1st channel. </p>

<p>Referenced by <a class="el" href="xgpio__low__level__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="group__gpio__v4__4.html#gae430718af9f347c91be42aad580b216c">XGpio_DiscreteClear()</a>, <a class="el" href="group__gpio__v4__4.html#gaed95c58f21d567fca624f9f51cb25e20">XGpio_DiscreteRead()</a>, <a class="el" href="group__gpio__v4__4.html#ga8f2cea7ef78412c03c7ebdba87b7cdd4">XGpio_DiscreteSet()</a>, and <a class="el" href="group__gpio__v4__4.html#gab6965e5986a770e5e9d62d0ea4e56636">XGpio_DiscreteWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="ga389241f63fd0ce9af2c1f6dc0f69dcb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_GIE_OFFSET&#160;&#160;&#160;0x11C</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Glogal interrupt enable register. </p>

<p>Referenced by <a class="el" href="group__gpio__v4__4.html#ga6241d0ae28815c258bb89a61ce0a6366">XGpio_InterruptGlobalDisable()</a>, and <a class="el" href="group__gpio__v4__4.html#ga116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f62e4ffa9e47cd55133c583134f4f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_IER_OFFSET&#160;&#160;&#160;0x128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt enable register. </p>

<p>Referenced by <a class="el" href="group__gpio__v4__4.html#ga21c295f935fdc4e37c9f958b3652fbf6">XGpio_InterruptDisable()</a>, <a class="el" href="group__gpio__v4__4.html#gaa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a>, and <a class="el" href="group__gpio__v4__4.html#ga1e5e23001aa3d35febe4859270ede71e">XGpio_InterruptGetEnabled()</a>.</p>

</div>
</div>
<a class="anchor" id="ga216177d9cad31a8fa22c4114c754f3ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_IR_CH1_MASK&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for the 1st channel. </p>

</div>
</div>
<a class="anchor" id="ga202cdf1a14179cd31df27346a55dced4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_IR_CH2_MASK&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for the 2nd channel. </p>

</div>
</div>
<a class="anchor" id="ga421755999f173a708b8254bb9cdc9b62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_IR_MASK&#160;&#160;&#160;0x3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask of all bits. </p>

</div>
</div>
<a class="anchor" id="ga6cbde8210cb1476b67ca87eccacbc2ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_ISR_OFFSET&#160;&#160;&#160;0x120</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt status register. </p>

<p>Referenced by <a class="el" href="group__gpio__v4__4.html#ga5138b55159f8b2387f5cf16079b40bbe">XGpio_InterruptClear()</a>, and <a class="el" href="group__gpio__v4__4.html#ga95b0fa50ff962243ea284a4a767fe01e">XGpio_InterruptGetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7199da4092b92413af00c613c8cffa57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGpio_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XGpio_In32((BaseAddress) + (RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a GPIO register. </p>
<p>A 32 bit read is performed. If the GPIO core is implemented in a smaller width, only the least significant data is read from the register. The most significant data will be read as 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the GPIO device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset from the base to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data read from the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57" title="Read a value from a GPIO register.">XGpio_ReadReg(u32 BaseAddress, u32 RegOffset)</a> </dd></dl>

<p>Referenced by <a class="el" href="xgpio__low__level__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="group__gpio__v4__4.html#gae430718af9f347c91be42aad580b216c">XGpio_DiscreteClear()</a>, <a class="el" href="group__gpio__v4__4.html#gaed95c58f21d567fca624f9f51cb25e20">XGpio_DiscreteRead()</a>, <a class="el" href="group__gpio__v4__4.html#ga8f2cea7ef78412c03c7ebdba87b7cdd4">XGpio_DiscreteSet()</a>, <a class="el" href="group__gpio__v4__4.html#ga77090853c15dc3d72e2bfbc66e635ada">XGpio_GetDataDirection()</a>, <a class="el" href="group__gpio__v4__4.html#ga5138b55159f8b2387f5cf16079b40bbe">XGpio_InterruptClear()</a>, <a class="el" href="group__gpio__v4__4.html#ga21c295f935fdc4e37c9f958b3652fbf6">XGpio_InterruptDisable()</a>, <a class="el" href="group__gpio__v4__4.html#gaa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a>, <a class="el" href="group__gpio__v4__4.html#ga1e5e23001aa3d35febe4859270ede71e">XGpio_InterruptGetEnabled()</a>, and <a class="el" href="group__gpio__v4__4.html#ga95b0fa50ff962243ea284a4a767fe01e">XGpio_InterruptGetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="gac881efa0580f36e99ab03230b26ca2e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_TRI2_OFFSET&#160;&#160;&#160;0xC</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O direction reg for 2nd channel. </p>

</div>
</div>
<a class="anchor" id="gafcefd582c52e56dc7c438a72dfa95546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_TRI_OFFSET&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O direction reg for 1st channel. </p>

<p>Referenced by <a class="el" href="xgpio__low__level__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="group__gpio__v4__4.html#ga77090853c15dc3d72e2bfbc66e635ada">XGpio_GetDataDirection()</a>, and <a class="el" href="group__gpio__v4__4.html#gabee6bcad28382ef5ecd336887647c238">XGpio_SetDataDirection()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2cd75ed11bd48af96704b073fa65ef22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGpio_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XGpio_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a GPIO register. </p>
<p>A 32 bit write is performed. If the GPIO core is implemented in a smaller width, only the least significant data is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the GPIO device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset from the base to write to. </td></tr>
    <tr><td class="paramname">Data</td><td>is the data written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22" title="Write a value to a GPIO register.">XGpio_WriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)</a> </dd></dl>

<p>Referenced by <a class="el" href="xgpio__low__level__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="group__gpio__v4__4.html#gae430718af9f347c91be42aad580b216c">XGpio_DiscreteClear()</a>, <a class="el" href="group__gpio__v4__4.html#ga8f2cea7ef78412c03c7ebdba87b7cdd4">XGpio_DiscreteSet()</a>, <a class="el" href="group__gpio__v4__4.html#gab6965e5986a770e5e9d62d0ea4e56636">XGpio_DiscreteWrite()</a>, <a class="el" href="group__gpio__v4__4.html#ga5138b55159f8b2387f5cf16079b40bbe">XGpio_InterruptClear()</a>, <a class="el" href="group__gpio__v4__4.html#ga21c295f935fdc4e37c9f958b3652fbf6">XGpio_InterruptDisable()</a>, <a class="el" href="group__gpio__v4__4.html#gaa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a>, <a class="el" href="group__gpio__v4__4.html#ga6241d0ae28815c258bb89a61ce0a6366">XGpio_InterruptGlobalDisable()</a>, <a class="el" href="group__gpio__v4__4.html#ga116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable()</a>, and <a class="el" href="group__gpio__v4__4.html#gabee6bcad28382ef5ecd336887647c238">XGpio_SetDataDirection()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf76e70c9ddd0dc3966123c09646d880c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XGpio_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> *&#160;</td>
          <td class="paramname"><em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance provided by the caller based on the given configuration data. </p>
<p>Nothing is done except to initialize the InstancePtr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance. The memory the pointer references must be pre-allocated by the caller. Further calls to manipulate the driver through the <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> API must be made with this pointer. </td></tr>
    <tr><td class="paramname">Config</td><td>is a reference to a structure containing information about a specific GPIO device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the initialization is successfull.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__gpio__v4__4.html#ga080482882d1f60cbd84b8e4ea856560c">XGpio_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gae430718af9f347c91be42aad580b216c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_DiscreteClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output discrete(s) to logic 0 for the specified GPIO channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPIO (1 or 2) to operate on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the set of bits that will be set to 0 in the discrete data register. All other bits in the data register are unaffected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert.</p>
<p>This API can only be used if the GPIO_IO ports in the IP are used for connecting to the external output ports. </p>

<p>References <a class="el" href="group__gpio__v4__4.html#ga1712704f3a009d03d0b3201c90259793">XGPIO_DATA_OFFSET</a>, <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xgpio__tapp__example_8c.html#a38d5dc74a5216dde3e6c9f5ab6ac2402">GpioOutputExample()</a>, and <a class="el" href="xgpio__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed95c58f21d567fca624f9f51cb25e20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_DiscreteRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read state of discretes for the specified GPIO channnel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPIO (1 or 2) to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current copy of the discretes register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#ga1712704f3a009d03d0b3201c90259793">XGPIO_DATA_OFFSET</a>, and <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xgpio__tapp__example_8c.html#a174af7fb675bce8c6d81a0f89303d048">GpioInputExample()</a>, and <a class="el" href="group__gpio__v4__4.html#gaf01e2f4d8e75fa4922a5d92798be7b25">XGpio_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f2cea7ef78412c03c7ebdba87b7cdd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_DiscreteSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output discrete(s) to logic 1 for the specified GPIO channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPIO (1 or 2) to operate on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the set of bits that will be set to 1 in the discrete data register. All other bits in the data register are unaffected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert.</p>
<p>This API can only be used if the GPIO_IO ports in the IP are used for connecting to the external output ports. </p>

<p>References <a class="el" href="group__gpio__v4__4.html#ga1712704f3a009d03d0b3201c90259793">XGPIO_DATA_OFFSET</a>, <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gab6965e5986a770e5e9d62d0ea4e56636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_DiscreteWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to discretes register for the specified GPIO channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPIO (1 or 2) to operate on. </td></tr>
    <tr><td class="paramname">Data</td><td>is the value to be written to the discretes register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert. See also <a class="el" href="group__gpio__v4__4.html#ga8f2cea7ef78412c03c7ebdba87b7cdd4" title="Set output discrete(s) to logic 1 for the specified GPIO channel.">XGpio_DiscreteSet()</a> and <a class="el" href="group__gpio__v4__4.html#gae430718af9f347c91be42aad580b216c" title="Set output discrete(s) to logic 0 for the specified GPIO channel.">XGpio_DiscreteClear()</a>. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#ga1712704f3a009d03d0b3201c90259793">XGPIO_DATA_OFFSET</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xgpio__tapp__example_8c.html#a38d5dc74a5216dde3e6c9f5ab6ac2402">GpioOutputExample()</a>, and <a class="el" href="xgpio__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ga77090853c15dc3d72e2bfbc66e635ada"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_GetDataDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the input/output direction of all discrete signals for the specified GPIO channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPIO (1 or 2) to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitmask specifying which discretes are input and which are output. Bits set to 0 are output and bits set to 1 are input.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert. </p>

<p>References <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>, and <a class="el" href="group__gpio__v4__4.html#gafcefd582c52e56dc7c438a72dfa95546">XGPIO_TRI_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="ga080482882d1f60cbd84b8e4ea856560c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XGpio_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance provided by the caller based on the given DeviceID. </p>
<p>Nothing is done except to initialize the InstancePtr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance. The memory the pointer references must be pre-allocated by the caller. Further calls to manipulate the instance/driver through the <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> API must be made with this pointer. </td></tr>
    <tr><td class="paramname">DeviceId</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the initialization was successfull.<ul>
<li>XST_DEVICE_NOT_FOUND if the device configuration data was not found for a device with the supplied device ID.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#gaf76e70c9ddd0dc3966123c09646d880c">XGpio_CfgInitialize()</a>, and <a class="el" href="group__gpio__v4__4.html#ga3b208ffd7b19c2176d459223bc63ea14">XGpio_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="xgpio__tapp__example_8c.html#a174af7fb675bce8c6d81a0f89303d048">GpioInputExample()</a>, <a class="el" href="xgpio__intr__tapp__example_8c.html#a590eda570d4e0b373a68f1911ce58d32">GpioIntrExample()</a>, <a class="el" href="xgpio__tapp__example_8c.html#a38d5dc74a5216dde3e6c9f5ab6ac2402">GpioOutputExample()</a>, and <a class="el" href="xgpio__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5138b55159f8b2387f5cf16079b40bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending interrupts with the provided mask. </p>
<p>This function should be called after the software has serviced the interrupts that are pending. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the mask to clear pending interrupts for. Bit positions of 1 are cleared. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#ga6cbde8210cb1476b67ca87eccacbc2ed">XGPIO_ISR_OFFSET</a>, <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xgpio__intr__tapp__example_8c.html#a11b79a03b5bf53310d0f20adeca131d6">GpioHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga21c295f935fdc4e37c9f958b3652fbf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable interrupts. </p>
<p>This function allows specific interrupts for each channel to be disabled. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the mask to disable. Bits set to 1 are disabled. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#ga4f62e4ffa9e47cd55133c583134f4f57">XGPIO_IER_OFFSET</a>, <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xgpio__intr__tapp__example_8c.html#a2316ea8becbdd561d98c80ccab43a984">GpioDisableIntr()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5b62394f65ecbb6566d91412616509c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupts. </p>
<p>The global interrupt must also be enabled by calling <a class="el" href="group__gpio__v4__4.html#ga116bf1509220aa688f76f80501eb0d9e" title="Enable the interrupt output signal.">XGpio_InterruptGlobalEnable()</a> for interrupts to occur. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the mask to enable. Bit positions of 1 are enabled. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#ga4f62e4ffa9e47cd55133c583134f4f57">XGPIO_IER_OFFSET</a>, <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xgpio__intr__tapp__example_8c.html#a94c5c78b0558a936c75dcbe18492c658">GpioSetupIntrSystem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e5e23001aa3d35febe4859270ede71e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_InterruptGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interrupt enable mask. </p>
<p>This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask of bits made from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</dd>
<dd>
None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#ga4f62e4ffa9e47cd55133c583134f4f57">XGPIO_IER_OFFSET</a>, and <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga95b0fa50ff962243ea284a4a767fe01e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_InterruptGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of interrupt signals. </p>
<p>Any bit in the mask set to 1 indicates that the channel associated with the bit has asserted an interrupt condition. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a mask of bits made from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The interrupt status indicates the status of the device irregardless if the interrupts from the devices have been enabled or not through <a class="el" href="group__gpio__v4__4.html#gaa5b62394f65ecbb6566d91412616509c" title="Enable interrupts.">XGpio_InterruptEnable()</a>. </p>

<p>References <a class="el" href="group__gpio__v4__4.html#ga6cbde8210cb1476b67ca87eccacbc2ed">XGPIO_ISR_OFFSET</a>, and <a class="el" href="group__gpio__v4__4.html#ga7199da4092b92413af00c613c8cffa57">XGpio_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga6241d0ae28815c258bb89a61ce0a6366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptGlobalDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the interrupt output signal. </p>
<p>Interrupts enabled through <a class="el" href="group__gpio__v4__4.html#gaa5b62394f65ecbb6566d91412616509c" title="Enable interrupts.">XGpio_InterruptEnable()</a> will no longer be passed through until the global enable bit is set by <a class="el" href="group__gpio__v4__4.html#ga116bf1509220aa688f76f80501eb0d9e" title="Enable the interrupt output signal.">XGpio_InterruptGlobalEnable()</a>. This function is designed to allow all interrupts (both channels) to be disabled easily for entering a critical section. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#ga389241f63fd0ce9af2c1f6dc0f69dcb3">XGPIO_GIE_OFFSET</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga116bf1509220aa688f76f80501eb0d9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptGlobalEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the interrupt output signal. </p>
<p>Interrupts enabled through <a class="el" href="group__gpio__v4__4.html#gaa5b62394f65ecbb6566d91412616509c" title="Enable interrupts.">XGpio_InterruptEnable()</a> will not be passed through until the global enable bit is set by this function. This function is designed to allow all interrupts (both channels) to be enabled easily for exiting a critical section. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#ga389241f63fd0ce9af2c1f6dc0f69dcb3">XGPIO_GIE_OFFSET</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xgpio__intr__tapp__example_8c.html#a94c5c78b0558a936c75dcbe18492c658">GpioSetupIntrSystem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b208ffd7b19c2176d459223bc63ea14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> * XGpio_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the device configuration based on the unique device ID. </p>
<p>The table ConfigTable contains the configuration info for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the device identifier to lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A pointer of data type <a class="el" href="struct_x_gpio___config.html" title="This typedef contains configuration information for the device.">XGpio_Config</a> which points to the device configuration if DeviceID is found.<ul>
<li>NULL if DeviceID is not found.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#gae056125811a82e494e01d590523fdd00">XGpio_ConfigTable</a>.</p>

<p>Referenced by <a class="el" href="group__gpio__v4__4.html#ga080482882d1f60cbd84b8e4ea856560c">XGpio_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf01e2f4d8e75fa4922a5d92798be7b25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XGpio_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a self-test on the driver/device. </p>
<p>This function does a minimal test in which the data register is read. It only does a read without any kind of test because the hardware has been parameterized such that it may be only an input such that the state of the inputs won't be known.</p>
<p>All other hardware features of the device are not guaranteed to be in the hardware since they are parameterizable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance to be worked on. This parameter must have been previously initialized with <a class="el" href="group__gpio__v4__4.html#ga080482882d1f60cbd84b8e4ea856560c" title="Initialize the XGpio instance provided by the caller based on the given DeviceID.">XGpio_Initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS always. If the GPIO device was not present in the hardware a bus error could be generated. Other indicators of a bus error, such as registers in bridges or buses, may be necessary to determine if this function caused a bus error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#gaed95c58f21d567fca624f9f51cb25e20">XGpio_DiscreteRead()</a>.</p>

</div>
</div>
<a class="anchor" id="gabee6bcad28382ef5ecd336887647c238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_SetDataDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DirectionMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the input/output direction of all discrete signals for the specified GPIO channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html" title="The XGpio driver instance data.">XGpio</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPIO (1 or 2) to operate on. </td></tr>
    <tr><td class="paramname">DirectionMask</td><td>is a bitmask specifying which discretes are input and which are output. Bits set to 0 are output and bits set to 1 are input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert. </dd></dl>

<p>References <a class="el" href="group__gpio__v4__4.html#gafcefd582c52e56dc7c438a72dfa95546">XGPIO_TRI_OFFSET</a>, and <a class="el" href="group__gpio__v4__4.html#ga2cd75ed11bd48af96704b073fa65ef22">XGpio_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xgpio__tapp__example_8c.html#a174af7fb675bce8c6d81a0f89303d048">GpioInputExample()</a>, <a class="el" href="xgpio__tapp__example_8c.html#a38d5dc74a5216dde3e6c9f5ab6ac2402">GpioOutputExample()</a>, and <a class="el" href="xgpio__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gae056125811a82e494e01d590523fdd00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> XGpio_ConfigTable[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        {</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This table contains configuration information for each GPIO device in the system. </p>

<p>Referenced by <a class="el" href="group__gpio__v4__4.html#ga3b208ffd7b19c2176d459223bc63ea14">XGpio_LookupConfig()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
