<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>llfifo: Llfifo_v5_4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">llfifo
   </div>
   <div id="projectbrief">Xilinx Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__llfifo__v5__4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Llfifo_v5_4</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines a run-time instance of an <a class="el" href="struct_x_ll_fifo.html" title="This typedef defines a run-time instance of an XLlFifo device.">XLlFifo</a> device.  <a href="struct_x_ll_fifo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_strm___rx_fifo_streamer.html">XStrm_RxFifoStreamer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines a run-time instance of a receive byte-streamer.  <a href="struct_x_strm___rx_fifo_streamer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines a run-time instance of a transmit byte-streamer.  <a href="struct_x_strm___tx_fifo_streamer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gace8f47c03f1818797c152cb27296df7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gace8f47c03f1818797c152cb27296df7c">XLlFifo_Reset</a>(InstancePtr)</td></tr>
<tr class="memdesc:gace8f47c03f1818797c152cb27296df7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_Reset resets both the Tx and Rx channels and the local link interface the FIFO specified by <em>InstancePtr</em>.  <a href="#gace8f47c03f1818797c152cb27296df7c"></a><br/></td></tr>
<tr class="separator:gace8f47c03f1818797c152cb27296df7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095f3e0f8571dc02959852e38237f23e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga095f3e0f8571dc02959852e38237f23e">XLlFifo_Status</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="el" href="group__llfifo__v5__4.html#ga90a5fafb06870a7ff8043d3a34bf54cc">XLLF_ISR_OFFSET</a>)</td></tr>
<tr class="memdesc:ga095f3e0f8571dc02959852e38237f23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_Status returns a bit mask of the interrupt status register (ISR) for the FIFO specified by <em>InstancePtr</em>.  <a href="#ga095f3e0f8571dc02959852e38237f23e"></a><br/></td></tr>
<tr class="separator:ga095f3e0f8571dc02959852e38237f23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae65ece5c6c9cce1ccdcf9d404fd8f463"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gae65ece5c6c9cce1ccdcf9d404fd8f463">XLlFifo_IntEnable</a>(InstancePtr, Mask)</td></tr>
<tr class="memdesc:gae65ece5c6c9cce1ccdcf9d404fd8f463"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_IntEnable enables the interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>.  <a href="#gae65ece5c6c9cce1ccdcf9d404fd8f463"></a><br/></td></tr>
<tr class="separator:gae65ece5c6c9cce1ccdcf9d404fd8f463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff8f5ef31f09865808da90055e29d42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gabff8f5ef31f09865808da90055e29d42">XLlFifo_IntDisable</a>(InstancePtr, Mask)</td></tr>
<tr class="memdesc:gabff8f5ef31f09865808da90055e29d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_IntDisable disables the interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>.  <a href="#gabff8f5ef31f09865808da90055e29d42"></a><br/></td></tr>
<tr class="separator:gabff8f5ef31f09865808da90055e29d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac356d3e8d55aa6e82753400f0bd026a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gac356d3e8d55aa6e82753400f0bd026a1">XLlFifo_IntPending</a>(InstancePtr)</td></tr>
<tr class="memdesc:gac356d3e8d55aa6e82753400f0bd026a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_IntPending returns a bit mask of the pending interrupts for the FIFO specified by <em>InstancePtr</em>.  <a href="#gac356d3e8d55aa6e82753400f0bd026a1"></a><br/></td></tr>
<tr class="separator:gac356d3e8d55aa6e82753400f0bd026a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac712eea89e9d7fa37d095003c927c61e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gac712eea89e9d7fa37d095003c927c61e">XLlFifo_IntClear</a>(InstancePtr, Mask)</td></tr>
<tr class="memdesc:gac712eea89e9d7fa37d095003c927c61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_IntClear clears pending interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>.  <a href="#gac712eea89e9d7fa37d095003c927c61e"></a><br/></td></tr>
<tr class="separator:gac712eea89e9d7fa37d095003c927c61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3739a78b92f17cead0d831757b3a134"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaf3739a78b92f17cead0d831757b3a134">XLlFifo_RxReset</a>(InstancePtr)</td></tr>
<tr class="memdesc:gaf3739a78b92f17cead0d831757b3a134"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_RxReset resets the receive channel of the FIFO specified by <em>InstancePtr</em>.  <a href="#gaf3739a78b92f17cead0d831757b3a134"></a><br/></td></tr>
<tr class="separator:gaf3739a78b92f17cead0d831757b3a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba876eb888126638848fb2f89a9b4436"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaba876eb888126638848fb2f89a9b4436">XLlFifo_IsRxEmpty</a>(InstancePtr)</td></tr>
<tr class="memdesc:gaba876eb888126638848fb2f89a9b4436"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_IsRxEmpty returns true if the receive channel of the FIFO, specified by <em>InstancePtr</em>, is empty.  <a href="#gaba876eb888126638848fb2f89a9b4436"></a><br/></td></tr>
<tr class="separator:gaba876eb888126638848fb2f89a9b4436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12da547aa1c9a85e2b0b151f438ff9d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga12da547aa1c9a85e2b0b151f438ff9d5">XLlFifo_RxOccupancy</a>(InstancePtr)&#160;&#160;&#160;XStrm_RxOccupancy(&amp;((InstancePtr)-&gt;RxStreamer))</td></tr>
<tr class="memdesc:ga12da547aa1c9a85e2b0b151f438ff9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_RxOccupancy returns the number of 32-bit words available (occupancy) to be read from the receive channel of the FIFO, specified by <em>InstancePtr</em>.  <a href="#ga12da547aa1c9a85e2b0b151f438ff9d5"></a><br/></td></tr>
<tr class="separator:ga12da547aa1c9a85e2b0b151f438ff9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53af32ae6901462cc8d6fb9adc04655e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga53af32ae6901462cc8d6fb9adc04655e">XLlFifo_RxGetLen</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga479d2eb3193ad0a5efc3c3b432a78381">XStrm_RxGetLen</a>(&amp;((InstancePtr)-&gt;RxStreamer))</td></tr>
<tr class="memdesc:ga53af32ae6901462cc8d6fb9adc04655e"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_RxGetLen notifies the hardware that the program is ready to receive the next frame from the receive channel of the FIFO, specified by <em>InstancePtr</em>.  <a href="#ga53af32ae6901462cc8d6fb9adc04655e"></a><br/></td></tr>
<tr class="separator:ga53af32ae6901462cc8d6fb9adc04655e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc3685592b060c0d864850e86be5c03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaadc3685592b060c0d864850e86be5c03">XLlFifo_Read</a>(InstancePtr, BufPtr, Bytes)&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga915d68a9cce0f2464fc7644383cb887a">XStrm_Read</a>(&amp;((InstancePtr)-&gt;RxStreamer), (BufPtr), (Bytes))</td></tr>
<tr class="memdesc:gaadc3685592b060c0d864850e86be5c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_Read reads <em>Bytes</em> bytes from the receive channel of the FIFO referenced by <em>InstancePtr</em> to the block of memory, referenced by <em>BufPtr</em>.  <a href="#gaadc3685592b060c0d864850e86be5c03"></a><br/></td></tr>
<tr class="separator:gaadc3685592b060c0d864850e86be5c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922419fdcd342fa709fb07ec1a9e5577"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga922419fdcd342fa709fb07ec1a9e5577">XLlFifo_TxReset</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga922419fdcd342fa709fb07ec1a9e5577"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_TxReset resets the transmit channel of the FIFO specified by <em>InstancePtr</em>.  <a href="#ga922419fdcd342fa709fb07ec1a9e5577"></a><br/></td></tr>
<tr class="separator:ga922419fdcd342fa709fb07ec1a9e5577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869bc4c1072da021e747a0a179bfe2da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga869bc4c1072da021e747a0a179bfe2da">XLlFifo_IsTxDone</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga869bc4c1072da021e747a0a179bfe2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_IsTxDone returns true if the transmission in the transmit channel of the FIFO, specified by <em>InstancePtr</em>, is complete.  <a href="#ga869bc4c1072da021e747a0a179bfe2da"></a><br/></td></tr>
<tr class="separator:ga869bc4c1072da021e747a0a179bfe2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556524c17aee71ae8407540a5e2cd65f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga556524c17aee71ae8407540a5e2cd65f">XLlFifo_IsRxDone</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga556524c17aee71ae8407540a5e2cd65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_IsRxDone returns true if the reception in the receive channel of the FIFO, specified by <em>InstancePtr</em>, is complete.  <a href="#ga556524c17aee71ae8407540a5e2cd65f"></a><br/></td></tr>
<tr class="separator:ga556524c17aee71ae8407540a5e2cd65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2884c49ae41dc5c5317c2ef6df45a28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaf2884c49ae41dc5c5317c2ef6df45a28">XLlFifo_TxVacancy</a>(InstancePtr)&#160;&#160;&#160;XStrm_TxVacancy(&amp;((InstancePtr)-&gt;TxStreamer))</td></tr>
<tr class="memdesc:gaf2884c49ae41dc5c5317c2ef6df45a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_TxVacancy returns the number of unused 32 bit words available (vacancy) in the send channel of the FIFO specified by <em>InstancePtr</em>.  <a href="#gaf2884c49ae41dc5c5317c2ef6df45a28"></a><br/></td></tr>
<tr class="separator:gaf2884c49ae41dc5c5317c2ef6df45a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd09ed5189e0b85994901102655964f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gacd09ed5189e0b85994901102655964f7">XLlFifo_TxSetLen</a>(InstancePtr, Bytes)&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga1e99fb51e0cfab7d0e8de5e93c27fd9c">XStrm_TxSetLen</a>(&amp;((InstancePtr)-&gt;TxStreamer), (Bytes))</td></tr>
<tr class="memdesc:gacd09ed5189e0b85994901102655964f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_TxSetLen begins a hardware transfer of <em>Bytes</em> bytes out of the transmit channel of the FIFO specified by <em>InstancePtr</em>.  <a href="#gacd09ed5189e0b85994901102655964f7"></a><br/></td></tr>
<tr class="separator:gacd09ed5189e0b85994901102655964f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa93f486abaaf35c7d599a8cd91b295"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga1fa93f486abaaf35c7d599a8cd91b295">XLlFifo_Write</a>(InstancePtr, BufPtr, Bytes)&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga1f43ea833af99162745ceef66849b666">XStrm_Write</a>(&amp;((InstancePtr)-&gt;TxStreamer), (BufPtr), (Bytes))</td></tr>
<tr class="memdesc:ga1fa93f486abaaf35c7d599a8cd91b295"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_Write writes <em>Bytes</em> bytes of the block of memory, referenced by <em>BufPtr</em>, to the transmit channel of the FIFO referenced by <em>InstancePtr</em>.  <a href="#ga1fa93f486abaaf35c7d599a8cd91b295"></a><br/></td></tr>
<tr class="separator:ga1fa93f486abaaf35c7d599a8cd91b295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105828f79f13c07d571db218c5837fae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga105828f79f13c07d571db218c5837fae">XLlFifo_WriteTdr</a>(InstancePtr, Tdest)</td></tr>
<tr class="memdesc:ga105828f79f13c07d571db218c5837fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_WriteTdr writes to the Transmit Destination Register (TDR)  <a href="#ga105828f79f13c07d571db218c5837fae"></a><br/></td></tr>
<tr class="separator:ga105828f79f13c07d571db218c5837fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59307ef23e5b4b71d0d01cef8e06e247"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga59307ef23e5b4b71d0d01cef8e06e247">XLlFifo_ReadRdr</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="el" href="group__llfifo__v5__4.html#gaf0240fc89cce2e27e1943d2e23a5af25">XLLF_RDR_OFFSET</a>)</td></tr>
<tr class="memdesc:ga59307ef23e5b4b71d0d01cef8e06e247"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_ReadTdr returns the contents of the Receive Destination Register(RDR).  <a href="#ga59307ef23e5b4b71d0d01cef8e06e247"></a><br/></td></tr>
<tr class="separator:ga59307ef23e5b4b71d0d01cef8e06e247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7526eab563fa4e0fe8b60474e96afe55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>(BaseAddress, RegOffset)&#160;&#160;&#160;(Xil_In32((BaseAddress) + (RegOffset)))</td></tr>
<tr class="memdesc:ga7526eab563fa4e0fe8b60474e96afe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_ReadReg returns the value of the register at the offet, <em>RegOffset</em>, from the memory mapped base address, <em>BaseAddress</em>.  <a href="#ga7526eab563fa4e0fe8b60474e96afe55"></a><br/></td></tr>
<tr class="separator:ga7526eab563fa4e0fe8b60474e96afe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd283ce73981f7f9eab94f8bb421bc78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>(BaseAddress, RegOffset, Value)&#160;&#160;&#160;((Xil_Out32((BaseAddress) + (RegOffset), (Value))))</td></tr>
<tr class="memdesc:gacd283ce73981f7f9eab94f8bb421bc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_WriteReg writes the value, <em>Value</em>, to the register at the offet, <em>RegOffset</em>, from the memory mapped base address, <em>BaseAddress</em>.  <a href="#gacd283ce73981f7f9eab94f8bb421bc78"></a><br/></td></tr>
<tr class="separator:gacd283ce73981f7f9eab94f8bb421bc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga89057d90d6eacdbe8adc766f53f60ed7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_x_ll_fifo.html">XLlFifo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga89057d90d6eacdbe8adc766f53f60ed7">XLlFifo</a></td></tr>
<tr class="memdesc:ga89057d90d6eacdbe8adc766f53f60ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines a run-time instance of an <a class="el" href="struct_x_ll_fifo.html" title="This typedef defines a run-time instance of an XLlFifo device.">XLlFifo</a> device.  <a href="#ga89057d90d6eacdbe8adc766f53f60ed7"></a><br/></td></tr>
<tr class="separator:ga89057d90d6eacdbe8adc766f53f60ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f27ac6f38ad77d7b92014a52eb5c16b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_x_strm___rx_fifo_streamer.html">XStrm_RxFifoStreamer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga4f27ac6f38ad77d7b92014a52eb5c16b">XStrm_RxFifoStreamer</a></td></tr>
<tr class="memdesc:ga4f27ac6f38ad77d7b92014a52eb5c16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines a run-time instance of a receive byte-streamer.  <a href="#ga4f27ac6f38ad77d7b92014a52eb5c16b"></a><br/></td></tr>
<tr class="separator:ga4f27ac6f38ad77d7b92014a52eb5c16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1351f115d97cbce95da390d0ea4033"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga3d1351f115d97cbce95da390d0ea4033">XStrm_TxFifoStreamer</a></td></tr>
<tr class="memdesc:ga3d1351f115d97cbce95da390d0ea4033"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines a run-time instance of a transmit byte-streamer.  <a href="#ga3d1351f115d97cbce95da390d0ea4033"></a><br/></td></tr>
<tr class="separator:ga3d1351f115d97cbce95da390d0ea4033"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaacc66a5dc69ac5a882fa7f3d161efbcb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaacc66a5dc69ac5a882fa7f3d161efbcb">xdbg_stmnt</a> (u32 _xllfifo_rr_value;)</td></tr>
<tr class="memdesc:gaacc66a5dc69ac5a882fa7f3d161efbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_iRxOccupancy returns the number of 32-bit words available (occupancy) to be read from the receive channel of the FIFO, specified by <em>InstancePtr</em>.  <a href="#gaacc66a5dc69ac5a882fa7f3d161efbcb"></a><br/></td></tr>
<tr class="separator:gaacc66a5dc69ac5a882fa7f3d161efbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad292ddf2a2c9dde261b93da802c8080"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaad292ddf2a2c9dde261b93da802c8080">XLlFifo_iRxGetLen</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaad292ddf2a2c9dde261b93da802c8080"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_iRxGetLen notifies the hardware that the program is ready to receive the next frame from the receive channel of the FIFO specified by <em>InstancePtr</em>.  <a href="#gaad292ddf2a2c9dde261b93da802c8080"></a><br/></td></tr>
<tr class="separator:gaad292ddf2a2c9dde261b93da802c8080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18bc620d388cbca83d63cc1c6ef33225"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga18bc620d388cbca83d63cc1c6ef33225">XLlFifo_iRead_Aligned</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, void *BufPtr, unsigned WordCount)</td></tr>
<tr class="memdesc:ga18bc620d388cbca83d63cc1c6ef33225"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_iRead_Aligned reads, <em>WordCount</em>, words from the FIFO referenced by <em>InstancePtr</em> to the block of memory, referenced by <em>BufPtr</em>.  <a href="#ga18bc620d388cbca83d63cc1c6ef33225"></a><br/></td></tr>
<tr class="separator:ga18bc620d388cbca83d63cc1c6ef33225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02405b23499d780e7bc1dfe371281a6"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gac02405b23499d780e7bc1dfe371281a6">XLlFifo_iTxVacancy</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr)</td></tr>
<tr class="memdesc:gac02405b23499d780e7bc1dfe371281a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_iTxVacancy returns the number of unused 32 bit words available (vacancy) in the send channel of the FIFO, specified by <em>InstancePtr</em>.  <a href="#gac02405b23499d780e7bc1dfe371281a6"></a><br/></td></tr>
<tr class="separator:gac02405b23499d780e7bc1dfe371281a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49ecc1529434fd932d8a65d63a1a04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaa49ecc1529434fd932d8a65d63a1a04d">XLlFifo_iTxSetLen</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, u32 Bytes)</td></tr>
<tr class="memdesc:gaa49ecc1529434fd932d8a65d63a1a04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_iTxSetLen begins a hardware transfer of data out of the transmit channel of the FIFO, specified by <em>InstancePtr</em>.  <a href="#gaa49ecc1529434fd932d8a65d63a1a04d"></a><br/></td></tr>
<tr class="separator:gaa49ecc1529434fd932d8a65d63a1a04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be5556d593980195e43a31ffb37e0fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga9be5556d593980195e43a31ffb37e0fe">XLlFifo_iWrite_Aligned</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, void *BufPtr, unsigned WordCount)</td></tr>
<tr class="memdesc:ga9be5556d593980195e43a31ffb37e0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_iWrite_Aligned writes, <em>WordCount</em>, words to the FIFO referenced by <em>InstancePtr</em> from the block of memory, referenced by <em>BufPtr</em>.  <a href="#ga9be5556d593980195e43a31ffb37e0fe"></a><br/></td></tr>
<tr class="separator:ga9be5556d593980195e43a31ffb37e0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874c22807476dc0ffec670c38f452443"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, XLlFifo_Config *Config, UINTPTR EffectiveAddress)</td></tr>
<tr class="memdesc:ga874c22807476dc0ffec670c38f452443"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_CfgInitialize initializes an XPS_ll_Fifo device along with the <em>InstancePtr</em> that references it.  <a href="#ga874c22807476dc0ffec670c38f452443"></a><br/></td></tr>
<tr class="separator:ga874c22807476dc0ffec670c38f452443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3ae31c8c24f46139fbd709027329ec"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaed3ae31c8c24f46139fbd709027329ec">XLlFifo_RxGetWord</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaed3ae31c8c24f46139fbd709027329ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_RxGetWord reads one 32 bit word from the FIFO specified by <em>InstancePtr</em>.  <a href="#gaed3ae31c8c24f46139fbd709027329ec"></a><br/></td></tr>
<tr class="separator:gaed3ae31c8c24f46139fbd709027329ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29654d755dce84b861022179c99ca7a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga29654d755dce84b861022179c99ca7a3">XLlFifo_TxPutWord</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, u32 Word)</td></tr>
<tr class="memdesc:ga29654d755dce84b861022179c99ca7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_TxPutWord writes the 32 bit word, <em>Word</em> to the FIFO specified by <em>InstancePtr</em>.  <a href="#ga29654d755dce84b861022179c99ca7a3"></a><br/></td></tr>
<tr class="separator:ga29654d755dce84b861022179c99ca7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3debde0a34325b3f314d15fe6f43a7ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, UINTPTR BaseAddress)</td></tr>
<tr class="memdesc:ga3debde0a34325b3f314d15fe6f43a7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">XLlFifo_Initialize initializes an XPS_ll_Fifo device along with the <em>InstancePtr</em> that references it.  <a href="#ga3debde0a34325b3f314d15fe6f43a7ee"></a><br/></td></tr>
<tr class="separator:ga3debde0a34325b3f314d15fe6f43a7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga549da0fb83b3bb11ea6401b8001f9c4e"><td class="memItemLeft" align="right" valign="top">XLlFifo_Config *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga549da0fb83b3bb11ea6401b8001f9c4e">XLlFfio_LookupConfig</a> (u32 DeviceId)</td></tr>
<tr class="memdesc:ga549da0fb83b3bb11ea6401b8001f9c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the hardware configuration for a device instance.  <a href="#ga549da0fb83b3bb11ea6401b8001f9c4e"></a><br/></td></tr>
<tr class="separator:ga549da0fb83b3bb11ea6401b8001f9c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a67c77f811a505b658e06642eb9c964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga8a67c77f811a505b658e06642eb9c964">XStrm_TxInitialize</a> (<a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a> *InstancePtr, unsigned FifoWidth, void *FifoInstance, XStrm_XferFnType WriteFn, XStrm_SetLenFnType SetLenFn, XStrm_GetVacancyFnType GetVacancyFn)</td></tr>
<tr class="memdesc:ga8a67c77f811a505b658e06642eb9c964"><td class="mdescLeft">&#160;</td><td class="mdescRight">XStrm_TxInitialize initializes the <a class="el" href="struct_x_strm___tx_fifo_streamer.html" title="This typedef defines a run-time instance of a transmit byte-streamer.">XStrm_TxFifoStreamer</a> object referenced by <em>InstancePtr</em>.  <a href="#ga8a67c77f811a505b658e06642eb9c964"></a><br/></td></tr>
<tr class="separator:ga8a67c77f811a505b658e06642eb9c964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga479d2eb3193ad0a5efc3c3b432a78381"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga479d2eb3193ad0a5efc3c3b432a78381">XStrm_RxGetLen</a> (<a class="el" href="struct_x_strm___rx_fifo_streamer.html">XStrm_RxFifoStreamer</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga479d2eb3193ad0a5efc3c3b432a78381"><td class="mdescLeft">&#160;</td><td class="mdescRight">XStrm_RxGetLen notifies the hardware that the program is ready to receive the next frame from the receive channel of the FIFO, specified by <em>InstancePtr</em>.  <a href="#ga479d2eb3193ad0a5efc3c3b432a78381"></a><br/></td></tr>
<tr class="separator:ga479d2eb3193ad0a5efc3c3b432a78381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga915d68a9cce0f2464fc7644383cb887a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga915d68a9cce0f2464fc7644383cb887a">XStrm_Read</a> (<a class="el" href="struct_x_strm___rx_fifo_streamer.html">XStrm_RxFifoStreamer</a> *InstancePtr, void *BufPtr, unsigned Bytes)</td></tr>
<tr class="memdesc:ga915d68a9cce0f2464fc7644383cb887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">XStrm_Read reads <em>Bytes</em> bytes from the FIFO specified by <em>InstancePtr</em> to the block of memory, referenced by <em>BufPtr</em>.  <a href="#ga915d68a9cce0f2464fc7644383cb887a"></a><br/></td></tr>
<tr class="separator:ga915d68a9cce0f2464fc7644383cb887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e99fb51e0cfab7d0e8de5e93c27fd9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga1e99fb51e0cfab7d0e8de5e93c27fd9c">XStrm_TxSetLen</a> (<a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a> *InstancePtr, u32 Bytes)</td></tr>
<tr class="memdesc:ga1e99fb51e0cfab7d0e8de5e93c27fd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">XStrm_TxSetLen flushes to the FIFO, specified by <em>InstancePtr</em>, any bytes remaining in internal buffers and begins a hardware transfer of data out of the transmit channel of the FIFO.  <a href="#ga1e99fb51e0cfab7d0e8de5e93c27fd9c"></a><br/></td></tr>
<tr class="separator:ga1e99fb51e0cfab7d0e8de5e93c27fd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f43ea833af99162745ceef66849b666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga1f43ea833af99162745ceef66849b666">XStrm_Write</a> (<a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a> *InstancePtr, void *BufPtr, unsigned Bytes)</td></tr>
<tr class="memdesc:ga1f43ea833af99162745ceef66849b666"><td class="mdescLeft">&#160;</td><td class="mdescRight">XStrm_Write writes <em>Bytes</em> bytes of the block of memory, referenced by <em>BufPtr</em>, to the transmit channel of the FIFO referenced by <em>InstancePtr</em>.  <a href="#ga1f43ea833af99162745ceef66849b666"></a><br/></td></tr>
<tr class="separator:ga1f43ea833af99162745ceef66849b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Registers</h2></td></tr>
<tr class="memitem:ga90a5fafb06870a7ff8043d3a34bf54cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga90a5fafb06870a7ff8043d3a34bf54cc">XLLF_ISR_OFFSET</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="memdesc:ga90a5fafb06870a7ff8043d3a34bf54cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Status.  <a href="#ga90a5fafb06870a7ff8043d3a34bf54cc"></a><br/></td></tr>
<tr class="separator:ga90a5fafb06870a7ff8043d3a34bf54cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac34e090e52a9ef5cdf4337cae6ca717c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gac34e090e52a9ef5cdf4337cae6ca717c">XLLF_IER_OFFSET</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:gac34e090e52a9ef5cdf4337cae6ca717c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Enable.  <a href="#gac34e090e52a9ef5cdf4337cae6ca717c"></a><br/></td></tr>
<tr class="separator:gac34e090e52a9ef5cdf4337cae6ca717c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55be9e9452783cde92cd70a33e31e56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaa55be9e9452783cde92cd70a33e31e56">XLLF_TDFR_OFFSET</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:gaa55be9e9452783cde92cd70a33e31e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Reset.  <a href="#gaa55be9e9452783cde92cd70a33e31e56"></a><br/></td></tr>
<tr class="separator:gaa55be9e9452783cde92cd70a33e31e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab77ae26c2fe9b0ac15ebdbf0c6c30960"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gab77ae26c2fe9b0ac15ebdbf0c6c30960">XLLF_TDFV_OFFSET</a>&#160;&#160;&#160;0x0000000c</td></tr>
<tr class="memdesc:gab77ae26c2fe9b0ac15ebdbf0c6c30960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Vacancy.  <a href="#gab77ae26c2fe9b0ac15ebdbf0c6c30960"></a><br/></td></tr>
<tr class="separator:gab77ae26c2fe9b0ac15ebdbf0c6c30960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca8c86badc0df67426442f9bb6a5195"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaeca8c86badc0df67426442f9bb6a5195">XLLF_TDFD_OFFSET</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:gaeca8c86badc0df67426442f9bb6a5195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Data.  <a href="#gaeca8c86badc0df67426442f9bb6a5195"></a><br/></td></tr>
<tr class="separator:gaeca8c86badc0df67426442f9bb6a5195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a72ef43b9e2ca7e28a9e939012f1044"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga7a72ef43b9e2ca7e28a9e939012f1044">XLLF_AXI4_TDFD_OFFSET</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="memdesc:ga7a72ef43b9e2ca7e28a9e939012f1044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axi4 Transmit Data.  <a href="#ga7a72ef43b9e2ca7e28a9e939012f1044"></a><br/></td></tr>
<tr class="separator:ga7a72ef43b9e2ca7e28a9e939012f1044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14e6d7e1116f9a43c0adfbe93422fa7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gac14e6d7e1116f9a43c0adfbe93422fa7">XLLF_TLF_OFFSET</a>&#160;&#160;&#160;0x00000014</td></tr>
<tr class="memdesc:gac14e6d7e1116f9a43c0adfbe93422fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Length.  <a href="#gac14e6d7e1116f9a43c0adfbe93422fa7"></a><br/></td></tr>
<tr class="separator:gac14e6d7e1116f9a43c0adfbe93422fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1533e466df30729597a1b44ed1059ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gae1533e466df30729597a1b44ed1059ed">XLLF_RDFR_OFFSET</a>&#160;&#160;&#160;0x00000018</td></tr>
<tr class="memdesc:gae1533e466df30729597a1b44ed1059ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Reset.  <a href="#gae1533e466df30729597a1b44ed1059ed"></a><br/></td></tr>
<tr class="separator:gae1533e466df30729597a1b44ed1059ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c4bbf51bc4b0410b61ef3933776a63c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga9c4bbf51bc4b0410b61ef3933776a63c">XLLF_RDFO_OFFSET</a>&#160;&#160;&#160;0x0000001c</td></tr>
<tr class="memdesc:ga9c4bbf51bc4b0410b61ef3933776a63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Occupancy.  <a href="#ga9c4bbf51bc4b0410b61ef3933776a63c"></a><br/></td></tr>
<tr class="separator:ga9c4bbf51bc4b0410b61ef3933776a63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e049a21e43548bf03161b4a4394440"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga93e049a21e43548bf03161b4a4394440">XLLF_RDFD_OFFSET</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:ga93e049a21e43548bf03161b4a4394440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Data.  <a href="#ga93e049a21e43548bf03161b4a4394440"></a><br/></td></tr>
<tr class="separator:ga93e049a21e43548bf03161b4a4394440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256c51f97ca57cc89c9b51449f3601e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga256c51f97ca57cc89c9b51449f3601e1">XLLF_AXI4_RDFD_OFFSET</a>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="memdesc:ga256c51f97ca57cc89c9b51449f3601e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axi4 Receive Data.  <a href="#ga256c51f97ca57cc89c9b51449f3601e1"></a><br/></td></tr>
<tr class="separator:ga256c51f97ca57cc89c9b51449f3601e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267285e6015808291ef6671038cba888"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga267285e6015808291ef6671038cba888">XLLF_RLF_OFFSET</a>&#160;&#160;&#160;0x00000024</td></tr>
<tr class="memdesc:ga267285e6015808291ef6671038cba888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Length.  <a href="#ga267285e6015808291ef6671038cba888"></a><br/></td></tr>
<tr class="separator:ga267285e6015808291ef6671038cba888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5331d2736e9b1b516b4262d8e3f11690"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga5331d2736e9b1b516b4262d8e3f11690">XLLF_LLR_OFFSET</a>&#160;&#160;&#160;0x00000028</td></tr>
<tr class="memdesc:ga5331d2736e9b1b516b4262d8e3f11690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Link Reset.  <a href="#ga5331d2736e9b1b516b4262d8e3f11690"></a><br/></td></tr>
<tr class="separator:ga5331d2736e9b1b516b4262d8e3f11690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c691ac1237fb77b8e356a7d2b0b8b54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga5c691ac1237fb77b8e356a7d2b0b8b54">XLLF_TDR_OFFSET</a>&#160;&#160;&#160;0x0000002C</td></tr>
<tr class="memdesc:ga5c691ac1237fb77b8e356a7d2b0b8b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Destination.  <a href="#ga5c691ac1237fb77b8e356a7d2b0b8b54"></a><br/></td></tr>
<tr class="separator:ga5c691ac1237fb77b8e356a7d2b0b8b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0240fc89cce2e27e1943d2e23a5af25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaf0240fc89cce2e27e1943d2e23a5af25">XLLF_RDR_OFFSET</a>&#160;&#160;&#160;0x00000030</td></tr>
<tr class="memdesc:gaf0240fc89cce2e27e1943d2e23a5af25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Destination.  <a href="#gaf0240fc89cce2e27e1943d2e23a5af25"></a><br/></td></tr>
<tr class="separator:gaf0240fc89cce2e27e1943d2e23a5af25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interrupt bits</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd321abe0f7c2fd3c46c4c5533272e1f7"></a>These bits are associated with the XLLF_IER_OFFSET and XLLF_ISR_OFFSET registers. </p>
</td></tr>
<tr class="memitem:gab34174dc4dc0d42aa610f51bcf2cb492"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gab34174dc4dc0d42aa610f51bcf2cb492">XLLF_INT_RPURE_MASK</a>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:gab34174dc4dc0d42aa610f51bcf2cb492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive under-read.  <a href="#gab34174dc4dc0d42aa610f51bcf2cb492"></a><br/></td></tr>
<tr class="separator:gab34174dc4dc0d42aa610f51bcf2cb492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ccef60e66cffea379deead95c3084e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga98ccef60e66cffea379deead95c3084e">XLLF_INT_RPORE_MASK</a>&#160;&#160;&#160;0x40000000</td></tr>
<tr class="memdesc:ga98ccef60e66cffea379deead95c3084e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive over-read.  <a href="#ga98ccef60e66cffea379deead95c3084e"></a><br/></td></tr>
<tr class="separator:ga98ccef60e66cffea379deead95c3084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c30251a44596328ec255b652e20f15a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga2c30251a44596328ec255b652e20f15a">XLLF_INT_RPUE_MASK</a>&#160;&#160;&#160;0x20000000</td></tr>
<tr class="memdesc:ga2c30251a44596328ec255b652e20f15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive underrun (empty)  <a href="#ga2c30251a44596328ec255b652e20f15a"></a><br/></td></tr>
<tr class="separator:ga2c30251a44596328ec255b652e20f15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44becb1eedec6a7d02293d1f088d30c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga44becb1eedec6a7d02293d1f088d30c7">XLLF_INT_TPOE_MASK</a>&#160;&#160;&#160;0x10000000</td></tr>
<tr class="memdesc:ga44becb1eedec6a7d02293d1f088d30c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit overrun.  <a href="#ga44becb1eedec6a7d02293d1f088d30c7"></a><br/></td></tr>
<tr class="separator:ga44becb1eedec6a7d02293d1f088d30c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca5de4c7fc02bcad56912a2919319ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gabca5de4c7fc02bcad56912a2919319ae">XLLF_INT_TC_MASK</a>&#160;&#160;&#160;0x08000000</td></tr>
<tr class="memdesc:gabca5de4c7fc02bcad56912a2919319ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit complete.  <a href="#gabca5de4c7fc02bcad56912a2919319ae"></a><br/></td></tr>
<tr class="separator:gabca5de4c7fc02bcad56912a2919319ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838f0b2d56bffea01160c141b0c1de67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga838f0b2d56bffea01160c141b0c1de67">XLLF_INT_RC_MASK</a>&#160;&#160;&#160;0x04000000</td></tr>
<tr class="memdesc:ga838f0b2d56bffea01160c141b0c1de67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive complete.  <a href="#ga838f0b2d56bffea01160c141b0c1de67"></a><br/></td></tr>
<tr class="separator:ga838f0b2d56bffea01160c141b0c1de67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c2faac5f93834b0a6f7b9da529c5ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga77c2faac5f93834b0a6f7b9da529c5ad">XLLF_INT_TSE_MASK</a>&#160;&#160;&#160;0x02000000</td></tr>
<tr class="memdesc:ga77c2faac5f93834b0a6f7b9da529c5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit length mismatch.  <a href="#ga77c2faac5f93834b0a6f7b9da529c5ad"></a><br/></td></tr>
<tr class="separator:ga77c2faac5f93834b0a6f7b9da529c5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08cda800d1468726a65844d40100b9cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga08cda800d1468726a65844d40100b9cb">XLLF_INT_TRC_MASK</a>&#160;&#160;&#160;0x01000000</td></tr>
<tr class="memdesc:ga08cda800d1468726a65844d40100b9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit reset complete.  <a href="#ga08cda800d1468726a65844d40100b9cb"></a><br/></td></tr>
<tr class="separator:ga08cda800d1468726a65844d40100b9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9d308d7b3224c47b619467c2384754"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaaa9d308d7b3224c47b619467c2384754">XLLF_INT_RRC_MASK</a>&#160;&#160;&#160;0x00800000</td></tr>
<tr class="memdesc:gaaa9d308d7b3224c47b619467c2384754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive reset complete.  <a href="#gaaa9d308d7b3224c47b619467c2384754"></a><br/></td></tr>
<tr class="separator:gaaa9d308d7b3224c47b619467c2384754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b6dae752508cc137eb13b88561f88a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga8b6dae752508cc137eb13b88561f88a5">XLLF_INT_TFPF_MASK</a>&#160;&#160;&#160;0x00400000</td></tr>
<tr class="memdesc:ga8b6dae752508cc137eb13b88561f88a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tx FIFO Programmable Full, AXI FIFO MM2S Only.  <a href="#ga8b6dae752508cc137eb13b88561f88a5"></a><br/></td></tr>
<tr class="separator:ga8b6dae752508cc137eb13b88561f88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e06f24d66d729c445ebb72dde652aad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga7e06f24d66d729c445ebb72dde652aad">XLLF_INT_TFPE_MASK</a>&#160;&#160;&#160;0x00200000</td></tr>
<tr class="memdesc:ga7e06f24d66d729c445ebb72dde652aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tx FIFO Programmable Empty AXI FIFO MM2S Only.  <a href="#ga7e06f24d66d729c445ebb72dde652aad"></a><br/></td></tr>
<tr class="separator:ga7e06f24d66d729c445ebb72dde652aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb37ede3ec3b10522a8bf3c597747331"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gacb37ede3ec3b10522a8bf3c597747331">XLLF_INT_RFPF_MASK</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="memdesc:gacb37ede3ec3b10522a8bf3c597747331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rx FIFO Programmable Full AXI FIFO MM2S Only.  <a href="#gacb37ede3ec3b10522a8bf3c597747331"></a><br/></td></tr>
<tr class="separator:gacb37ede3ec3b10522a8bf3c597747331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeef1be2532662b2b6aa865057e30b48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gabeef1be2532662b2b6aa865057e30b48">XLLF_INT_RFPE_MASK</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="memdesc:gabeef1be2532662b2b6aa865057e30b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rx FIFO Programmable Empty AXI FIFO MM2S Only.  <a href="#gabeef1be2532662b2b6aa865057e30b48"></a><br/></td></tr>
<tr class="separator:gabeef1be2532662b2b6aa865057e30b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3bfcad24428233d9e2a8a861e2d9eed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gae3bfcad24428233d9e2a8a861e2d9eed">XLLF_INT_ALL_MASK</a>&#160;&#160;&#160;0xfff80000</td></tr>
<tr class="memdesc:gae3bfcad24428233d9e2a8a861e2d9eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the ints.  <a href="#gae3bfcad24428233d9e2a8a861e2d9eed"></a><br/></td></tr>
<tr class="separator:gae3bfcad24428233d9e2a8a861e2d9eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d0964de7c5721e6856a9d7ccb22ebd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga97d0964de7c5721e6856a9d7ccb22ebd">XLLF_INT_ERROR_MASK</a>&#160;&#160;&#160;0xf2000000</td></tr>
<tr class="memdesc:ga97d0964de7c5721e6856a9d7ccb22ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error status ints.  <a href="#ga97d0964de7c5721e6856a9d7ccb22ebd"></a><br/></td></tr>
<tr class="separator:ga97d0964de7c5721e6856a9d7ccb22ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6b02f445993c00ec77914e3696fd9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga2e6b02f445993c00ec77914e3696fd9a">XLLF_INT_RXERROR_MASK</a>&#160;&#160;&#160;0xe0000000</td></tr>
<tr class="memdesc:ga2e6b02f445993c00ec77914e3696fd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Error status ints.  <a href="#ga2e6b02f445993c00ec77914e3696fd9a"></a><br/></td></tr>
<tr class="separator:ga2e6b02f445993c00ec77914e3696fd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga417b7cfe9d44e8154311f8d7c5cef577"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga417b7cfe9d44e8154311f8d7c5cef577">XLLF_INT_TXERROR_MASK</a>&#160;&#160;&#160;0x12000000</td></tr>
<tr class="memdesc:ga417b7cfe9d44e8154311f8d7c5cef577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Error status ints.  <a href="#ga417b7cfe9d44e8154311f8d7c5cef577"></a><br/></td></tr>
<tr class="separator:ga417b7cfe9d44e8154311f8d7c5cef577"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Reset register values</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbfafd7b8ae36584b38f867e933006985"></a>These bits are associated with the XLLF_TDFR_OFFSET and XLLF_RDFR_OFFSET reset registers. </p>
</td></tr>
<tr class="memitem:ga11c4da53ae9b166832186f9a817fba6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#ga11c4da53ae9b166832186f9a817fba6d">XLLF_RDFR_RESET_MASK</a>&#160;&#160;&#160;0x000000a5</td></tr>
<tr class="memdesc:ga11c4da53ae9b166832186f9a817fba6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">receive reset value  <a href="#ga11c4da53ae9b166832186f9a817fba6d"></a><br/></td></tr>
<tr class="separator:ga11c4da53ae9b166832186f9a817fba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b4bcf41280c1fb01684b6706603420"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gaf7b4bcf41280c1fb01684b6706603420">XLLF_TDFR_RESET_MASK</a>&#160;&#160;&#160;0x000000a5</td></tr>
<tr class="memdesc:gaf7b4bcf41280c1fb01684b6706603420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit reset value.  <a href="#gaf7b4bcf41280c1fb01684b6706603420"></a><br/></td></tr>
<tr class="separator:gaf7b4bcf41280c1fb01684b6706603420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b59856939038963e68acf4e2e2c47c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__llfifo__v5__4.html#gad8b59856939038963e68acf4e2e2c47c">XLLF_LLR_RESET_MASK</a>&#160;&#160;&#160;0x000000a5</td></tr>
<tr class="memdesc:gad8b59856939038963e68acf4e2e2c47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local Link reset value.  <a href="#gad8b59856939038963e68acf4e2e2c47c"></a><br/></td></tr>
<tr class="separator:gad8b59856939038963e68acf4e2e2c47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga256c51f97ca57cc89c9b51449f3601e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_AXI4_RDFD_OFFSET&#160;&#160;&#160;0x00001000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Axi4 Receive Data. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#gaed3ae31c8c24f46139fbd709027329ec">XLlFifo_RxGetWord()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a72ef43b9e2ca7e28a9e939012f1044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_AXI4_TDFD_OFFSET&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Axi4 Transmit Data. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga29654d755dce84b861022179c99ca7a3">XLlFifo_TxPutWord()</a>.</p>

</div>
</div>
<a class="anchor" id="gac34e090e52a9ef5cdf4337cae6ca717c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_IER_OFFSET&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt Enable. </p>

</div>
</div>
<a class="anchor" id="gae3bfcad24428233d9e2a8a861e2d9eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_ALL_MASK&#160;&#160;&#160;0xfff80000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All the ints. </p>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a8d6febbfb5e669f63287fc75c282d1f6">XLlFifoInterruptExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga97d0964de7c5721e6856a9d7ccb22ebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_ERROR_MASK&#160;&#160;&#160;0xf2000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error status ints. </p>

</div>
</div>
<a class="anchor" id="ga838f0b2d56bffea01160c141b0c1de67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_RC_MASK&#160;&#160;&#160;0x04000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive complete. </p>

</div>
</div>
<a class="anchor" id="gabeef1be2532662b2b6aa865057e30b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_RFPE_MASK&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rx FIFO Programmable Empty AXI FIFO MM2S Only. </p>

</div>
</div>
<a class="anchor" id="gacb37ede3ec3b10522a8bf3c597747331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_RFPF_MASK&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rx FIFO Programmable Full AXI FIFO MM2S Only. </p>

</div>
</div>
<a class="anchor" id="ga98ccef60e66cffea379deead95c3084e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_RPORE_MASK&#160;&#160;&#160;0x40000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive over-read. </p>

</div>
</div>
<a class="anchor" id="ga2c30251a44596328ec255b652e20f15a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_RPUE_MASK&#160;&#160;&#160;0x20000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive underrun (empty) </p>

</div>
</div>
<a class="anchor" id="gab34174dc4dc0d42aa610f51bcf2cb492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_RPURE_MASK&#160;&#160;&#160;0x80000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive under-read. </p>

</div>
</div>
<a class="anchor" id="gaaa9d308d7b3224c47b619467c2384754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_RRC_MASK&#160;&#160;&#160;0x00800000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive reset complete. </p>

</div>
</div>
<a class="anchor" id="ga2e6b02f445993c00ec77914e3696fd9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_RXERROR_MASK&#160;&#160;&#160;0xe0000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Error status ints. </p>

</div>
</div>
<a class="anchor" id="gabca5de4c7fc02bcad56912a2919319ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_TC_MASK&#160;&#160;&#160;0x08000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit complete. </p>

</div>
</div>
<a class="anchor" id="ga7e06f24d66d729c445ebb72dde652aad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_TFPE_MASK&#160;&#160;&#160;0x00200000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tx FIFO Programmable Empty AXI FIFO MM2S Only. </p>

</div>
</div>
<a class="anchor" id="ga8b6dae752508cc137eb13b88561f88a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_TFPF_MASK&#160;&#160;&#160;0x00400000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tx FIFO Programmable Full, AXI FIFO MM2S Only. </p>

</div>
</div>
<a class="anchor" id="ga44becb1eedec6a7d02293d1f088d30c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_TPOE_MASK&#160;&#160;&#160;0x10000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit overrun. </p>

</div>
</div>
<a class="anchor" id="ga08cda800d1468726a65844d40100b9cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_TRC_MASK&#160;&#160;&#160;0x01000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit reset complete. </p>

</div>
</div>
<a class="anchor" id="ga77c2faac5f93834b0a6f7b9da529c5ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_TSE_MASK&#160;&#160;&#160;0x02000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit length mismatch. </p>

</div>
</div>
<a class="anchor" id="ga417b7cfe9d44e8154311f8d7c5cef577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_INT_TXERROR_MASK&#160;&#160;&#160;0x12000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Error status ints. </p>

</div>
</div>
<a class="anchor" id="ga90a5fafb06870a7ff8043d3a34bf54cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_ISR_OFFSET&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt Status. </p>

</div>
</div>
<a class="anchor" id="ga5331d2736e9b1b516b4262d8e3f11690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_LLR_OFFSET&#160;&#160;&#160;0x00000028</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local Link Reset. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gad8b59856939038963e68acf4e2e2c47c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_LLR_RESET_MASK&#160;&#160;&#160;0x000000a5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local Link reset value. </p>

</div>
</div>
<a class="anchor" id="ga93e049a21e43548bf03161b4a4394440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_RDFD_OFFSET&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Data. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#gaed3ae31c8c24f46139fbd709027329ec">XLlFifo_RxGetWord()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c4bbf51bc4b0410b61ef3933776a63c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_RDFO_OFFSET&#160;&#160;&#160;0x0000001c</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Occupancy. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#gaacc66a5dc69ac5a882fa7f3d161efbcb">xdbg_stmnt()</a>.</p>

</div>
</div>
<a class="anchor" id="gae1533e466df30729597a1b44ed1059ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_RDFR_OFFSET&#160;&#160;&#160;0x00000018</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Reset. </p>

</div>
</div>
<a class="anchor" id="ga11c4da53ae9b166832186f9a817fba6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_RDFR_RESET_MASK&#160;&#160;&#160;0x000000a5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>receive reset value </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0240fc89cce2e27e1943d2e23a5af25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_RDR_OFFSET&#160;&#160;&#160;0x00000030</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Destination. </p>

</div>
</div>
<a class="anchor" id="ga267285e6015808291ef6671038cba888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_RLF_OFFSET&#160;&#160;&#160;0x00000024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Length. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#gaad292ddf2a2c9dde261b93da802c8080">XLlFifo_iRxGetLen()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeca8c86badc0df67426442f9bb6a5195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_TDFD_OFFSET&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Data. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga29654d755dce84b861022179c99ca7a3">XLlFifo_TxPutWord()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa55be9e9452783cde92cd70a33e31e56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_TDFR_OFFSET&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Reset. </p>

</div>
</div>
<a class="anchor" id="gaf7b4bcf41280c1fb01684b6706603420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_TDFR_RESET_MASK&#160;&#160;&#160;0x000000a5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit reset value. </p>

</div>
</div>
<a class="anchor" id="gab77ae26c2fe9b0ac15ebdbf0c6c30960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_TDFV_OFFSET&#160;&#160;&#160;0x0000000c</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Vacancy. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#gac02405b23499d780e7bc1dfe371281a6">XLlFifo_iTxVacancy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c691ac1237fb77b8e356a7d2b0b8b54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_TDR_OFFSET&#160;&#160;&#160;0x0000002C</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Destination. </p>

</div>
</div>
<a class="anchor" id="gac14e6d7e1116f9a43c0adfbe93422fa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLF_TLF_OFFSET&#160;&#160;&#160;0x00000014</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Length. </p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#gaa49ecc1529434fd932d8a65d63a1a04d">XLlFifo_iTxSetLen()</a>.</p>

</div>
</div>
<a class="anchor" id="gac712eea89e9d7fa37d095003c927c61e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IntClear</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78" title="XLlFifo_WriteReg writes the value, Value, to the register at the offet, RegOffset, from the memory mapped base address, BaseAddress.">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#ga90a5fafb06870a7ff8043d3a34bf54cc" title="Interrupt Status.">XLLF_ISR_OFFSET</a>, \</div>
<div class="line">                        ((Mask) &amp; <a class="code" href="group__llfifo__v5__4.html#gae3bfcad24428233d9e2a8a861e2d9eed" title="All the ints.">XLLF_INT_ALL_MASK</a>))</div>
</div><!-- fragment -->
<p>XLlFifo_IntClear clears pending interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>. </p>
<p>The corresponding pending interrupt for each bit set to 1 in <em>Mask</em>, will be cleared. In other words, XLlFifo_IntClear uses the "set a bit to clear it" scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">Mask</td><td>contains a bit mask of the pending interrupts to clear. The mask can be formed using a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__llfifo__v5__4.html#gac712eea89e9d7fa37d095003c927c61e" title="XLlFifo_IntClear clears pending interrupts specified in Mask for the FIFO specified by InstancePtr...">XLlFifo_IntClear(XLlFifo *InstancePtr, u32 Mask)</a> </dd></dl>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a8d6febbfb5e669f63287fc75c282d1f6">XLlFifoInterruptExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gabff8f5ef31f09865808da90055e29d42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IntDisable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">        u32 Reg = <a class="code" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55" title="XLlFifo_ReadReg returns the value of the register at the offet, RegOffset, from the memory mapped bas...">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, \</div>
<div class="line">                        <a class="code" href="group__llfifo__v5__4.html#gac34e090e52a9ef5cdf4337cae6ca717c" title="Interrupt Enable.">XLLF_IER_OFFSET</a>); \</div>
<div class="line">        Reg &amp;= ~((Mask) &amp; <a class="code" href="group__llfifo__v5__4.html#gae3bfcad24428233d9e2a8a861e2d9eed" title="All the ints.">XLLF_INT_ALL_MASK</a>);  \</div>
<div class="line">        XLlFifo_WriteReg((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#gac34e090e52a9ef5cdf4337cae6ca717c" title="Interrupt Enable.">XLLF_IER_OFFSET</a>, \</div>
<div class="line">                        Reg); \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>XLlFifo_IntDisable disables the interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>. </p>
<p>The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be disabled. In other words, XLlFifo_IntDisable uses the "set a bit to clear it" scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">Mask</td><td>contains a bit mask of the interrupts to disable. The mask can be formed using a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__llfifo__v5__4.html#gabff8f5ef31f09865808da90055e29d42" title="XLlFifo_IntDisable disables the interrupts specified in Mask for the FIFO specified by InstancePtr...">XLlFifo_IntDisable(XLlFifo *InstancePtr, u32 Mask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae65ece5c6c9cce1ccdcf9d404fd8f463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IntEnable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">        u32 Reg = <a class="code" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55" title="XLlFifo_ReadReg returns the value of the register at the offet, RegOffset, from the memory mapped bas...">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, \</div>
<div class="line">                        <a class="code" href="group__llfifo__v5__4.html#gac34e090e52a9ef5cdf4337cae6ca717c" title="Interrupt Enable.">XLLF_IER_OFFSET</a>); \</div>
<div class="line">        Reg |= ((Mask) &amp; <a class="code" href="group__llfifo__v5__4.html#gae3bfcad24428233d9e2a8a861e2d9eed" title="All the ints.">XLLF_INT_ALL_MASK</a>);                    \</div>
<div class="line">        XLlFifo_WriteReg((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#gac34e090e52a9ef5cdf4337cae6ca717c" title="Interrupt Enable.">XLLF_IER_OFFSET</a>, \</div>
<div class="line">                        Reg); \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>XLlFifo_IntEnable enables the interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>. </p>
<p>The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">Mask</td><td>contains a bit mask of the interrupts to enable. The mask can be formed using a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__llfifo__v5__4.html#gae65ece5c6c9cce1ccdcf9d404fd8f463" title="XLlFifo_IntEnable enables the interrupts specified in Mask for the FIFO specified by InstancePtr...">XLlFifo_IntEnable(XLlFifo *InstancePtr, u32 Mask)</a> </dd></dl>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a8d6febbfb5e669f63287fc75c282d1f6">XLlFifoInterruptExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gac356d3e8d55aa6e82753400f0bd026a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IntPending</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55" title="XLlFifo_ReadReg returns the value of the register at the offet, RegOffset, from the memory mapped bas...">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#gac34e090e52a9ef5cdf4337cae6ca717c" title="Interrupt Enable.">XLLF_IER_OFFSET</a>) &amp;  \</div>
<div class="line">         XLlFifo_ReadReg((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#ga90a5fafb06870a7ff8043d3a34bf54cc" title="Interrupt Status.">XLLF_ISR_OFFSET</a>))</div>
</div><!-- fragment -->
<p>XLlFifo_IntPending returns a bit mask of the pending interrupts for the FIFO specified by <em>InstancePtr</em>. </p>
<p>Each bit set to 1 in the return value represents a pending interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_IntPending returns a bit mask of the interrupts that are pending. The mask will be a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__llfifo__v5__4.html#gac356d3e8d55aa6e82753400f0bd026a1" title="XLlFifo_IntPending returns a bit mask of the pending interrupts for the FIFO specified by InstancePtr...">XLlFifo_IntPending(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga556524c17aee71ae8407540a5e2cd65f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IsRxDone</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55" title="XLlFifo_ReadReg returns the value of the register at the offet, RegOffset, from the memory mapped bas...">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#ga90a5fafb06870a7ff8043d3a34bf54cc" title="Interrupt Status.">XLLF_ISR_OFFSET</a>) &amp; \</div>
<div class="line">                XLLF_INT_RC_MASK) \</div>
<div class="line">                ? TRUE : FALSE)</div>
</div><!-- fragment -->
<p>XLlFifo_IsRxDone returns true if the reception in the receive channel of the FIFO, specified by <em>InstancePtr</em>, is complete. </p>
<p>XLlFifo_IsRxDone works only if the RC bit in the ISR register is cleared before receiving a frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_IsRxDone returns TRUE when the receive channel of the FIFO is complete. Otherwise, XLlFifo_IsRxDone returns FALSE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: int <a class="el" href="group__llfifo__v5__4.html#ga556524c17aee71ae8407540a5e2cd65f" title="XLlFifo_IsRxDone returns true if the reception in the receive channel of the FIFO, specified by InstancePtr, is complete.">XLlFifo_IsRxDone(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaba876eb888126638848fb2f89a9b4436"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IsRxEmpty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55" title="XLlFifo_ReadReg returns the value of the register at the offet, RegOffset, from the memory mapped bas...">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#ga9c4bbf51bc4b0410b61ef3933776a63c" title="Receive Occupancy.">XLLF_RDFO_OFFSET</a>) == 0) \</div>
<div class="line">                                                        ? TRUE : FALSE)</div>
</div><!-- fragment -->
<p>XLlFifo_IsRxEmpty returns true if the receive channel of the FIFO, specified by <em>InstancePtr</em>, is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_IsRxEmpty returns TRUE when the receive channel of the FIFO is empty. Otherwise, XLlFifo_IsRxEmpty returns FALSE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: int <a class="el" href="group__llfifo__v5__4.html#gaba876eb888126638848fb2f89a9b4436" title="XLlFifo_IsRxEmpty returns true if the receive channel of the FIFO, specified by InstancePtr, is empty.">XLlFifo_IsRxEmpty(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga869bc4c1072da021e747a0a179bfe2da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IsTxDone</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55" title="XLlFifo_ReadReg returns the value of the register at the offet, RegOffset, from the memory mapped bas...">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#ga90a5fafb06870a7ff8043d3a34bf54cc" title="Interrupt Status.">XLLF_ISR_OFFSET</a>) &amp; \</div>
<div class="line">                XLLF_INT_TC_MASK) \</div>
<div class="line">                ? TRUE : FALSE)</div>
</div><!-- fragment -->
<p>XLlFifo_IsTxDone returns true if the transmission in the transmit channel of the FIFO, specified by <em>InstancePtr</em>, is complete. </p>
<p>XLlFifo_IsTxDone works only if the TC bit in the IS register is cleared before sending a frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_IsTxDone returns TRUE when the transmit channel of the FIFO is complete. Otherwise, XLlFifo_IsTxDone returns FALSE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: int <a class="el" href="group__llfifo__v5__4.html#ga869bc4c1072da021e747a0a179bfe2da" title="XLlFifo_IsTxDone returns true if the transmission in the transmit channel of the FIFO, specified by InstancePtr, is complete.">XLlFifo_IsTxDone(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaadc3685592b060c0d864850e86be5c03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_Read</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BufPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga915d68a9cce0f2464fc7644383cb887a">XStrm_Read</a>(&amp;((InstancePtr)-&gt;RxStreamer), (BufPtr), (Bytes))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_Read reads <em>Bytes</em> bytes from the receive channel of the FIFO referenced by <em>InstancePtr</em> to the block of memory, referenced by <em>BufPtr</em>. </p>
<p>Care must be taken to ensure that the number of bytes read with one or more calls to <a class="el" href="group__llfifo__v5__4.html#gaadc3685592b060c0d864850e86be5c03" title="XLlFifo_Read reads Bytes bytes from the receive channel of the FIFO referenced by InstancePtr to the ...">XLlFifo_Read()</a> does not exceed the number of bytes available given from the last call to <a class="el" href="group__llfifo__v5__4.html#ga53af32ae6901462cc8d6fb9adc04655e" title="XLlFifo_RxGetLen notifies the hardware that the program is ready to receive the next frame from the r...">XLlFifo_RxGetLen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">BufPtr</td><td>specifies the memory address to place the data read.</td></tr>
    <tr><td class="paramname">Bytes</td><td>specifies the number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Error handling is handled through hardware exceptions and interrupts.</dd></dl>
<p>C Signature: void <a class="el" href="group__llfifo__v5__4.html#gaadc3685592b060c0d864850e86be5c03" title="XLlFifo_Read reads Bytes bytes from the receive channel of the FIFO referenced by InstancePtr to the ...">XLlFifo_Read(XLlFifo *InstancePtr, void *BufPtr, unsigned Bytes)</a> </p>

</div>
</div>
<a class="anchor" id="ga59307ef23e5b4b71d0d01cef8e06e247"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_ReadRdr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="el" href="group__llfifo__v5__4.html#gaf0240fc89cce2e27e1943d2e23a5af25">XLLF_RDR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_ReadTdr returns the contents of the Receive Destination Register(RDR). </p>
<p>The RDR contains destination address corresponding to the valid packet that is received. The RDR should only be read when a receive packet is available for processing (the receive occupancy is not zero). Once the RDR is read, the receive packet data should be read from the receive data FIFO before the RDR is read again. The RDR values are stored in the receive data FIFO by the AXI4-Stream FIFO core with the data of each packet. The RDR value for the subsequent packet to be processed is moved to the RDR when the previous RDR value has been read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Receive Destination address read from the RDR.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C Signature: u32 <a class="el" href="group__llfifo__v5__4.html#ga59307ef23e5b4b71d0d01cef8e06e247" title="XLlFifo_ReadTdr returns the contents of the Receive Destination Register(RDR).">XLlFifo_ReadRdr(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7526eab563fa4e0fe8b60474e96afe55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(Xil_In32((BaseAddress) + (RegOffset)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_ReadReg returns the value of the register at the offet, <em>RegOffset</em>, from the memory mapped base address, <em>BaseAddress</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>specifies the base address of the device.</td></tr>
    <tr><td class="paramname">RegOffset</td><td>specifies the offset from BaseAddress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_ReadReg returns the value of the specified register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55" title="XLlFifo_ReadReg returns the value of the register at the offet, RegOffset, from the memory mapped bas...">XLlFifo_ReadReg(u32 BaseAddress, u32 RegOffset)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#gaacc66a5dc69ac5a882fa7f3d161efbcb">xdbg_stmnt()</a>, <a class="el" href="group__llfifo__v5__4.html#gaad292ddf2a2c9dde261b93da802c8080">XLlFifo_iRxGetLen()</a>, <a class="el" href="group__llfifo__v5__4.html#gac02405b23499d780e7bc1dfe371281a6">XLlFifo_iTxVacancy()</a>, and <a class="el" href="group__llfifo__v5__4.html#gaed3ae31c8c24f46139fbd709027329ec">XLlFifo_RxGetWord()</a>.</p>

</div>
</div>
<a class="anchor" id="gace8f47c03f1818797c152cb27296df7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_Reset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78" title="XLlFifo_WriteReg writes the value, Value, to the register at the offet, RegOffset, from the memory mapped base address, BaseAddress.">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#ga5331d2736e9b1b516b4262d8e3f11690" title="Local Link Reset.">XLLF_LLR_OFFSET</a>, \</div>
<div class="line">                        <a class="code" href="group__llfifo__v5__4.html#gad8b59856939038963e68acf4e2e2c47c" title="Local Link reset value.">XLLF_LLR_RESET_MASK</a>)</div>
</div><!-- fragment -->
<p>XLlFifo_Reset resets both the Tx and Rx channels and the local link interface the FIFO specified by <em>InstancePtr</em>. </p>
<p>XLlFifo_TxReset resets also sends a reset pulse to the downstream device (e.g. TEMAC). XLlFifo_Reset drops any bytes in the FIFO not yet retrieved. XLlFifo_Reset drops any bytes in the FIFO not yet transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__llfifo__v5__4.html#gace8f47c03f1818797c152cb27296df7c" title="XLlFifo_Reset resets both the Tx and Rx channels and the local link interface the FIFO specified by I...">XLlFifo_Reset(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga53af32ae6901462cc8d6fb9adc04655e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_RxGetLen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga479d2eb3193ad0a5efc3c3b432a78381">XStrm_RxGetLen</a>(&amp;((InstancePtr)-&gt;RxStreamer))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_RxGetLen notifies the hardware that the program is ready to receive the next frame from the receive channel of the FIFO, specified by <em>InstancePtr</em>. </p>
<p>Note that the program must first call XLlFifo_RxGetLen before pulling data out of the receive channel of the FIFO with XLlFifo_Read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_RxGetLen returns the number of bytes available in the next frame.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>C Signature: u32 <a class="el" href="group__llfifo__v5__4.html#ga53af32ae6901462cc8d6fb9adc04655e" title="XLlFifo_RxGetLen notifies the hardware that the program is ready to receive the next frame from the r...">XLlFifo_RxGetLen(XLlFifo *InstancePtr)</a> </p>

</div>
</div>
<a class="anchor" id="ga12da547aa1c9a85e2b0b151f438ff9d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_RxOccupancy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;XStrm_RxOccupancy(&amp;((InstancePtr)-&gt;RxStreamer))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_RxOccupancy returns the number of 32-bit words available (occupancy) to be read from the receive channel of the FIFO, specified by <em>InstancePtr</em>. </p>
<p>The xps_ll_fifo core uses the same fifo to store data values and frame length values. Upon initialization, the XLlFifo_RxOccupancy will give the value of 1, which means one length value (a reserved fifo location) and no data values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_RxOccupancy returns the occupancy count for the specified packet FIFO.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>C Signature: u32 <a class="el" href="group__llfifo__v5__4.html#ga12da547aa1c9a85e2b0b151f438ff9d5" title="XLlFifo_RxOccupancy returns the number of 32-bit words available (occupancy) to be read from the rece...">XLlFifo_RxOccupancy(XLlFifo *InstancePtr)</a> </p>

</div>
</div>
<a class="anchor" id="gaf3739a78b92f17cead0d831757b3a134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_RxReset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78" title="XLlFifo_WriteReg writes the value, Value, to the register at the offet, RegOffset, from the memory mapped base address, BaseAddress.">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#gae1533e466df30729597a1b44ed1059ed" title="Receive Reset.">XLLF_RDFR_OFFSET</a>, \</div>
<div class="line">                        <a class="code" href="group__llfifo__v5__4.html#ga11c4da53ae9b166832186f9a817fba6d" title="receive reset value">XLLF_RDFR_RESET_MASK</a>)</div>
</div><!-- fragment -->
<p>XLlFifo_RxReset resets the receive channel of the FIFO specified by <em>InstancePtr</em>. </p>
<p>XLlFifo_RxReset drops any bytes in the FIFO not yet retrieved.</p>
<p>The calling software may want to test for the completion of the reset by reading the interrupt status (IS) register and testing for the Rx Reset complete (RRC) bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__llfifo__v5__4.html#gaf3739a78b92f17cead0d831757b3a134" title="XLlFifo_RxReset resets the receive channel of the FIFO specified by InstancePtr.">XLlFifo_RxReset(XLlFifo *InstancePtr)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga095f3e0f8571dc02959852e38237f23e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_Status</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="el" href="group__llfifo__v5__4.html#ga90a5fafb06870a7ff8043d3a34bf54cc">XLLF_ISR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_Status returns a bit mask of the interrupt status register (ISR) for the FIFO specified by <em>InstancePtr</em>. </p>
<p>XLlFifo_Status can be used to query the status of the FIFO without having to have interrupts enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_IntStatus returns a bit mask of the status conditions. The mask will be a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 XLlFifo_IntStatus(XLlFifo *InstancePtr) </dd></dl>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a8d6febbfb5e669f63287fc75c282d1f6">XLlFifoInterruptExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga922419fdcd342fa709fb07ec1a9e5577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_TxReset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78" title="XLlFifo_WriteReg writes the value, Value, to the register at the offet, RegOffset, from the memory mapped base address, BaseAddress.">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#gaa55be9e9452783cde92cd70a33e31e56" title="Transmit Reset.">XLLF_TDFR_OFFSET</a>, \</div>
<div class="line">                        <a class="code" href="group__llfifo__v5__4.html#gaf7b4bcf41280c1fb01684b6706603420" title="Transmit reset value.">XLLF_TDFR_RESET_MASK</a>)</div>
</div><!-- fragment -->
<p>XLlFifo_TxReset resets the transmit channel of the FIFO specified by <em>InstancePtr</em>. </p>
<p>XLlFifo_TxReset drops any bytes in the FIFO not yet transmitted.</p>
<p>The calling software may want to test for the completion of the reset by reading the interrupt status (IS) register and testing for the Tx Reset complete (TRC) bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__llfifo__v5__4.html#ga922419fdcd342fa709fb07ec1a9e5577" title="XLlFifo_TxReset resets the transmit channel of the FIFO specified by InstancePtr.">XLlFifo_TxReset(XLlFifo *InstancePtr)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd09ed5189e0b85994901102655964f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_TxSetLen</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga1e99fb51e0cfab7d0e8de5e93c27fd9c">XStrm_TxSetLen</a>(&amp;((InstancePtr)-&gt;TxStreamer), (Bytes))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_TxSetLen begins a hardware transfer of <em>Bytes</em> bytes out of the transmit channel of the FIFO specified by <em>InstancePtr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">Bytes</td><td>specifies the frame length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>C Signature: void <a class="el" href="group__llfifo__v5__4.html#gacd09ed5189e0b85994901102655964f7" title="XLlFifo_TxSetLen begins a hardware transfer of Bytes bytes out of the transmit channel of the FIFO sp...">XLlFifo_TxSetLen(XLlFifo *InstancePtr, u32 Bytes)</a> </p>

</div>
</div>
<a class="anchor" id="gaf2884c49ae41dc5c5317c2ef6df45a28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_TxVacancy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;XStrm_TxVacancy(&amp;((InstancePtr)-&gt;TxStreamer))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_TxVacancy returns the number of unused 32 bit words available (vacancy) in the send channel of the FIFO specified by <em>InstancePtr</em>. </p>
<p>The xps_ll_fifo core uses tXLLF_he same fifo to store data values and frame length values. Upon initialization, the XLlFifo_TxVacancy will give the value of FIFO_WIDTH - 1, which means one length value used (a reserved fifo location) and no data values yet present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_TxVacancy returns the vacancy count in 32-bit words for the specified FIFO.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__llfifo__v5__4.html#gaf2884c49ae41dc5c5317c2ef6df45a28" title="XLlFifo_TxVacancy returns the number of unused 32 bit words available (vacancy) in the send channel o...">XLlFifo_TxVacancy(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1fa93f486abaaf35c7d599a8cd91b295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_Write</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BufPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__llfifo__v5__4.html#ga1f43ea833af99162745ceef66849b666">XStrm_Write</a>(&amp;((InstancePtr)-&gt;TxStreamer), (BufPtr), (Bytes))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_Write writes <em>Bytes</em> bytes of the block of memory, referenced by <em>BufPtr</em>, to the transmit channel of the FIFO referenced by <em>InstancePtr</em>. </p>
<p>Care must be taken to ensure that the number of bytes written with one or more calls to <a class="el" href="group__llfifo__v5__4.html#ga1fa93f486abaaf35c7d599a8cd91b295" title="XLlFifo_Write writes Bytes bytes of the block of memory, referenced by BufPtr, to the transmit channe...">XLlFifo_Write()</a> matches the number of bytes given in the next call to <a class="el" href="group__llfifo__v5__4.html#gacd09ed5189e0b85994901102655964f7" title="XLlFifo_TxSetLen begins a hardware transfer of Bytes bytes out of the transmit channel of the FIFO sp...">XLlFifo_TxSetLen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">BufPtr</td><td>specifies the memory address of data to write.</td></tr>
    <tr><td class="paramname">Bytes</td><td>specifies the number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Error handling is handled through hardware exceptions and interrupts.</dd></dl>
<p>C Signature: void <a class="el" href="group__llfifo__v5__4.html#ga1fa93f486abaaf35c7d599a8cd91b295" title="XLlFifo_Write writes Bytes bytes of the block of memory, referenced by BufPtr, to the transmit channe...">XLlFifo_Write(XLlFifo *InstancePtr, void *BufPtr, unsigned Bytes)</a> </p>

</div>
</div>
<a class="anchor" id="gacd283ce73981f7f9eab94f8bb421bc78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((Xil_Out32((BaseAddress) + (RegOffset), (Value))))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_WriteReg writes the value, <em>Value</em>, to the register at the offet, <em>RegOffset</em>, from the memory mapped base address, <em>BaseAddress</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>specifies the base address of the device.</td></tr>
    <tr><td class="paramname">RegOffset</td><td>specifies the offset from BaseAddress.</td></tr>
    <tr><td class="paramname">Value</td><td>is value to write to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78" title="XLlFifo_WriteReg writes the value, Value, to the register at the offet, RegOffset, from the memory mapped base address, BaseAddress.">XLlFifo_WriteReg(u32 BaseAddress, u32 RegOffset, u32 Value)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>, <a class="el" href="group__llfifo__v5__4.html#gaa49ecc1529434fd932d8a65d63a1a04d">XLlFifo_iTxSetLen()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga29654d755dce84b861022179c99ca7a3">XLlFifo_TxPutWord()</a>.</p>

</div>
</div>
<a class="anchor" id="ga105828f79f13c07d571db218c5837fae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_WriteTdr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Tdest&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78" title="XLlFifo_WriteReg writes the value, Value, to the register at the offet, RegOffset, from the memory mapped base address, BaseAddress.">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="group__llfifo__v5__4.html#ga5c691ac1237fb77b8e356a7d2b0b8b54" title="Transmit Destination.">XLLF_TDR_OFFSET</a>, \</div>
<div class="line">                          Tdest &amp; 0xF)</div>
</div><!-- fragment -->
<p>XLlFifo_WriteTdr writes to the Transmit Destination Register (TDR) </p>
<p>The TDR stores the destination address corresponding to the packet to be transmitted. When presenting a transmit packet to the AXI4-Stream FIFO core the following sequence should be followed</p>
<ul>
<li>Write the destination address into TDR first,</li>
<li>Write the packet data to the Transmit Data FIFO next</li>
<li>Write the length of the packet into the Transmit Length Register.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate. </td></tr>
    <tr><td class="paramname">Tdest</td><td>is the Transmit Destination address to be written to TDR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C Signature: void <a class="el" href="group__llfifo__v5__4.html#ga105828f79f13c07d571db218c5837fae" title="XLlFifo_WriteTdr writes to the Transmit Destination Register (TDR)">XLlFifo_WriteTdr(XLlFifo *InstancePtr, u32 Tdest)</a>; </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga89057d90d6eacdbe8adc766f53f60ed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_x_ll_fifo.html">XLlFifo</a>  <a class="el" href="struct_x_ll_fifo.html">XLlFifo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This typedef defines a run-time instance of an <a class="el" href="struct_x_ll_fifo.html" title="This typedef defines a run-time instance of an XLlFifo device.">XLlFifo</a> device. </p>

</div>
</div>
<a class="anchor" id="ga4f27ac6f38ad77d7b92014a52eb5c16b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_x_strm___rx_fifo_streamer.html">XStrm_RxFifoStreamer</a>  <a class="el" href="struct_x_strm___rx_fifo_streamer.html">XStrm_RxFifoStreamer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This typedef defines a run-time instance of a receive byte-streamer. </p>

</div>
</div>
<a class="anchor" id="ga3d1351f115d97cbce95da390d0ea4033"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a>  <a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This typedef defines a run-time instance of a transmit byte-streamer. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaacc66a5dc69ac5a882fa7f3d161efbcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xdbg_stmnt </td>
          <td>(</td>
          <td class="paramtype">u32 _xllfifo_rr_value;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_iRxOccupancy returns the number of 32-bit words available (occupancy) to be read from the receive channel of the FIFO, specified by <em>InstancePtr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_iRxOccupancy returns the occupancy count in 32-bit words for the specified FIFO. </dd></dl>

<p>References <a class="el" href="struct_x_ll_fifo.html#a458030a162537427b617cbb204a701fd">XLlFifo::BaseAddress</a>, <a class="el" href="group__llfifo__v5__4.html#ga9c4bbf51bc4b0410b61ef3933776a63c">XLLF_RDFO_OFFSET</a>, and <a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga549da0fb83b3bb11ea6401b8001f9c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XLlFifo_Config * XLlFfio_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the hardware configuration for a device instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the unique device ID of the device to lookup for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The configuration structure for the device. If the device ID is not found,a NULL pointer is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a8d6febbfb5e669f63287fc75c282d1f6">XLlFifoInterruptExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga874c22807476dc0ffec670c38f452443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLlFifo_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XLlFifo_Config *&#160;</td>
          <td class="paramname"><em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_CfgInitialize initializes an XPS_ll_Fifo device along with the <em>InstancePtr</em> that references it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Axi Streaming FIFO instance to be worked on. </td></tr>
    <tr><td class="paramname">Config</td><td>references the structure holding the hardware configuration for the Axi Streaming FIFO core to initialize. </td></tr>
    <tr><td class="paramname">EffectiveAddress</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

<p>References <a class="el" href="struct_x_ll_fifo.html#a455c634fb80553cecfcba0845eb99937">XLlFifo::Axi4BaseAddress</a>, <a class="el" href="struct_x_ll_fifo.html#a458030a162537427b617cbb204a701fd">XLlFifo::BaseAddress</a>, <a class="el" href="struct_x_ll_fifo.html#a9e2342496ea8183c012567d7c89851b3">XLlFifo::Datainterface</a>, <a class="el" href="struct_x_ll_fifo.html#abe388bb422699248b26a9d76652474b1">XLlFifo::IsReady</a>, <a class="el" href="struct_x_ll_fifo.html#a456fbf87ce23b1334c67b386722b1434">XLlFifo::RxStreamer</a>, <a class="el" href="struct_x_ll_fifo.html#a13363fb4d5d45a5725b7427b36c44817">XLlFifo::TxStreamer</a>, <a class="el" href="group__llfifo__v5__4.html#ga5331d2736e9b1b516b4262d8e3f11690">XLLF_LLR_OFFSET</a>, <a class="el" href="group__llfifo__v5__4.html#ga11c4da53ae9b166832186f9a817fba6d">XLLF_RDFR_RESET_MASK</a>, <a class="el" href="group__llfifo__v5__4.html#ga18bc620d388cbca83d63cc1c6ef33225">XLlFifo_iRead_Aligned()</a>, <a class="el" href="group__llfifo__v5__4.html#gaad292ddf2a2c9dde261b93da802c8080">XLlFifo_iRxGetLen()</a>, <a class="el" href="group__llfifo__v5__4.html#gaa49ecc1529434fd932d8a65d63a1a04d">XLlFifo_iTxSetLen()</a>, <a class="el" href="group__llfifo__v5__4.html#gac02405b23499d780e7bc1dfe371281a6">XLlFifo_iTxVacancy()</a>, <a class="el" href="group__llfifo__v5__4.html#ga9be5556d593980195e43a31ffb37e0fe">XLlFifo_iWrite_Aligned()</a>, <a class="el" href="group__llfifo__v5__4.html#gaf3739a78b92f17cead0d831757b3a134">XLlFifo_RxReset</a>, <a class="el" href="group__llfifo__v5__4.html#ga922419fdcd342fa709fb07ec1a9e5577">XLlFifo_TxReset</a>, <a class="el" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>, and <a class="el" href="group__llfifo__v5__4.html#ga8a67c77f811a505b658e06642eb9c964">XStrm_TxInitialize()</a>.</p>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a8d6febbfb5e669f63287fc75c282d1f6">XLlFifoInterruptExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3debde0a34325b3f314d15fe6f43a7ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLlFifo_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_Initialize initializes an XPS_ll_Fifo device along with the <em>InstancePtr</em> that references it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the memory instance to be associated with the FIFO device upon initialization.</td></tr>
    <tr><td class="paramname">BaseAddress</td><td>is the processor address used to access the base address of the Fifo device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

<p>References <a class="el" href="struct_x_ll_fifo.html#a455c634fb80553cecfcba0845eb99937">XLlFifo::Axi4BaseAddress</a>, <a class="el" href="struct_x_ll_fifo.html#a458030a162537427b617cbb204a701fd">XLlFifo::BaseAddress</a>, <a class="el" href="struct_x_ll_fifo.html#abe388bb422699248b26a9d76652474b1">XLlFifo::IsReady</a>, <a class="el" href="struct_x_ll_fifo.html#a456fbf87ce23b1334c67b386722b1434">XLlFifo::RxStreamer</a>, <a class="el" href="struct_x_ll_fifo.html#a13363fb4d5d45a5725b7427b36c44817">XLlFifo::TxStreamer</a>, <a class="el" href="group__llfifo__v5__4.html#ga5331d2736e9b1b516b4262d8e3f11690">XLLF_LLR_OFFSET</a>, <a class="el" href="group__llfifo__v5__4.html#ga11c4da53ae9b166832186f9a817fba6d">XLLF_RDFR_RESET_MASK</a>, <a class="el" href="group__llfifo__v5__4.html#ga18bc620d388cbca83d63cc1c6ef33225">XLlFifo_iRead_Aligned()</a>, <a class="el" href="group__llfifo__v5__4.html#gaad292ddf2a2c9dde261b93da802c8080">XLlFifo_iRxGetLen()</a>, <a class="el" href="group__llfifo__v5__4.html#gaa49ecc1529434fd932d8a65d63a1a04d">XLlFifo_iTxSetLen()</a>, <a class="el" href="group__llfifo__v5__4.html#gac02405b23499d780e7bc1dfe371281a6">XLlFifo_iTxVacancy()</a>, <a class="el" href="group__llfifo__v5__4.html#ga9be5556d593980195e43a31ffb37e0fe">XLlFifo_iWrite_Aligned()</a>, <a class="el" href="group__llfifo__v5__4.html#gaf3739a78b92f17cead0d831757b3a134">XLlFifo_RxReset</a>, <a class="el" href="group__llfifo__v5__4.html#ga922419fdcd342fa709fb07ec1a9e5577">XLlFifo_TxReset</a>, <a class="el" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>, and <a class="el" href="group__llfifo__v5__4.html#ga8a67c77f811a505b658e06642eb9c964">XStrm_TxInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga18bc620d388cbca83d63cc1c6ef33225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLlFifo_iRead_Aligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>BufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>WordCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_iRead_Aligned reads, <em>WordCount</em>, words from the FIFO referenced by <em>InstancePtr</em> to the block of memory, referenced by <em>BufPtr</em>. </p>
<p>XLlFifo_iRead_Aligned assumes that <em>BufPtr</em> is already aligned according to the following hardware limitations: ppc - aligned on 32 bit boundaries to avoid performance penalties from unaligned exception handling. microblaze - aligned on 32 bit boundaries as microblaze does not handle unaligned transfers.</p>
<p>Care must be taken to ensure that the number of words read with one or more calls to <a class="el" href="group__llfifo__v5__4.html#gaadc3685592b060c0d864850e86be5c03" title="XLlFifo_Read reads Bytes bytes from the receive channel of the FIFO referenced by InstancePtr to the ...">XLlFifo_Read()</a> does not exceed the number of bytes (rounded up to the nearest whole 32 bit word) available given from the last call to <a class="el" href="group__llfifo__v5__4.html#ga53af32ae6901462cc8d6fb9adc04655e" title="XLlFifo_RxGetLen notifies the hardware that the program is ready to receive the next frame from the r...">XLlFifo_RxGetLen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">BufPtr</td><td>specifies the memory address to place the data read.</td></tr>
    <tr><td class="paramname">WordCount</td><td>specifies the number of 32 bit words to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_iRead_Aligned always returns XST_SUCCESS. Error handling is otherwise handled through hardware exceptions and interrupts. </dd></dl>

<p>References <a class="el" href="group__llfifo__v5__4.html#gaed3ae31c8c24f46139fbd709027329ec">XLlFifo_RxGetWord()</a>.</p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaad292ddf2a2c9dde261b93da802c8080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLlFifo_iRxGetLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_iRxGetLen notifies the hardware that the program is ready to receive the next frame from the receive channel of the FIFO specified by <em>InstancePtr</em>. </p>
<p>Note that the program must first call XLlFifo_iRxGetLen before pulling data out of the receive channel of the FIFO with XLlFifo_Read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_iRxGetLen returns the number of bytes available in the next frame. </dd></dl>

<p>References <a class="el" href="struct_x_ll_fifo.html#a458030a162537427b617cbb204a701fd">XLlFifo::BaseAddress</a>, <a class="el" href="group__llfifo__v5__4.html#ga267285e6015808291ef6671038cba888">XLLF_RLF_OFFSET</a>, and <a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa49ecc1529434fd932d8a65d63a1a04d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLlFifo_iTxSetLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_iTxSetLen begins a hardware transfer of data out of the transmit channel of the FIFO, specified by <em>InstancePtr</em>. </p>
<p><em>Bytes</em> specifies the number of bytes in the frame to transmit.</p>
<p>Note that <em>Bytes</em> (rounded up to the nearest whole 32 bit word) must be same number of words just written using one or more calls to <a class="el" href="group__llfifo__v5__4.html#ga9be5556d593980195e43a31ffb37e0fe" title="XLlFifo_iWrite_Aligned writes, WordCount, words to the FIFO referenced by InstancePtr from the block ...">XLlFifo_iWrite_Aligned()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">Bytes</td><td>specifies the number of bytes to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

<p>References <a class="el" href="struct_x_ll_fifo.html#a458030a162537427b617cbb204a701fd">XLlFifo::BaseAddress</a>, <a class="el" href="group__llfifo__v5__4.html#gac14e6d7e1116f9a43c0adfbe93422fa7">XLLF_TLF_OFFSET</a>, and <a class="el" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a38cd37c9e86c6d514d731db7bc520a0b">TxSend()</a>, <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gac02405b23499d780e7bc1dfe371281a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLlFifo_iTxVacancy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_iTxVacancy returns the number of unused 32 bit words available (vacancy) in the send channel of the FIFO, specified by <em>InstancePtr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_iTxVacancy returns the vacancy count in 32-bit words for the specified FIFO. </dd></dl>

<p>References <a class="el" href="struct_x_ll_fifo.html#a458030a162537427b617cbb204a701fd">XLlFifo::BaseAddress</a>, <a class="el" href="group__llfifo__v5__4.html#gab77ae26c2fe9b0ac15ebdbf0c6c30960">XLLF_TDFV_OFFSET</a>, and <a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a38cd37c9e86c6d514d731db7bc520a0b">TxSend()</a>, <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9be5556d593980195e43a31ffb37e0fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLlFifo_iWrite_Aligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>BufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>WordCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_iWrite_Aligned writes, <em>WordCount</em>, words to the FIFO referenced by <em>InstancePtr</em> from the block of memory, referenced by <em>BufPtr</em>. </p>
<p>XLlFifo_iWrite_Aligned assumes that <em>BufPtr</em> is already aligned according to the following hardware limitations: ppc - aligned on 32 bit boundaries to avoid performance penalties from unaligned exception handling. microblaze - aligned on 32 bit boundaries as microblaze does not handle unaligned transfers.</p>
<p>Care must be taken to ensure that the number of words written with one or more calls to <a class="el" href="group__llfifo__v5__4.html#ga9be5556d593980195e43a31ffb37e0fe" title="XLlFifo_iWrite_Aligned writes, WordCount, words to the FIFO referenced by InstancePtr from the block ...">XLlFifo_iWrite_Aligned()</a> matches the number of bytes (rounded up to the nearest whole 32 bit word) given in the next call to <a class="el" href="group__llfifo__v5__4.html#gaa49ecc1529434fd932d8a65d63a1a04d" title="XLlFifo_iTxSetLen begins a hardware transfer of data out of the transmit channel of the FIFO...">XLlFifo_iTxSetLen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">BufPtr</td><td>specifies the memory address to place the data read.</td></tr>
    <tr><td class="paramname">WordCount</td><td>specifies the number of 32 bit words to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_iWrite_Aligned always returns XST_SUCCESS. Error handling is otherwise handled through hardware exceptions and interrupts.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>C Signature: int XLlFifo_iWrite_Aligned(<a class="el" href="struct_x_ll_fifo.html" title="This typedef defines a run-time instance of an XLlFifo device.">XLlFifo</a> *InstancePtr, void *BufPtr, unsigned WordCount); </p>

<p>References <a class="el" href="group__llfifo__v5__4.html#ga29654d755dce84b861022179c99ca7a3">XLlFifo_TxPutWord()</a>.</p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed3ae31c8c24f46139fbd709027329ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLlFifo_RxGetWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_RxGetWord reads one 32 bit word from the FIFO specified by <em>InstancePtr</em>. </p>
<p>XLlFifo_RxGetLen or XLlFifo_iRxGetLen must be called before calling XLlFifo_RxGetWord. Otherwise, the hardware will raise an <em>Over Read Exception</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XLlFifo_RxGetWord returns the 32 bit word read from the FIFO.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__llfifo__v5__4.html#gaed3ae31c8c24f46139fbd709027329ec" title="XLlFifo_RxGetWord reads one 32 bit word from the FIFO specified by InstancePtr.">XLlFifo_RxGetWord(XLlFifo *InstancePtr)</a> </dd></dl>

<p>References <a class="el" href="struct_x_ll_fifo.html#a9e2342496ea8183c012567d7c89851b3">XLlFifo::Datainterface</a>, <a class="el" href="group__llfifo__v5__4.html#ga256c51f97ca57cc89c9b51449f3601e1">XLLF_AXI4_RDFD_OFFSET</a>, <a class="el" href="group__llfifo__v5__4.html#ga93e049a21e43548bf03161b4a4394440">XLLF_RDFD_OFFSET</a>, and <a class="el" href="group__llfifo__v5__4.html#ga7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga18bc620d388cbca83d63cc1c6ef33225">XLlFifo_iRead_Aligned()</a>.</p>

</div>
</div>
<a class="anchor" id="ga29654d755dce84b861022179c99ca7a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLlFifo_TxPutWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XLlFifo_TxPutWord writes the 32 bit word, <em>Word</em> to the FIFO specified by <em>InstancePtr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate. </td></tr>
    <tr><td class="paramname">Word</td><td>is the data word to be written to FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__llfifo__v5__4.html#ga29654d755dce84b861022179c99ca7a3" title="XLlFifo_TxPutWord writes the 32 bit word, Word to the FIFO specified by InstancePtr.">XLlFifo_TxPutWord(XLlFifo *InstancePtr, u32 Word)</a> </dd></dl>

<p>References <a class="el" href="struct_x_ll_fifo.html#a9e2342496ea8183c012567d7c89851b3">XLlFifo::Datainterface</a>, <a class="el" href="group__llfifo__v5__4.html#ga7a72ef43b9e2ca7e28a9e939012f1044">XLLF_AXI4_TDFD_OFFSET</a>, <a class="el" href="group__llfifo__v5__4.html#gaeca8c86badc0df67426442f9bb6a5195">XLLF_TDFD_OFFSET</a>, and <a class="el" href="group__llfifo__v5__4.html#gacd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xllfifo__interrupt__example_8c.html#a38cd37c9e86c6d514d731db7bc520a0b">TxSend()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga9be5556d593980195e43a31ffb37e0fe">XLlFifo_iWrite_Aligned()</a>.</p>

</div>
</div>
<a class="anchor" id="ga915d68a9cce0f2464fc7644383cb887a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XStrm_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_strm___rx_fifo_streamer.html">XStrm_RxFifoStreamer</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>BufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XStrm_Read reads <em>Bytes</em> bytes from the FIFO specified by <em>InstancePtr</em> to the block of memory, referenced by <em>BufPtr</em>. </p>
<p>Care must be taken to ensure that the number of bytes read with one or more calls to <a class="el" href="group__llfifo__v5__4.html#ga915d68a9cce0f2464fc7644383cb887a" title="XStrm_Read reads Bytes bytes from the FIFO specified by InstancePtr to the block of memory...">XStrm_Read()</a> does not exceed the number of bytes available given from the last call to <a class="el" href="group__llfifo__v5__4.html#ga479d2eb3193ad0a5efc3c3b432a78381" title="XStrm_RxGetLen notifies the hardware that the program is ready to receive the next frame from the rec...">XStrm_RxGetLen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">BufPtr</td><td>specifies the memory address to place the data read.</td></tr>
    <tr><td class="paramname">Bytes</td><td>specifies the number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

<p>References <a class="el" href="struct_x_strm___rx_fifo_streamer.html#ab278ceaef035943f8a3a8b85a8cab99d">XStrm_RxFifoStreamer::FifoInstance</a>, <a class="el" href="struct_x_strm___rx_fifo_streamer.html#a3ad4cdd1ad14dcecfaf5f923850289fb">XStrm_RxFifoStreamer::FifoWidth</a>, <a class="el" href="struct_x_strm___rx_fifo_streamer.html#a9fa74d02f4fa2607e78b11de059be837">XStrm_RxFifoStreamer::FrmByteCnt</a>, <a class="el" href="struct_x_strm___rx_fifo_streamer.html#a6321ab6bf1a1f3979c0771618a4aba7c">XStrm_RxFifoStreamer::HeadIndex</a>, and <a class="el" href="struct_x_strm___rx_fifo_streamer.html#af3bfc974fd88c7b707edf680b3c9aed2">XStrm_RxFifoStreamer::ReadFn</a>.</p>

</div>
</div>
<a class="anchor" id="ga479d2eb3193ad0a5efc3c3b432a78381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XStrm_RxGetLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_strm___rx_fifo_streamer.html">XStrm_RxFifoStreamer</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XStrm_RxGetLen notifies the hardware that the program is ready to receive the next frame from the receive channel of the FIFO, specified by <em>InstancePtr</em>. </p>
<p>Note that the program must first call XStrm_RxGetLen before pulling data out of the receive channel of the FIFO with XStrm_Read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XStrm_RxGetLen returns the number of bytes available in the next frame. </dd></dl>

<p>References <a class="el" href="struct_x_strm___rx_fifo_streamer.html#ab278ceaef035943f8a3a8b85a8cab99d">XStrm_RxFifoStreamer::FifoInstance</a>, <a class="el" href="struct_x_strm___rx_fifo_streamer.html#a3ad4cdd1ad14dcecfaf5f923850289fb">XStrm_RxFifoStreamer::FifoWidth</a>, <a class="el" href="struct_x_strm___rx_fifo_streamer.html#a9fa74d02f4fa2607e78b11de059be837">XStrm_RxFifoStreamer::FrmByteCnt</a>, <a class="el" href="struct_x_strm___rx_fifo_streamer.html#a01fa1cc2098388ac9371beb090c0c212">XStrm_RxFifoStreamer::GetLenFn</a>, and <a class="el" href="struct_x_strm___rx_fifo_streamer.html#a6321ab6bf1a1f3979c0771618a4aba7c">XStrm_RxFifoStreamer::HeadIndex</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a67c77f811a505b658e06642eb9c964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XStrm_TxInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>FifoWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>FifoInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XStrm_XferFnType&#160;</td>
          <td class="paramname"><em>WriteFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XStrm_SetLenFnType&#160;</td>
          <td class="paramname"><em>SetLenFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XStrm_GetVacancyFnType&#160;</td>
          <td class="paramname"><em>GetVacancyFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XStrm_TxInitialize initializes the <a class="el" href="struct_x_strm___tx_fifo_streamer.html" title="This typedef defines a run-time instance of a transmit byte-streamer.">XStrm_TxFifoStreamer</a> object referenced by <em>InstancePtr</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the tx streamer on which to operate.</td></tr>
    <tr><td class="paramname">FifoWidth</td><td>specifies the FIFO keyhole size in bytes.</td></tr>
    <tr><td class="paramname">FifoInstance</td><td>references the FIFO driver instance that this streamer object should use to transfer data into the the actual fifo.</td></tr>
    <tr><td class="paramname">WriteFn</td><td>specifies a routine to use to write data into the actual FIFO. It is assumed that this write routine will handle only writes from an aligned buffer. (Otherwise, why are we using this streamer driver?)</td></tr>
    <tr><td class="paramname">SetLenFn</td><td>specifies a routine to use to initiate a transmit on the actual FIFO.</td></tr>
    <tr><td class="paramname">GetVacancyFn</td><td>specifies a routine to use to retrieve the vacancy in the actual FIFO. The true vacancy value needs to come through this streamer driver because it holds some of the bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

<p>References <a class="el" href="struct_x_strm___tx_fifo_streamer.html#ac20fde8a3090fddfc01f8b2900fd9051">XStrm_TxFifoStreamer::FifoInstance</a>, <a class="el" href="struct_x_strm___tx_fifo_streamer.html#a474cf91d66d43f716a34299d4ab9b9b2">XStrm_TxFifoStreamer::FifoWidth</a>, <a class="el" href="struct_x_strm___tx_fifo_streamer.html#ab33212eea0a6327f2c6b1173510170a9">XStrm_TxFifoStreamer::GetVacancyFn</a>, <a class="el" href="struct_x_strm___tx_fifo_streamer.html#aa315e740022ccc81ef9cccfe7c82022d">XStrm_TxFifoStreamer::SetLenFn</a>, <a class="el" href="struct_x_strm___tx_fifo_streamer.html#a265500391a387c5354a14fea79a1b446">XStrm_TxFifoStreamer::TailIndex</a>, and <a class="el" href="struct_x_strm___tx_fifo_streamer.html#abaed83d1259485a6deadbf4644b0be1b">XStrm_TxFifoStreamer::WriteFn</a>.</p>

<p>Referenced by <a class="el" href="group__llfifo__v5__4.html#ga874c22807476dc0ffec670c38f452443">XLlFifo_CfgInitialize()</a>, and <a class="el" href="group__llfifo__v5__4.html#ga3debde0a34325b3f314d15fe6f43a7ee">XLlFifo_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e99fb51e0cfab7d0e8de5e93c27fd9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XStrm_TxSetLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XStrm_TxSetLen flushes to the FIFO, specified by <em>InstancePtr</em>, any bytes remaining in internal buffers and begins a hardware transfer of data out of the transmit channel of the FIFO. </p>
<p><em>Bytes</em> specifies the number of bytes in the frame to transmit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO Streamer on which to operate.</td></tr>
    <tr><td class="paramname">Bytes</td><td>specifies the frame length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

<p>References <a class="el" href="struct_x_strm___tx_fifo_streamer.html#ac20fde8a3090fddfc01f8b2900fd9051">XStrm_TxFifoStreamer::FifoInstance</a>, <a class="el" href="struct_x_strm___tx_fifo_streamer.html#a265500391a387c5354a14fea79a1b446">XStrm_TxFifoStreamer::TailIndex</a>, and <a class="el" href="struct_x_strm___tx_fifo_streamer.html#abaed83d1259485a6deadbf4644b0be1b">XStrm_TxFifoStreamer::WriteFn</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f43ea833af99162745ceef66849b666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XStrm_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_strm___tx_fifo_streamer.html">XStrm_TxFifoStreamer</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>BufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>Bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XStrm_Write writes <em>Bytes</em> bytes of the block of memory, referenced by <em>BufPtr</em>, to the transmit channel of the FIFO referenced by <em>InstancePtr</em>. </p>
<p>Care must be taken to ensure that the number of bytes written with one or more calls to <a class="el" href="group__llfifo__v5__4.html#ga1f43ea833af99162745ceef66849b666" title="XStrm_Write writes Bytes bytes of the block of memory, referenced by BufPtr, to the transmit channel ...">XStrm_Write()</a> matches the number of bytes given in the next call to <a class="el" href="group__llfifo__v5__4.html#ga1e99fb51e0cfab7d0e8de5e93c27fd9c" title="XStrm_TxSetLen flushes to the FIFO, specified by InstancePtr, any bytes remaining in internal buffers...">XStrm_TxSetLen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td class="paramname">BufPtr</td><td>specifies the memory address of data to write.</td></tr>
    <tr><td class="paramname">Bytes</td><td>specifies the number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

<p>References <a class="el" href="struct_x_strm___tx_fifo_streamer.html#ac20fde8a3090fddfc01f8b2900fd9051">XStrm_TxFifoStreamer::FifoInstance</a>, <a class="el" href="struct_x_strm___tx_fifo_streamer.html#a474cf91d66d43f716a34299d4ab9b9b2">XStrm_TxFifoStreamer::FifoWidth</a>, <a class="el" href="struct_x_strm___tx_fifo_streamer.html#a265500391a387c5354a14fea79a1b446">XStrm_TxFifoStreamer::TailIndex</a>, and <a class="el" href="struct_x_strm___tx_fifo_streamer.html#abaed83d1259485a6deadbf4644b0be1b">XStrm_TxFifoStreamer::WriteFn</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
