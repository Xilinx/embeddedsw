<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uartlite: Uartlite_v3_2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uartlite
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__uartlite__v3__2.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Uartlite_v3_2</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_lite___stats.html">XUartLite_Stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> driver.  <a href="struct_x_uart_lite___stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_lite___buffer.html">XUartLite_Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following data type is used to manage the buffers that are handled when sending and receiving data in the interrupt mode.  <a href="struct_x_uart_lite___buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_lite___config.html">XUartLite_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for the device.  <a href="struct_x_uart_lite___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_lite.html">XUartLite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> driver instance data.  <a href="struct_x_uart_lite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacb96d217d7b77e8d517e9556d421db95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>(BaseAddress,  RegOffset,  Data)&#160;&#160;&#160;XUartLite_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td></tr>
<tr class="memdesc:gacb96d217d7b77e8d517e9556d421db95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a UartLite register.  <a href="#gacb96d217d7b77e8d517e9556d421db95">More...</a><br /></td></tr>
<tr class="separator:gacb96d217d7b77e8d517e9556d421db95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41431b69c8c2c2829277a851d70b7bf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6">XUartLite_ReadReg</a>(BaseAddress,  RegOffset)&#160;&#160;&#160;XUartLite_In32((BaseAddress) + (RegOffset))</td></tr>
<tr class="memdesc:ga41431b69c8c2c2829277a851d70b7bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a UartLite register.  <a href="#ga41431b69c8c2c2829277a851d70b7bf6">More...</a><br /></td></tr>
<tr class="separator:ga41431b69c8c2c2829277a851d70b7bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef0be395bab4e7b6c4bc8c081ebe9cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gacef0be395bab4e7b6c4bc8c081ebe9cf">XUartLite_SetControlReg</a>(BaseAddress,  Mask)&#160;&#160;&#160;<a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>((BaseAddress), XUL_CONTROL_REG_OFFSET, (Mask))</td></tr>
<tr class="memdesc:gacef0be395bab4e7b6c4bc8c081ebe9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the contents of the control register.  <a href="#gacef0be395bab4e7b6c4bc8c081ebe9cf">More...</a><br /></td></tr>
<tr class="separator:gacef0be395bab4e7b6c4bc8c081ebe9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c823eabd69cc7e34fa76921ea294dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a>(BaseAddress)&#160;&#160;&#160;<a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6">XUartLite_ReadReg</a>((BaseAddress), XUL_STATUS_REG_OFFSET)</td></tr>
<tr class="memdesc:gac2c823eabd69cc7e34fa76921ea294dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of the status register.  <a href="#gac2c823eabd69cc7e34fa76921ea294dd">More...</a><br /></td></tr>
<tr class="separator:gac2c823eabd69cc7e34fa76921ea294dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03599e323029e7b9263f1bd458cd5ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gad03599e323029e7b9263f1bd458cd5ce">XUartLite_IsReceiveEmpty</a>(BaseAddress)</td></tr>
<tr class="memdesc:gad03599e323029e7b9263f1bd458cd5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the receiver has data.  <a href="#gad03599e323029e7b9263f1bd458cd5ce">More...</a><br /></td></tr>
<tr class="separator:gad03599e323029e7b9263f1bd458cd5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63565710e31e2c07851858e835016086"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga63565710e31e2c07851858e835016086">XUartLite_IsTransmitFull</a>(BaseAddress)</td></tr>
<tr class="memdesc:ga63565710e31e2c07851858e835016086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the transmitter is full.  <a href="#ga63565710e31e2c07851858e835016086">More...</a><br /></td></tr>
<tr class="separator:ga63565710e31e2c07851858e835016086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa2025650e6a0618c0527ca224fe3db3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gafa2025650e6a0618c0527ca224fe3db3">XUartLite_IsIntrEnabled</a>(BaseAddress)</td></tr>
<tr class="memdesc:gafa2025650e6a0618c0527ca224fe3db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the interrupt is enabled.  <a href="#gafa2025650e6a0618c0527ca224fe3db3">More...</a><br /></td></tr>
<tr class="separator:gafa2025650e6a0618c0527ca224fe3db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60612a3ae00273a06a2905f6cfd7b10f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga60612a3ae00273a06a2905f6cfd7b10f">XUartLite_EnableIntr</a>(BaseAddress)&#160;&#160;&#160;<a class="el" href="group__uartlite__v3__2.html#gacef0be395bab4e7b6c4bc8c081ebe9cf">XUartLite_SetControlReg</a>((BaseAddress), XUL_CR_ENABLE_INTR)</td></tr>
<tr class="memdesc:ga60612a3ae00273a06a2905f6cfd7b10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the device interrupt.  <a href="#ga60612a3ae00273a06a2905f6cfd7b10f">More...</a><br /></td></tr>
<tr class="separator:ga60612a3ae00273a06a2905f6cfd7b10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2947c72dbab9e7397fcfcbca4e300f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga6b2947c72dbab9e7397fcfcbca4e300f">XUartLite_DisableIntr</a>(BaseAddress)&#160;&#160;&#160;<a class="el" href="group__uartlite__v3__2.html#gacef0be395bab4e7b6c4bc8c081ebe9cf">XUartLite_SetControlReg</a>((BaseAddress), 0)</td></tr>
<tr class="memdesc:ga6b2947c72dbab9e7397fcfcbca4e300f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the device interrupt.  <a href="#ga6b2947c72dbab9e7397fcfcbca4e300f">More...</a><br /></td></tr>
<tr class="separator:ga6b2947c72dbab9e7397fcfcbca4e300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga516b36e319627a8a53a5b10b3f8fb62f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga516b36e319627a8a53a5b10b3f8fb62f">XUartLite_Handler</a>) (void *CallBackRef, unsigned int ByteCount)</td></tr>
<tr class="memdesc:ga516b36e319627a8a53a5b10b3f8fb62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function.  <a href="#ga516b36e319627a8a53a5b10b3f8fb62f">More...</a><br /></td></tr>
<tr class="separator:ga516b36e319627a8a53a5b10b3f8fb62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf61ea88e001e95175590cb5b221a18d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gaaf61ea88e001e95175590cb5b221a18d">XUartLite_CfgInitialize</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr, <a class="el" href="struct_x_uart_lite___config.html">XUartLite_Config</a> *Config, UINTPTR EffectiveAddr)</td></tr>
<tr class="memdesc:gaaf61ea88e001e95175590cb5b221a18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.  <a href="#gaaf61ea88e001e95175590cb5b221a18d">More...</a><br /></td></tr>
<tr class="separator:gaaf61ea88e001e95175590cb5b221a18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd990348cf8483d47934d3263dc6fe90"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gacd990348cf8483d47934d3263dc6fe90">XUartLite_Send</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)</td></tr>
<tr class="memdesc:gacd990348cf8483d47934d3263dc6fe90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions sends the specified buffer of data using the UART in either polled or interrupt driven modes.  <a href="#gacd990348cf8483d47934d3263dc6fe90">More...</a><br /></td></tr>
<tr class="separator:gacd990348cf8483d47934d3263dc6fe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa30ed8bfedba1acdc67dc94e77d5a41d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gaa30ed8bfedba1acdc67dc94e77d5a41d">XUartLite_Recv</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)</td></tr>
<tr class="memdesc:gaa30ed8bfedba1acdc67dc94e77d5a41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer.  <a href="#gaa30ed8bfedba1acdc67dc94e77d5a41d">More...</a><br /></td></tr>
<tr class="separator:gaa30ed8bfedba1acdc67dc94e77d5a41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7932155bf2bc603fc0a972f5aefec77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga7932155bf2bc603fc0a972f5aefec77e">XUartLite_ResetFifos</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga7932155bf2bc603fc0a972f5aefec77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the FIFOs, both transmit and receive, of the UART such that they are emptied.  <a href="#ga7932155bf2bc603fc0a972f5aefec77e">More...</a><br /></td></tr>
<tr class="separator:ga7932155bf2bc603fc0a972f5aefec77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40bc490d296a7a929f1cc5d07bb29b3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga40bc490d296a7a929f1cc5d07bb29b3c">XUartLite_IsSending</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga40bc490d296a7a929f1cc5d07bb29b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines if the specified UART is sending data.  <a href="#ga40bc490d296a7a929f1cc5d07bb29b3c">More...</a><br /></td></tr>
<tr class="separator:ga40bc490d296a7a929f1cc5d07bb29b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155b5a1fba111533992e283445ad8f73"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga155b5a1fba111533992e283445ad8f73">XUartLite_SendBuffer</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga155b5a1fba111533992e283445ad8f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends a buffer that has been previously specified by setting up the instance variables of the instance.  <a href="#ga155b5a1fba111533992e283445ad8f73">More...</a><br /></td></tr>
<tr class="separator:ga155b5a1fba111533992e283445ad8f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74efaecba1b6b1406c8c82abbb628cc8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga74efaecba1b6b1406c8c82abbb628cc8">XUartLite_ReceiveBuffer</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga74efaecba1b6b1406c8c82abbb628cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function receives a buffer that has been previously specified by setting up the instance variables of the instance.  <a href="#ga74efaecba1b6b1406c8c82abbb628cc8">More...</a><br /></td></tr>
<tr class="separator:ga74efaecba1b6b1406c8c82abbb628cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1026cbafbd78e1f3a7fd0ee433d001"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gacf1026cbafbd78e1f3a7fd0ee433d001">XUartLite_Initialize</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr class="memdesc:gacf1026cbafbd78e1f3a7fd0ee433d001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.  <a href="#gacf1026cbafbd78e1f3a7fd0ee433d001">More...</a><br /></td></tr>
<tr class="separator:gacf1026cbafbd78e1f3a7fd0ee433d001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081d00a44aeebe19ed77e195a063b4e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga081d00a44aeebe19ed77e195a063b4e1">XUartLite_GetStats</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr, <a class="el" href="struct_x_uart_lite___stats.html">XUartLite_Stats</a> *StatsPtr)</td></tr>
<tr class="memdesc:ga081d00a44aeebe19ed77e195a063b4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a snapshot of the current statistics in the structure specified.  <a href="#ga081d00a44aeebe19ed77e195a063b4e1">More...</a><br /></td></tr>
<tr class="separator:ga081d00a44aeebe19ed77e195a063b4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33651bc4c0c36496d86038d95f39f0cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga33651bc4c0c36496d86038d95f39f0cd">XUartLite_ClearStats</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga33651bc4c0c36496d86038d95f39f0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function zeros the statistics for the given instance.  <a href="#ga33651bc4c0c36496d86038d95f39f0cd">More...</a><br /></td></tr>
<tr class="separator:ga33651bc4c0c36496d86038d95f39f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfbfaddf9ab531ff85a1c4f9036631aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gabfbfaddf9ab531ff85a1c4f9036631aa">XUartLite_SelfTest</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:gabfbfaddf9ab531ff85a1c4f9036631aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a self-test on the device hardware.  <a href="#gabfbfaddf9ab531ff85a1c4f9036631aa">More...</a><br /></td></tr>
<tr class="separator:gabfbfaddf9ab531ff85a1c4f9036631aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca08a21fa15779ce8dedd2ac9f25971e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gaca08a21fa15779ce8dedd2ac9f25971e">XUartLite_EnableInterrupt</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaca08a21fa15779ce8dedd2ac9f25971e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the UART interrupt such that an interrupt will occur when data is received or data has been transmitted.  <a href="#gaca08a21fa15779ce8dedd2ac9f25971e">More...</a><br /></td></tr>
<tr class="separator:gaca08a21fa15779ce8dedd2ac9f25971e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1b67ac0d2f5bf69ce6084ea49cef39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gaaa1b67ac0d2f5bf69ce6084ea49cef39">XUartLite_DisableInterrupt</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaaa1b67ac0d2f5bf69ce6084ea49cef39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the UART interrupt.  <a href="#gaaa1b67ac0d2f5bf69ce6084ea49cef39">More...</a><br /></td></tr>
<tr class="separator:gaaa1b67ac0d2f5bf69ce6084ea49cef39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312d1ce48b9e29e08ebb25d942b2ff51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga312d1ce48b9e29e08ebb25d942b2ff51">XUartLite_SetRecvHandler</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr, <a class="el" href="group__uartlite__v3__2.html#ga516b36e319627a8a53a5b10b3f8fb62f">XUartLite_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:ga312d1ce48b9e29e08ebb25d942b2ff51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handler that will be called when an event (interrupt) occurs in the driver.  <a href="#ga312d1ce48b9e29e08ebb25d942b2ff51">More...</a><br /></td></tr>
<tr class="separator:ga312d1ce48b9e29e08ebb25d942b2ff51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282cca48bbd4c1144c811681854fc780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga282cca48bbd4c1144c811681854fc780">XUartLite_SetSendHandler</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr, <a class="el" href="group__uartlite__v3__2.html#ga516b36e319627a8a53a5b10b3f8fb62f">XUartLite_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:ga282cca48bbd4c1144c811681854fc780"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handler that will be called when an event (interrupt) occurs in the driver.  <a href="#ga282cca48bbd4c1144c811681854fc780">More...</a><br /></td></tr>
<tr class="separator:ga282cca48bbd4c1144c811681854fc780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399463f89d7b4e846a4a4089e9cd54fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga399463f89d7b4e846a4a4089e9cd54fb">XUartLite_InterruptHandler</a> (<a class="el" href="struct_x_uart_lite.html">XUartLite</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga399463f89d7b4e846a4a4089e9cd54fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the UART lite driver.  <a href="#ga399463f89d7b4e846a4a4089e9cd54fb">More...</a><br /></td></tr>
<tr class="separator:ga399463f89d7b4e846a4a4089e9cd54fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac1bc87a3b2b3873eff73cc3b93c153d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gaac1bc87a3b2b3873eff73cc3b93c153d">XUartLite_SendByte</a> (UINTPTR BaseAddress, u8 Data)</td></tr>
<tr class="memdesc:gaac1bc87a3b2b3873eff73cc3b93c153d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions sends a single byte using the UART.  <a href="#gaac1bc87a3b2b3873eff73cc3b93c153d">More...</a><br /></td></tr>
<tr class="separator:gaac1bc87a3b2b3873eff73cc3b93c153d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cccdf9978fb4d1f7fab69a4b39e6e26"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga2cccdf9978fb4d1f7fab69a4b39e6e26">XUartLite_RecvByte</a> (UINTPTR BaseAddress)</td></tr>
<tr class="memdesc:ga2cccdf9978fb4d1f7fab69a4b39e6e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions receives a single byte using the UART.  <a href="#ga2cccdf9978fb4d1f7fab69a4b39e6e26">More...</a><br /></td></tr>
<tr class="separator:ga2cccdf9978fb4d1f7fab69a4b39e6e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga6433869fe2d0dd5e9282352ca2fce41f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_uart_lite___config.html">XUartLite_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#ga6433869fe2d0dd5e9282352ca2fce41f">XUartLite_ConfigTable</a> [XPAR_XUARTLITE_NUM_INSTANCES]</td></tr>
<tr class="memdesc:ga6433869fe2d0dd5e9282352ca2fce41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration table for UART Lite devices.  <a href="#ga6433869fe2d0dd5e9282352ca2fce41f">More...</a><br /></td></tr>
<tr class="separator:ga6433869fe2d0dd5e9282352ca2fce41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00e4300e2ccd4b82fd4414b054a589e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_uart_lite___config.html">XUartLite_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartlite__v3__2.html#gaa00e4300e2ccd4b82fd4414b054a589e">XUartLite_ConfigTable</a> []</td></tr>
<tr class="memdesc:gaa00e4300e2ccd4b82fd4414b054a589e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration table for UART Lite devices.  <a href="#gaa00e4300e2ccd4b82fd4414b054a589e">More...</a><br /></td></tr>
<tr class="separator:gaa00e4300e2ccd4b82fd4414b054a589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6b2947c72dbab9e7397fcfcbca4e300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b2947c72dbab9e7397fcfcbca4e300f">&#9670;&nbsp;</a></span>XUartLite_DisableIntr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_DisableIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__uartlite__v3__2.html#gacef0be395bab4e7b6c4bc8c081ebe9cf">XUartLite_SetControlReg</a>((BaseAddress), 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>

<p>Disable the device interrupt. </p>
<p>We cannot read the control register, so we just clear all bits. Since the only other ones are the FIFO reset bits, this works without side effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: void <a class="el" href="group__uartlite__v3__2.html#ga6b2947c72dbab9e7397fcfcbca4e300f" title="Disable the device interrupt. ">XUartLite_DisableIntr(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a id="ga60612a3ae00273a06a2905f6cfd7b10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60612a3ae00273a06a2905f6cfd7b10f">&#9670;&nbsp;</a></span>XUartLite_EnableIntr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_EnableIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__uartlite__v3__2.html#gacef0be395bab4e7b6c4bc8c081ebe9cf">XUartLite_SetControlReg</a>((BaseAddress), XUL_CR_ENABLE_INTR)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>

<p>Enable the device interrupt. </p>
<p>We cannot read the control register, so we just write the enable interrupt bit and clear all others. Since the only other ones are the FIFO reset bits, this works without side effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: void <a class="el" href="group__uartlite__v3__2.html#ga60612a3ae00273a06a2905f6cfd7b10f" title="Enable the device interrupt. ">XUartLite_EnableIntr(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a id="gac2c823eabd69cc7e34fa76921ea294dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2c823eabd69cc7e34fa76921ea294dd">&#9670;&nbsp;</a></span>XUartLite_GetStatusReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_GetStatusReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6">XUartLite_ReadReg</a>((BaseAddress), XUL_STATUS_REG_OFFSET)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>

<p>Get the contents of the status register. </p>
<p>Use the XUL_SR_* constants defined above to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the status register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: u32 <a class="el" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd" title="Get the contents of the status register. ">XUartLite_GetStatusReg(u32 BaseAddress)</a>; </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__uartlite__v3__2.html#ga74efaecba1b6b1406c8c82abbb628cc8">XUartLite_ReceiveBuffer()</a>, <a class="el" href="group__uartlite__v3__2.html#gaa30ed8bfedba1acdc67dc94e77d5a41d">XUartLite_Recv()</a>, <a class="el" href="group__uartlite__v3__2.html#gacd990348cf8483d47934d3263dc6fe90">XUartLite_Send()</a>, and <a class="el" href="group__uartlite__v3__2.html#ga155b5a1fba111533992e283445ad8f73">XUartLite_SendBuffer()</a>.</p>

</div>
</div>
<a id="gafa2025650e6a0618c0527ca224fe3db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa2025650e6a0618c0527ca224fe3db3">&#9670;&nbsp;</a></span>XUartLite_IsIntrEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_IsIntrEnabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a>((BaseAddress)) &amp; XUL_SR_INTR_ENABLED) == \</div><div class="line">          XUL_SR_INTR_ENABLED)</div><div class="ttc" id="group__uartlite__v3__2_html_gac2c823eabd69cc7e34fa76921ea294dd"><div class="ttname"><a href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a></div><div class="ttdeci">#define XUartLite_GetStatusReg(BaseAddress)</div><div class="ttdoc">Get the contents of the status register. </div><div class="ttdef"><b>Definition:</b> xuartlite_l.h:229</div></div>
</div><!-- fragment -->
<p>Check to see if the interrupt is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the interrupt is enabled, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: int <a class="el" href="group__uartlite__v3__2.html#gafa2025650e6a0618c0527ca224fe3db3" title="Check to see if the interrupt is enabled. ">XUartLite_IsIntrEnabled(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a id="gad03599e323029e7b9263f1bd458cd5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad03599e323029e7b9263f1bd458cd5ce">&#9670;&nbsp;</a></span>XUartLite_IsReceiveEmpty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_IsReceiveEmpty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a>((BaseAddress)) &amp; XUL_SR_RX_FIFO_VALID_DATA) != \</div><div class="line">        XUL_SR_RX_FIFO_VALID_DATA)</div><div class="ttc" id="group__uartlite__v3__2_html_gac2c823eabd69cc7e34fa76921ea294dd"><div class="ttname"><a href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a></div><div class="ttdeci">#define XUartLite_GetStatusReg(BaseAddress)</div><div class="ttdoc">Get the contents of the status register. </div><div class="ttdef"><b>Definition:</b> xuartlite_l.h:229</div></div>
</div><!-- fragment -->
<p>Check to see if the receiver has data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the receiver is empty, FALSE if there is data present.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: int <a class="el" href="group__uartlite__v3__2.html#gad03599e323029e7b9263f1bd458cd5ce" title="Check to see if the receiver has data. ">XUartLite_IsReceiveEmpty(u32 BaseAddress)</a>; </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__uartlite__v3__2.html#ga2cccdf9978fb4d1f7fab69a4b39e6e26">XUartLite_RecvByte()</a>.</p>

</div>
</div>
<a id="ga63565710e31e2c07851858e835016086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63565710e31e2c07851858e835016086">&#9670;&nbsp;</a></span>XUartLite_IsTransmitFull</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_IsTransmitFull</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a>((BaseAddress)) &amp; XUL_SR_TX_FIFO_FULL) == \</div><div class="line">          XUL_SR_TX_FIFO_FULL)</div><div class="ttc" id="group__uartlite__v3__2_html_gac2c823eabd69cc7e34fa76921ea294dd"><div class="ttname"><a href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a></div><div class="ttdeci">#define XUartLite_GetStatusReg(BaseAddress)</div><div class="ttdoc">Get the contents of the status register. </div><div class="ttdef"><b>Definition:</b> xuartlite_l.h:229</div></div>
</div><!-- fragment -->
<p>Check to see if the transmitter is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the transmitter is full, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: int <a class="el" href="group__uartlite__v3__2.html#ga63565710e31e2c07851858e835016086" title="Check to see if the transmitter is full. ">XUartLite_IsTransmitFull(u32 BaseAddress)</a>; </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__uartlite__v3__2.html#gaac1bc87a3b2b3873eff73cc3b93c153d">XUartLite_SendByte()</a>.</p>

</div>
</div>
<a id="ga41431b69c8c2c2829277a851d70b7bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41431b69c8c2c2829277a851d70b7bf6">&#9670;&nbsp;</a></span>XUartLite_ReadReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XUartLite_In32((BaseAddress) + (RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>

<p>Read a value from a UartLite register. </p>
<p>A 32 bit read is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the UartLite device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset from the base to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data read from the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6" title="Read a value from a UartLite register. ">XUartLite_ReadReg(u32 BaseAddress, u32 RegOffset)</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__uartlite__v3__2.html#ga399463f89d7b4e846a4a4089e9cd54fb">XUartLite_InterruptHandler()</a>, <a class="el" href="group__uartlite__v3__2.html#ga40bc490d296a7a929f1cc5d07bb29b3c">XUartLite_IsSending()</a>, <a class="el" href="group__uartlite__v3__2.html#ga2cccdf9978fb4d1f7fab69a4b39e6e26">XUartLite_RecvByte()</a>, <a class="el" href="group__uartlite__v3__2.html#ga7932155bf2bc603fc0a972f5aefec77e">XUartLite_ResetFifos()</a>, and <a class="el" href="group__uartlite__v3__2.html#gabfbfaddf9ab531ff85a1c4f9036631aa">XUartLite_SelfTest()</a>.</p>

</div>
</div>
<a id="gacef0be395bab4e7b6c4bc8c081ebe9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef0be395bab4e7b6c4bc8c081ebe9cf">&#9670;&nbsp;</a></span>XUartLite_SetControlReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_SetControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>((BaseAddress), XUL_CONTROL_REG_OFFSET, (Mask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>

<p>Set the contents of the control register. </p>
<p>Use the XUL_CR_* constants defined above to create the bit-mask to be written to the register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 32-bit value to write to the control register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: void <a class="el" href="group__uartlite__v3__2.html#gacef0be395bab4e7b6c4bc8c081ebe9cf" title="Set the contents of the control register. ">XUartLite_SetControlReg(u32 BaseAddress, u32 Mask)</a>; </dd></dl>

</div>
</div>
<a id="gacb96d217d7b77e8d517e9556d421db95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb96d217d7b77e8d517e9556d421db95">&#9670;&nbsp;</a></span>XUartLite_WriteReg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUartLite_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XUartLite_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8h.html">xuartlite_l.h</a>&gt;</code></p>

<p>Write a value to a UartLite register. </p>
<p>A 32 bit write is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the UartLite device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset from the base to write to. </td></tr>
    <tr><td class="paramname">Data</td><td>is the data written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void XUartLite_WriteReg(u32 BaseAddress, u32 RegOffset, u32 Data) </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__uartlite__v3__2.html#gaaa1b67ac0d2f5bf69ce6084ea49cef39">XUartLite_DisableInterrupt()</a>, <a class="el" href="group__uartlite__v3__2.html#gaca08a21fa15779ce8dedd2ac9f25971e">XUartLite_EnableInterrupt()</a>, <a class="el" href="group__uartlite__v3__2.html#ga74efaecba1b6b1406c8c82abbb628cc8">XUartLite_ReceiveBuffer()</a>, <a class="el" href="group__uartlite__v3__2.html#gaa30ed8bfedba1acdc67dc94e77d5a41d">XUartLite_Recv()</a>, <a class="el" href="group__uartlite__v3__2.html#gacd990348cf8483d47934d3263dc6fe90">XUartLite_Send()</a>, <a class="el" href="group__uartlite__v3__2.html#ga155b5a1fba111533992e283445ad8f73">XUartLite_SendBuffer()</a>, and <a class="el" href="group__uartlite__v3__2.html#gaac1bc87a3b2b3873eff73cc3b93c153d">XUartLite_SendByte()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga516b36e319627a8a53a5b10b3f8fb62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga516b36e319627a8a53a5b10b3f8fb62f">&#9670;&nbsp;</a></span>XUartLite_Handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XUartLite_Handler) (void *CallBackRef, unsigned int ByteCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>Callback function. </p>
<p>The first argument is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. The second argument is the ByteCount which is the number of bytes that actually moved from/to the buffer provided in the _Send/_Receive call. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaf61ea88e001e95175590cb5b221a18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf61ea88e001e95175590cb5b221a18d">&#9670;&nbsp;</a></span>XUartLite_CfgInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartLite_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite___config.html">XUartLite_Config</a> *&#160;</td>
          <td class="paramname"><em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8c.html">xuartlite.c</a>&gt;</code></p>

<p>Initialize a <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. </p>
<p>The receive and transmit FIFOs of the UART are not flushed, so the user may want to flush them. The hardware device does not have any way to disable the receiver such that any valid data may be present in the receive FIFO. This function disables the UART interrupt. The baudrate and format of the data are fixed in the hardware at hardware build time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. </td></tr>
    <tr><td class="paramname">Config</td><td>is a reference to a structure containing information about a specific UART Lite device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if everything starts up as expected.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Config pointer argument is not used by this function, but is provided to keep the function signature consistent with other drivers. </dd></dl>

</div>
</div>
<a id="ga33651bc4c0c36496d86038d95f39f0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33651bc4c0c36496d86038d95f39f0cd">&#9670;&nbsp;</a></span>XUartLite_ClearStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>This function zeros the statistics for the given instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_uart_lite___stats.html#a419c9a4c527458f4ca8e681fa300160f">XUartLite_Stats::CharactersReceived</a>, <a class="el" href="struct_x_uart_lite___stats.html#a2835184ffdbb9eb956f475f71460c699">XUartLite_Stats::CharactersTransmitted</a>, <a class="el" href="struct_x_uart_lite___stats.html#ad78aa2351dfb161a2651a4229137e5e9">XUartLite_Stats::ReceiveFramingErrors</a>, <a class="el" href="struct_x_uart_lite___stats.html#a5aa85c00c96797e499040c43f000b458">XUartLite_Stats::ReceiveInterrupts</a>, <a class="el" href="struct_x_uart_lite___stats.html#af82d51917660948cd9fd5860ee1c9e00">XUartLite_Stats::ReceiveOverrunErrors</a>, <a class="el" href="struct_x_uart_lite___stats.html#a54e9bfc44f29f17020ed86b0eba6da86">XUartLite_Stats::ReceiveParityErrors</a>, and <a class="el" href="struct_x_uart_lite___stats.html#a046cc0881c445ef40f27140e19e2c174">XUartLite_Stats::TransmitInterrupts</a>.</p>

</div>
</div>
<a id="gaaa1b67ac0d2f5bf69ce6084ea49cef39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1b67ac0d2f5bf69ce6084ea49cef39">&#9670;&nbsp;</a></span>XUartLite_DisableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_DisableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>This function disables the UART interrupt. </p>
<p>After calling this function, data may still be received by the UART but no interrupt will be generated since the hardware device has no way to disable the receiver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>.</p>

</div>
</div>
<a id="gaca08a21fa15779ce8dedd2ac9f25971e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca08a21fa15779ce8dedd2ac9f25971e">&#9670;&nbsp;</a></span>XUartLite_EnableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_EnableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>This function enables the UART interrupt such that an interrupt will occur when data is received or data has been transmitted. </p>
<p>The device contains 16 byte receive and transmit FIFOs such that an interrupt is generated anytime there is data in the receive FIFO and when the transmit FIFO transitions from not empty to empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="xuartlite__intr__example_8c.html#a189cb51308d09a387e9b48d5fee44136">UartLiteIntrExample()</a>.</p>

</div>
</div>
<a id="ga081d00a44aeebe19ed77e195a063b4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081d00a44aeebe19ed77e195a063b4e1">&#9670;&nbsp;</a></span>XUartLite_GetStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite___stats.html">XUartLite_Stats</a> *&#160;</td>
          <td class="paramname"><em>StatsPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>Returns a snapshot of the current statistics in the structure specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. </td></tr>
    <tr><td class="paramname">StatsPtr</td><td>is a pointer to a XUartLiteStats structure to where the statistics are to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_uart_lite___stats.html#a419c9a4c527458f4ca8e681fa300160f">XUartLite_Stats::CharactersReceived</a>, <a class="el" href="struct_x_uart_lite___stats.html#a2835184ffdbb9eb956f475f71460c699">XUartLite_Stats::CharactersTransmitted</a>, <a class="el" href="struct_x_uart_lite___stats.html#ad78aa2351dfb161a2651a4229137e5e9">XUartLite_Stats::ReceiveFramingErrors</a>, <a class="el" href="struct_x_uart_lite___stats.html#a5aa85c00c96797e499040c43f000b458">XUartLite_Stats::ReceiveInterrupts</a>, <a class="el" href="struct_x_uart_lite___stats.html#af82d51917660948cd9fd5860ee1c9e00">XUartLite_Stats::ReceiveOverrunErrors</a>, <a class="el" href="struct_x_uart_lite___stats.html#a54e9bfc44f29f17020ed86b0eba6da86">XUartLite_Stats::ReceiveParityErrors</a>, and <a class="el" href="struct_x_uart_lite___stats.html#a046cc0881c445ef40f27140e19e2c174">XUartLite_Stats::TransmitInterrupts</a>.</p>

</div>
</div>
<a id="gacf1026cbafbd78e1f3a7fd0ee433d001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf1026cbafbd78e1f3a7fd0ee433d001">&#9670;&nbsp;</a></span>XUartLite_Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartLite_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>Initialize a <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. </p>
<p>The receive and transmit FIFOs of the UART are not flushed, so the user may want to flush them. The hardware device does not have any way to disable the receiver such that any valid data may be present in the receive FIFO. This function disables the UART interrupt. The baudrate and format of the data are fixed in the hardware at hardware build time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. </td></tr>
    <tr><td class="paramname">DeviceId</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if everything starts up as expected.</li>
<li>XST_DEVICE_NOT_FOUND if the device is not found in the configuration table.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">Referenced by <a class="el" href="xuartlite__intr__example_8c.html#a189cb51308d09a387e9b48d5fee44136">UartLiteIntrExample()</a>, <a class="el" href="xuartlite__polled__example_8c.html#a607e1a223534673ff024c2941e59f2ff">UartLitePolledExample()</a>, and <a class="el" href="xuartlite__selftest__example_8c.html#a5c80f36afa14fc3e704c714ba8b80278">UartLiteSelfTestExample()</a>.</p>

</div>
</div>
<a id="ga399463f89d7b4e846a4a4089e9cd54fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399463f89d7b4e846a4a4089e9cd54fb">&#9670;&nbsp;</a></span>XUartLite_InterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>This function is the interrupt handler for the UART lite driver. </p>
<p>It must be connected to an interrupt system by the user such that it is called when an interrupt for any UART lite occurs. This function does not save or restore the processor context such that the user must ensure this occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>contains a pointer to the instance of the UART that the interrupt is for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6">XUartLite_ReadReg</a>.</p>

</div>
</div>
<a id="ga40bc490d296a7a929f1cc5d07bb29b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40bc490d296a7a929f1cc5d07bb29b3c">&#9670;&nbsp;</a></span>XUartLite_IsSending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartLite_IsSending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8c.html">xuartlite.c</a>&gt;</code></p>

<p>This function determines if the specified UART is sending data. </p>
<p>If the transmitter register is not empty, it is sending data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of TRUE if the UART is sending data, otherwise FALSE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6">XUartLite_ReadReg</a>.</p>

</div>
</div>
<a id="ga74efaecba1b6b1406c8c82abbb628cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74efaecba1b6b1406c8c82abbb628cc8">&#9670;&nbsp;</a></span>XUartLite_ReceiveBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XUartLite_ReceiveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8c.html">xuartlite.c</a>&gt;</code></p>

<p>This function receives a buffer that has been previously specified by setting up the instance variables of the instance. </p>
<p>This function is designed to be an internal function for the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> component such that it may be called from a shell function that sets up the buffer or from an interrupt handler.</p>
<p>This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if there is no data has already received by the UART.</p>
<p>In a polled mode, this function will only receive as much data as the UART can buffer, either in the receiver or in the FIFO if present and enabled. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.</p>
<p>In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a>, and <a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>.</p>

</div>
</div>
<a id="gaa30ed8bfedba1acdc67dc94e77d5a41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa30ed8bfedba1acdc67dc94e77d5a41d">&#9670;&nbsp;</a></span>XUartLite_Recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XUartLite_Recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>NumBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8c.html">xuartlite.c</a>&gt;</code></p>

<p>This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. </p>
<p>This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if no data has already received by the UART.</p>
<p>In a polled mode, this function will only receive as much data as the UART can buffer in the FIFO. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.</p>
<p>In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue receiving data until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. </td></tr>
    <tr><td class="paramname">DataBufferPtr</td><td>is pointer to buffer for data to be received into. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is the number of bytes to be received. A value of zero will stop a previous receive operation that is in progress in interrupt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a>, and <a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>.</p>

</div>
</div>
<a id="ga2cccdf9978fb4d1f7fab69a4b39e6e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cccdf9978fb4d1f7fab69a4b39e6e26">&#9670;&nbsp;</a></span>XUartLite_RecvByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XUartLite_RecvByte </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8c.html">xuartlite_l.c</a>&gt;</code></p>

<p>This functions receives a single byte using the UART. </p>
<p>It is blocking in that it waits for the receiver to become non-empty before it reads from the receive register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte of data received.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#gad03599e323029e7b9263f1bd458cd5ce">XUartLite_IsReceiveEmpty</a>, and <a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6">XUartLite_ReadReg</a>.</p>

</div>
</div>
<a id="ga7932155bf2bc603fc0a972f5aefec77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7932155bf2bc603fc0a972f5aefec77e">&#9670;&nbsp;</a></span>XUartLite_ResetFifos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_ResetFifos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8c.html">xuartlite.c</a>&gt;</code></p>

<p>This function resets the FIFOs, both transmit and receive, of the UART such that they are emptied. </p>
<p>Since the UART does not have any way to disable it from receiving data, it may be necessary for the application to reset the FIFOs to get rid of any unwanted data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6">XUartLite_ReadReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__uartlite__v3__2.html#gabfbfaddf9ab531ff85a1c4f9036631aa">XUartLite_SelfTest()</a>.</p>

</div>
</div>
<a id="gabfbfaddf9ab531ff85a1c4f9036631aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfbfaddf9ab531ff85a1c4f9036631aa">&#9670;&nbsp;</a></span>XUartLite_SelfTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartLite_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>Runs a self-test on the device hardware. </p>
<p>Since there is no way to perform a loopback in the hardware, this test can only check the state of the status register to verify it is correct. This test assumes that the hardware device is still in its reset state, but has been initialized with the Initialize function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the self-test was successful.</li>
<li>XST_FAILURE if the self-test failed, the status register value was not correct</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#ga41431b69c8c2c2829277a851d70b7bf6">XUartLite_ReadReg</a>, and <a class="el" href="group__uartlite__v3__2.html#ga7932155bf2bc603fc0a972f5aefec77e">XUartLite_ResetFifos()</a>.</p>

<p class="reference">Referenced by <a class="el" href="xuartlite__intr__example_8c.html#a189cb51308d09a387e9b48d5fee44136">UartLiteIntrExample()</a>, <a class="el" href="xuartlite__polled__example_8c.html#a607e1a223534673ff024c2941e59f2ff">UartLitePolledExample()</a>, and <a class="el" href="xuartlite__selftest__example_8c.html#a5c80f36afa14fc3e704c714ba8b80278">UartLiteSelfTestExample()</a>.</p>

</div>
</div>
<a id="gacd990348cf8483d47934d3263dc6fe90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd990348cf8483d47934d3263dc6fe90">&#9670;&nbsp;</a></span>XUartLite_Send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XUartLite_Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>NumBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8c.html">xuartlite.c</a>&gt;</code></p>

<p>This functions sends the specified buffer of data using the UART in either polled or interrupt driven modes. </p>
<p>This function is non-blocking such that it will return before the data has been sent by the UART. If the UART is busy sending data, it will return and indicate zero bytes were sent.</p>
<p>In a polled mode, this function will only send as much data as the UART can buffer in the FIFO. The application may need to call it repeatedly to send a buffer.</p>
<p>In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue sending data until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. </td></tr>
    <tr><td class="paramname">DataBufferPtr</td><td>is pointer to a buffer of data to be sent. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>contains the number of bytes to be sent. A value of zero will stop a previous send operation that is in progress in interrupt mode. Any data that was already put into the transmit FIFO will be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually sent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a>, and <a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>.</p>

</div>
</div>
<a id="ga155b5a1fba111533992e283445ad8f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga155b5a1fba111533992e283445ad8f73">&#9670;&nbsp;</a></span>XUartLite_SendBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XUartLite_SendBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8c.html">xuartlite.c</a>&gt;</code></p>

<p>This function sends a buffer that has been previously specified by setting up the instance variables of the instance. </p>
<p>This function is designed to be an internal function for the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> component such that it may be called from a shell function that sets up the buffer or from an interrupt handler.</p>
<p>This function sends the specified buffer of data to the UART in either polled or interrupt driven modes. This function is non-blocking such that it will return before the data has been sent by the UART.</p>
<p>In a polled mode, this function will only send as much data as the UART can buffer, either in the transmitter or in the FIFO if present and enabled. The application may need to call it repeatedly to send a buffer.</p>
<p>In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NumBytes is the number of bytes actually sent (put into the UART transmitter and/or FIFO).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#gac2c823eabd69cc7e34fa76921ea294dd">XUartLite_GetStatusReg</a>, and <a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>.</p>

</div>
</div>
<a id="gaac1bc87a3b2b3873eff73cc3b93c153d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac1bc87a3b2b3873eff73cc3b93c153d">&#9670;&nbsp;</a></span>XUartLite_SendByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_SendByte </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__l_8c.html">xuartlite_l.c</a>&gt;</code></p>

<p>This functions sends a single byte using the UART. </p>
<p>It is blocking in that it waits for the transmitter to become non-full before it writes the byte to the transmit register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">Data</td><td>is the byte of data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__uartlite__v3__2.html#ga63565710e31e2c07851858e835016086">XUartLite_IsTransmitFull</a>, and <a class="el" href="group__uartlite__v3__2.html#gacb96d217d7b77e8d517e9556d421db95">XUartLite_WriteReg</a>.</p>

</div>
</div>
<a id="ga312d1ce48b9e29e08ebb25d942b2ff51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga312d1ce48b9e29e08ebb25d942b2ff51">&#9670;&nbsp;</a></span>XUartLite_SetRecvHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_SetRecvHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uartlite__v3__2.html#ga516b36e319627a8a53a5b10b3f8fb62f">XUartLite_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver. </p>
<p>The purpose of the handler is to allow application specific processing to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance. </td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

<p class="reference">Referenced by <a class="el" href="xuartlite__intr__example_8c.html#a189cb51308d09a387e9b48d5fee44136">UartLiteIntrExample()</a>.</p>

</div>
</div>
<a id="ga282cca48bbd4c1144c811681854fc780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282cca48bbd4c1144c811681854fc780">&#9670;&nbsp;</a></span>XUartLite_SetSendHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartLite_SetSendHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_lite.html">XUartLite</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uartlite__v3__2.html#ga516b36e319627a8a53a5b10b3f8fb62f">XUartLite_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite_8h.html">xuartlite.h</a>&gt;</code></p>

<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver. </p>
<p>The purpose of the handler is to allow application specific processing to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_uart_lite.html" title="The XUartLite driver instance data. ">XUartLite</a> instance . </td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

<p class="reference">Referenced by <a class="el" href="xuartlite__intr__example_8c.html#a189cb51308d09a387e9b48d5fee44136">UartLiteIntrExample()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga6433869fe2d0dd5e9282352ca2fce41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6433869fe2d0dd5e9282352ca2fce41f">&#9670;&nbsp;</a></span>XUartLite_ConfigTable <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_uart_lite___config.html">XUartLite_Config</a> XUartLite_ConfigTable[XPAR_XUARTLITE_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__g_8c.html">xuartlite_g.c</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">        {</div><div class="line">                XPAR_UARTLITE_0_DEVICE_ID,      </div><div class="line">                XPAR_UARTLITE_0_BASEADDR,       </div><div class="line">                XPAR_UARTLITE_0_BAUDRATE,       </div><div class="line">                XPAR_UARTLITE_0_USE_PARITY,     </div><div class="line">                XPAR_UARTLITE_0_ODD_PARITY,     </div><div class="line">                XPAR_UARTLITE_0_DATA_BITS       </div><div class="line">        },</div><div class="line">}</div></div><!-- fragment -->
<p>The configuration table for UART Lite devices. </p>

</div>
</div>
<a id="gaa00e4300e2ccd4b82fd4414b054a589e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa00e4300e2ccd4b82fd4414b054a589e">&#9670;&nbsp;</a></span>XUartLite_ConfigTable <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_uart_lite___config.html">XUartLite_Config</a> XUartLite_ConfigTable[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xuartlite__i_8h.html">xuartlite_i.h</a>&gt;</code></p>

<p>The configuration table for UART Lite devices. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
