<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>qspipsu: xqspipsu_write_protect_example.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">qspipsu
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xqspipsu__write__protect__example_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xqspipsu_write_protect_example.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This file contains a design example using the QSPIPSU driver (<a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a>) with a serial Flash device greater than or equal to 128Mb. </p>
<p>The example writes to flash and reads it back in DMA mode. This examples runs with GENFIFO Manual start. It runs in interrupt mode. This example works only with single mode and x1 or x2 data mode. This example will not work with x4 data mode and dual parallel or stacked configuration. The hardware which this example runs on, must have a serial Flash (Micron N25Q or MT25Q) for it to run. In order to test in single flash configurations the necessary HW must be present and QSPI_MODE (also reflected in ConnectionMode in the instance) has to be in sync with HW flash configuration being tested.</p>
<p>This example neither set the required MIO to control the Write Protect pin nor the driver is setting the MIO. The MIO must be configured to be used by QSPI.This example has been tested with the Micron Serial Flash (N25Q512) and ISSI Serial Flash parts of IS25WP and IS25LP series flashes in single mode using A53 and R5 processors.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who Date     Changes
</p>
<hr/>
<p>
 1.7    tjs 01/25/18 Added support to toggle the WP pin of flash. (PR#2448)
 1.7    tjs 26/03/18 In dual parallel mode enable both CS when issuing Write
                                 enable command. CR-998478
 1.8    tjs 05/02/18 Added support for IS25LP064 and IS25WP064.
 1.8    tjs 16/07/18 Added support for the low density ISSI flash parts.
 1.9    akm 02/27/19 Added support for IS25LP128, IS25WP128, IS25LP256,
                     IS25WP256, IS25LP512, IS25WP512 Flash Devices
 1.9   akm 04/03/19 Fixed data alignment warnings on IAR compiler.
 1.13  akm 11/30/20 Removed unwanted header files.
 1.15  akm 11/19/21 Fix read/write failures on Spansion flash parts.
 1.15  akm 12/22/21 Initialize variables before use.
 1.16  akm 08/16/22 Fix logical error in NumSect calculation.
 1.17  akm 12/16/22 Add timeout in QSPIPSU driver examples.
 1.18  sb  05/19/23 Update number of sector calculation logic
           in flash erase API.
 1.18  sb  06/07/23 Added support for system device-tree flow.
 1.18  sb  07/24/23 Fix wrong init sequence for spansion byte ID.
 1.18  sb  08/02/23 Add status check for XQspiPsu_SetClkPrescaler API.</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a191ca904211eda1c8b5dddc5e6a16331"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#a191ca904211eda1c8b5dddc5e6a16331">QspiPsuWriteProtectFlashExample</a> (XScuGic *IntcInstancePtr, <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuInstancePtr, u16 QspiPsuDeviceId, u16 QspiPsuIntrId)</td></tr>
<tr class="memdesc:a191ca904211eda1c8b5dddc5e6a16331"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a> device driver in single mode with x1 or x2 data mode using flash devices greater than or equal to 128Mb and drive the Write Protect pin of the flash device using GQSPI GPIO.  <a href="#a191ca904211eda1c8b5dddc5e6a16331">More...</a><br/></td></tr>
<tr class="separator:a191ca904211eda1c8b5dddc5e6a16331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c0194bd58d158581c699b8c07c309d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#ac7c0194bd58d158581c699b8c07c309d">FlashReadID</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr)</td></tr>
<tr class="memdesc:ac7c0194bd58d158581c699b8c07c309d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the flash ID and identifies the flash in FCT table.  <a href="#ac7c0194bd58d158581c699b8c07c309d">More...</a><br/></td></tr>
<tr class="separator:ac7c0194bd58d158581c699b8c07c309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#a8c7c38172a5258ee7cdfaef5a1a9af82">FlashErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases the sectors in the serial Flash connected to the QSPIPSU interface.  <a href="#a8c7c38172a5258ee7cdfaef5a1a9af82">More...</a><br/></td></tr>
<tr class="separator:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333c8e44e9af52811dee98f2cfcacf53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#a333c8e44e9af52811dee98f2cfcacf53">FlashWrite</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a333c8e44e9af52811dee98f2cfcacf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to the serial Flash connected to the QSPIPSU interface.  <a href="#a333c8e44e9af52811dee98f2cfcacf53">More...</a><br/></td></tr>
<tr class="separator:a333c8e44e9af52811dee98f2cfcacf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaad34739d0ad6d1fb5436c1d6428463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#aaaad34739d0ad6d1fb5436c1d6428463">FlashRead</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr, u8 *ReadBfrPtr)</td></tr>
<tr class="memdesc:aaaad34739d0ad6d1fb5436c1d6428463"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a read.  <a href="#aaaad34739d0ad6d1fb5436c1d6428463">More...</a><br/></td></tr>
<tr class="separator:aaaad34739d0ad6d1fb5436c1d6428463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45c38b76bbabbaf848a33cdc889ebfb"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#af45c38b76bbabbaf848a33cdc889ebfb">GetRealAddr</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address)</td></tr>
<tr class="memdesc:af45c38b76bbabbaf848a33cdc889ebfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions translates the address based on the type of interconnection.  <a href="#af45c38b76bbabbaf848a33cdc889ebfb">More...</a><br/></td></tr>
<tr class="separator:af45c38b76bbabbaf848a33cdc889ebfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#a4f09bf044ed26b11fc5489cb7b7ca1e6">BulkErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a bulk erase operation when the flash device has a single die.  <a href="#a4f09bf044ed26b11fc5489cb7b7ca1e6">More...</a><br/></td></tr>
<tr class="separator:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d8ab88e6002a97c30b95b66db231ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#a97d8ab88e6002a97c30b95b66db231ea">DieErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a97d8ab88e6002a97c30b95b66db231ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a die erase operation on all the die in the flash device.  <a href="#a97d8ab88e6002a97c30b95b66db231ea">More...</a><br/></td></tr>
<tr class="separator:a97d8ab88e6002a97c30b95b66db231ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48231ad0042a647ddbcf702df748d1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#a48231ad0042a647ddbcf702df748d1a4">QspiPsuHandler</a> (void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)</td></tr>
<tr class="memdesc:a48231ad0042a647ddbcf702df748d1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback handler.  <a href="#a48231ad0042a647ddbcf702df748d1a4">More...</a><br/></td></tr>
<tr class="separator:a48231ad0042a647ddbcf702df748d1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d1767607b58391ccb2d0103c2fd456"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#ae8d1767607b58391ccb2d0103c2fd456">FlashEnterExit4BAddMode</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, unsigned int Enable)</td></tr>
<tr class="memdesc:ae8d1767607b58391ccb2d0103c2fd456"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enters the flash device into 4 bytes addressing mode.  <a href="#ae8d1767607b58391ccb2d0103c2fd456">More...</a><br/></td></tr>
<tr class="separator:ae8d1767607b58391ccb2d0103c2fd456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#a83a78784f5ba39b5e76b17a7e4a5ecad">FlashEnableQuadMode</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr)</td></tr>
<tr class="memdesc:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables Quad mode for the flash parts which require to enable quad mode before using Quad commands.  <a href="#a83a78784f5ba39b5e76b17a7e4a5ecad">More...</a><br/></td></tr>
<tr class="separator:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__write__protect__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr class="memdesc:a840291bc02cba5474a4cb46a9b9566fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to call the QSPIPSU Flash example.  <a href="#a840291bc02cba5474a4cb46a9b9566fe">More...</a><br/></td></tr>
<tr class="separator:a840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4f09bf044ed26b11fc5489cb7b7ca1e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BulkErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a bulk erase operation when the flash device has a single die. </p>
<p>Works for both Spansion and Micron</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a97d8ab88e6002a97c30b95b66db231ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DieErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a die erase operation on all the die in the flash device. </p>
<p>This function uses the die erase command for Micron 512Mbit and 1Gbit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a83a78784f5ba39b5e76b17a7e4a5ecad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashEnableQuadMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables Quad mode for the flash parts which require to enable quad mode before using Quad commands. </p>
<p>For S25FL-L series flash parts this is required as the default configuration is x1/x2 mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae8d1767607b58391ccb2d0103c2fd456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashEnterExit4BAddMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enters the flash device into 4 bytes addressing mode. </p>
<p>As per the Micron and ISSI spec, before issuing the command to enter into 4 byte addr mode, a write enable command is issued. For Macronix and Winbond flash parts write enable is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Enable</td><td>is a either 1 or 0 if 1 then enters 4 byte if 0 exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8c7c38172a5258ee7cdfaef5a1a9af82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases the sectors in the serial Flash connected to the QSPIPSU interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is pointer to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaad34739d0ad6d1fb5436c1d6428463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a read. </p>
<p>Default setting is in DMA mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to read data from the flash. Supports normal, fast, dual and quad read commands. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is pointer to the write buffer which contains data to be transmitted </td></tr>
    <tr><td class="paramname">ReadBfrPtr</td><td>is pointer to the read buffer to which valid received data should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7c0194bd58d158581c699b8c07c309d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashReadID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the flash ID and identifies the flash in FCT table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a333c8e44e9af52811dee98f2cfcacf53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to the serial Flash connected to the QSPIPSU interface. </p>
<p>All the data put into the buffer must be in the same page of the device with page boundaries being on 256 byte boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address to write data to in the Flash. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to write. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to write data to the flash. QSPIPSU device supports only Page Program command to write data to the flash. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is pointer to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af45c38b76bbabbaf848a33cdc889ebfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 GetRealAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions translates the address based on the type of interconnection. </p>
<p>In case of stacked, this function asserts the corresponding slave select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>which is to be accessed (for erase, write or read)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RealAddr is the translated address - for single it is unchanged; for stacked, the lower flash size is subtracted; for parallel the address is divided by 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In addition to get the actual address to work on flash this function also selects the CS and BUS based on the configuration detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a840291bc02cba5474a4cb46a9b9566fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to call the QSPIPSU Flash example. </p>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, otherwise XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="xqspipsu__write__protect__example_8c.html#a191ca904211eda1c8b5dddc5e6a16331">QspiPsuWriteProtectFlashExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a48231ad0042a647ddbcf702df748d1a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QspiPsuHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>StatusEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td class="paramname">StatusEvent</td><td>is the event that just occurred. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>is the number of bytes transferred up until the event occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a191ca904211eda1c8b5dddc5e6a16331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QspiPsuWriteProtectFlashExample </td>
          <td>(</td>
          <td class="paramtype">XScuGic *&#160;</td>
          <td class="paramname"><em>IntcInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>QspiPsuDeviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>QspiPsuIntrId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a> device driver in single mode with x1 or x2 data mode using flash devices greater than or equal to 128Mb and drive the Write Protect pin of the flash device using GQSPI GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IntcInstancePtr</td><td>is a pointer to the instance of the Intc device. </td></tr>
    <tr><td class="paramname">QspiPsuInstancePtr</td><td>is a pointer to the instance of the QspiPsu device. </td></tr>
    <tr><td class="paramname">QspiPsuDeviceId</td><td>is the Device ID of the Qspi Device and is the XPAR_&lt;QSPI_instance&gt;_DEVICE_ID value from xparameters.h. </td></tr>
    <tr><td class="paramname">QspiPsuIntrId</td><td>is the interrupt Id for an QSPIPSU device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_qspi_psu___config.html#a4048264c3ac6b3455c0295eeacac874b">XQspiPsu_Config::BaseAddress</a>, <a class="el" href="struct_x_qspi_psu___config.html#afb9b153a78b4112212d7850efd1c6add">XQspiPsu_Config::BusWidth</a>, <a class="el" href="struct_x_qspi_psu.html#a9b3aa272eb335fecaaa8f47fd2ed9241">XQspiPsu::Config</a>, <a class="el" href="struct_x_qspi_psu___config.html#aa771e1e018426eb1f68fe5241ed45e71">XQspiPsu_Config::ConnectionMode</a>, <a class="el" href="xqspipsu__generic__flash__interrupt__example_8c.html#ae8d1767607b58391ccb2d0103c2fd456">FlashEnterExit4BAddMode()</a>, <a class="el" href="xqspipsu__generic__flash__interrupt__example_8c.html#a8c7c38172a5258ee7cdfaef5a1a9af82">FlashErase()</a>, <a class="el" href="xqspipsu__generic__flash__interrupt__example_8c.html#aaaad34739d0ad6d1fb5436c1d6428463">FlashRead()</a>, <a class="el" href="xqspipsu__generic__flash__interrupt__example_8c.html#ac7c0194bd58d158581c699b8c07c309d">FlashReadID()</a>, <a class="el" href="xqspipsu__generic__flash__interrupt__example_8c.html#a333c8e44e9af52811dee98f2cfcacf53">FlashWrite()</a>, <a class="el" href="xqspipsu__generic__flash__interrupt__example_8c.html#a48231ad0042a647ddbcf702df748d1a4">QspiPsuHandler()</a>, <a class="el" href="group__qspipsu.html#ga803eccd67d1dfde416b54488865c1e9d">XQspiPsu_CfgInitialize()</a>, <a class="el" href="group__qspipsu.html#ga37ca68c0fddda883028f393eb5626437">XQSPIPSU_CLK_PRESCALE_8</a>, <a class="el" href="group__qspipsu.html#ga493629a6f3d8fb0312dbcaf3e9cbe0e8">XQSPIPSU_CONNECTION_MODE_PARALLEL</a>, <a class="el" href="group__qspipsu.html#gaa345ea3ab3694a94a60e6217cb8d5e59">XQspiPsu_InterruptHandler()</a>, <a class="el" href="group__qspipsu.html#gafd84d3f23643ccbcbd4637f786ba48fa">XQspiPsu_LookupConfig()</a>, <a class="el" href="group__qspipsu.html#ga47c246bab4c5d4f6c8ff84e44049adc9">XQSPIPSU_MANUAL_START_OPTION</a>, <a class="el" href="group__qspipsu.html#ga2d896ad5edf8b15e6dbd4d7a87517a35">XQSPIPSU_SELECT_FLASH_BUS_LOWER</a>, <a class="el" href="group__qspipsu.html#ga4c5dd4c0387f6ae12a78b86c653bb74d">XQSPIPSU_SELECT_FLASH_CS_LOWER</a>, <a class="el" href="group__qspipsu.html#ga28338ae42ed4f7d2685ab18de2d21128">XQspiPsu_SelectFlash()</a>, <a class="el" href="group__qspipsu.html#ga9d60815d3d62d01558f5ece03f79da51">XQSPIPSU_SET_WP</a>, <a class="el" href="group__qspipsu.html#ga9b86ec1c50d3af19b922698fa9ba7dfb">XQspiPsu_SetClkPrescaler()</a>, <a class="el" href="group__qspipsu.html#gad0fea713a1ec2a4ce6159439e30f7cd7">XQspiPsu_SetOptions()</a>, <a class="el" href="group__qspipsu.html#ga02ea5e95c8939c2be78d26c255a6ba6f">XQspiPsu_SetStatusHandler()</a>, <a class="el" href="group__qspipsu.html#ga54cce449d0bda6133fe2c254a164e08e">XQspiPsu_SetWP()</a>, and <a class="el" href="group__qspipsu.html#ga0ec97b3d7c6cb24544f0bfa8114b56d7">XQspiPsu_WriteProtectToggle()</a>.</p>

<p>Referenced by <a class="el" href="xqspipsu__write__protect__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
