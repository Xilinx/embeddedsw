<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>qspipsu: xqspipsu_generic_flash_polled_example.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">qspipsu
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xqspipsu__generic__flash__polled__example_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xqspipsu_generic_flash_polled_example.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This file contains a design example using the QSPIPSU driver (<a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a>) with a serial Flash device greater than or equal to 128Mb. </p>
<p>The example writes to flash and reads it back in DMA mode. This examples runs with GENFIFO Manual start. It runs in polled mode. This example illustrates single, parallel and stacked modes. Both the flash devices have to be of the same make and size. The hardware which this example runs on, must have a serial Flash (Micron N25Q or Spansion S25FL) for it to run. In order to test in single, parallel or stacked flash configurations the necessary HW must be present and QSPI_MODE (also reflected in ConnectionMode in the instance) has to be in sync with HW flash configuration being tested.</p>
<p>This example has been tested with the Micron Serial Flash (N25Q512) in single and parallel modes using A53 and R5 processors.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None.</p>
<pre>
  MODIFICATION HISTORY:</pre><pre>  Ver   Who Date     Changes
<hr/>

  1.0   hk  08/21/14 First release
        sk  06/17/15 Used Tx/Rx flags for Transmitting/Receiving.
                sk  11/23/15 Added Support for Macronix 1Gb part.
        ms  04/05/17 Modified Comment lines in functions to
                     recognize it as documentation block for doxygen
                     generation.
  1.1   tjs     06/16/17 Added support for IS25LP256D flash part (PR-4650)
*</pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac7a0e7a44578f580f46491eb6f6ce726"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#ac7a0e7a44578f580f46491eb6f6ce726">QspiPsuPolledFlashExample</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuInstancePtr, u16 QspiPsuDeviceId)</td></tr>
<tr class="memdesc:ac7a0e7a44578f580f46491eb6f6ce726"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a> device driver in single, parallel and stacked modes using flash devices greater than or equal to 128Mb.  <a href="#ac7a0e7a44578f580f46491eb6f6ce726">More...</a><br /></td></tr>
<tr class="separator:ac7a0e7a44578f580f46491eb6f6ce726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c0194bd58d158581c699b8c07c309d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#ac7c0194bd58d158581c699b8c07c309d">FlashReadID</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr)</td></tr>
<tr class="memdesc:ac7c0194bd58d158581c699b8c07c309d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the flash ID and identifies the flash in FCT table.  <a href="#ac7c0194bd58d158581c699b8c07c309d">More...</a><br /></td></tr>
<tr class="separator:ac7c0194bd58d158581c699b8c07c309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a8c7c38172a5258ee7cdfaef5a1a9af82">FlashErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases the sectors in the serial Flash connected to the QSPIPSU interface.  <a href="#a8c7c38172a5258ee7cdfaef5a1a9af82">More...</a><br /></td></tr>
<tr class="separator:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333c8e44e9af52811dee98f2cfcacf53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a333c8e44e9af52811dee98f2cfcacf53">FlashWrite</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a333c8e44e9af52811dee98f2cfcacf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to the serial Flash connected to the QSPIPSU interface.  <a href="#a333c8e44e9af52811dee98f2cfcacf53">More...</a><br /></td></tr>
<tr class="separator:a333c8e44e9af52811dee98f2cfcacf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaad34739d0ad6d1fb5436c1d6428463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#aaaad34739d0ad6d1fb5436c1d6428463">FlashRead</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr, u8 *ReadBfrPtr)</td></tr>
<tr class="memdesc:aaaad34739d0ad6d1fb5436c1d6428463"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs read.  <a href="#aaaad34739d0ad6d1fb5436c1d6428463">More...</a><br /></td></tr>
<tr class="separator:aaaad34739d0ad6d1fb5436c1d6428463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45c38b76bbabbaf848a33cdc889ebfb"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#af45c38b76bbabbaf848a33cdc889ebfb">GetRealAddr</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address)</td></tr>
<tr class="memdesc:af45c38b76bbabbaf848a33cdc889ebfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions translates the address based on the type of interconnection.  <a href="#af45c38b76bbabbaf848a33cdc889ebfb">More...</a><br /></td></tr>
<tr class="separator:af45c38b76bbabbaf848a33cdc889ebfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a4f09bf044ed26b11fc5489cb7b7ca1e6">BulkErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a bulk erase operation when the flash device has a single die.  <a href="#a4f09bf044ed26b11fc5489cb7b7ca1e6">More...</a><br /></td></tr>
<tr class="separator:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d8ab88e6002a97c30b95b66db231ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a97d8ab88e6002a97c30b95b66db231ea">DieErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a97d8ab88e6002a97c30b95b66db231ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a die erase operation on all the die in the flash device.  <a href="#a97d8ab88e6002a97c30b95b66db231ea">More...</a><br /></td></tr>
<tr class="separator:a97d8ab88e6002a97c30b95b66db231ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e40a81a572bfacbf4d7a39af7905cea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a5e40a81a572bfacbf4d7a39af7905cea">FlashRegisterRead</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 ByteCount, u8 Command, u8 *ReadBfrPtr)</td></tr>
<tr class="memdesc:a5e40a81a572bfacbf4d7a39af7905cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API can be used to write to a flash register.  <a href="#a5e40a81a572bfacbf4d7a39af7905cea">More...</a><br /></td></tr>
<tr class="separator:a5e40a81a572bfacbf4d7a39af7905cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b70ac0045f51c4babd8709e1c030752"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a5b70ac0045f51c4babd8709e1c030752">FlashRegisterWrite</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 ByteCount, u8 Command, u8 *WriteBfrPtr, u8 WrEn)</td></tr>
<tr class="memdesc:a5b70ac0045f51c4babd8709e1c030752"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API can be used to write to a flash register.  <a href="#a5b70ac0045f51c4babd8709e1c030752">More...</a><br /></td></tr>
<tr class="separator:a5b70ac0045f51c4babd8709e1c030752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr class="memdesc:a840291bc02cba5474a4cb46a9b9566fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to call the QSPIPSU Flash Polled example.  <a href="#a840291bc02cba5474a4cb46a9b9566fe">More...</a><br /></td></tr>
<tr class="separator:a840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4f09bf044ed26b11fc5489cb7b7ca1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f09bf044ed26b11fc5489cb7b7ca1e6">&#9670;&nbsp;</a></span>BulkErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BulkErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a bulk erase operation when the flash device has a single die. </p>
<p>Works for both Spansion and Micron</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">WritBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a97d8ab88e6002a97c30b95b66db231ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d8ab88e6002a97c30b95b66db231ea">&#9670;&nbsp;</a></span>DieErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DieErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a die erase operation on all the die in the flash device. </p>
<p>This function uses the die erase command for Micron 512Mbit and 1Gbit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">WritBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a8c7c38172a5258ee7cdfaef5a1a9af82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7c38172a5258ee7cdfaef5a1a9af82">&#9670;&nbsp;</a></span>FlashErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases the sectors in the serial Flash connected to the QSPIPSU interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">Pointer</td><td>to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a id="aaaad34739d0ad6d1fb5436c1d6428463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaad34739d0ad6d1fb5436c1d6428463">&#9670;&nbsp;</a></span>FlashRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs read. </p>
<p>DMA is the default setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to read data from the flash. Supports normal, fast, dual and quad read commands. </td></tr>
    <tr><td class="paramname">Pointer</td><td>to the write buffer which contains data to be transmitted </td></tr>
    <tr><td class="paramname">Pointer</td><td>to the read buffer to which valid received data should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ac7c0194bd58d158581c699b8c07c309d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c0194bd58d158581c699b8c07c309d">&#9670;&nbsp;</a></span>FlashReadID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashReadID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the flash ID and identifies the flash in FCT table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a5e40a81a572bfacbf4d7a39af7905cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e40a81a572bfacbf4d7a39af7905cea">&#9670;&nbsp;</a></span>FlashRegisterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRegisterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API can be used to write to a flash register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>is the number of bytes to write. </td></tr>
    <tr><td class="paramname">Command</td><td>is specific register write command. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to value to be written. </td></tr>
    <tr><td class="paramname">WrEn</td><td>is a flag to mention if WREN has to be sent before write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API can only be used for one flash at a time. </dd></dl>

</div>
</div>
<a id="a5b70ac0045f51c4babd8709e1c030752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b70ac0045f51c4babd8709e1c030752">&#9670;&nbsp;</a></span>FlashRegisterWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRegisterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>WrEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API can be used to write to a flash register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>is the number of bytes to write. </td></tr>
    <tr><td class="paramname">Command</td><td>is specific register write command. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to value to be written. </td></tr>
    <tr><td class="paramname">WrEn</td><td>is a flag to mention if WREN has to be sent before write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API can only be used for one flash at a time. </dd></dl>

</div>
</div>
<a id="a333c8e44e9af52811dee98f2cfcacf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333c8e44e9af52811dee98f2cfcacf53">&#9670;&nbsp;</a></span>FlashWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to the serial Flash connected to the QSPIPSU interface. </p>
<p>All the data put into the buffer must be in the same page of the device with page boundaries being on 256 byte boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address to write data to in the Flash. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to write. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to write data to the flash. QSPIPSU device supports only Page Program command to write data to the flash. </td></tr>
    <tr><td class="paramname">Pointer</td><td>to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a id="af45c38b76bbabbaf848a33cdc889ebfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45c38b76bbabbaf848a33cdc889ebfb">&#9670;&nbsp;</a></span>GetRealAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 GetRealAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions translates the address based on the type of interconnection. </p>
<p>In case of stacked, this function asserts the corresponding slave select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>which is to be accessed (for erase, write or read)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RealAddr is the translated address - for single it is unchanged; for stacked, the lower flash size is subtracted; for parallel the address is divided by 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_qspi_psu.html#a9b3aa272eb335fecaaa8f47fd2ed9241">XQspiPsu::Config</a>, and <a class="el" href="struct_x_qspi_psu___config.html#aa771e1e018426eb1f68fe5241ed45e71">XQspiPsu_Config::ConnectionMode</a>.</p>

</div>
</div>
<a id="a840291bc02cba5474a4cb46a9b9566fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840291bc02cba5474a4cb46a9b9566fe">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to call the QSPIPSU Flash Polled example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, otherwise XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p class="reference">References <a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#ac7a0e7a44578f580f46491eb6f6ce726">QspiPsuPolledFlashExample()</a>.</p>

</div>
</div>
<a id="ac7a0e7a44578f580f46491eb6f6ce726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a0e7a44578f580f46491eb6f6ce726">&#9670;&nbsp;</a></span>QspiPsuPolledFlashExample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QspiPsuPolledFlashExample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>QspiPsuDeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a> device driver in single, parallel and stacked modes using flash devices greater than or equal to 128Mb. </p>
<p>This function reads data in DMA mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">Referenced by <a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
