<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>qspipsu: xqspipsu_generic_flash_polled_example.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">qspipsu
   </div>
   <div id="projectbrief">Xilinx Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xqspipsu__generic__flash__polled__example_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xqspipsu_generic_flash_polled_example.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This file contains a design example using the QSPIPSU driver (<a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a>) with a serial Flash device greater than or equal to 128Mb. </p>
<p>The example writes to flash and reads it back in DMA mode. This examples runs with GENFIFO Manual start. It runs in polled mode. This example illustrates single, parallel and stacked modes. Both the flash devices have to be of the same make and size. The hardware which this example runs on, must have a serial Flash (Micron N25Q or Spansion S25FL) for it to run. In order to test in single, parallel or stacked flash configurations the necessary HW must be present and QSPI_MODE (also reflected in ConnectionMode in the instance) has to be in sync with HW flash configuration being tested.</p>
<p>This example has been tested with the Micron Serial Flash (N25Q512) and ISSI Serial Flash parts of IS25WP and IS25LP series flashes in single and parallel modes using A53 and R5 processors.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who Date     Changes
</p>
<hr/>
<p>
 1.0   hk  08/21/14 First release
       sk  06/17/15 Used Tx/Rx flags for Transmitting/Receiving.
                sk  11/23/15 Added Support for Macronix 1Gb part.
       ms  04/05/17 Modified Comment lines in functions to
                    recognize it as documentation block for doxygen
                    generation.
 1.1    tjs     06/16/17 Added support for IS25LP256D flash part (PR-4650)
 1.5    tjs 09/15/17 Replaced #ifdef COMMENTS to #if USE_FOUR_BYTE (CR-984966)
 1.6    tjs 10/16/17 #ifdef COMMENT replaced with the flow similar to
                    u-boot and linux for accessing flash parts with
                    size more then 16MB (CR-984966)
 1.7   tjs 11/16/17 Removed the unsupported 4 Byte write and sector erase
                    commands.
 1.7    tjs     12/01/17 Added support for MT25QL02G Flash from Micron. CR-990642
 1.7    tjs 12/19/17 Added support for S25FL064L from Spansion. CR-990724
 1.7    tjs 01/11/18 Added support for MX66L1G45G flash from Macronix CR-992367
 1.7    tjs 26/03/18 In dual parallel mode enable both CS when issuing Write
                                 enable command. CR-998478
 1.8    tjs 05/02/18 Added support for IS25LP064 and IS25WP064.
 1.8    tjs 16/07/18 Added support for the low density ISSI flash parts.
 1.9   akm 02/27/19 Added support for IS25LP128, IS25WP128, IS25LP256,
                     IS25WP256, IS25LP512, IS25WP512 Flash Devices
 1.9   akm 04/03/19 Fixed data alignment warnings on IAR compiler.
 1.10  akm 09/05/19 Added Multi Die Erase and Muti Die Read support.
 1.13  akm 11/30/20 Removed unwanted header files.
 1.13  akm 12/10/20 Set Read command as per the qspi bus width.
 1.14  akm 07/16/21 Enable Quad Mode for Winbond flashes.
 1.15  akm 11/19/21 Fix read/write failures on Spansion flash parts.
 1.15  akm 12/22/21 Initialize variables before use.
 1.16  akm 08/16/22 Fix logical error in NumSect calculation.</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac7a0e7a44578f580f46491eb6f6ce726"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#ac7a0e7a44578f580f46491eb6f6ce726">QspiPsuPolledFlashExample</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuInstancePtr, u16 QspiPsuDeviceId)</td></tr>
<tr class="memdesc:ac7a0e7a44578f580f46491eb6f6ce726"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a> device driver in single, parallel and stacked modes using flash devices greater than or equal to 128Mb.  <a href="#ac7a0e7a44578f580f46491eb6f6ce726">More...</a><br/></td></tr>
<tr class="separator:ac7a0e7a44578f580f46491eb6f6ce726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c0194bd58d158581c699b8c07c309d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#ac7c0194bd58d158581c699b8c07c309d">FlashReadID</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr)</td></tr>
<tr class="memdesc:ac7c0194bd58d158581c699b8c07c309d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the flash ID and identifies the flash in FCT table.  <a href="#ac7c0194bd58d158581c699b8c07c309d">More...</a><br/></td></tr>
<tr class="separator:ac7c0194bd58d158581c699b8c07c309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a8c7c38172a5258ee7cdfaef5a1a9af82">FlashErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases the sectors in the serial Flash connected to the QSPIPSU interface.  <a href="#a8c7c38172a5258ee7cdfaef5a1a9af82">More...</a><br/></td></tr>
<tr class="separator:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333c8e44e9af52811dee98f2cfcacf53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a333c8e44e9af52811dee98f2cfcacf53">FlashWrite</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a333c8e44e9af52811dee98f2cfcacf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to the serial Flash connected to the QSPIPSU interface.  <a href="#a333c8e44e9af52811dee98f2cfcacf53">More...</a><br/></td></tr>
<tr class="separator:a333c8e44e9af52811dee98f2cfcacf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaad34739d0ad6d1fb5436c1d6428463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#aaaad34739d0ad6d1fb5436c1d6428463">FlashRead</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr, u8 *ReadBfrPtr)</td></tr>
<tr class="memdesc:aaaad34739d0ad6d1fb5436c1d6428463"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs read.  <a href="#aaaad34739d0ad6d1fb5436c1d6428463">More...</a><br/></td></tr>
<tr class="separator:aaaad34739d0ad6d1fb5436c1d6428463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6007218826af36e0df62b747de40de5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#aa6007218826af36e0df62b747de40de5">MultiDieRead</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr, u8 *ReadBfrPtr)</td></tr>
<tr class="memdesc:aa6007218826af36e0df62b747de40de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a read operation for multi die flash devices.  <a href="#aa6007218826af36e0df62b747de40de5">More...</a><br/></td></tr>
<tr class="separator:aa6007218826af36e0df62b747de40de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45c38b76bbabbaf848a33cdc889ebfb"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#af45c38b76bbabbaf848a33cdc889ebfb">GetRealAddr</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address)</td></tr>
<tr class="memdesc:af45c38b76bbabbaf848a33cdc889ebfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions translates the address based on the type of interconnection.  <a href="#af45c38b76bbabbaf848a33cdc889ebfb">More...</a><br/></td></tr>
<tr class="separator:af45c38b76bbabbaf848a33cdc889ebfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a4f09bf044ed26b11fc5489cb7b7ca1e6">BulkErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a bulk erase operation when the flash device has a single die.  <a href="#a4f09bf044ed26b11fc5489cb7b7ca1e6">More...</a><br/></td></tr>
<tr class="separator:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d8ab88e6002a97c30b95b66db231ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a97d8ab88e6002a97c30b95b66db231ea">DieErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a97d8ab88e6002a97c30b95b66db231ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a die erase operation on all the die in the flash device.  <a href="#a97d8ab88e6002a97c30b95b66db231ea">More...</a><br/></td></tr>
<tr class="separator:a97d8ab88e6002a97c30b95b66db231ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e40a81a572bfacbf4d7a39af7905cea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a5e40a81a572bfacbf4d7a39af7905cea">FlashRegisterRead</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 ByteCount, u8 Command, u8 *ReadBfrPtr)</td></tr>
<tr class="memdesc:a5e40a81a572bfacbf4d7a39af7905cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API can be used to write to a flash register.  <a href="#a5e40a81a572bfacbf4d7a39af7905cea">More...</a><br/></td></tr>
<tr class="separator:a5e40a81a572bfacbf4d7a39af7905cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b70ac0045f51c4babd8709e1c030752"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a5b70ac0045f51c4babd8709e1c030752">FlashRegisterWrite</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 ByteCount, u8 Command, u8 *WriteBfrPtr, u8 WrEn)</td></tr>
<tr class="memdesc:a5b70ac0045f51c4babd8709e1c030752"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API can be used to write to a flash register.  <a href="#a5b70ac0045f51c4babd8709e1c030752">More...</a><br/></td></tr>
<tr class="separator:a5b70ac0045f51c4babd8709e1c030752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d1767607b58391ccb2d0103c2fd456"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#ae8d1767607b58391ccb2d0103c2fd456">FlashEnterExit4BAddMode</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, unsigned int Enable)</td></tr>
<tr class="memdesc:ae8d1767607b58391ccb2d0103c2fd456"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enters the flash device into 4 bytes addressing mode.  <a href="#ae8d1767607b58391ccb2d0103c2fd456">More...</a><br/></td></tr>
<tr class="separator:ae8d1767607b58391ccb2d0103c2fd456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a83a78784f5ba39b5e76b17a7e4a5ecad">FlashEnableQuadMode</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr)</td></tr>
<tr class="memdesc:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables Quad mode for the flash parts which require to enable quad mode before using Quad commands.  <a href="#a83a78784f5ba39b5e76b17a7e4a5ecad">More...</a><br/></td></tr>
<tr class="separator:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__generic__flash__polled__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr class="memdesc:a840291bc02cba5474a4cb46a9b9566fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to call the QSPIPSU Flash Polled example.  <a href="#a840291bc02cba5474a4cb46a9b9566fe">More...</a><br/></td></tr>
<tr class="separator:a840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4f09bf044ed26b11fc5489cb7b7ca1e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BulkErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a bulk erase operation when the flash device has a single die. </p>
<p>Works for both Spansion and Micron</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a97d8ab88e6002a97c30b95b66db231ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DieErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a die erase operation on all the die in the flash device. </p>
<p>This function uses the die erase command for Micron 512Mbit and 1Gbit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a83a78784f5ba39b5e76b17a7e4a5ecad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashEnableQuadMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables Quad mode for the flash parts which require to enable quad mode before using Quad commands. </p>
<p>For S25FL-L series flash parts this is required as the default configuration is x1/x2 mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae8d1767607b58391ccb2d0103c2fd456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashEnterExit4BAddMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enters the flash device into 4 bytes addressing mode. </p>
<p>As per the Micron and ISSI spec, before issuing the command to enter into 4 byte addr mode, a write enable command is issued. For Macronix and Winbond flash parts write enable is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Enable</td><td>is a either 1 or 0 if 1 then enters 4 byte if 0 exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8c7c38172a5258ee7cdfaef5a1a9af82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases the sectors in the serial Flash connected to the QSPIPSU interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is pointer to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaad34739d0ad6d1fb5436c1d6428463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs read. </p>
<p>DMA is the default setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to read data from the flash. Supports normal, fast, dual and quad read commands. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is pointer to the write buffer which contains data to be transmitted </td></tr>
    <tr><td class="paramname">ReadBfrPtr</td><td>is pointer to the read buffer to which valid received data should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7c0194bd58d158581c699b8c07c309d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashReadID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the flash ID and identifies the flash in FCT table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e40a81a572bfacbf4d7a39af7905cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRegisterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API can be used to write to a flash register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>is the number of bytes to write. </td></tr>
    <tr><td class="paramname">Command</td><td>is specific register write command. </td></tr>
    <tr><td class="paramname">ReadBfrPtr</td><td>is the pointer to value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API can only be used for one flash at a time. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b70ac0045f51c4babd8709e1c030752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRegisterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>WrEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API can be used to write to a flash register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>is the number of bytes to write. </td></tr>
    <tr><td class="paramname">Command</td><td>is specific register write command. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to value to be written. </td></tr>
    <tr><td class="paramname">WrEn</td><td>is a flag to mention if WREN has to be sent before write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API can only be used for one flash at a time. </dd></dl>

</div>
</div>
<a class="anchor" id="a333c8e44e9af52811dee98f2cfcacf53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to the serial Flash connected to the QSPIPSU interface. </p>
<p>All the data put into the buffer must be in the same page of the device with page boundaries being on 256 byte boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address to write data to in the Flash. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to write. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to write data to the flash. QSPIPSU device supports only Page Program command to write data to the flash. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is pointer to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af45c38b76bbabbaf848a33cdc889ebfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 GetRealAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions translates the address based on the type of interconnection. </p>
<p>In case of stacked, this function asserts the corresponding slave select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>which is to be accessed (for erase, write or read)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RealAddr is the translated address - for single it is unchanged; for stacked, the lower flash size is subtracted; for parallel the address is divided by 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In addition to get the actual address to work on flash this function also selects the CS and BUS based on the configuration detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a840291bc02cba5474a4cb46a9b9566fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to call the QSPIPSU Flash Polled example. </p>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, otherwise XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="xqspipsu__generic__flash__polled__64bit__dma__r5__example_8c.html#ac7a0e7a44578f580f46491eb6f6ce726">QspiPsuPolledFlashExample()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6007218826af36e0df62b747de40de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MultiDieRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a read operation for multi die flash devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to read data from the flash. Supports normal, fast, dual and quad read commands. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is pointer to the write buffer which contains data to be transmitted </td></tr>
    <tr><td class="paramname">ReadBfrPtr</td><td>is pointer to the read buffer to which valid received data should be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7a0e7a44578f580f46491eb6f6ce726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QspiPsuPolledFlashExample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>QspiPsuDeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a> device driver in single, parallel and stacked modes using flash devices greater than or equal to 128Mb. </p>
<p>This function reads data in DMA mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPsuInstancePtr</td><td>is a pointer to the instance of the QspiPsu device. </td></tr>
    <tr><td class="paramname">QspiPsuDeviceId</td><td>is the Device ID of the Qspi Device and is the XPAR_&lt;QSPI_instance&gt;_DEVICE_ID value from xparameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
