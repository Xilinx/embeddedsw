<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>qspipsu: xqspipsu_polldata_polltimeout_interrupt_example.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">qspipsu
   </div>
   <div id="projectbrief">Xilinx Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xqspipsu__polldata__polltimeout__interrupt__example_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xqspipsu_polldata_polltimeout_interrupt_example.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This file contains a design example using the QSPIPSU driver (<a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a>) with a serial Flash device greater than or equal to 128Mb. </p>
<p>The example writes to flash and reads it back in DMA mode. This examples runs with GENFIFO Manual start. It runs in interrupt mode. This example illustrates single, parallel and stacked modes. Both the flash devices have to be of the same make and size. The hardware which this example runs on, must have a serial Flash (Micron N25Q or Spansion S25FL) for it to run. In order to test in single, parallel or stacked flash configurations the necessary HW must be present and QSPI_MODE (also reflected in ConnectionMode in the instance) has to be in sync with HW flash configuration being tested. This application will configure GQSPI controller to send status command to know the flash status, instead of sending status command from the application.</p>
<p>This example has been tested with the Micron Serial Flash (N25Q512A) and ISSI Serial Flash parts of IS25WP and IS25LP series flashes in single and parallel using A53 and r5 processors.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who Date     Changes
</p>
<hr/>
<p>
 1.2   nsk  08/05/16 First release
 1.3   nsk  09/16/16 Update for dual parallel configuration
 1.3    nsk  09/19/16 Update documentation
       ms  04/05/17 Modified Comment lines in functions to
                    recognize it as documentation block and modified filename
                    tag to include the file in doxygen examples.
 1.4    tjs     06/16/17 Added support for IS25LP256D flash part (PR-4650)
 1.5    tjs     07/20/17 Added extended read support for MT25Q series flash (CR-980491)
 1.5    tjs 09/15/17 Replaced #ifdef COMMENTS to #if USE_FOUR_BYTE (CR-984966)
 1.7   tjs 11/16/17 Removed the unsupported 4 Byte write and sector erase
                    commands.
 1.7    tjs     12/01/17 Added support for MT25QL02G Flash from Micron. CR-990642
 1.7    tjs 12/19/17 Added support for S25FL064L from Spansion. CR-990724
 1.7    tjs 01/11/18 Added support for MX66L1G45G flash from Macronix CR-992367
 1.7    tjs 26/03/18 In dual parallel mode enable both CS when issuing Write
                                 enable command. CR-998478
 1.8    tjs 16/07/18 Added support for the low density ISSI flash parts.
 1.8    tjs 09/14/18 Fixed compilation warnings.
 1.9   akm 02/27/19 Added support for IS25LP128, IS25WP128, IS25LP256,
                     IS25WP256, IS25LP512, IS25WP512 Flash Devices
 1.9   akm 04/03/19 Fixed data alignment warnings on IAR compiler.</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1d5699f770ac9e1ceaf76398b568b9ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a1d5699f770ac9e1ceaf76398b568b9ee">QspiPsuInterruptFlashExample</a> (XScuGic *IntcInstancePtr, <a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuInstancePtr, u16 QspiPsuDeviceId, u16 QspiPsuIntrId)</td></tr>
<tr class="memdesc:a1d5699f770ac9e1ceaf76398b568b9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a> device driver in single, parallel and stacked modes using flash devices greater than or equal to 128Mb.  <a href="#a1d5699f770ac9e1ceaf76398b568b9ee">More...</a><br/></td></tr>
<tr class="separator:a1d5699f770ac9e1ceaf76398b568b9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c0194bd58d158581c699b8c07c309d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#ac7c0194bd58d158581c699b8c07c309d">FlashReadID</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr)</td></tr>
<tr class="memdesc:ac7c0194bd58d158581c699b8c07c309d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the flash ID and identifies the flash in FCT table.  <a href="#ac7c0194bd58d158581c699b8c07c309d">More...</a><br/></td></tr>
<tr class="separator:ac7c0194bd58d158581c699b8c07c309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a8c7c38172a5258ee7cdfaef5a1a9af82">FlashErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases the sectors in the serial Flash connected to the QSPIPSU interface.  <a href="#a8c7c38172a5258ee7cdfaef5a1a9af82">More...</a><br/></td></tr>
<tr class="separator:a8c7c38172a5258ee7cdfaef5a1a9af82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333c8e44e9af52811dee98f2cfcacf53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a333c8e44e9af52811dee98f2cfcacf53">FlashWrite</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a333c8e44e9af52811dee98f2cfcacf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to the serial Flash connected to the QSPIPSU interface.  <a href="#a333c8e44e9af52811dee98f2cfcacf53">More...</a><br/></td></tr>
<tr class="separator:a333c8e44e9af52811dee98f2cfcacf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaad34739d0ad6d1fb5436c1d6428463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#aaaad34739d0ad6d1fb5436c1d6428463">FlashRead</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address, u32 ByteCount, u8 Command, u8 *WriteBfrPtr, u8 *ReadBfrPtr)</td></tr>
<tr class="memdesc:aaaad34739d0ad6d1fb5436c1d6428463"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a read.  <a href="#aaaad34739d0ad6d1fb5436c1d6428463">More...</a><br/></td></tr>
<tr class="separator:aaaad34739d0ad6d1fb5436c1d6428463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45c38b76bbabbaf848a33cdc889ebfb"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#af45c38b76bbabbaf848a33cdc889ebfb">GetRealAddr</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u32 Address)</td></tr>
<tr class="memdesc:af45c38b76bbabbaf848a33cdc889ebfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions translates the address based on the type of interconnection.  <a href="#af45c38b76bbabbaf848a33cdc889ebfb">More...</a><br/></td></tr>
<tr class="separator:af45c38b76bbabbaf848a33cdc889ebfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a4f09bf044ed26b11fc5489cb7b7ca1e6">BulkErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a bulk erase operation when the flash device has a single die.  <a href="#a4f09bf044ed26b11fc5489cb7b7ca1e6">More...</a><br/></td></tr>
<tr class="separator:a4f09bf044ed26b11fc5489cb7b7ca1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d8ab88e6002a97c30b95b66db231ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a97d8ab88e6002a97c30b95b66db231ea">DieErase</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a97d8ab88e6002a97c30b95b66db231ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a die erase operation on all the die in the flash device.  <a href="#a97d8ab88e6002a97c30b95b66db231ea">More...</a><br/></td></tr>
<tr class="separator:a97d8ab88e6002a97c30b95b66db231ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48231ad0042a647ddbcf702df748d1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a48231ad0042a647ddbcf702df748d1a4">QspiPsuHandler</a> (void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)</td></tr>
<tr class="memdesc:a48231ad0042a647ddbcf702df748d1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback handler.  <a href="#a48231ad0042a647ddbcf702df748d1a4">More...</a><br/></td></tr>
<tr class="separator:a48231ad0042a647ddbcf702df748d1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90454c300a46c3a9c1ba66d2a680b63c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a90454c300a46c3a9c1ba66d2a680b63c">QspiPsuConfigurePoll</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr)</td></tr>
<tr class="memdesc:a90454c300a46c3a9c1ba66d2a680b63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the values required to poll the device for status.  <a href="#a90454c300a46c3a9c1ba66d2a680b63c">More...</a><br/></td></tr>
<tr class="separator:a90454c300a46c3a9c1ba66d2a680b63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d1767607b58391ccb2d0103c2fd456"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#ae8d1767607b58391ccb2d0103c2fd456">FlashEnterExit4BAddMode</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr, unsigned int Enable)</td></tr>
<tr class="memdesc:ae8d1767607b58391ccb2d0103c2fd456"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enters the flash device into 4 bytes addressing mode.  <a href="#ae8d1767607b58391ccb2d0103c2fd456">More...</a><br/></td></tr>
<tr class="separator:ae8d1767607b58391ccb2d0103c2fd456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a83a78784f5ba39b5e76b17a7e4a5ecad">FlashEnableQuadMode</a> (<a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *QspiPsuPtr)</td></tr>
<tr class="memdesc:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables Quad mode for the flash parts which require to enable quad mode before using Quad commands.  <a href="#a83a78784f5ba39b5e76b17a7e4a5ecad">More...</a><br/></td></tr>
<tr class="separator:a83a78784f5ba39b5e76b17a7e4a5ecad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspipsu__polldata__polltimeout__interrupt__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr class="memdesc:a840291bc02cba5474a4cb46a9b9566fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to call the QSPIPSU Flash example.  <a href="#a840291bc02cba5474a4cb46a9b9566fe">More...</a><br/></td></tr>
<tr class="separator:a840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4f09bf044ed26b11fc5489cb7b7ca1e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BulkErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a bulk erase operation when the flash device has a single die. </p>
<p>Works for both Spansion and Micron</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">WritBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a97d8ab88e6002a97c30b95b66db231ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DieErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a die erase operation on all the die in the flash device. </p>
<p>This function uses the die erase command for Micron 512Mbit and 1Gbit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">WritBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a83a78784f5ba39b5e76b17a7e4a5ecad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashEnableQuadMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables Quad mode for the flash parts which require to enable quad mode before using Quad commands. </p>
<p>For S25FL-L series flash parts this is required as the default configuration is x1/x2 mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae8d1767607b58391ccb2d0103c2fd456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashEnterExit4BAddMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enters the flash device into 4 bytes addressing mode. </p>
<p>As per the Micron and ISSI spec, before issuing the command to enter into 4 byte addr mode, a write enable command is issued. For Macronix and Winbond flash parts write enable is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Enable</td><td>is a either 1 or 0 if 1 then enters 4 byte if 0 exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8c7c38172a5258ee7cdfaef5a1a9af82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases the sectors in the serial Flash connected to the QSPIPSU interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">Pointer</td><td>to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaad34739d0ad6d1fb5436c1d6428463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a read. </p>
<p>Default setting is in DMA mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to read data from the flash. Supports normal, fast, dual and quad read commands. </td></tr>
    <tr><td class="paramname">Pointer</td><td>to the write buffer which contains data to be transmitted </td></tr>
    <tr><td class="paramname">Pointer</td><td>to the read buffer to which valid received data should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7c0194bd58d158581c699b8c07c309d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashReadID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the flash ID and identifies the flash in FCT table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a333c8e44e9af52811dee98f2cfcacf53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to the serial Flash connected to the QSPIPSU interface. </p>
<p>All the data put into the buffer must be in the same page of the device with page boundaries being on 256 byte boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address to write data to in the Flash. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to write. </td></tr>
    <tr><td class="paramname">Command</td><td>is the command used to write data to the flash. QSPIPSU device supports only Page Program command to write data to the flash. </td></tr>
    <tr><td class="paramname">Pointer</td><td>to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af45c38b76bbabbaf848a33cdc889ebfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 GetRealAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions translates the address based on the type of interconnection. </p>
<p>In case of stacked, this function asserts the corresponding slave select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>which is to be accessed (for erase, write or read)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RealAddr is the translated address - for single it is unchanged; for stacked, the lower flash size is subtracted; for parallel the address is divided by 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In addition to get the actual address to work on flash this function also selects the CS and BUS based on the configuration detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a840291bc02cba5474a4cb46a9b9566fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to call the QSPIPSU Flash example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, otherwise XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="xqspipsu__generic__flash__interrupt__example_8c.html#a1d5699f770ac9e1ceaf76398b568b9ee">QspiPsuInterruptFlashExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a90454c300a46c3a9c1ba66d2a680b63c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QspiPsuConfigurePoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the values required to poll the device for status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to the QSPIPSU driver component to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_qspi_psu.html#a9b3aa272eb335fecaaa8f47fd2ed9241">XQspiPsu::Config</a>, <a class="el" href="struct_x_qspi_psu___config.html#aa771e1e018426eb1f68fe5241ed45e71">XQspiPsu_Config::ConnectionMode</a>, and <a class="el" href="group__qspipsu__v1__12.html#ga28338ae42ed4f7d2685ab18de2d21128">XQspiPsu_SelectFlash()</a>.</p>

</div>
</div>
<a class="anchor" id="a48231ad0042a647ddbcf702df748d1a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QspiPsuHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>StatusEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d5699f770ac9e1ceaf76398b568b9ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QspiPsuInterruptFlashExample </td>
          <td>(</td>
          <td class="paramtype">XScuGic *&#160;</td>
          <td class="paramname"><em>IntcInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_qspi_psu.html">XQspiPsu</a> *&#160;</td>
          <td class="paramname"><em>QspiPsuInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>QspiPsuDeviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>QspiPsuIntrId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_qspi_psu.html" title="The XQspiPsu driver instance data. ">XQspiPsu</a> device driver in single, parallel and stacked modes using flash devices greater than or equal to 128Mb. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
