<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>v_hdmirx: xv_hdmirx.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">v_hdmirx
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xv__hdmirx_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xv_hdmirx.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This is the main file for Xilinx HDMI RX core. </p>
<p>Please see <a class="el" href="xv__hdmirx_8h.html" title="This is the main header file for Xilinx HDMI RX core. ">xv_hdmirx.h</a> for more details of the driver.</p>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who    Date     Changes
<hr/>

1.00  gm, mg 11/03/15 Initial release.
1.01  MG     30/12/15 Added DDC HDCP 2.2 calls
1.02  yh     15/01/16 Added 3D Video support
1.03  MG     19/02/16 Added link error callback
1.04  MG     08/03/16 Updated XV_HdmiRx_SetStream to use RefClk
1.05  MG     27/05/16 Updated XV_HdmiRx_CfgInitialize
1.06  YH     18/07/16 Replace xil_printf with xdbg_printf
1.07  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
                         XV_HdmiRx_CfgInitialize
1.08  YH     18/08/16 squash unused variable compiler warning
1.09  YH     29/08/16 Set Match to FALSE when HTotal = 0
1.10  MG     02/03/17 Fixed YUV420 reading in function
                         XV_HdmiRx_GetVideoTiming
1.40  YH     19/07/17 Clean up Print Statement line ending to "\r\n"
             05/09/17 Enhanced Video Timing checking
</pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a35f897045a59a453923ce248b1eb8183"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a35f897045a59a453923ce248b1eb8183">XV_HdmiRx_CfgInitialize</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr, <a class="el" href="struct_x_v___hdmi_rx___config.html">XV_HdmiRx_Config</a> *CfgPtr, UINTPTR EffectiveAddr)</td></tr>
<tr class="memdesc:a35f897045a59a453923ce248b1eb8183"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the HDMI RX core.  <a href="#a35f897045a59a453923ce248b1eb8183">More...</a><br /></td></tr>
<tr class="separator:a35f897045a59a453923ce248b1eb8183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa424ff55e1b21973d23de5f1a03071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#adaa424ff55e1b21973d23de5f1a03071">XV_HdmiRx_Clear</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:adaa424ff55e1b21973d23de5f1a03071"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the HDMI RX variables and sets them to the defaults.  <a href="#adaa424ff55e1b21973d23de5f1a03071">More...</a><br /></td></tr>
<tr class="separator:adaa424ff55e1b21973d23de5f1a03071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903b465cb41a9a040ba40eefa3109929"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a903b465cb41a9a040ba40eefa3109929">XV_HdmiRx_SetStream</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr, XVidC_PixelsPerClock Ppc, u32 Clock)</td></tr>
<tr class="memdesc:a903b465cb41a9a040ba40eefa3109929"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the HDMI RX stream parameters.  <a href="#a903b465cb41a9a040ba40eefa3109929">More...</a><br /></td></tr>
<tr class="separator:a903b465cb41a9a040ba40eefa3109929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48ac8ab5eeddd6197c6220db1ac8ee5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#ab48ac8ab5eeddd6197c6220db1ac8ee5">XV_HdmiRx_SetPixelRate</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:ab48ac8ab5eeddd6197c6220db1ac8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the pixel rate.  <a href="#ab48ac8ab5eeddd6197c6220db1ac8ee5">More...</a><br /></td></tr>
<tr class="separator:ab48ac8ab5eeddd6197c6220db1ac8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72457c11b43becc2fd5bffc1b748bf30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a72457c11b43becc2fd5bffc1b748bf30">XV_HdmiRx_SetColorFormat</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a72457c11b43becc2fd5bffc1b748bf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the color format.  <a href="#a72457c11b43becc2fd5bffc1b748bf30">More...</a><br /></td></tr>
<tr class="separator:a72457c11b43becc2fd5bffc1b748bf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8601d159dffdd4fd77d05d248b366a54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a8601d159dffdd4fd77d05d248b366a54">XV_HdmiRx_SetHpd</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr, u8 SetClr)</td></tr>
<tr class="memdesc:a8601d159dffdd4fd77d05d248b366a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/clear Hot-Plug-Detect.  <a href="#a8601d159dffdd4fd77d05d248b366a54">More...</a><br /></td></tr>
<tr class="separator:a8601d159dffdd4fd77d05d248b366a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad02ea3d99f0ac3a7f4a0b18f88d62e8"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#aad02ea3d99f0ac3a7f4a0b18f88d62e8">XV_HdmiRx_GetLinkStatus</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr, u8 Type)</td></tr>
<tr class="memdesc:aad02ea3d99f0ac3a7f4a0b18f88d62e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides status of the HDMI RX core Link Status peripheral.  <a href="#aad02ea3d99f0ac3a7f4a0b18f88d62e8">More...</a><br /></td></tr>
<tr class="separator:aad02ea3d99f0ac3a7f4a0b18f88d62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bb5419e7285a268518668fda1d70cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a70bb5419e7285a268518668fda1d70cd">XV_HdmiRx_IsLinkStatusErrMax</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a70bb5419e7285a268518668fda1d70cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides status of one of the link error counters reached the maximum value.  <a href="#a70bb5419e7285a268518668fda1d70cd">More...</a><br /></td></tr>
<tr class="separator:a70bb5419e7285a268518668fda1d70cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b7e27bd3874e33114b2e0210f54d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#ac1b7e27bd3874e33114b2e0210f54d4c">XV_HdmiRx_ClearLinkStatus</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:ac1b7e27bd3874e33114b2e0210f54d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the link error counters.  <a href="#ac1b7e27bd3874e33114b2e0210f54d4c">More...</a><br /></td></tr>
<tr class="separator:ac1b7e27bd3874e33114b2e0210f54d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3dcd032d351867697f19280fdeb1eeb"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#ae3dcd032d351867697f19280fdeb1eeb">XV_HdmiRx_GetAcrCts</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:ae3dcd032d351867697f19280fdeb1eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides audio clock regenerating CTS (Cycle-Time Stamp) value at the HDMI sink device.  <a href="#ae3dcd032d351867697f19280fdeb1eeb">More...</a><br /></td></tr>
<tr class="separator:ae3dcd032d351867697f19280fdeb1eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9483d540e72c619bcc9ba5d516ebe8"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a0b9483d540e72c619bcc9ba5d516ebe8">XV_HdmiRx_GetAcrN</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a0b9483d540e72c619bcc9ba5d516ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides audio clock regenerating factor N value.  <a href="#a0b9483d540e72c619bcc9ba5d516ebe8">More...</a><br /></td></tr>
<tr class="separator:a0b9483d540e72c619bcc9ba5d516ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ede81f7ab3357d5fe81c8df0f125e27"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a0ede81f7ab3357d5fe81c8df0f125e27">XV_HdmiRx_DdcGetEdidWords</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a0ede81f7ab3357d5fe81c8df0f125e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the size of the EDID buffer of the DDC slave.  <a href="#a0ede81f7ab3357d5fe81c8df0f125e27">More...</a><br /></td></tr>
<tr class="separator:a0ede81f7ab3357d5fe81c8df0f125e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af2c795e31eaf65f261afacd8b0119f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a5af2c795e31eaf65f261afacd8b0119f">XV_HdmiRx_DdcLoadEdid</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr, u8 *EdidData, u16 Length)</td></tr>
<tr class="memdesc:a5af2c795e31eaf65f261afacd8b0119f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the EDID data into the DDC slave.  <a href="#a5af2c795e31eaf65f261afacd8b0119f">More...</a><br /></td></tr>
<tr class="separator:a5af2c795e31eaf65f261afacd8b0119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125a52cc72ca34c839e07a145225cbe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a125a52cc72ca34c839e07a145225cbe7">XV_HdmiRx_DdcHdcpSetAddress</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr, u32 Address)</td></tr>
<tr class="memdesc:a125a52cc72ca34c839e07a145225cbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the HDCP address in the DDC peripheral.  <a href="#a125a52cc72ca34c839e07a145225cbe7">More...</a><br /></td></tr>
<tr class="separator:a125a52cc72ca34c839e07a145225cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc9095feabfbd561eeb22c90f793a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a7cc9095feabfbd561eeb22c90f793a7b">XV_HdmiRx_DdcHdcpWriteData</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:a7cc9095feabfbd561eeb22c90f793a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes HDCP data in the DDC peripheral.  <a href="#a7cc9095feabfbd561eeb22c90f793a7b">More...</a><br /></td></tr>
<tr class="separator:a7cc9095feabfbd561eeb22c90f793a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17547b4a343f0d8a57728948d063ef90"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a17547b4a343f0d8a57728948d063ef90">XV_HdmiRx_DdcHdcpReadData</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a17547b4a343f0d8a57728948d063ef90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads HDCP data from the DDC peripheral.  <a href="#a17547b4a343f0d8a57728948d063ef90">More...</a><br /></td></tr>
<tr class="separator:a17547b4a343f0d8a57728948d063ef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6a4d5464644a04891aaa68c3343edb"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a5d6a4d5464644a04891aaa68c3343edb">XV_HdmiRx_DdcGetHdcpWriteMessageBufferWords</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a5d6a4d5464644a04891aaa68c3343edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the number of bytes of the HDCP 2.2 write buffer in the DDC slave.  <a href="#a5d6a4d5464644a04891aaa68c3343edb">More...</a><br /></td></tr>
<tr class="separator:a5d6a4d5464644a04891aaa68c3343edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974d5daca9913663c9752972d3953ba4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a974d5daca9913663c9752972d3953ba4">XV_HdmiRx_DdcIsHdcpWriteMessageBufferEmpty</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a974d5daca9913663c9752972d3953ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the status of the HDCP 2.2 write buffer in the DDC slave.  <a href="#a974d5daca9913663c9752972d3953ba4">More...</a><br /></td></tr>
<tr class="separator:a974d5daca9913663c9752972d3953ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257f8ee397eb2b80be3bd776c4120320"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a257f8ee397eb2b80be3bd776c4120320">XV_HdmiRx_DdcGetHdcpReadMessageBufferWords</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a257f8ee397eb2b80be3bd776c4120320"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the number of bytes of the HDCP 2.2 read buffer in the DDC slave.  <a href="#a257f8ee397eb2b80be3bd776c4120320">More...</a><br /></td></tr>
<tr class="separator:a257f8ee397eb2b80be3bd776c4120320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6118306bb3bc6821b5a87640a34cafcc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a6118306bb3bc6821b5a87640a34cafcc">XV_HdmiRx_DdcIsHdcpReadMessageBufferEmpty</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a6118306bb3bc6821b5a87640a34cafcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the status of the HDCP 2.2 read message buffer in the DDC slave.  <a href="#a6118306bb3bc6821b5a87640a34cafcc">More...</a><br /></td></tr>
<tr class="separator:a6118306bb3bc6821b5a87640a34cafcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3a0edaaf96c13a8b7296883cc3c195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a8a3a0edaaf96c13a8b7296883cc3c195">XV_HdmiRx_DebugInfo</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a8a3a0edaaf96c13a8b7296883cc3c195"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints stream and timing information on STDIO/Uart console.  <a href="#a8a3a0edaaf96c13a8b7296883cc3c195">More...</a><br /></td></tr>
<tr class="separator:a8a3a0edaaf96c13a8b7296883cc3c195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b5ed80c20dbf62ab2e98569097be2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#ac7b5ed80c20dbf62ab2e98569097be2f">XV_HdmiRx_IsStreamUp</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:ac7b5ed80c20dbf62ab2e98569097be2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides status of the stream.  <a href="#ac7b5ed80c20dbf62ab2e98569097be2f">More...</a><br /></td></tr>
<tr class="separator:ac7b5ed80c20dbf62ab2e98569097be2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc46a138f5d16ad0b85da090e3abb11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a0cc46a138f5d16ad0b85da090e3abb11">XV_HdmiRx_IsStreamScrambled</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a0cc46a138f5d16ad0b85da090e3abb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the stream scrambler status.  <a href="#a0cc46a138f5d16ad0b85da090e3abb11">More...</a><br /></td></tr>
<tr class="separator:a0cc46a138f5d16ad0b85da090e3abb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbc4765c852092e33ff24124b2fc3f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a9bbc4765c852092e33ff24124b2fc3f8">XV_HdmiRx_IsStreamConnected</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a9bbc4765c852092e33ff24124b2fc3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides the stream connected status.  <a href="#a9bbc4765c852092e33ff24124b2fc3f8">More...</a><br /></td></tr>
<tr class="separator:a9bbc4765c852092e33ff24124b2fc3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bca352ee91492da1392cae5ddcfa6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a36bca352ee91492da1392cae5ddcfa6c">XV_HdmiRx_GetTmdsClockRatio</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a36bca352ee91492da1392cae5ddcfa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the SCDC TMDS clock ratio bit.  <a href="#a36bca352ee91492da1392cae5ddcfa6c">More...</a><br /></td></tr>
<tr class="separator:a36bca352ee91492da1392cae5ddcfa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa89bbc453b2d7e1446140c73b7baee"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#afaa89bbc453b2d7e1446140c73b7baee">XV_HdmiRx_GetAviVic</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:afaa89bbc453b2d7e1446140c73b7baee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the AVI VIC (captured by the AUX peripheral)  <a href="#afaa89bbc453b2d7e1446140c73b7baee">More...</a><br /></td></tr>
<tr class="separator:afaa89bbc453b2d7e1446140c73b7baee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2650f744a2a244482124697e632863"><td class="memItemLeft" align="right" valign="top">XVidC_ColorFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a4b2650f744a2a244482124697e632863">XV_HdmiRx_GetAviColorSpace</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a4b2650f744a2a244482124697e632863"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the AVI colorspace (captured by the AUX peripheral)  <a href="#a4b2650f744a2a244482124697e632863">More...</a><br /></td></tr>
<tr class="separator:a4b2650f744a2a244482124697e632863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e0904b6a6167f3cde2e7fcc0843e1d"><td class="memItemLeft" align="right" valign="top">XVidC_ColorDepth&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a87e0904b6a6167f3cde2e7fcc0843e1d">XV_HdmiRx_GetGcpColorDepth</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a87e0904b6a6167f3cde2e7fcc0843e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the GCP color depth (captured by the AUX peripheral)  <a href="#a87e0904b6a6167f3cde2e7fcc0843e1d">More...</a><br /></td></tr>
<tr class="separator:a87e0904b6a6167f3cde2e7fcc0843e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed0eb9c0b7dfc1013f6f347ef1f040c"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a1ed0eb9c0b7dfc1013f6f347ef1f040c">XV_HdmiRx_Divide</a> (u32 Dividend, u32 Divisor)</td></tr>
<tr class="memdesc:a1ed0eb9c0b7dfc1013f6f347ef1f040c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the divider for the frame calculation.  <a href="#a1ed0eb9c0b7dfc1013f6f347ef1f040c">More...</a><br /></td></tr>
<tr class="separator:a1ed0eb9c0b7dfc1013f6f347ef1f040c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae971dd56fea8451e407ceba3af0612f7"><td class="memItemLeft" align="right" valign="top">XVidC_VideoMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#ae971dd56fea8451e407ceba3af0612f7">XV_HdmiRx_LookupVmId</a> (u8 Vic)</td></tr>
<tr class="memdesc:ae971dd56fea8451e407ceba3af0612f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for the video mode based on the vic.  <a href="#ae971dd56fea8451e407ceba3af0612f7">More...</a><br /></td></tr>
<tr class="separator:ae971dd56fea8451e407ceba3af0612f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f74899b52dfbb8e0e554bbdea04bd29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a6f74899b52dfbb8e0e554bbdea04bd29">XV_HdmiRx_GetVideoProperties</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a6f74899b52dfbb8e0e554bbdea04bd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the video properties from the aux peripheral.  <a href="#a6f74899b52dfbb8e0e554bbdea04bd29">More...</a><br /></td></tr>
<tr class="separator:a6f74899b52dfbb8e0e554bbdea04bd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e11e21cff30c73785c0a2f63944ccd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirx_8c.html#a9e11e21cff30c73785c0a2f63944ccd0">XV_HdmiRx_GetVideoTiming</a> (<a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *InstancePtr)</td></tr>
<tr class="memdesc:a9e11e21cff30c73785c0a2f63944ccd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the video timing from the VTD peripheral.  <a href="#a9e11e21cff30c73785c0a2f63944ccd0">More...</a><br /></td></tr>
<tr class="separator:a9e11e21cff30c73785c0a2f63944ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a35f897045a59a453923ce248b1eb8183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f897045a59a453923ce248b1eb8183">&#9670;&nbsp;</a></span>XV_HdmiRx_CfgInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx___config.html">XV_HdmiRx_Config</a> *&#160;</td>
          <td class="paramname"><em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the HDMI RX core. </p>
<p>This function must be called prior to using the HDMI RX core. Initialization of the HDMI RX includes setting up the instance data, and ensuring the hardware is in a quiescent state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdmiRx core instance. </td></tr>
    <tr><td class="paramname">CfgPtr</td><td>points to the configuration structure associated with the HDMI RX core. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the base address of the device. If address translation is being used, then this parameter must reflect the virtual base address. Otherwise, the physical address should be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if XV_HdmiRx_CfgInitialize was successful.</li>
<li>XST_FAILURE if HDMI RX PIO ID mismatched.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ab19565a18843e9dc2e5162ba19112607">XV_HdmiRx::ConnectCallback</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a4a6303e5aa23e44351563d3559d9a7cc">XV_HDMIRX_MASK_16</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a3b2aba60044d1ec3e9ddfc0172f77141">XV_HDMIRX_PIO_ID</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a3072b2f474e183f436eceb634d67a7cf">XV_HDMIRX_PIO_ID_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a58ff62ffa6d07e198733b7ef576f2ac3">XV_HDMIRX_SHIFT_16</a>.</p>

</div>
</div>
<a id="adaa424ff55e1b21973d23de5f1a03071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa424ff55e1b21973d23de5f1a03071">&#9670;&nbsp;</a></span>XV_HdmiRx_Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRx_Clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the HDMI RX variables and sets them to the defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is required after a reset or init. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___audio_stream.html#a62436417a204c891460a4a70603eb523">XV_HdmiRx_AudioStream::Active</a>, <a class="el" href="struct_x_v___hdmi_rx.html#a5599189446aa34a986126f1dc5e309ef">XV_HdmiRx::AudCts</a>, <a class="el" href="struct_x_v___hdmi_rx.html#a6888233d6f5b66f05d05232bc49ba029">XV_HdmiRx::AudFormat</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a99397f2c97c560a3a7e78e14fb315cfe">XV_HdmiRx_Stream::Audio</a>, <a class="el" href="struct_x_v___hdmi_rx.html#a4b3259927c96554e2e278d3f9aeb6014">XV_HdmiRx::AudN</a>, <a class="el" href="struct_x_v___hdmi_rx.html#a9d8420dc7f4417e6107eeaf9f8e28306">XV_HdmiRx::Aux</a>, <a class="el" href="struct_x_v___hdmi_rx___audio_stream.html#ac2fce5e2b2f4d39c4ca275bbbee2e000">XV_HdmiRx_AudioStream::Channels</a>, <a class="el" href="union_x_v___hdmi_rx___aux_header.html#af3e0f7a1e86930ae5427a98fb783f9ac">XV_HdmiRx_AuxHeader::Data</a>, <a class="el" href="union_x_v___hdmi_rx___aux_data.html#a66dadb86713a34b4bec97957a511fe3e">XV_HdmiRx_AuxData::Data</a>, <a class="el" href="struct_x_v___hdmi_rx___aux.html#ab3dc0a540cac6ef317fd3135a459cc3c">XV_HdmiRx_Aux::Data</a>, <a class="el" href="struct_x_v___hdmi_rx___aux.html#acdbf28da615dedad4be9bf8e9ff58216">XV_HdmiRx_Aux::Header</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#ac923f4d27cb6fe74d202de5d6c201464">XV_HdmiRx_Stream::IsHdmi</a>, <a class="el" href="struct_x_v___hdmi_rx.html#abec1436490b52a721664e6f532a0810f">XV_HdmiRx::IsStreamDownCallbackSet</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a0dd7bc8d80e7b48cfa2e719ee8c00ad1">XV_HdmiRx_Stream::State</a>, <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>, <a class="el" href="struct_x_v___hdmi_rx.html#a4487a94b3952681506cc3b2700ff68d2">XV_HdmiRx::StreamDownCallback</a>, <a class="el" href="struct_x_v___hdmi_rx.html#af057991b7be7e1ac4ea309df7e38587c">XV_HdmiRx::StreamDownRef</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a6e300e58c18687d3d6227cc410593373">XV_HdmiRx_Stream::Vic</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a637935d82811b204c720970e7f7e582a">XV_HdmiRx_Stream::Video</a>, and <a class="el" href="xv__hdmirx_8h.html#a1a0a96c3c2d056c688b7444355656695a4998c41076823a110a2794ed12e48485">XV_HDMIRX_STATE_STREAM_DOWN</a>.</p>

</div>
</div>
<a id="ac1b7e27bd3874e33114b2e0210f54d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b7e27bd3874e33114b2e0210f54d4c">&#9670;&nbsp;</a></span>XV_HdmiRx_ClearLinkStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRx_ClearLinkStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the link error counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#abc673f54db2a25dee45c4f1c8d321e95">XV_HDMIRX_LNKSTA_CTRL_CLR_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#aa6d26913bac16d95ae5a5af1173ccb13">XV_HDMIRX_LNKSTA_CTRL_ERR_CLR_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#aa310321ea49ca6efcd3cd727554d74df">XV_HDMIRX_LNKSTA_CTRL_SET_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a407dbf36f2752c30d265e3a8a25d29fe">XV_HdmiRx_WriteReg</a>.</p>

</div>
</div>
<a id="a0ede81f7ab3357d5fe81c8df0f125e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ede81f7ab3357d5fe81c8df0f125e27">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcGetEdidWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XV_HdmiRx_DdcGetEdidWords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the size of the EDID buffer of the DDC slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>EDID buffer size</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a353a7e74a37ccc5fe06e7dfbf1d1e05d">XV_HDMIRX_DDC_EDID_STA_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a6f7e2758e963a54d5dfb9152ab55a9a0">XV_HDMIRX_DDC_STA_EDID_WORDS_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#af604d47ae26f7f564092cf94e9cb85d8">XV_HDMIRX_DDC_STA_EDID_WORDS_SHIFT</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="xv__hdmirx_8h.html#a15aff8e40535d72186c05dcdd2e5aa93">XV_HdmiRx_DdcLoadEdid()</a>.</p>

</div>
</div>
<a id="a257f8ee397eb2b80be3bd776c4120320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257f8ee397eb2b80be3bd776c4120320">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcGetHdcpReadMessageBufferWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XV_HdmiRx_DdcGetHdcpReadMessageBufferWords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the number of bytes of the HDCP 2.2 read buffer in the DDC slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdmi_Rx core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>HDCP 2.2 read buffer words</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#af496088efcd5b696f2c6a53b19c73679">XV_HDMIRX_DDC_HDCP_STA_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a64024b1389da182f45323458cf1498d3">XV_HDMIRX_DDC_STA_HDCP_RMSG_WORDS_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a1f53e7a0221d509783bfbdb538dc6f37">XV_HDMIRX_DDC_STA_HDCP_RMSG_WORDS_SHIFT</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a5d6a4d5464644a04891aaa68c3343edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6a4d5464644a04891aaa68c3343edb">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcGetHdcpWriteMessageBufferWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XV_HdmiRx_DdcGetHdcpWriteMessageBufferWords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the number of bytes of the HDCP 2.2 write buffer in the DDC slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdmi_Rx core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>HDCP 2.2 write buffer words</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#af496088efcd5b696f2c6a53b19c73679">XV_HDMIRX_DDC_HDCP_STA_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a364015db506a68de44778c9bd34c081e">XV_HDMIRX_DDC_STA_HDCP_WMSG_WORDS_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a87098e726a4f0f15c69fa3fff49cf5c2">XV_HDMIRX_DDC_STA_HDCP_WMSG_WORDS_SHIFT</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a17547b4a343f0d8a57728948d063ef90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17547b4a343f0d8a57728948d063ef90">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcHdcpReadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_HdmiRx_DdcHdcpReadData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads HDCP data from the DDC peripheral. </p>
<p>This is implemented as a function and not a macro, so the HDCP driver can bind the function call with a handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdmi_Rx core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the HDCP data read from the DDC peripheral.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 XHdmiRx_DdcHdcpReadData(XHdmi_Rx *InstancePtr) </dd></dl>

<p class="reference">References <a class="el" href="xv__hdmirx__hw_8h.html#acc2e9a9d6af18df813b60237a319900a">XV_HDMIRX_DDC_HDCP_DATA_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a125a52cc72ca34c839e07a145225cbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125a52cc72ca34c839e07a145225cbe7">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcHdcpSetAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRx_DdcHdcpSetAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the HDCP address in the DDC peripheral. </p>
<p>This is implemented as a function and not a macro, so the HDCP driver can bind the function call with a handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdmi_Rx core instance. </td></tr>
    <tr><td class="paramname">Address</td><td>is the HDCP address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void XHdmiRx_DdcHdcpSetAddress(XHdmi_Rx *InstancePtr, u8 Address) </dd></dl>

<p class="reference">References <a class="el" href="xv__hdmirx__hw_8h.html#a6b100412180e030ef95cb8ecaa5934b3">XV_HDMIRX_DDC_HDCP_ADDRESS_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a407dbf36f2752c30d265e3a8a25d29fe">XV_HdmiRx_WriteReg</a>.</p>

</div>
</div>
<a id="a7cc9095feabfbd561eeb22c90f793a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc9095feabfbd561eeb22c90f793a7b">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcHdcpWriteData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRx_DdcHdcpWriteData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes HDCP data in the DDC peripheral. </p>
<p>This is implemented as a function and not a macro, so the HDCP driver can bind the function call with a handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdmi_Rx core instance. </td></tr>
    <tr><td class="paramname">Data</td><td>is the HDCP data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void XHdmiRx_DdcHdcpWriteData(XHdmi_Rx *InstancePtr, u8 Data) </dd></dl>

<p class="reference">References <a class="el" href="xv__hdmirx__hw_8h.html#acc2e9a9d6af18df813b60237a319900a">XV_HDMIRX_DDC_HDCP_DATA_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a407dbf36f2752c30d265e3a8a25d29fe">XV_HdmiRx_WriteReg</a>.</p>

</div>
</div>
<a id="a6118306bb3bc6821b5a87640a34cafcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6118306bb3bc6821b5a87640a34cafcc">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcIsHdcpReadMessageBufferEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_DdcIsHdcpReadMessageBufferEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the status of the HDCP 2.2 read message buffer in the DDC slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdmi_Rx core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE = HDCP 2.2 message buffer is empty.</li>
<li>FALSE = HDCP 2.2 message buffer contains data.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#af496088efcd5b696f2c6a53b19c73679">XV_HDMIRX_DDC_HDCP_STA_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a321b4e4dc6951519245480d9597a2480">XV_HDMIRX_DDC_STA_HDCP_RMSG_EP_MASK</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a974d5daca9913663c9752972d3953ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974d5daca9913663c9752972d3953ba4">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcIsHdcpWriteMessageBufferEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_DdcIsHdcpWriteMessageBufferEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the status of the HDCP 2.2 write buffer in the DDC slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XHdmi_Rx core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE = HDCP 2.2 message buffer is empty.</li>
<li>FALSE = HDCP 2.2 message buffer contains data.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#af496088efcd5b696f2c6a53b19c73679">XV_HDMIRX_DDC_HDCP_STA_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a6d5995d1a4d8d19ede4fb69ad8130eac">XV_HDMIRX_DDC_STA_HDCP_WMSG_EP_MASK</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a5af2c795e31eaf65f261afacd8b0119f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af2c795e31eaf65f261afacd8b0119f">&#9670;&nbsp;</a></span>XV_HdmiRx_DdcLoadEdid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_DdcLoadEdid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>EdidData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads the EDID data into the DDC slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance. </td></tr>
    <tr><td class="paramname">EdidData</td><td>is a pointer to the EDID data array. </td></tr>
    <tr><td class="paramname">Length</td><td>is the length, in bytes, of the EDID array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the EDID data was loaded successfully</li>
<li>XST_FAILURE if the EDID data load failed</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a92855dc688a9f79d080f1eab92e17144">XV_HDMIRX_DDC_CTRL_EDID_EN_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a8272d8237c5560511743f6645351c889">XV_HDMIRX_DDC_CTRL_SET_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a87d82ea13dd71da7ed87b4645b056dd5">XV_HDMIRX_DDC_EDID_DATA_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#abd5e2bee6eb83de864de63600afef44d">XV_HDMIRX_DDC_EDID_WP_OFFSET</a>, <a class="el" href="xv__hdmirx_8c.html#a0ede81f7ab3357d5fe81c8df0f125e27">XV_HdmiRx_DdcGetEdidWords()</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a407dbf36f2752c30d265e3a8a25d29fe">XV_HdmiRx_WriteReg</a>.</p>

</div>
</div>
<a id="a8a3a0edaaf96c13a8b7296883cc3c195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3a0edaaf96c13a8b7296883cc3c195">&#9670;&nbsp;</a></span>XV_HdmiRx_DebugInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRx_DebugInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints stream and timing information on STDIO/Uart console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>, and <a class="el" href="struct_x_v___hdmi_rx___stream.html#a637935d82811b204c720970e7f7e582a">XV_HdmiRx_Stream::Video</a>.</p>

</div>
</div>
<a id="a1ed0eb9c0b7dfc1013f6f347ef1f040c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed0eb9c0b7dfc1013f6f347ef1f040c">&#9670;&nbsp;</a></span>XV_HdmiRx_Divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_HdmiRx_Divide </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the divider for the frame calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dividend</td><td>is the dividend value to use in the calculation. </td></tr>
    <tr><td class="paramname">Divisor</td><td>is the divisor value to use in the calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the calculation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">Referenced by <a class="el" href="xv__hdmirx_8h.html#a9e11e21cff30c73785c0a2f63944ccd0">XV_HdmiRx_GetVideoTiming()</a>.</p>

</div>
</div>
<a id="ae3dcd032d351867697f19280fdeb1eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dcd032d351867697f19280fdeb1eeb">&#9670;&nbsp;</a></span>XV_HdmiRx_GetAcrCts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_HdmiRx_GetAcrCts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides audio clock regenerating CTS (Cycle-Time Stamp) value at the HDMI sink device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Audio clock CTS value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a3f83199b3cdb183ee02353d031743062">XV_HDMIRX_AUD_CTS_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a0b9483d540e72c619bcc9ba5d516ebe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9483d540e72c619bcc9ba5d516ebe8">&#9670;&nbsp;</a></span>XV_HdmiRx_GetAcrN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_HdmiRx_GetAcrN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides audio clock regenerating factor N value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACR N value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a0c222588615d7174edf1b8c474675ec3">XV_HDMIRX_AUD_N_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a4b2650f744a2a244482124697e632863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2650f744a2a244482124697e632863">&#9670;&nbsp;</a></span>XV_HdmiRx_GetAviColorSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XVidC_ColorFormat XV_HdmiRx_GetAviColorSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the AVI colorspace (captured by the AUX peripheral) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The AVI colorspace value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a18c0b376a593da7df6775ebc78394355">XV_HDMIRX_AUX_STA_AVI_CS_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#ac299e0cc30499f86f60267f7c23d3242">XV_HDMIRX_AUX_STA_AVI_CS_SHIFT</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a73d86d2cff54ce9143501c9029b6666e">XV_HDMIRX_AUX_STA_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="xv__hdmirx_8h.html#a6f74899b52dfbb8e0e554bbdea04bd29">XV_HdmiRx_GetVideoProperties()</a>.</p>

</div>
</div>
<a id="afaa89bbc453b2d7e1446140c73b7baee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa89bbc453b2d7e1446140c73b7baee">&#9670;&nbsp;</a></span>XV_HdmiRx_GetAviVic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRx_GetAviVic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the AVI VIC (captured by the AUX peripheral) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The AVI VIC code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#aae57be2d73942a73e349d3d468d4f8b7">XV_HDMIRX_AUX_STA_AVI_VIC_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a1eac59ae54921281d77742aabb932158">XV_HDMIRX_AUX_STA_AVI_VIC_SHIFT</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a73d86d2cff54ce9143501c9029b6666e">XV_HDMIRX_AUX_STA_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="xv__hdmirx_8h.html#a6f74899b52dfbb8e0e554bbdea04bd29">XV_HdmiRx_GetVideoProperties()</a>.</p>

</div>
</div>
<a id="a87e0904b6a6167f3cde2e7fcc0843e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e0904b6a6167f3cde2e7fcc0843e1d">&#9670;&nbsp;</a></span>XV_HdmiRx_GetGcpColorDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XVidC_ColorDepth XV_HdmiRx_GetGcpColorDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the GCP color depth (captured by the AUX peripheral) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The GCP color depth.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a6e84a7312408ad6204ee0846573e292c">XV_HDMIRX_AUX_STA_GCP_CD_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a6078073cb572492cffb23b1c85a514a2">XV_HDMIRX_AUX_STA_GCP_CD_SHIFT</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a73d86d2cff54ce9143501c9029b6666e">XV_HDMIRX_AUX_STA_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="xv__hdmirx_8h.html#a6f74899b52dfbb8e0e554bbdea04bd29">XV_HdmiRx_GetVideoProperties()</a>.</p>

</div>
</div>
<a id="aad02ea3d99f0ac3a7f4a0b18f88d62e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad02ea3d99f0ac3a7f4a0b18f88d62e8">&#9670;&nbsp;</a></span>XV_HdmiRx_GetLinkStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_HdmiRx_GetLinkStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides status of the HDMI RX core Link Status peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance. </td></tr>
    <tr><td class="paramname">Type</td><td>specifies one of the type for which status to be provided:<ul>
<li>0 = Link error counter for channel 0.</li>
<li>1 = Link error counter for channel 1.</li>
<li>2 = Link error counter for channel 2.</li>
<li>3 = Link phase.</li>
<li>4 = Link delay.</li>
<li>5 = Link line length</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Link status of the HDMI RX core link.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#afb0995c7dadd967e0be16f4d31d60bd8">XV_HDMIRX_LNKSTA_LNK_ERR0_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a36bca352ee91492da1392cae5ddcfa6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bca352ee91492da1392cae5ddcfa6c">&#9670;&nbsp;</a></span>XV_HdmiRx_GetTmdsClockRatio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_GetTmdsClockRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the SCDC TMDS clock ratio bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE = TMDS clock ratio bit is set.</li>
<li>FALSE = TMDS clock ratio bit is cleared.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a729bb6c385b324610317135c52298eba">XV_HDMIRX_PIO_IN_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#af439412374d6713f5b5a375c54d9df68">XV_HDMIRX_PIO_IN_SCDC_TMDS_CLOCK_RATIO_MASK</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a6f74899b52dfbb8e0e554bbdea04bd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f74899b52dfbb8e0e554bbdea04bd29">&#9670;&nbsp;</a></span>XV_HdmiRx_GetVideoProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_GetVideoProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the video properties from the aux peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a6e300e58c18687d3d6227cc410593373">XV_HdmiRx_Stream::Vic</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a637935d82811b204c720970e7f7e582a">XV_HdmiRx_Stream::Video</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a2a2964d1f987bbdb5055dc4afeb66c0a">XV_HDMIRX_AUX_STA_AVI_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a73d86d2cff54ce9143501c9029b6666e">XV_HDMIRX_AUX_STA_OFFSET</a>, <a class="el" href="xv__hdmirx_8c.html#a4b2650f744a2a244482124697e632863">XV_HdmiRx_GetAviColorSpace()</a>, <a class="el" href="xv__hdmirx_8c.html#afaa89bbc453b2d7e1446140c73b7baee">XV_HdmiRx_GetAviVic()</a>, <a class="el" href="xv__hdmirx_8c.html#a87e0904b6a6167f3cde2e7fcc0843e1d">XV_HdmiRx_GetGcpColorDepth()</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a9e11e21cff30c73785c0a2f63944ccd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e11e21cff30c73785c0a2f63944ccd0">&#9670;&nbsp;</a></span>XV_HdmiRx_GetVideoTiming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_GetVideoTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the video timing from the VTD peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a7720ba7e2a246551fa148bd7611bfdbf">XV_HdmiRx_Stream::PixelClk</a>, <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a6e300e58c18687d3d6227cc410593373">XV_HdmiRx_Stream::Vic</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a637935d82811b204c720970e7f7e582a">XV_HdmiRx_Stream::Video</a>, <a class="el" href="xv__hdmirx_8c.html#a1ed0eb9c0b7dfc1013f6f347ef1f040c">XV_HdmiRx_Divide()</a>, <a class="el" href="xv__hdmirx_8c.html#ae971dd56fea8451e407ceba3af0612f7">XV_HdmiRx_LookupVmId()</a>, <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a8e1330cc6542ff96733cb7f7e29465fc">XV_HDMIRX_VTD_ACT_LIN_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a680b488ede6d6a8ec9d730deff7559e8">XV_HDMIRX_VTD_ACT_PIX_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#ae639e59a8ebf41da214a1de1246feae3">XV_HDMIRX_VTD_HBP_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a9d1c2a6712699269f8e69dd2c576a3eb">XV_HDMIRX_VTD_HFP_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a18b3fcc81e0b4ebffe5d03b93b9e3a92">XV_HDMIRX_VTD_HSW_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a8810fe79655104c0b273b6868b2407fb">XV_HDMIRX_VTD_STA_FMT_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#abb3320c46658b4aaa9faa3c78f535fd1">XV_HDMIRX_VTD_STA_HS_POL_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#aa0927784dd0514805715557437733268">XV_HDMIRX_VTD_STA_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#aa003ad3deba710d8250e4d09c3d706a4">XV_HDMIRX_VTD_STA_VS_POL_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a760c24aa9d33dd2727c6106537c4723d">XV_HDMIRX_VTD_TOT_LIN_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#ada7dd9b96b61f5400488120a035a733c">XV_HDMIRX_VTD_TOT_PIX_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a0f25a70ae387411851a4e26d62c4a42a">XV_HDMIRX_VTD_VBP_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a7976bef95da52ceaf075d949bbf95fe4">XV_HDMIRX_VTD_VFP_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a38aa5d3cc486342d8414cccece29d578">XV_HDMIRX_VTD_VSW_OFFSET</a>.</p>

</div>
</div>
<a id="a70bb5419e7285a268518668fda1d70cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bb5419e7285a268518668fda1d70cd">&#9670;&nbsp;</a></span>XV_HdmiRx_IsLinkStatusErrMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_IsLinkStatusErrMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides status of one of the link error counters reached the maximum value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE = Maximum error counter reached.</li>
<li>FALSE = Maximum error counter not reached.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a6b68f41c0790de0b711903449a1286b2">XV_HDMIRX_LNKSTA_STA_ERR_MAX_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a99d2e4c21738838bb3de9ab7042019b1">XV_HDMIRX_LNKSTA_STA_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#ab1245a8a62b2b5611cc4cbb2aa4af75b">XV_HdmiRx_ReadReg</a>.</p>

</div>
</div>
<a id="a9bbc4765c852092e33ff24124b2fc3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbc4765c852092e33ff24124b2fc3f8">&#9670;&nbsp;</a></span>XV_HdmiRx_IsStreamConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_IsStreamConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the stream connected status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE = Stream is connected.</li>
<li>FALSE = Stream is connected.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___stream.html#ac8e73b60a5a883be23f2eef66d72f016">XV_HdmiRx_Stream::IsConnected</a>, and <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>.</p>

</div>
</div>
<a id="a0cc46a138f5d16ad0b85da090e3abb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc46a138f5d16ad0b85da090e3abb11">&#9670;&nbsp;</a></span>XV_HdmiRx_IsStreamScrambled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_IsStreamScrambled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides the stream scrambler status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE = Stream is scrambled.</li>
<li>FALSE = Stream is not scrambled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___stream.html#ac084ff2af93033a9504140eea22edf6c">XV_HdmiRx_Stream::IsScrambled</a>, and <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>.</p>

</div>
</div>
<a id="ac7b5ed80c20dbf62ab2e98569097be2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b5ed80c20dbf62ab2e98569097be2f">&#9670;&nbsp;</a></span>XV_HdmiRx_IsStreamUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_IsStreamUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides status of the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE = Stream is up.</li>
<li>FALSE = Stream is down.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___stream.html#a0dd7bc8d80e7b48cfa2e719ee8c00ad1">XV_HdmiRx_Stream::State</a>, <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>, and <a class="el" href="xv__hdmirx_8h.html#a1a0a96c3c2d056c688b7444355656695a3b9a5021e46340fc32df2d4b5c7cf941">XV_HDMIRX_STATE_STREAM_UP</a>.</p>

</div>
</div>
<a id="ae971dd56fea8451e407ceba3af0612f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae971dd56fea8451e407ceba3af0612f7">&#9670;&nbsp;</a></span>XV_HdmiRx_LookupVmId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XVidC_VideoMode XV_HdmiRx_LookupVmId </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Vic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function searches for the video mode based on the vic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vic</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vic defined in the VIC table.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">Referenced by <a class="el" href="xv__hdmirx_8h.html#a9e11e21cff30c73785c0a2f63944ccd0">XV_HdmiRx_GetVideoTiming()</a>.</p>

</div>
</div>
<a id="a72457c11b43becc2fd5bffc1b748bf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72457c11b43becc2fd5bffc1b748bf30">&#9670;&nbsp;</a></span>XV_HdmiRx_SetColorFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRx_SetColorFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the color format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a637935d82811b204c720970e7f7e582a">XV_HdmiRx_Stream::Video</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a03f17ccc9e2953ac921f07446dfc9c16">XV_HDMIRX_PIO_OUT_COLOR_SPACE_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a5c1716813413cd8ca952fafe0520b782">XV_HDMIRX_PIO_OUT_COLOR_SPACE_SHIFT</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a7e3ed781e3e5bc38c206ee7d712894c8">XV_HDMIRX_PIO_OUT_MSK_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a21ac38c5488361502fc525c6497e922b">XV_HDMIRX_PIO_OUT_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a407dbf36f2752c30d265e3a8a25d29fe">XV_HdmiRx_WriteReg</a>.</p>

</div>
</div>
<a id="a8601d159dffdd4fd77d05d248b366a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8601d159dffdd4fd77d05d248b366a54">&#9670;&nbsp;</a></span>XV_HdmiRx_SetHpd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_SetHpd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SetClr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/clear Hot-Plug-Detect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance. </td></tr>
    <tr><td class="paramname">SetClr</td><td>specifies TRUE/FALSE value to either enable or clear HPD respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS is always returned.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a80d63952308a1e96d3bfd10db732b94c">XV_HDMIRX_PIO_OUT_CLR_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a51974eaab5f1447924b24e7ad9795f41">XV_HDMIRX_PIO_OUT_HPD_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#add1b42f293960a225e7c7addc81ba41a">XV_HDMIRX_PIO_OUT_SET_OFFSET</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a407dbf36f2752c30d265e3a8a25d29fe">XV_HdmiRx_WriteReg</a>.</p>

</div>
</div>
<a id="ab48ac8ab5eeddd6197c6220db1ac8ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48ac8ab5eeddd6197c6220db1ac8ee5">&#9670;&nbsp;</a></span>XV_HdmiRx_SetPixelRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_SetPixelRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the pixel rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS is always returned.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___config.html#af7bfcbc5394a19ebdb89c10cb8622d39">XV_HdmiRx_Config::BaseAddress</a>, <a class="el" href="struct_x_v___hdmi_rx.html#ad2b9509ba5aae6678619d0e1845ef09e">XV_HdmiRx::Config</a>, <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a637935d82811b204c720970e7f7e582a">XV_HdmiRx_Stream::Video</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a7e3ed781e3e5bc38c206ee7d712894c8">XV_HDMIRX_PIO_OUT_MSK_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a21ac38c5488361502fc525c6497e922b">XV_HDMIRX_PIO_OUT_OFFSET</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a415a6510fe5c6bc29230e9c370e13985">XV_HDMIRX_PIO_OUT_PIXEL_RATE_MASK</a>, <a class="el" href="xv__hdmirx__hw_8h.html#a93050e6b1ea95d7147823e81113e6919">XV_HDMIRX_PIO_OUT_PIXEL_RATE_SHIFT</a>, and <a class="el" href="xv__hdmirx__hw_8h.html#a407dbf36f2752c30d265e3a8a25d29fe">XV_HdmiRx_WriteReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="xv__hdmirx_8h.html#a903b465cb41a9a040ba40eefa3109929">XV_HdmiRx_SetStream()</a>.</p>

</div>
</div>
<a id="a903b465cb41a9a040ba40eefa3109929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903b465cb41a9a040ba40eefa3109929">&#9670;&nbsp;</a></span>XV_HdmiRx_SetStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRx_SetStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx.html">XV_HdmiRx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XVidC_PixelsPerClock&#160;</td>
          <td class="paramname"><em>Ppc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Clock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the HDMI RX stream parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx.html" title="The XHdmiRx driver instance data. ">XV_HdmiRx</a> core instance. </td></tr>
    <tr><td class="paramname">Ppc</td><td>specifies the pixel per clock.<ul>
<li>1 = XVIDC_PPC_1</li>
<li>2 = XVIDC_PPC_2</li>
<li>4 = XVIDC_PPC_4 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Clock</td><td>specifies reference pixel clock frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS is always returned.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx___stream.html#a8b6027e80fbba82d752bf10a44fa2bc4">XV_HdmiRx_Stream::RefClk</a>, <a class="el" href="struct_x_v___hdmi_rx.html#af05084fa8d75129bcba271b86a8d3e62">XV_HdmiRx::Stream</a>, <a class="el" href="struct_x_v___hdmi_rx___stream.html#a637935d82811b204c720970e7f7e582a">XV_HdmiRx_Stream::Video</a>, and <a class="el" href="xv__hdmirx_8c.html#ab48ac8ab5eeddd6197c6220db1ac8ee5">XV_HdmiRx_SetPixelRate()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
