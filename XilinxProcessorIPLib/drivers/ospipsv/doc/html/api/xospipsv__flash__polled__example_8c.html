<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>ospipsv: xospipsv_flash_polled_example.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">ospipsv
   </div>
   <div id="projectbrief">Xilinx Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xospipsv__flash__polled__example_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xospipsv_flash_polled_example.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This file contains a design example using the OSPIPSV driver (xospipsv) The example writes to flash in IO mode and reads it back in DMA mode. </p>
<p>It runs in polled mode. The hardware which this example runs on, must have an octal serial Flash (Micron) for it to run.</p>
<p>This example has been tested with the Micron Octal Serial Flash (mt35xu01gbba).</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who Date     Changes
</p>
<hr/>
<p>
 1.0   nsk  02/19/17 First release
       sk   01/09/19 Updated flash configuration table with
                     supported commands.
       sk   02/04/19 Add support for SDR+PHY and DDR+PHY modes.
 1.0   akm 03/29/19 Fixed data alignment issues on IAR compiler.
 1.1   sk  07/23/19 Based on RX Tuning, updated the dummy cycles.
       sk  08/08/19 Issue device reset to bring back to default state.
 1.3   sk  05/27/20 Added Stacked mode support.
 1.4   sk  02/18/21 Added support for Macronix flash and DualByte commands.</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a47495bff6dd24133e2922fd1d1af277a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a47495bff6dd24133e2922fd1d1af277a">OspiPsvPolledFlashExample</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvInstancePtr, u16 OspiPsvDeviceId)</td></tr>
<tr class="memdesc:a47495bff6dd24133e2922fd1d1af277a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_ospi_psv.html" title="The XOspiPsv driver instance data. ">XOspiPsv</a> device driver using OSPI flash devices greater than or equal to 128Mb.  <a href="#a47495bff6dd24133e2922fd1d1af277a">More...</a><br/></td></tr>
<tr class="separator:a47495bff6dd24133e2922fd1d1af277a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dbfab221d6a11c3fa45674c1304f2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a19dbfab221d6a11c3fa45674c1304f2e">FlashReadID</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr)</td></tr>
<tr class="memdesc:a19dbfab221d6a11c3fa45674c1304f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the flash ID and identifies the flash in FCT table.  <a href="#a19dbfab221d6a11c3fa45674c1304f2e">More...</a><br/></td></tr>
<tr class="separator:a19dbfab221d6a11c3fa45674c1304f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d28e30d23e136e4af00a436d43c9923"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a6d28e30d23e136e4af00a436d43c9923">FlashErase</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, u32 Address, u32 ByteCount, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a6d28e30d23e136e4af00a436d43c9923"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function erases the sectors in the serial Flash connected to the OSPIPSV interface.  <a href="#a6d28e30d23e136e4af00a436d43c9923">More...</a><br/></td></tr>
<tr class="separator:a6d28e30d23e136e4af00a436d43c9923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8337d4d551570e7ecaa44321605280a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a8337d4d551570e7ecaa44321605280a7">FlashIoWrite</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, u32 Address, u32 ByteCount, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a8337d4d551570e7ecaa44321605280a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to the serial Flash connected to the OSPIPSV interface.  <a href="#a8337d4d551570e7ecaa44321605280a7">More...</a><br/></td></tr>
<tr class="separator:a8337d4d551570e7ecaa44321605280a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fff73aa13d90cd15521ab1f7de503dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a6fff73aa13d90cd15521ab1f7de503dc">FlashLinearWrite</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, u32 Address, u32 ByteCount, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a6fff73aa13d90cd15521ab1f7de503dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes to the serial Flash connected to the OSPIPSV interface.  <a href="#a6fff73aa13d90cd15521ab1f7de503dc">More...</a><br/></td></tr>
<tr class="separator:a6fff73aa13d90cd15521ab1f7de503dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1355d0e2c6bb04d1f65ca815d71d5996"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a1355d0e2c6bb04d1f65ca815d71d5996">FlashRead</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, u32 Address, u32 ByteCount, u8 *WriteBfrPtr, u8 *ReadBfrPtr)</td></tr>
<tr class="memdesc:a1355d0e2c6bb04d1f65ca815d71d5996"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs read.  <a href="#a1355d0e2c6bb04d1f65ca815d71d5996">More...</a><br/></td></tr>
<tr class="separator:a1355d0e2c6bb04d1f65ca815d71d5996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08db22955675661860c9008890b0138"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#ae08db22955675661860c9008890b0138">GetRealAddr</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, u32 Address)</td></tr>
<tr class="memdesc:ae08db22955675661860c9008890b0138"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions translates the address based on the type of interconnection.  <a href="#ae08db22955675661860c9008890b0138">More...</a><br/></td></tr>
<tr class="separator:ae08db22955675661860c9008890b0138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223a0d4b5dd8fb7fca1b1e42872d3521"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a223a0d4b5dd8fb7fca1b1e42872d3521">BulkErase</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a223a0d4b5dd8fb7fca1b1e42872d3521"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a bulk erase operation when the flash device has a single die.  <a href="#a223a0d4b5dd8fb7fca1b1e42872d3521">More...</a><br/></td></tr>
<tr class="separator:a223a0d4b5dd8fb7fca1b1e42872d3521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb61abe9a7b767c75ad57929adf3b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a7ceb61abe9a7b767c75ad57929adf3b3">DieErase</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, u8 *WriteBfrPtr)</td></tr>
<tr class="memdesc:a7ceb61abe9a7b767c75ad57929adf3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions performs a die erase operation on all the die in the flash device.  <a href="#a7ceb61abe9a7b767c75ad57929adf3b3">More...</a><br/></td></tr>
<tr class="separator:a7ceb61abe9a7b767c75ad57929adf3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e1c114b2752e00136aa5ebb3cbeda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a929e1c114b2752e00136aa5ebb3cbeda">FlashEnterExit4BAddMode</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, int Enable)</td></tr>
<tr class="memdesc:a929e1c114b2752e00136aa5ebb3cbeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enters the flash device into 4 bytes addressing mode.  <a href="#a929e1c114b2752e00136aa5ebb3cbeda">More...</a><br/></td></tr>
<tr class="separator:a929e1c114b2752e00136aa5ebb3cbeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ee697864550c95e476b41c43c0764f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a92ee697864550c95e476b41c43c0764f">FlashSetSDRDDRMode</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvPtr, int Mode)</td></tr>
<tr class="memdesc:a92ee697864550c95e476b41c43c0764f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enters the flash device into Octal DDR mode or exit from octal DDR mode (switches to Extended SPI mode).  <a href="#a92ee697864550c95e476b41c43c0764f">More...</a><br/></td></tr>
<tr class="separator:a92ee697864550c95e476b41c43c0764f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr class="memdesc:a840291bc02cba5474a4cb46a9b9566fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function to call the OSPIPSV Flash Polled example.  <a href="#a840291bc02cba5474a4cb46a9b9566fe">More...</a><br/></td></tr>
<tr class="separator:a840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2382b1a337e871524e10a23f1b984"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xospipsv__flash__polled__example_8c.html#a08e2382b1a337e871524e10a23f1b984">XOspiPsv_Get_Proto</a> (<a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *OspiPsvInstancePtr, int Read)</td></tr>
<tr class="memdesc:a08e2382b1a337e871524e10a23f1b984"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this function is to determine the number of lines used for command, address and data.  <a href="#a08e2382b1a337e871524e10a23f1b984">More...</a><br/></td></tr>
<tr class="separator:a08e2382b1a337e871524e10a23f1b984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a223a0d4b5dd8fb7fca1b1e42872d3521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BulkErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a bulk erase operation when the flash device has a single die. </p>
<p>Works for both Spansion and Micron</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ceb61abe9a7b767c75ad57929adf3b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DieErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions performs a die erase operation on all the die in the flash device. </p>
<p>This function uses the die erase command for Micron 512Mbit and 1Gbit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is the pointer to command+address to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a929e1c114b2752e00136aa5ebb3cbeda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashEnterExit4BAddMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enters the flash device into 4 bytes addressing mode. </p>
<p>As per the Micron spec, before issuing the command to enter into 4 byte addr mode, a write enable command is issued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">Enable</td><td>is a either 1 or 0 if 1 then enters 4 byte if 0 exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- XST_SUCCESS if successful.<ul>
<li>XST_FAILURE if it fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6d28e30d23e136e4af00a436d43c9923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function erases the sectors in the serial Flash connected to the OSPIPSV interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is Pointer to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8337d4d551570e7ecaa44321605280a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashIoWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to the serial Flash connected to the OSPIPSV interface. </p>
<p>All the data put into the buffer must be in the same page of the device with page boundaries being on 256 byte boundaries. This can be used in IO or DMA mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address to write data to in the Flash. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to write. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is Pointer to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fff73aa13d90cd15521ab1f7de503dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashLinearWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes to the serial Flash connected to the OSPIPSV interface. </p>
<p>All the data put into the buffer must be in the same page of the device with page boundaries being on 256 byte boundaries. This can be used when controller is in Linear mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address to write data to in the Flash. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to write. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is Pointer to the write buffer (which is to be transmitted)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_ospi_psv___msg.html#af8358bd6a8075c4abacf9b0a7b10a490">XOspiPsv_Msg::Addr</a>, <a class="el" href="struct_x_ospi_psv___msg.html#aed44f5b363f17a6ebb50ec89b032f112">XOspiPsv_Msg::Addrsize</a>, <a class="el" href="struct_x_ospi_psv___msg.html#a3df927f0564ffc2896abff80b63e5601">XOspiPsv_Msg::Addrvalid</a>, <a class="el" href="struct_x_ospi_psv___msg.html#ab46554545943ecf8f1a0152c237489f4">XOspiPsv_Msg::ByteCount</a>, <a class="el" href="struct_x_ospi_psv.html#a4796e4047cf6a5cb697cfdb5e4799aa7">XOspiPsv::DualByteOpcodeEn</a>, <a class="el" href="struct_x_ospi_psv___msg.html#aee5814ae840542f0968358c6c00371d8">XOspiPsv_Msg::Dummy</a>, <a class="el" href="struct_x_ospi_psv___msg.html#a63025a20ca549b4b65f2c6d611d40abc">XOspiPsv_Msg::ExtendedOpcode</a>, <a class="el" href="struct_x_ospi_psv___msg.html#a960350cdb6c3c5dc679c637ca1e21be0">XOspiPsv_Msg::Flags</a>, <a class="el" href="struct_x_ospi_psv___msg.html#a5a9c4b0b141795207120a3d62c6d5144">XOspiPsv_Msg::IsDDROpCode</a>, <a class="el" href="struct_x_ospi_psv___msg.html#a55ac289317d94775757cac9529ea51c2">XOspiPsv_Msg::Opcode</a>, <a class="el" href="struct_x_ospi_psv___msg.html#a9d8c2658ecdf8c0e9d7f4196844cccf0">XOspiPsv_Msg::Proto</a>, <a class="el" href="struct_x_ospi_psv___msg.html#a584672579015305052780c6b14e5a576">XOspiPsv_Msg::RxBfrPtr</a>, <a class="el" href="struct_x_ospi_psv.html#acf4693770163d8061cd9eb4bdaa32605">XOspiPsv::SdrDdrMode</a>, <a class="el" href="struct_x_ospi_psv___msg.html#a95f5d41c7ebd3d5b5da41c6289049e6f">XOspiPsv_Msg::TxBfrPtr</a>, <a class="el" href="xospipsv__flash__intr__example_8c.html#a08e2382b1a337e871524e10a23f1b984">XOspiPsv_Get_Proto()</a>, and <a class="el" href="group__ospipsv__v1__4.html#ga808cc2759798221d0d4f44eef27c0629">XOspiPsv_PollTransfer()</a>.</p>

<p>Referenced by <a class="el" href="xospipsv__flash__non__blocking__read__example_8c.html#add3e41c7ec3ce5d1ae9f84b65b180829">OspiPsvFlashNonBlockingReadExample()</a>, and <a class="el" href="xospipsv__flash__polled__example_8c.html#a47495bff6dd24133e2922fd1d1af277a">OspiPsvPolledFlashExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a1355d0e2c6bb04d1f65ca815d71d5996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WriteBfrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadBfrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs read. </p>
<p>DMA is the default setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>contains the address of the first sector which needs to be erased. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the total size to be erased. </td></tr>
    <tr><td class="paramname">WriteBfrPtr</td><td>is Pointer to the write buffer which contains data to be transmitted </td></tr>
    <tr><td class="paramname">ReadBfrPtr</td><td>is Pointer to the read buffer to which valid received data should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a19dbfab221d6a11c3fa45674c1304f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashReadID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the flash ID and identifies the flash in FCT table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a92ee697864550c95e476b41c43c0764f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FlashSetSDRDDRMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enters the flash device into Octal DDR mode or exit from octal DDR mode (switches to Extended SPI mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">Mode</td><td>is either 1 or 0 if 1 then enter octal DDR mode if 0 exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- XST_SUCCESS if successful.<ul>
<li>XST_FAILURE if it fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae08db22955675661860c9008890b0138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 GetRealAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions translates the address based on the type of interconnection. </p>
<p>In case of stacked, this function asserts the corresponding slave select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvPtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">Address</td><td>which is to be accessed (for erase, write or read)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RealAddr is the translated address - for single it is unchanged; for stacked, the lower flash size is subtracted;</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In addition to get the actual address to work on flash this function also selects the CS based on the configuration detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a840291bc02cba5474a4cb46a9b9566fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function to call the OSPIPSV Flash Polled example. </p>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, otherwise XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="xospipsv__flash__polled__example_8c.html#a47495bff6dd24133e2922fd1d1af277a">OspiPsvPolledFlashExample()</a>.</p>

</div>
</div>
<a class="anchor" id="a47495bff6dd24133e2922fd1d1af277a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OspiPsvPolledFlashExample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>OspiPsvDeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The purpose of this function is to illustrate how to use the <a class="el" href="struct_x_ospi_psv.html" title="The XOspiPsv driver instance data. ">XOspiPsv</a> device driver using OSPI flash devices greater than or equal to 128Mb. </p>
<p>This function reads data in either DMA or DAC mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvInstancePtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">OspiPsvDeviceId</td><td>is the Device ID of the OSpi Device and is the XPAR_&lt;OSPI_instance&gt;_DEVICE_ID value from xparameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful, else XST_FAILURE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_ospi_psv.html#a587249b499cdfc3e3da286143039006c">XOspiPsv::Config</a>, <a class="el" href="struct_x_ospi_psv___config.html#a5ca4fb3ed8b0107599596c5cbf8e8591">XOspiPsv_Config::ConnectionMode</a>, <a class="el" href="xospipsv__flash__intr__example_8c.html#a929e1c114b2752e00136aa5ebb3cbeda">FlashEnterExit4BAddMode()</a>, <a class="el" href="xospipsv__flash__intr__example_8c.html#a6d28e30d23e136e4af00a436d43c9923">FlashErase()</a>, <a class="el" href="xospipsv__flash__intr__example_8c.html#a8337d4d551570e7ecaa44321605280a7">FlashIoWrite()</a>, <a class="el" href="xospipsv__flash__intr__example_8c.html#a6fff73aa13d90cd15521ab1f7de503dc">FlashLinearWrite()</a>, <a class="el" href="xospipsv__flash__intr__example_8c.html#a1355d0e2c6bb04d1f65ca815d71d5996">FlashRead()</a>, <a class="el" href="xospipsv__flash__intr__example_8c.html#a19dbfab221d6a11c3fa45674c1304f2e">FlashReadID()</a>, <a class="el" href="xospipsv__flash__intr__example_8c.html#a92ee697864550c95e476b41c43c0764f">FlashSetSDRDDRMode()</a>, <a class="el" href="group__ospipsv__v1__4.html#gae5a31f79cc2df46027e4b9f26cad97ad">XOspiPsv_CfgInitialize()</a>, <a class="el" href="group__ospipsv__v1__4.html#ga15c0973b6b32cee5484231f4b0964024">XOSPIPSV_DAC_EN_OPTION</a>, <a class="el" href="group__ospipsv__v1__4.html#ga16fcc38cab80027ea601c99569517067">XOspiPsv_DeviceReset()</a>, <a class="el" href="group__ospipsv__v1__4.html#ga19324f8c6c1156b26c84cc9d413a4801">XOspiPsv_GetOptions()</a>, <a class="el" href="group__ospipsv__v1__4.html#ga1354e2d970f4721642687811112360d1">XOSPIPSV_HWPIN_RESET</a>, <a class="el" href="group__ospipsv__v1__4.html#gaf44a1c9ce528880318fbfd61c256b0d3">XOspiPsv_LookupConfig()</a>, <a class="el" href="group__ospipsv__v1__4.html#ga40bc60d265ec996c0327b2ae56f22e93">XOSPIPSV_SELECT_FLASH_CS0</a>, <a class="el" href="group__ospipsv__v1__4.html#ga2d17525a71d9df7268fcc4269f19270c">XOspiPsv_SelectFlash()</a>, <a class="el" href="group__ospipsv__v1__4.html#ga45c51bcfa1e2d996298847c2b7910ba6">XOspiPsv_SetClkPrescaler()</a>, <a class="el" href="group__ospipsv__v1__4.html#gab47df170b16816d4cc11dee6c3008e3c">XOspiPsv_SetOptions()</a>, and <a class="el" href="group__ospipsv__v1__4.html#ga74efb98d92b16935c3ea41e4f77cecea">XOspiPsv_SetSdrDdrMode()</a>.</p>

<p>Referenced by <a class="el" href="xospipsv__flash__polled__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a08e2382b1a337e871524e10a23f1b984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XOspiPsv_Get_Proto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ospi_psv.html">XOspiPsv</a> *&#160;</td>
          <td class="paramname"><em>OspiPsvInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The purpose of this function is to determine the number of lines used for command, address and data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OspiPsvInstancePtr</td><td>is a pointer to the OSPIPSV driver component to use. </td></tr>
    <tr><td class="paramname">Read</td><td>is to tell whether a read or write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns value to program the lines for command, address and data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_ospi_psv.html#abb16a8f44c9ec93487044060e9fb522e">XOspiPsv::OpMode</a>, <a class="el" href="group__ospipsv__v1__4.html#gad90cde53aa1c59a7a9a8450c8b109782">XOSPIPSV_IDAC_MODE</a>, and <a class="el" href="group__ospipsv__v1__4.html#ga2cadd5891ddc5aaa4344c4c5f04df53f">XOSPIPSV_READ_1_1_1</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
