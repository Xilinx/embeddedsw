<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>axiethernet: xavb.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">axiethernet
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xavb_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xavb.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>The top level c file for the AVB driver. </p>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who  Date     Changes
</p>
<hr/>
<p>
1.00a mbr  09/19/08 First release
1.01a mbr  06/24/09 PTP frame format updates for IEEE802.1 AS draft 5-0
2_02a mbr  09/16/09 Updates for programmable PTP timers
2_04a kag  07/23/10 PTP frame format updates for IEEE802.1 AS draft 6-7
3_01a kag  08/29/11 Added new APIs to update the RX Filter Control Reg.
              Fix for CR:572539. Updated bit map for Rx Filter
              control reg.</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8ddc8d42f610c49547f6cf4778629d1"><td class="memItemLeft" align="right" valign="top">XStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#af8ddc8d42f610c49547f6cf4778629d1">XAvb_CfgInitialize</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, <a class="el" href="struct_x_avb___config.html">XAvb_Config</a> *ConfigPtr, u32 EffectiveAddress)</td></tr>
<tr class="memdesc:af8ddc8d42f610c49547f6cf4778629d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to initialise variables in the data structure records.  <a href="#af8ddc8d42f610c49547f6cf4778629d1">More...</a><br/></td></tr>
<tr class="separator:af8ddc8d42f610c49547f6cf4778629d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24c248c31c6c45cdb8a46f82de175c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:af24c248c31c6c45cdb8a46f82de175c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets all of the AVB device driver functions to the start-up (reset) defaults.  <a href="#af24c248c31c6c45cdb8a46f82de175c5">More...</a><br/></td></tr>
<tr class="separator:af24c248c31c6c45cdb8a46f82de175c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8657704dc9974d465536615ebbeb79d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#a8657704dc9974d465536615ebbeb79d9">XAvb_Start</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a8657704dc9974d465536615ebbeb79d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will start the PTP drivers running.  <a href="#a8657704dc9974d465536615ebbeb79d9">More...</a><br/></td></tr>
<tr class="separator:a8657704dc9974d465536615ebbeb79d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5d4a65b18da8805b9a6bf464961f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#a5a5d4a65b18da8805b9a6bf464961f25">XAvb_Stop</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a5a5d4a65b18da8805b9a6bf464961f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will stop the PTP drivers from running.  <a href="#a5a5d4a65b18da8805b9a6bf464961f25">More...</a><br/></td></tr>
<tr class="separator:a5a5d4a65b18da8805b9a6bf464961f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab96c1602bda46380e25d0bb03a8ac01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:aab96c1602bda46380e25d0bb03a8ac01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Interrupt subroutine for the "interruptPtpTimer" signal.  <a href="#aab96c1602bda46380e25d0bb03a8ac01">More...</a><br/></td></tr>
<tr class="separator:aab96c1602bda46380e25d0bb03a8ac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99019d3795040dd7110d47aaa598ab7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a99019d3795040dd7110d47aaa598ab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Interrupt subroutine for the "interrupt_ptp_rx" signal.  <a href="#a99019d3795040dd7110d47aaa598ab7b">More...</a><br/></td></tr>
<tr class="separator:a99019d3795040dd7110d47aaa598ab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a970ecc2621c88825ecc3f01ff1c4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#a4a970ecc2621c88825ecc3f01ff1c4ad">XAvb_SetupRxFilterControlPcp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 VlanPriority, u8 SrClass)</td></tr>
<tr class="memdesc:a4a970ecc2621c88825ecc3f01ff1c4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to set the VLAN PCP field for either SR A or B traffic in the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter.  <a href="#a4a970ecc2621c88825ecc3f01ff1c4ad">More...</a><br/></td></tr>
<tr class="separator:a4a970ecc2621c88825ecc3f01ff1c4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb10d8fd68257130d0fc50bfe71ad3e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#afb10d8fd68257130d0fc50bfe71ad3e6">XAvb_SetupRxFilterControlVid</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 VlanVid, u8 SrClass)</td></tr>
<tr class="memdesc:afb10d8fd68257130d0fc50bfe71ad3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to set the VLAN VID field for either SR A or B traffic in the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter.  <a href="#afb10d8fd68257130d0fc50bfe71ad3e6">More...</a><br/></td></tr>
<tr class="separator:afb10d8fd68257130d0fc50bfe71ad3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888d220aeb387018ce33558e08d0166e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8c.html#a888d220aeb387018ce33558e08d0166e">XAvb_SetupRxFilterControlMatchMode</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 VlanMatchMode)</td></tr>
<tr class="memdesc:a888d220aeb387018ce33558e08d0166e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to set the VLAN Match Mode field for the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter.  <a href="#a888d220aeb387018ce33558e08d0166e">More...</a><br/></td></tr>
<tr class="separator:a888d220aeb387018ce33558e08d0166e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af8ddc8d42f610c49547f6cf4778629d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XStatus XAvb_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___config.html">XAvb_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EffectiveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to initialise variables in the data structure records. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">ConfigPtr</td><td>is the Configuration Pointer </td></tr>
    <tr><td class="paramname">EffectiveAddress</td><td>is the base address of the Configuration Pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_NOT_FOUND if device configuration information was not found for a device with the supplied device ID.* </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>The component is not yet ready to use</p>
<p>Clear instance memory</p>
<p>Lookup the device configuration in the temporary CROM table. Use this configuration info down below when initializing this component.</p>
<p>Populate Base Address field using the base address value in the configuration structure.</p>
<p>Indicate the component is now ready to use.</p>
<p>Set the callback handler to a stub</p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb.html#adaa9fca5f2df9e76794cb97f8bd1f307">XAvb::GMDiscHandler</a>, and <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a99019d3795040dd7110d47aaa598ab7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_PtpRxInterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Interrupt subroutine for the "interrupt_ptp_rx" signal. </p>
<p>This interrupt fires whenever a PTP frame has been received. The main function is to identify, decode, and act on the type of PTP frame received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>RxPtpHardPointer indicates the bin location of the last frame to be received and written into the Rx PTP buffer in hardware. This read will also clear the interrupt.</p>
<p>If PTP functions are marked as not running, then take no further action</p>
<p>RxPtpSoftPointer indicates the bin location of the last frame to be processed in software.</p>
<p>decode the rx'd frames until RxPtpHardPointer = RxPtpSoftPointer</p>
<p>Set the base address of the current PTP frame in the Buffer</p>
<p>Perform very basic sanity checking of the frame : is it a PTP?</p>
<p>Determine which PTP frame was received.</p>
<p>Now act on the received frame</p>
<h2>Sync Frame </h2>
<h2>Follow Up Frame </h2>
<h2>PDelayReq Frame </h2>
<p>Send a send PDelayResp frame after receiving a PDelayReq Frame</p>
<p>Send a send PDelayRespFollowUp frame after a PDelayResp Frame</p>
<h2>PDelayResp Frame </h2>
<h2>PDelayRespFollowUp Frame </h2>
<h2>Announce Frame </h2>
<h2>Signaling Frame </h2>
<h2>Unknown Frame </h2>
<p>PTP is not running so just consume the packets so they are not left in the queue and cause problems when we actually start</p>
<p>RxPtpSoftPointer indicates the bin location of the last frame to be processed in software.</p>
<p>decode the rx'd frames until RxPtpHardPointer = RxPtpSoftPointer </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a194197130a475d3183dc70f1319d73dc">XAvb::PtpIsRunning</a>, <a class="el" href="struct_x_avb___counters.html#a736ce9a6afef4a9305cdd6e2e2ba28dc">XAvb_Counters::RxPtpHardPointer</a>, <a class="el" href="struct_x_avb___counters.html#a4efdfe9a00248e2adfae1c7015d1a5fa">XAvb_Counters::RxPtpSoftPointer</a>, <a class="el" href="xavb_8h.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, <a class="el" href="xavb_8h.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>, <a class="el" href="xavb_8h.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb_8h.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>, <a class="el" href="xavb_8h.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling()</a>, <a class="el" href="xavb_8h.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>, <a class="el" href="xavb_8h.html#aaefe66ad0ca9e6af05129765cca4c3df">XAvb_IsRxFramePTP()</a>, <a class="el" href="xavb__hw_8h.html#ad0d33dc36a4a6b1f046d7ad862775922">XAVB_PTP_RX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb_8h.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp()</a>, and <a class="el" href="xavb_8h.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp()</a>.</p>

</div>
</div>
<a class="anchor" id="aab96c1602bda46380e25d0bb03a8ac01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_PtpTimerInterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Interrupt subroutine for the "interruptPtpTimer" signal. </p>
<p>This interrupt fires regularly on a 1/128 second period (based on the RTC).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Clear Interrupt</p>
<p>If PTP functions are marked as not running, then take no further action</p>
<p>If the Link Partner is not AS capable, then take no further action</p>
<p>If a Master, then initiate Sync Frames and Announce frames at the correct intervals</p>
<p>Master will initiate a Sync Frame when the SyncIntervalDuration expires (SyncIntervalDuration is used to count/time the duration)</p>
<ul>
<li>unless a Signalling frame has told us not to send Sync Frames</li>
</ul>
<p>Following a Sync Frame, a Follow Up frame should always be sent</p>
<p>Master will initiate an Announce Frame when the AnnounceIntervalDuration expires (CounterAnnounceInterval is used to count/time the duration)</p>
<ul>
<li>unless a Signalling frame has told us not to send Announce Frames</li>
</ul>
<p>If a Slave, monitor Announce/Sync Packet reception from the Master</p>
<p>Timeout for Announce Packet reception: XAVB_ANNOUNCE_RECEIPT_TIMEOUT The AnnounceIntervalDuration is stored with the GrandMaster BMCA data as it is captured from the last Announce frame that was received.</p>
<p>No Announce received from GM for timeout interval: we become the master</p>
<p>Timeout for Sync Packet reception: XAVB_SYNC_RECEIPT_TIMEOUT * The SyncIntervalDuration is stored with the Received Sync data as it is captured from the last Sync frame that was received.</p>
<p>No Syncs received from GM for timeout interval: we become the master</p>
<p>Both Master and Slave will initiate a link delay measurement when the LinkDelayIntervalDuration expires (LinkDelayIntervalDuration is used to count/time the duration)</p>
<ul>
<li>unless a Signalling frame has told us not to send PdelayReq Frames</li>
</ul>
<p>Check to see if we've received PDelayResp and PDelayRespFollowUp messages since the last PDelayReq was sent</p>
<p>the peer is no longer ASCapable</p>
<p>avoid potential overflow</p>
<p>end of 'if (InstancePtr-&gt;PtpIsRunning == 1)' </p>

<p>References <a class="el" href="struct_x_avb___bmc_data.html#af3bcc274ccdd364fe5983d586b5cff62">XAvb_BmcData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#ac149d8b00d1c397cf52784a7213bd5b6">XAvb_SignallingFrameData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#af9de244165a5492b2ee9b90a625a7922">XAvb_Counters::CounterAnnounceInterval</a>, <a class="el" href="struct_x_avb___counters.html#a618c3216d8806db71be2a72d24d5d9ac">XAvb_Counters::CounterLinkDelayInterval</a>, <a class="el" href="struct_x_avb___counters.html#a33a32af6ca968fac37957cbe9435f1db">XAvb_Counters::CounterSyncInterval</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="struct_x_avb.html#a42340ba979c53633a3cf53628c7eaec9">XAvb::latestMDSyncReceive</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a32e2ddf2ae1a19a457c9bd64516796e1">XAvb_SignallingFrameData::LinkDelayIntervalDuration</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad6a63a3cd991e1b350b8622921b88089">XAvb_StateMachineData::lostResponses</a>, <a class="el" href="struct_x_avb.html#a8311fd4524732cca626191f25591bfba">XAvb::PeerASCapable</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a194197130a475d3183dc70f1319d73dc">XAvb::PtpIsRunning</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad668575ffd6c4bbdc6b4c683137ba893">XAvb_StateMachineData::rcvdPDelayResp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#aef3a1d747515c6c5af274ac32281d1ee">XAvb_StateMachineData::rcvdPDelayRespFollowUp</a>, <a class="el" href="struct_x_avb.html#a0594bd4664c37ed685bb007113e8e2b6">XAvb::SignallingFrameData</a>, <a class="el" href="struct_x_avb.html#a779ce95ec439713b953c0fbf89cd818e">XAvb::StateMachineData</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a59ba334a92e4849faf31579ef5221b77">XAvb_SignallingFrameData::SyncIntervalDuration</a>, <a class="el" href="struct_x_avb___m_d_sync_receive.html#a944032b9d928ba8760663d512d56432f">XAvb_MDSyncReceive::SyncIntervalDuration</a>, <a class="el" href="xavb_8h.html#a3182fdfc7befebf2408090b1ab791bcc">XAVB_ALLOWED_LOST_RESPONSES</a>, <a class="el" href="xavb_8h.html#aafbcc1c1bf07dece3f745f8189740672">XAVB_ANNOUNCE_RECEIPT_TIMEOUT</a>, <a class="el" href="xavb_8h.html#a5ef1c55c51f5781c4395ff20cc07f410">XAvb_BecomeRtcMaster()</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, <a class="el" href="xavb_8h.html#aeeaf9984303a07b8935d4a391f0ca188">XAvb_MasterSendAnnounce()</a>, <a class="el" href="xavb_8h.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp()</a>, <a class="el" href="xavb_8h.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync()</a>, <a class="el" href="xavb__hw_8h.html#a2f724f6845f2fc8b62dc841ef36525d5">XAVB_RTC_CLEAR_INT_OFFSET</a>, <a class="el" href="xavb_8h.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq()</a>, <a class="el" href="xavb_8h.html#a15a4a25d453f50c7cdc57b81b91e8aba">XAVB_SYNC_RECEIPT_TIMEOUT</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="af24c248c31c6c45cdb8a46f82de175c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets all of the AVB device driver functions to the start-up (reset) defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Xavb instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Assert bad arguments and conditions</p>
<p>Perform a Software Reset of the AVB Core. This will reset both the transmitter and receiver paths. The RTC counter is not reset here.</p>
<p>Set IEEE specification default values in the device's data structure</p>
<p>Update logMeanMessageInterval in the pre-loaded TX SYNC message buffer</p>
<p>Update logMeanMessageInterval in the pre-loaded TX FOLLOW_UP message buffer</p>
<p>Update logMeanMessageInterval in the pre-loaded TX PDELAYREQ message buffer</p>
<p>Update logMeanMessageInterval in the pre-loaded TX ANNOUNCE message buffer</p>
<p>Initialise other driver variables in the device's data structure</p>

<p>References <a class="el" href="struct_x_avb___signalling_frame_data.html#ac149d8b00d1c397cf52784a7213bd5b6">XAvb_SignallingFrameData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#af9de244165a5492b2ee9b90a625a7922">XAvb_Counters::CounterAnnounceInterval</a>, <a class="el" href="struct_x_avb___counters.html#a618c3216d8806db71be2a72d24d5d9ac">XAvb_Counters::CounterLinkDelayInterval</a>, <a class="el" href="struct_x_avb___counters.html#a9228c57c4b090294bf8f034f94fbba06">XAvb_Counters::CounterSyncEvents</a>, <a class="el" href="struct_x_avb___counters.html#a33a32af6ca968fac37957cbe9435f1db">XAvb_Counters::CounterSyncInterval</a>, <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>, <a class="el" href="struct_x_avb.html#a42340ba979c53633a3cf53628c7eaec9">XAvb::latestMDSyncReceive</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ac88180ae256193d6ab58d964da0a15b8">XAvb_PtpStruct::LinkDelay</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a32e2ddf2ae1a19a457c9bd64516796e1">XAvb_SignallingFrameData::LinkDelayIntervalDuration</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad6a63a3cd991e1b350b8622921b88089">XAvb_StateMachineData::lostResponses</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a194197130a475d3183dc70f1319d73dc">XAvb::PtpIsRunning</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad668575ffd6c4bbdc6b4c683137ba893">XAvb_StateMachineData::rcvdPDelayResp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#aef3a1d747515c6c5af274ac32281d1ee">XAvb_StateMachineData::rcvdPDelayRespFollowUp</a>, <a class="el" href="struct_x_avb___counters.html#a736ce9a6afef4a9305cdd6e2e2ba28dc">XAvb_Counters::RxPtpHardPointer</a>, <a class="el" href="struct_x_avb___counters.html#a4efdfe9a00248e2adfae1c7015d1a5fa">XAvb_Counters::RxPtpSoftPointer</a>, <a class="el" href="struct_x_avb.html#a0594bd4664c37ed685bb007113e8e2b6">XAvb::SignallingFrameData</a>, <a class="el" href="struct_x_avb.html#a779ce95ec439713b953c0fbf89cd818e">XAvb::StateMachineData</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a59ba334a92e4849faf31579ef5221b77">XAvb_SignallingFrameData::SyncIntervalDuration</a>, <a class="el" href="struct_x_avb___m_d_sync_receive.html#a944032b9d928ba8760663d512d56432f">XAvb_MDSyncReceive::SyncIntervalDuration</a>, <a class="el" href="xavb_8h.html#a5ef1c55c51f5781c4395ff20cc07f410">XAvb_BecomeRtcMaster()</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, <a class="el" href="xavb_8h.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration()</a>, <a class="el" href="xavb__hw_8h.html#ae9e3a0562e191d4ea8eb166f5deadef3">XAVB_SW_RESET_OFFSET</a>, <a class="el" href="xavb_8h.html#a9c3933020b616a2a57b6229bce6f6151">XAvb_UpdateLogMeanMessageInterval()</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="xavb_8h.html#a5a5d4a65b18da8805b9a6bf464961f25">XAvb_Stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a888d220aeb387018ce33558e08d0166e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetupRxFilterControlMatchMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>VlanMatchMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to set the VLAN Match Mode field for the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
    <tr><td class="paramname">VlanMatchMode</td><td>contains the 1-bit value to be written to the register in the correct bit position as defined in the address map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#aeb18774c7074b8558f6f3d92ee894308">XAVB_RX_FILTER_CONTROL</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a4a970ecc2621c88825ecc3f01ff1c4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetupRxFilterControlPcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>VlanPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SrClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to set the VLAN PCP field for either SR A or B traffic in the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
    <tr><td class="paramname">VlanPriority</td><td>contains the 3-bit value to be written to the register in the correct bit positions as defined in the address map</td></tr>
    <tr><td class="paramname">SrClass</td><td>is '0' if VLAN Priority (PCP) A is to be updated and is '1' if VLAN Priority (PCP) B is to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#aeb18774c7074b8558f6f3d92ee894308">XAVB_RX_FILTER_CONTROL</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="afb10d8fd68257130d0fc50bfe71ad3e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetupRxFilterControlVid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>VlanVid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SrClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to set the VLAN VID field for either SR A or B traffic in the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
    <tr><td class="paramname">VlanVid</td><td>contains the 12-bit value to be written to the register in the correct bit positions as defined in the address map</td></tr>
    <tr><td class="paramname">SrClass</td><td>is '0' if VLAN VID A is to be updated and is '1' if VLAN VID B is to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#aeb18774c7074b8558f6f3d92ee894308">XAVB_RX_FILTER_CONTROL</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a8657704dc9974d465536615ebbeb79d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will start the PTP drivers running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Xavb instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Assert bad arguments and conditions</p>
<p>Re-run the BMCA algorithm with the current PTP buffer Announce Packet</p>
<p>Set to PTP running in the PTP data structure</p>
<p>Assume that the Peer is not AS capable until it replies to a pDelay_Req frame </p>

<p>References <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>, <a class="el" href="struct_x_avb.html#a194197130a475d3183dc70f1319d73dc">XAvb::PtpIsRunning</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, and <a class="el" href="xavb_8h.html#a4091121232495f00535ca134664b4f7c">XAvb_DecodeTxAnnounceFrame()</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a5d4a65b18da8805b9a6bf464961f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will stop the PTP drivers from running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Xavb instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Assert bad arguments and conditions </p>

<p>References <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>, and <a class="el" href="xavb_8c.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
