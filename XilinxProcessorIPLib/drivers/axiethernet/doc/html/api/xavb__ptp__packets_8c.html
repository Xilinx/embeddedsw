<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>axiethernet: xavb_ptp_packets.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">axiethernet
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xavb__ptp__packets_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xavb_ptp_packets.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>The <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> driver. </p>
<p>Functions in this file all contain functions which decode the received Precise Timing Protocol (PTP) frames, or to format and transmit PTP frames.</p>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who  Date     Changes
</p>
<hr/>
<p>
1.00a mbr  09/19/08 First release
1.01a mbr  06/24/09 PTP frame format updates for IEEE802.1 AS draft 5-0
2_02a mbr  09/16/09 Updates for programmable PTP timers
2_04a kag  07/23/10 PTP frame format updates for IEEE802.1 AS draft 6-7
3_01a kag  08/29/11 Added new APIs to update the RX Filter Control Reg.
              Fix for CR:572539. Updated bit map for Rx Filter
              control reg.</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa03b2f45590d8dabe5ad0eb39430e044"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#aa03b2f45590d8dabe5ad0eb39430e044">XAvb_CompareClockIdentity</a> (u32 BaseAddress, <a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a> Identity1, <a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a> Identity2)</td></tr>
<tr class="memdesc:aa03b2f45590d8dabe5ad0eb39430e044"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to compare two ClockIdentity values.  <a href="#aa03b2f45590d8dabe5ad0eb39430e044"></a><br/></td></tr>
<tr class="separator:aa03b2f45590d8dabe5ad0eb39430e044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8231a4001187aaff164037da857cb333"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity</a> (u32 BaseAddress, <a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> Identity1, <a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> Identity2)</td></tr>
<tr class="memdesc:a8231a4001187aaff164037da857cb333"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to compare two PortIdentity values.  <a href="#a8231a4001187aaff164037da857cb333"></a><br/></td></tr>
<tr class="separator:a8231a4001187aaff164037da857cb333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2030902e6748712f30a59a62dff010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity</a> (u32 BaseAddress, u32 PtpFrameBaseAddr, u32 PortIdOffset, <a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> *portID)</td></tr>
<tr class="memdesc:a2f2030902e6748712f30a59a62dff010"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to extract portIdentity information from a received PTP frame.  <a href="#a2f2030902e6748712f30a59a62dff010"></a><br/></td></tr>
<tr class="separator:a2f2030902e6748712f30a59a62dff010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73f986654f8315075dd1c3158087605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#ae73f986654f8315075dd1c3158087605">XAvb_WriteToMultipleTxPtpFrames</a> (u32 BaseAddress, u32 PtpFieldAddress, u32 Data, u32 DataBitEnable, u8 BufferEnable)</td></tr>
<tr class="memdesc:ae73f986654f8315075dd1c3158087605"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to write common data (eg the Source Address) to all PTP frames stored in the Tx PTP Packet buffer.  <a href="#ae73f986654f8315075dd1c3158087605"></a><br/></td></tr>
<tr class="separator:ae73f986654f8315075dd1c3158087605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664d83b2f34093d6000f3ea2facef449"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord</a> (u32 Data)</td></tr>
<tr class="memdesc:a664d83b2f34093d6000f3ea2facef449"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function switches the bytes in a 4-byte word, swapping the MSB for the LSB, and vice-versa.  <a href="#a664d83b2f34093d6000f3ea2facef449"></a><br/></td></tr>
<tr class="separator:a664d83b2f34093d6000f3ea2facef449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e7a11b4a2960e116891ba88bbb6c84"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a99e7a11b4a2960e116891ba88bbb6c84">XAvb_IncSequenceId</a> (u32 BaseAddress, u32 PtpFrameBaseAddress)</td></tr>
<tr class="memdesc:a99e7a11b4a2960e116891ba88bbb6c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to increment the sequenceId in a PTP frame template.  <a href="#a99e7a11b4a2960e116891ba88bbb6c84"></a><br/></td></tr>
<tr class="separator:a99e7a11b4a2960e116891ba88bbb6c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3695de30c54e17e3c3e0a461ab0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:afcb3695de30c54e17e3c3e0a461ab0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The software drivers are kept simple by only requesting a single PTP frame to be transmitted at a time.  <a href="#afcb3695de30c54e17e3c3e0a461ab0eb"></a><br/></td></tr>
<tr class="separator:afcb3695de30c54e17e3c3e0a461ab0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaf9984303a07b8935d4a391f0ca188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#aeeaf9984303a07b8935d4a391f0ca188">XAvb_MasterSendAnnounce</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:aeeaf9984303a07b8935d4a391f0ca188"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP Announce Packet.  <a href="#aeeaf9984303a07b8935d4a391f0ca188"></a><br/></td></tr>
<tr class="separator:aeeaf9984303a07b8935d4a391f0ca188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae239544f086bc86572b8e2d7e408a028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:ae239544f086bc86572b8e2d7e408a028"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP Sync Packet.  <a href="#ae239544f086bc86572b8e2d7e408a028"></a><br/></td></tr>
<tr class="separator:ae239544f086bc86572b8e2d7e408a028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989d44c98695fd6f286858f8b7976e3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a989d44c98695fd6f286858f8b7976e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP Follow-Up Packet.  <a href="#a989d44c98695fd6f286858f8b7976e3f"></a><br/></td></tr>
<tr class="separator:a989d44c98695fd6f286858f8b7976e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3f462007beb73497bbded566d7f364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a2e3f462007beb73497bbded566d7f364"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP PDelay Request Packet.  <a href="#a2e3f462007beb73497bbded566d7f364"></a><br/></td></tr>
<tr class="separator:a2e3f462007beb73497bbded566d7f364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63281acd385453959b333154bca2d9c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:a63281acd385453959b333154bca2d9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP PDelay Response Packet.  <a href="#a63281acd385453959b333154bca2d9c7"></a><br/></td></tr>
<tr class="separator:a63281acd385453959b333154bca2d9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1081cde03d0c53bc508927111fe87c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a2c1081cde03d0c53bc508927111fe87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP PDelay Response Follow-Up Packet.  <a href="#a2c1081cde03d0c53bc508927111fe87c"></a><br/></td></tr>
<tr class="separator:a2c1081cde03d0c53bc508927111fe87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefe66ad0ca9e6af05129765cca4c3df"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#aaefe66ad0ca9e6af05129765cca4c3df">XAvb_IsRxFramePTP</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:aaefe66ad0ca9e6af05129765cca4c3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to check that various fields in the received frame contain the expected values which define it as a valid AVB PTP frame.  <a href="#aaefe66ad0ca9e6af05129765cca4c3df"></a><br/></td></tr>
<tr class="separator:aaefe66ad0ca9e6af05129765cca4c3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed6d94f92c94a88dce9444e8a27fe8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:a3ed6d94f92c94a88dce9444e8a27fe8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received PTP Sync Packet.  <a href="#a3ed6d94f92c94a88dce9444e8a27fe8a"></a><br/></td></tr>
<tr class="separator:a3ed6d94f92c94a88dce9444e8a27fe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8650c4c94082dc746db9ec0259e1cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:afb8650c4c94082dc746db9ec0259e1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received PTP Follow-up Packet.  <a href="#afb8650c4c94082dc746db9ec0259e1cb"></a><br/></td></tr>
<tr class="separator:afb8650c4c94082dc746db9ec0259e1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5beb09f67f655b7eb8eb51b3cd2d8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:acc5beb09f67f655b7eb8eb51b3cd2d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received PDelayResp Packet.  <a href="#acc5beb09f67f655b7eb8eb51b3cd2d8a"></a><br/></td></tr>
<tr class="separator:acc5beb09f67f655b7eb8eb51b3cd2d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53beaf90143fc360dc6276ba1c49f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:afd53beaf90143fc360dc6276ba1c49f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received PDelayRespFollowUp Packet.  <a href="#afd53beaf90143fc360dc6276ba1c49f9"></a><br/></td></tr>
<tr class="separator:afd53beaf90143fc360dc6276ba1c49f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9afff73e01faafdc8ce9f8e0ee8d4de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:ab9afff73e01faafdc8ce9f8e0ee8d4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received Signalling Packet and modify the TX PTP Buffers based on the requested values.  <a href="#ab9afff73e01faafdc8ce9f8e0ee8d4de"></a><br/></td></tr>
<tr class="separator:ab9afff73e01faafdc8ce9f8e0ee8d4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d81de9521bde263313b2de412f45fe2"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a5d81de9521bde263313b2de412f45fe2">XAvb_UpdateIntervalDuration</a> (u16 currentIntervalDuration, char logMeanVal)</td></tr>
<tr class="memdesc:a5d81de9521bde263313b2de412f45fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to update a PTP message Interval Duration (defined as a fraction of 128 seconds).  <a href="#a5d81de9521bde263313b2de412f45fe2"></a><br/></td></tr>
<tr class="separator:a5d81de9521bde263313b2de412f45fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa725e8ddb08a833d10e8554067ac361"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration</a> (char logMeanVal)</td></tr>
<tr class="memdesc:afa725e8ddb08a833d10e8554067ac361"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to convert a logMean (power of 2) value into a fraction of 128 that is compatible with Signalling data.  <a href="#afa725e8ddb08a833d10e8554067ac361"></a><br/></td></tr>
<tr class="separator:afa725e8ddb08a833d10e8554067ac361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1539b744b6e5b9c9da652820948241"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a7c1539b744b6e5b9c9da652820948241">XAvb_ConvertDurationToLogMean</a> (u16 fractionalVal)</td></tr>
<tr class="memdesc:a7c1539b744b6e5b9c9da652820948241"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to convert a fraction of 128 value that is compatible with Signalling data into a logMean (power of 2) value;.  <a href="#a7c1539b744b6e5b9c9da652820948241"></a><br/></td></tr>
<tr class="separator:a7c1539b744b6e5b9c9da652820948241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3933020b616a2a57b6229bce6f6151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a9c3933020b616a2a57b6229bce6f6151">XAvb_UpdateLogMeanMessageInterval</a> (u32 BaseAddress, u32 PtpFrameBaseAddr, u16 intervalDuration)</td></tr>
<tr class="memdesc:a9c3933020b616a2a57b6229bce6f6151"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to update the logMeanMessageInterval field in a PTP packet.  <a href="#a9c3933020b616a2a57b6229bce6f6151"></a><br/></td></tr>
<tr class="separator:a9c3933020b616a2a57b6229bce6f6151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cd78e966447edcb45a0f419cc84cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb__ptp__packets_8c.html#a42cd78e966447edcb45a0f419cc84cb8">XAvb_SetupSourcePortIdentity</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, <a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> systemIdentity)</td></tr>
<tr class="memdesc:a42cd78e966447edcb45a0f419cc84cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the portIdLocal local copy of the sourcePortIdentity and writes this value into the TX PTP frame buffer templates.  <a href="#a42cd78e966447edcb45a0f419cc84cb8"></a><br/></td></tr>
<tr class="separator:a42cd78e966447edcb45a0f419cc84cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa03b2f45590d8dabe5ad0eb39430e044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_CompareClockIdentity </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a>&#160;</td>
          <td class="paramname"><em>Identity1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a>&#160;</td>
          <td class="paramname"><em>Identity2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to compare two ClockIdentity values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">Identity1</td><td>is the first ClockIdentity to be compared </td></tr>
    <tr><td class="paramname">Identity2</td><td>is the second ClockIdentity to be compared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the two values are equal, 0 if not equal</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>values are equal </p>

<p>References <a class="el" href="struct_x_avb___clock_identity.html#a6119ed21ae13fc8002df3ea89701a710">XAvb_ClockIdentity::ClockIdentityLower</a>, and <a class="el" href="struct_x_avb___clock_identity.html#a6d7f51bcff1917d372465c04a2f36d7b">XAvb_ClockIdentity::ClockIdentityUpper</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="a8231a4001187aaff164037da857cb333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_ComparePortIdentity </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a>&#160;</td>
          <td class="paramname"><em>Identity1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a>&#160;</td>
          <td class="paramname"><em>Identity2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to compare two PortIdentity values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">Identity1</td><td>is the first sourcePortIdentity to be compared </td></tr>
    <tr><td class="paramname">Identity2</td><td>is the second sourcePortIdentity to be compared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the two values are equal, 0 if not equal</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>values are equal </p>

<p>References <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, and <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c1539b744b6e5b9c9da652820948241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char XAvb_ConvertDurationToLogMean </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>fractionalVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to convert a fraction of 128 value that is compatible with Signalling data into a logMean (power of 2) value;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fractionalVal</td><td>is the Signalling data value that is to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fractionalVal represented as logMean (power of 2) value</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>just in case fractionalVal is not a power of 2, we'll only look at the most significant bit Count how many shifts it takes for most significant set bit to be in the highest (16th) bit location</p>
<p>logMeanVal = 0 = 2^0 = 128/128 would give us a numShifts result of 8, so 8 will be our base</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#a9c3933020b616a2a57b6229bce6f6151">XAvb_UpdateLogMeanMessageInterval()</a>.</p>

</div>
</div>
<a class="anchor" id="afa725e8ddb08a833d10e8554067ac361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XAvb_ConvertLogMeanToDuration </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>logMeanVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to convert a logMean (power of 2) value into a fraction of 128 that is compatible with Signalling data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logMeanVal</td><td>is the base2 value that is to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>logMeanVal represented as a fraction of 128</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>, <a class="el" href="xavb_8h.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a5d81de9521bde263313b2de412f45fe2">XAvb_UpdateIntervalDuration()</a>.</p>

</div>
</div>
<a class="anchor" id="afb8650c4c94082dc746db9ec0259e1cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxFollowUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received PTP Follow-up Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read sourcePortIdentity from packet</p>
<p>Only decode if configured for a slave and if SA is that of the RTC Clock Master</p>
<p>Capture the Follow Up SequenceID</p>
<p>SequenceID in Follow Up Frame should always match that of the Sync Frame</p>
<p>Capture the correction field from follow up frame</p>
<p>Perform the Course RTC Offset correction for every Sync / FollowUp pair</p>
<p>Every n Sync / FollowUp pairs, we are going to calculate a corrected increment rate of RTC</p>
<p>Reset the CounterSyncEvents Counter</p>
<p>Capture the Sequence ID of the Follow Up frame</p>
<p>Perform the RTC increment rate adjustment calculation</p>
<p>Sample Sync Frame Time sent (as estimated by the slave) for comparison in ten more repetition's time</p>
<p>Sample Sync Frame Time sent (as calculated by the master) for comparison in ten more repetition's time</p>
<p>Sample the current Follow Up Sequence ID for comparison in ten more repetition's time </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#a9228c57c4b090294bf8f034f94fbba06">XAvb_Counters::CounterSyncEvents</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a518f0eba3028ced57a8b6824df25692a">XAvb_SequenceIdStruct::FollowUpSequenceId</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a9ccce78c48aeb38e81ccfe20f4fcbf14">XAvb_PtpStruct::MasterCorrectionField</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a05590438022ee2dff39492654cfe3285">XAvb_PtpStruct::NewMasterTime</a>, <a class="el" href="struct_x_avb___ptp_struct.html#aecd30621bf3e8988ea4bebf59ab4d031">XAvb_PtpStruct::NewSlaveTime</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a689e9f68ca62fd5f25c4ba60be3419cc">XAvb_SequenceIdStruct::NewSyncSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a92f212eedbc5375293d822d97a56b11a">XAvb_PtpStruct::OldMasterTime</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a5f843941b210edca7edb0824ba342652">XAvb_PtpStruct::OldSlaveTime</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a6905c062e37474a276a80955ebe565b5">XAvb_SequenceIdStruct::OldSyncSequenceId</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae60a5e9cd8c572d2db805650287483f7">XAvb_BmcData::SourcePortIdentity</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a6128e3e436ca3a95f1735d4c49498b5a">XAvb_SequenceIdStruct::SyncSequenceId</a>, <a class="el" href="xavb_8h.html#a5ee8dd26b932ff82daa0dc87fd6d38d8">XAvb_CalcRtcOffset()</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, and <a class="el" href="xavb_8h.html#ada9dd75eb576b0e600686514fbea45e3">XAvb_UpdateRtcIncrement()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="acc5beb09f67f655b7eb8eb51b3cd2d8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxPDelayResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received PDelayResp Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Have we already seen a PDelayResp since the last PDelayReq was sent? If so, ignore the packet</p>
<p>Find the ClockIdentity of the Sender</p>
<p>Is the PDelayResp message from ourself? If so, the Peer is most likely a dumb hub and should be considered not ASCapable</p>
<p>Capture the requestingPortIdentity</p>
<p>Capture the PDelayResp SequenceID</p>
<p>Verify that the requestingPortIdentity matches our portIdentity</p>
<p>Only process if the received frame's sequenceId matches the sequenceId sent in the last pDelay_Req packet</p>
<p>Mark this as a valid PDelayResp packet</p>
<p>Capture timestamp for receipt time of PDelayReq at Master (t2)</p>
<p>Capture timestamp for receipt time of PDelayResp at Slave (t4) and adjust it for MAC receive latency </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a7dbe45bce7442efd949b26ec1e3e491a">XAvb_SequenceIdStruct::PDelayReqSequenceId</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a1cac4a458112f001f588b916a08582ae">XAvb_SequenceIdStruct::PDelayRespSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a031c19b7b7227814202cc7472fc0269a">XAvb_PtpStruct::PDelayTimestampT2</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ad4a5d5d897b354ab5bae245a08459c27">XAvb_PtpStruct::PDelayTimestampT4</a>, <a class="el" href="struct_x_avb.html#afa0f0b3779f43a549fc63b1c9d6e9f23">XAvb::portIdLocal</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad668575ffd6c4bbdc6b4c683137ba893">XAvb_StateMachineData::rcvdPDelayResp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#afd7c69f91db48d400d0e218eb41d4c21">XAvb_StateMachineData::respPortIdentity</a>, <a class="el" href="struct_x_avb___state_machine_data.html#a7e7ed5f180f67ac237f156753aa0e059">XAvb_StateMachineData::respReqPortIdentity</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="struct_x_avb.html#a779ce95ec439713b953c0fbf89cd818e">XAvb::StateMachineData</a>, <a class="el" href="xavb_8h.html#a3ce07f766a1033fab5a1981e947db52e">XAvb_CaptureNanoSec()</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="afd53beaf90143fc360dc6276ba1c49f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxPDelayRespFollowUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received PDelayRespFollowUp Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Has a valid PDelayResp packet been received since the last PDelayReq packet was sent?</p>
<p>Capture the PDelayRespFollowUp SequenceID</p>
<p>Get the sourcePortIdentity of the sender</p>
<p>The sourcePortIdentity of the PDelayRespFollowUp should match that of the last PDelayResp packet received</p>
<p>Get the requestingPortIdentity of the sender</p>
<p>The requestingPortIdentity of the PDelayRespFollowUp should match that of the last PDelayResp packet received</p>
<p>SequenceID of PDelayRespFollowUp Frame should always match that of the PDelayResp Frame and the original PDelayReq Frame.</p>
<p>Mark this as a valid PDelayRespFollowUp packet</p>
<p>Capture the timestamp for transmit time of PDelayResp at Master (t3)</p>
<p>Now we know t1, t2, t3 and t4, calculate the link delay </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#ad3a2d748388270eebdc20ae8d419f4d9">XAvb_SequenceIdStruct::PDelayFollowUpSequenceId</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a1cac4a458112f001f588b916a08582ae">XAvb_SequenceIdStruct::PDelayRespSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a3cbb26037696645f50c29addc3f6da46">XAvb_PtpStruct::PDelayTimestampT3</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad668575ffd6c4bbdc6b4c683137ba893">XAvb_StateMachineData::rcvdPDelayResp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#aef3a1d747515c6c5af274ac32281d1ee">XAvb_StateMachineData::rcvdPDelayRespFollowUp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#afd7c69f91db48d400d0e218eb41d4c21">XAvb_StateMachineData::respPortIdentity</a>, <a class="el" href="struct_x_avb___state_machine_data.html#a7e7ed5f180f67ac237f156753aa0e059">XAvb_StateMachineData::respReqPortIdentity</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="struct_x_avb.html#a779ce95ec439713b953c0fbf89cd818e">XAvb::StateMachineData</a>, <a class="el" href="xavb_8h.html#a6d7814f965d4141992654954f1243679">XAvb_CalcDelay()</a>, <a class="el" href="xavb_8h.html#a3ce07f766a1033fab5a1981e947db52e">XAvb_CaptureNanoSec()</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9afff73e01faafdc8ce9f8e0ee8d4de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxSignaling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received Signalling Packet and modify the TX PTP Buffers based on the requested values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Signaling Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read the requested logMeanMessage durations from the Signalling frame</p>
<p>update linkDelayInterval</p>
<p>don't change the interval</p>
<p>currently only support the default value</p>
<p>set the interval to initial value</p>
<p>Update logMeanMessageInterval in the pre-loaded TX PDELAYREQ message buffer</p>
<p>stop sending pDelay messages</p>
<p>update timeSyncInterval</p>
<p>don't change the interval</p>
<p>set the interval to initial value</p>
<p>Update logMeanMessageInterval in the pre-loaded TX SYNC message buffer</p>
<p>Update logMeanMessageInterval in the pre-loaded TX FOLLOW_UP message buffer</p>
<p>stop sending sync messages</p>
<p>update announceInterval</p>
<p>don't change the interval</p>
<p>set the interval to initial value</p>
<p>Update logMeanMessageInterval in the pre-loaded TX ANNOUNCE message buffer</p>
<p>stop sending Announce messages </p>

<p>References <a class="el" href="struct_x_avb___signalling_frame_data.html#ac149d8b00d1c397cf52784a7213bd5b6">XAvb_SignallingFrameData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a32e2ddf2ae1a19a457c9bd64516796e1">XAvb_SignallingFrameData::LinkDelayIntervalDuration</a>, <a class="el" href="struct_x_avb.html#a0594bd4664c37ed685bb007113e8e2b6">XAvb::SignallingFrameData</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a59ba334a92e4849faf31579ef5221b77">XAvb_SignallingFrameData::SyncIntervalDuration</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb_8h.html#a5d81de9521bde263313b2de412f45fe2">XAvb_UpdateIntervalDuration()</a>, and <a class="el" href="xavb_8h.html#a9c3933020b616a2a57b6229bce6f6151">XAvb_UpdateLogMeanMessageInterval()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ed6d94f92c94a88dce9444e8a27fe8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received PTP Sync Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read sourcePortIdentity from packet</p>
<p>Only decode if configured for a slave and if SourcePortID is that of the RTC Clock Master</p>
<p>Reset Sync Interval Counter as we have received a valid Sync</p>
<p>Capture the local Timestamp for receipt of this frame and adjust it for MAC receive latency</p>
<p>Capture the Sync SequenceID</p>
<p>Capture the logMeanMessageInterval and convert into a useful duration (NOTE: there is an implicit conversion from u32 to char here)</p>
<p>We don't need to capture the correction field - unless we want to check that it is 0. </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#a33a32af6ca968fac37957cbe9435f1db">XAvb_Counters::CounterSyncInterval</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="struct_x_avb.html#a42340ba979c53633a3cf53628c7eaec9">XAvb::latestMDSyncReceive</a>, <a class="el" href="struct_x_avb___m_d_sync_receive.html#a2216e32e52d75fbd0fce66973bfb0d0f">XAvb_MDSyncReceive::logMessageInterval</a>, <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ad6c2a017ae8f7df3d77654ffbb8a9955">XAvb_PtpStruct::SlaveSyncTimestamp</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae60a5e9cd8c572d2db805650287483f7">XAvb_BmcData::SourcePortIdentity</a>, <a class="el" href="struct_x_avb___m_d_sync_receive.html#a944032b9d928ba8760663d512d56432f">XAvb_MDSyncReceive::SyncIntervalDuration</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a6128e3e436ca3a95f1735d4c49498b5a">XAvb_SequenceIdStruct::SyncSequenceId</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration()</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f2030902e6748712f30a59a62dff010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_GetPortIdentity </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PortIdOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> *&#160;</td>
          <td class="paramname"><em>portID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to extract portIdentity information from a received PTP frame. </p>
<p>This can be any portIdentity field (header portIdentity, requestingPortIdentity, etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer </td></tr>
    <tr><td class="paramname">PortIdOffset</td><td>is the packet offset of the first byte of the portIdentity field to be parsed </td></tr>
    <tr><td class="paramname">portID</td><td>is the <a class="el" href="struct_x_avb___port_identity.html" title="This typedef defines the format for a data structure which stores the Port Identity information from ...">XAvb_PortIdentity</a> struct that the data will be written to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None, but portID will be updated with the portIdentity information</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>, and <a class="el" href="xavb__ptp__bmca_8c.html#a7c77fd7953811584a36001e5e74165b3">XAvb_ReadAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="a99e7a11b4a2960e116891ba88bbb6c84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_IncSequenceId </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to increment the sequenceId in a PTP frame template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddress</td><td>is the base address of the TX PTP Buffer whose SequenceID is to be incremented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant TX PTP Packet Buffer is written to with the updated SequenceID</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read the 32-bit BufferWord containing the SequenceId from the PTP buffer</p>
<p>Swap byte order into correct binary and increment the SequenceId</p>
<p>Swap back the byte order into frame storage order</p>
<p>Write the 32-bit BufferWord variable containing the updated SequenceId </p>

<p>References <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, and <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#aeeaf9984303a07b8935d4a391f0ca188">XAvb_MasterSendAnnounce()</a>, <a class="el" href="xavb__ptp__packets_8c.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq()</a>.</p>

</div>
</div>
<a class="anchor" id="aaefe66ad0ca9e6af05129765cca4c3df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_IsRxFramePTP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to check that various fields in the received frame contain the expected values which define it as a valid AVB PTP frame. </p>
<p>If this check does not pass then the frame should not be decoded and used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An updated True/False decision as to whether this received frame really is a valid PTP type.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Start by assuming that it is a valid PTP frame</p>
<p>Perform a 32-bit read from the relevant position in the frame</p>
<p>Check the Length/Type field for a valid Ethertype</p>
<p>Check the versionPTP </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="aeeaf9984303a07b8935d4a391f0ca188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_MasterSendAnnounce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP Announce Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<p>Increment the sequenceId</p>
<p>Send the Announce Frame! </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb_8h.html#a454f4f2c09586f6e787232cb0ae250c2">XAvb_IncSequenceId()</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#a59f550eaa57148613974c4aa5628bfb4">XAVB_RTC_NANOSEC_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#aa71292011b875c192d09141638c3a4e1">XAVB_RTC_SEC_LOWER_VALUE_OFFSET</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a989d44c98695fd6f286858f8b7976e3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_MasterSendFollowUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP Follow-Up Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<p>Read the current RTC offset</p>
<p>Read the Timestamp and adjust it for the MAC transmit latency</p>
<p>Adjust the Timestamp with current RTC ns offset</p>
<p>Calculate the Correction Field</p>
<p>Format the Correction Field into correct byte positioning for PTP frame storage in the buffer</p>
<p>Write the Correction Field to the Follow Up frame</p>
<p>Send the Follow Up Frame! </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a0fec4235a69761ed87eb29790cd8a7d2">XAvb_PtpStruct::Nanosec</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#a17b4489a857a0fcb761a529b749d5ad3">XAVB_RTC_NANOSEC_OFFSET</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ae239544f086bc86572b8e2d7e408a028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_MasterSendSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP Sync Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<p>Increment the sequenceId in the Sync frame</p>
<p>Read the current RTC Offset values</p>
<p>Send the Sync Frame!</p>
<h2>Now some pre-work on the Follow-Up Frame</h2>
<p>Write the same sequenceId to the Follow-up frame</p>
<p>Format the Timestamp (RTC) into correct byte positioning. Note: this is how the Timestamp is stored in the PTP frame itself (transmitted MSB of Epoch first):</p>
<p>|----------&mdash;&mdash;|----------&mdash;&mdash;|----------&mdash;&mdash;|----------&mdash;&mdash;| </p>
<table class="doxtable">
<tr>
<th>seconds[23:16] </th><th>seconds[31:24] </th><th>epoch[7:0] </th><th>epoch[15:8] </th></tr>
<tr>
<td>nanosec[23:16] </td><td>nanosec[31:24] </td><td>seconds[7:0] </td><td>seconds[15:8] </td></tr>
<tr>
<td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash; </td></tr>
<tr>
<td>0's </td><td>0's </td><td>nanosec[7:0] </td><td>nanosec[15:8] </td></tr>
<tr>
<td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash; </td></tr>
</table>
<p>Write the Timestamp (RTC) to the Follow-up frame </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a0fec4235a69761ed87eb29790cd8a7d2">XAvb_PtpStruct::Nanosec</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="xavb_8h.html#a454f4f2c09586f6e787232cb0ae250c2">XAvb_IncSequenceId()</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#a59f550eaa57148613974c4aa5628bfb4">XAVB_RTC_NANOSEC_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#aa71292011b875c192d09141638c3a4e1">XAVB_RTC_SEC_LOWER_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#ae38e8307c8da64ba9f42516168855a8f">XAVB_RTC_SEC_UPPER_VALUE_OFFSET</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a664d83b2f34093d6000f3ea2facef449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_ReorderWord </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function switches the bytes in a 4-byte word, swapping the MSB for the LSB, and vice-versa. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Data</td><td>is the 4-byte input data word</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input data word with the bytes swapped (most significant down to least significant</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="xavb_8h.html#a5ee8dd26b932ff82daa0dc87fd6d38d8">XAvb_CalcRtcOffset()</a>, <a class="el" href="xavb_8h.html#a3ce07f766a1033fab5a1981e947db52e">XAvb_CaptureNanoSec()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a99e7a11b4a2960e116891ba88bbb6c84">XAvb_IncSequenceId()</a>, <a class="el" href="xavb__ptp__packets_8c.html#aaefe66ad0ca9e6af05129765cca4c3df">XAvb_IsRxFramePTP()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync()</a>, <a class="el" href="xavb__ptp__bmca_8c.html#a7c77fd7953811584a36001e5e74165b3">XAvb_ReadAnnounceFrame()</a>, <a class="el" href="xavb__ptp__bmca_8c.html#aa66e9752ef47bf7eafe4784cb59e1093">XAvb_ReadAnnounceReceiptTimeout()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a42cd78e966447edcb45a0f419cc84cb8">XAvb_SetupSourcePortIdentity()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e3f462007beb73497bbded566d7f364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SendPDelayReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP PDelay Request Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<p>Increment the SequenceId</p>
<p>Send the PDelayReq Frame!</p>
<p>Wait for the frame to be transmitted</p>
<p>Capture the Timestamp for Tx of PDelayReq (t1) and adjust it for MAC transmit latency</p>
<p>Capture the SequenceID of the the PDelayReq </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a7dbe45bce7442efd949b26ec1e3e491a">XAvb_SequenceIdStruct::PDelayReqSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a3452c4beb43254ece9773c99e03e629f">XAvb_PtpStruct::PDelayTimestampT1</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="xavb_8h.html#a454f4f2c09586f6e787232cb0ae250c2">XAvb_IncSequenceId()</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a63281acd385453959b333154bca2d9c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SendPDelayResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP PDelay Response Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<h2>Format the Timestamp</h2>
<p>Capture the current Synchronised time</p>
<p>Read the current RTC offset</p>
<p>Read the TimestampT2 for PDelayReq reception and adjust it for MAC receive latency</p>
<p>The TimestampT2 was captured using syntonised ns time. We need to convert this into synchronised time by adding on the current offset</p>
<p>Check for ns wrap-around condition</p>
<p>Even though we read the RTC value at the beginning of this function, there would have been processing delay between the actual reception (and timestamping) of the PDelayReq frame and the start of this function. During this time, the RTC Seconds field could have wrapped around. We need to detect this and if it has done, the slave Seconds field would also have incremented (so it needs to be set back).</p>
<p>NanoSec has wrapped since timestamp was taken so decrement the Seconds field</p>
<p>Format the Timestamp (t2) into correct byte positioning for PTP frame storage, then write the Timestamp (t2) to the PDelayResp frame</p>
<h2>Format the SequenceId</h2>
<p>Set the SequenceId in the PDelayResp and PDelayRespFollowUp frame to be that of the received PDelayReq frame</p>
<h2>Format the sourcePortIdentity</h2>
<p>Copy the sourcePortIdentity field from the PDelayReq into the PDelayResp and PDelayRespFollowUp frame</p>
<h2>Send the PDelayResp Frame!</h2>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a810daa5475d7da25976222f9c9728337">XAvb_PtpStruct::NsOffsetForPDelayResp</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#a17b4489a857a0fcb761a529b749d5ad3">XAVB_RTC_NANOSEC_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a59f550eaa57148613974c4aa5628bfb4">XAVB_RTC_NANOSEC_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#aa71292011b875c192d09141638c3a4e1">XAVB_RTC_SEC_LOWER_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#ae38e8307c8da64ba9f42516168855a8f">XAVB_RTC_SEC_UPPER_VALUE_OFFSET</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c1081cde03d0c53bc508927111fe87c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SendPDelayRespFollowUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP PDelay Response Follow-Up Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<h2>Format the Timestamp</h2>
<p>Capture the current Synchronised time</p>
<p>Read the TimestampT3 for PDelayResp transmission and adjust it for MAC transmit latency</p>
<p>The TimestampT3 was captured using syntonised ns time. We need to convert this into synchronised time by adding on the ns offset. We use the same offset here as for the PDelayResp frame since if a ns offset change had been made between PDelayResp and , PDelayRespFollowUp, this would result in an error in the link delay measurement.</p>
<p>Check for ns wrap-around condition</p>
<p>Even though we read the RTC value at the beginning of this function, there would have been processing delay between the actual reception (and timestamping) of the PDelayReq frame and the start of this function. During this time, the RTC seconds field could have wrapped around. We need to detect this and if it has done, the slave seconds field would also have incremented (so it needs to be set back).</p>
<p>nanosec has wrapped since timestamp was taken so decrement the seconds field</p>
<p>Format the Timestamp (t3) into correct byte positioning for PTP frame storage, the write the Timestamp (t3) to the PDelayRespFollowUp frame</p>
<h2>Send the PDelayRespFollowUp Frame!</h2>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___rtc_format.html#ad30a5df1748ad71907d830893f23cbba">XAvb_RtcFormat::NanoSeconds</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a810daa5475d7da25976222f9c9728337">XAvb_PtpStruct::NsOffsetForPDelayResp</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___rtc_format.html#a5015cb1ee0a5eb14ef15e03225450a81">XAvb_RtcFormat::SecondsLower</a>, <a class="el" href="struct_x_avb___rtc_format.html#a84452962f60d5528bbb9da1df3c1bf7d">XAvb_RtcFormat::SecondsUpper</a>, <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8c.html#adbb46fbeb6b3bb40e8067ea6f8a0776c">XAvb_ReadRtc()</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a42cd78e966447edcb45a0f419cc84cb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetupSourcePortIdentity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a>&#160;</td>
          <td class="paramname"><em>systemIdentity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the portIdLocal local copy of the sourcePortIdentity and writes this value into the TX PTP frame buffer templates. </p>
<p>The fields that are written are: o sourcePortIdentity for all default PTP frames o Announce:: grandmasterIdentity o Announce:: TLV clockIdentity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">systemIdentity</td><td>is the clockIdentity and portNumber for this endpoint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Announce::TLV. By default the tlvType and length field are set up in the BRAM, assuming that N = 1. </dd></dl>
<p>Write the sourcePortIdentity into the header for all TX PTP buffers except the empty default buffer AND write the GMID for TX announce AND Write the ClockIdentity into the TX Announce TLV</p>
<p>(a) Write the upper 2 bytes of the ClockIdentityUpper</p>
<ul>
<li>REM: Swap back the byte order into frame storage order</li>
</ul>
<p>(b) Write the lower 2 bytes of the ClockIdentityUpper and upper 2 bytes of the ClockIdentityLower.</p>
<ul>
<li>REM: Swap back the byte order into frame storage order</li>
</ul>
<p>(c) Write the lower 2 bytes of the ClockIdentityLower and the portNumber</p>
<ul>
<li>REM: Swap back the byte order into frame storage order</li>
</ul>
<p>Write the grandmasterIdentity into the header for the TX Announce PTP buffer</p>
<p>(a) Write 1 byte of GMID (Upper)</p>
<p>(b) Write 3 bytes of GMID (Upper) and 1 byte of GMID (Lower)</p>
<p>(c) Write 3 bytes of GMID (Lower) </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb.html#afa0f0b3779f43a549fc63b1c9d6e9f23">XAvb::portIdLocal</a>, <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb_8h.html#a1fafde8d597983f3e827b93fcc8e3c8a">XAvb_WriteToMultipleTxPtpFrames()</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d81de9521bde263313b2de412f45fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XAvb_UpdateIntervalDuration </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>currentIntervalDuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>logMeanVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to update a PTP message Interval Duration (defined as a fraction of 128 seconds). </p>
<p>If the endpoint cannot support a requested logMeanVal then do not perform the conversion - return the current value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentIntervalDuration</td><td>is the Interval Duration to be updated </td></tr>
    <tr><td class="paramname">logMeanVal</td><td>is the base2 value that is to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>logMeanVal represented as a fraction of 128</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This endpoint only supports logMeanValues &gt;=-7 and &lt;=8. </dd></dl>

<p>References <a class="el" href="xavb_8h.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration()</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c3933020b616a2a57b6229bce6f6151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_UpdateLogMeanMessageInterval </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>intervalDuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to update the logMeanMessageInterval field in a PTP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the TX PTP Buffer to be updated </td></tr>
    <tr><td class="paramname">intervalDuration</td><td>is the "fraction of 128" value of the data to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated logMeanMessageInterval</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Convert intervalDuration to a logMean value</p>
<p>Read the current fields</p>
<p>Update just the logMeanMessageInterval field</p>
<p>Write back </p>

<p>References <a class="el" href="xavb_8h.html#a7c1539b744b6e5b9c9da652820948241">XAvb_ConvertDurationToLogMean()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling()</a>, and <a class="el" href="xavb_8h.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="afcb3695de30c54e17e3c3e0a461ab0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_WaitOnTxPtpQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The software drivers are kept simple by only requesting a single PTP frame to be transmitted at a time. </p>
<p>This function checks (and if necessary waits) until the previously request PTP frame has been transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data.">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until any queued PTP frame has been transmitted. This is a software safety feature, not a hardware restriction </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, and <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#aeeaf9984303a07b8935d4a391f0ca188">XAvb_MasterSendAnnounce()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp()</a>.</p>

</div>
</div>
<a class="anchor" id="ae73f986654f8315075dd1c3158087605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_WriteToMultipleTxPtpFrames </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFieldAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DataBitEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>BufferEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to write common data (eg the Source Address) to all PTP frames stored in the Tx PTP Packet buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFieldAddress</td><td>is the offset address of the relevant field in PTP frames. </td></tr>
    <tr><td class="paramname">Data</td><td>is the common data to be written to all Tx PTP frame templates </td></tr>
    <tr><td class="paramname">DataBitEnable</td><td>allows only selected bits of the 32-bit Data word to be modified. </td></tr>
    <tr><td class="paramname">BufferEnable</td><td>allows the selected buffer to be seleced: there are 8 PTP buffers - these are encoded as one-hot. For example, 0x3F will write the selected data to the first 6 buffers only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the Tx PTP Packet Buffer is written to as requested</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Write to all 8 PTP frame templates</p>
<p>Only write to selected buffers</p>
<p>Read the current value</p>
<p>Only change the selected data bits</p>
<p>Write the updated value </p>

<p>References <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a42cd78e966447edcb45a0f419cc84cb8">XAvb_SetupSourcePortIdentity()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
