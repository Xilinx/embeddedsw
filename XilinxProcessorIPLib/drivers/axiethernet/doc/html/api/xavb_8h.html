<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>axiethernet: xavb.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">axiethernet
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xavb_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xavb.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This header file contains the identifiers and basic driver functions (or macros) that can be used to access the device. </p>
<p>Other driver functions are defined in <a class="el" href="xavb_8h.html" title="This header file contains the identifiers and basic driver functions (or macros) that can be used to ...">xavb.h</a>.</p>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who  Date     Changes
</p>
<hr/>
<p>
1.00a mbr  09/19/08 First release
1.01a mbr  06/24/09 PTP frame format updates for IEEE802.1 AS draft 5-0
2_02a mbr  09/16/09 Updates for programmable PTP timers
2_04a kag  07/23/10 PTP frame format updates for IEEE802.1 AS draft 6-7
3_01a kag  08/29/11 Added new APIs to update the RX Filter Control Reg.
              Fix for CR:572539. Updated bit map for Rx Filter
              control reg.
4_0     asa  03/06/14 Fix for CR 740863. The value of XAVB_CLOCK_LOCK_THRESHOLD
                                  is increased to 1000ns (1 us) to make it more
                                  meningful and reasonable.</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___config.html">XAvb_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for a device.  <a href="struct_x_avb___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines the format for a data structure which stores the Port Identity information from received Announce packets.  <a href="struct_x_avb___port_identity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines the format for a data structure which stores the Clock Identity information from received Announce packets.  <a href="struct_x_avb___clock_identity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___clock_quality.html">XAvb_ClockQuality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines the quality of a clock.  <a href="struct_x_avb___clock_quality.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines the format for a data structure which stores the relevant fields which are captured from Announce Packets.  <a href="struct_x_avb___bmc_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___ptp_struct.html">XAvb_PtpStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines the format for a data structure which stores information relating to the 1588 based PTP timing calculations.  <a href="struct_x_avb___ptp_struct.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___sequence_id_struct.html">XAvb_SequenceIdStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines the format for a data structure which stores the last used sequence ID for all of the PTP timing frames.  <a href="struct_x_avb___sequence_id_struct.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___signalling_frame_data.html">XAvb_SignallingFrameData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Signalling frame defines the delays to be used between Sync Frames, Link Delay measurements and Announce Frame events.  <a href="struct_x_avb___signalling_frame_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___counters.html">XAvb_Counters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef defines the various counters which have to maintained for the PTP operation.  <a href="struct_x_avb___counters.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___state_machine_data.html">XAvb_StateMachineData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep track of state machine data to make sure we're fully compliant with the spec.  <a href="struct_x_avb___state_machine_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb___m_d_sync_receive.html">XAvb_MDSyncReceive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct captures information from RX'd Sync/FollowUp message pairs in a format similiar to the MDSyncReceive structure described in the IEEE P802.1AS specification.  <a href="struct_x_avb___m_d_sync_receive.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_avb.html">XAvb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> driver instance data.  <a href="struct_x_avb.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">MAC Latency Definitions</div></td></tr>
<tr class="memitem:abc073a3959ca6b86a41f242c3319caa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc073a3959ca6b86a41f242c3319caa6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_TX_MAC_LATENCY_IN_NS</b>&#160;&#160;&#160;80</td></tr>
<tr class="separator:abc073a3959ca6b86a41f242c3319caa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46866ca63ed6053a0bd8a249c9403ef7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46866ca63ed6053a0bd8a249c9403ef7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_RX_MAC_LATENCY_IN_NS</b>&#160;&#160;&#160;80</td></tr>
<tr class="separator:a46866ca63ed6053a0bd8a249c9403ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PTP Buffer Storage Definitions</div></td></tr>
<tr class="memitem:ad09ed6b13a7551d1143edd1b767c42da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad09ed6b13a7551d1143edd1b767c42da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_SYNC</b>&#160;&#160;&#160;0x0</td></tr>
<tr class="separator:ad09ed6b13a7551d1143edd1b767c42da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d230bb44704a3e672b722027bbfea3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33d230bb44704a3e672b722027bbfea3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_FOLLOW_UP</b>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a33d230bb44704a3e672b722027bbfea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e1514eba1af0d180998b5565fe3293"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3e1514eba1af0d180998b5565fe3293"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PDELAYREQ</b>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:ac3e1514eba1af0d180998b5565fe3293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c4df7486820d30a0873d739b8ff5f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c4df7486820d30a0873d739b8ff5f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PDELAYRESP</b>&#160;&#160;&#160;0x3</td></tr>
<tr class="separator:a53c4df7486820d30a0873d739b8ff5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f90b7d9ed319a2507fbd4e335696b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28f90b7d9ed319a2507fbd4e335696b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PDELAYRESP_FOLLOW_UP</b>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a28f90b7d9ed319a2507fbd4e335696b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015cf507254aee6e28cf14e2278daaf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a015cf507254aee6e28cf14e2278daaf1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_ANNOUNCE</b>&#160;&#160;&#160;0x5</td></tr>
<tr class="separator:a015cf507254aee6e28cf14e2278daaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216db274ec255028839d0039dd4a3c0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a216db274ec255028839d0039dd4a3c0b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_SIGNALING</b>&#160;&#160;&#160;0x6</td></tr>
<tr class="separator:a216db274ec255028839d0039dd4a3c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PTP Packet Message Type Definitions</div></td></tr>
<tr class="memitem:af16744add130381867a4b6e8129c675c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af16744add130381867a4b6e8129c675c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TYPE_SYNC</b>&#160;&#160;&#160;0x0</td></tr>
<tr class="separator:af16744add130381867a4b6e8129c675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dec9ccd740bbd893f17836ebbd280f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dec9ccd740bbd893f17836ebbd280f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TYPE_FOLLOW_UP</b>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:a9dec9ccd740bbd893f17836ebbd280f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d74575dc0ad832766d3a80d9f1dcf3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d74575dc0ad832766d3a80d9f1dcf3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TYPE_PDELAYREQ</b>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:a4d74575dc0ad832766d3a80d9f1dcf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c331f1cbf6d2917de2217aef4a1e24d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c331f1cbf6d2917de2217aef4a1e24d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TYPE_PDELAYRESP</b>&#160;&#160;&#160;0x3</td></tr>
<tr class="separator:a4c331f1cbf6d2917de2217aef4a1e24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2283f2ba09f95c3adc8f3207d0980e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2283f2ba09f95c3adc8f3207d0980e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TYPE_PDELAYRESP_FOLLOW_UP</b>&#160;&#160;&#160;0xA</td></tr>
<tr class="separator:a6c2283f2ba09f95c3adc8f3207d0980e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79a9df605e943834209369eee67dfbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa79a9df605e943834209369eee67dfbe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TYPE_ANNOUNCE</b>&#160;&#160;&#160;0xB</td></tr>
<tr class="separator:aa79a9df605e943834209369eee67dfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9174ce90b33e674f26086d939a4b1c3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9174ce90b33e674f26086d939a4b1c3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TYPE_SIGNALING</b>&#160;&#160;&#160;0xC</td></tr>
<tr class="separator:a9174ce90b33e674f26086d939a4b1c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Common PTP Frame Structure Definitions.</div></td></tr>
<tr class="memitem:ac07f3637517345a0e8f020d68e00049d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac07f3637517345a0e8f020d68e00049d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_PKT_CAPTURED_TIMESTAMP_OFFSET</b>&#160;&#160;&#160;0x000000FC</td></tr>
<tr class="separator:ac07f3637517345a0e8f020d68e00049d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">General Tx PTP Frame Structure Definitions.</div></td></tr>
<tr class="memitem:aadd6077cc945f5dc1f0fff4081c447a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadd6077cc945f5dc1f0fff4081c447a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_SA_UPPER_OFFSET</b>&#160;&#160;&#160;0x0000000C</td></tr>
<tr class="separator:aadd6077cc945f5dc1f0fff4081c447a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd3b201117fdc964e14eebbd980c7d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fd3b201117fdc964e14eebbd980c7d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_SA_LOWER_OFFSET</b>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="separator:a8fd3b201117fdc964e14eebbd980c7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7340ba13f956628ea8b68bf0b2d3de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d7340ba13f956628ea8b68bf0b2d3de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_TYPE_OFFSET</b>&#160;&#160;&#160;0x00000014</td></tr>
<tr class="separator:a9d7340ba13f956628ea8b68bf0b2d3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e757592bd8aa674896e2feb08649b8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e757592bd8aa674896e2feb08649b8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_CORRECTION_FIELD_OFFSET</b>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="separator:a6e757592bd8aa674896e2feb08649b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e08dad379e270f855379ec0a675f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae57e08dad379e270f855379ec0a675f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_PORTID_UPPER_OFFSET</b>&#160;&#160;&#160;0x00000028</td></tr>
<tr class="separator:ae57e08dad379e270f855379ec0a675f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e0a0d052851a2ffe2f9cb30b881f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a036e0a0d052851a2ffe2f9cb30b881f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_PORTID_MID_OFFSET</b>&#160;&#160;&#160;0x0000002C</td></tr>
<tr class="separator:a036e0a0d052851a2ffe2f9cb30b881f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6d3212cfdb68c98be34f392bac7d55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6d3212cfdb68c98be34f392bac7d55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_PORTID_LOWER_OFFSET</b>&#160;&#160;&#160;0x00000030</td></tr>
<tr class="separator:acf6d3212cfdb68c98be34f392bac7d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff1657654bb48b5f2d2831341960249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff1657654bb48b5f2d2831341960249"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_SEQUENCEID_OFFSET</b>&#160;&#160;&#160;0x00000034</td></tr>
<tr class="separator:a6ff1657654bb48b5f2d2831341960249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ffce21111828a7986e1e1b4891d9c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5ffce21111828a7986e1e1b4891d9c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_TIMESTAMP_UPPER_OFFSET</b>&#160;&#160;&#160;0x00000038</td></tr>
<tr class="separator:af5ffce21111828a7986e1e1b4891d9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af422f9e119a22f5df332d256cb1e5125"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af422f9e119a22f5df332d256cb1e5125"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_TIMESTAMP_MID_OFFSET</b>&#160;&#160;&#160;0x0000003C</td></tr>
<tr class="separator:af422f9e119a22f5df332d256cb1e5125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de23ef64d426361ae463b2a3e572305"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8de23ef64d426361ae463b2a3e572305"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_TIMESTAMP_LOWER_OFFSET</b>&#160;&#160;&#160;0x00000040  /* upper 2 bytes */</td></tr>
<tr class="separator:a8de23ef64d426361ae463b2a3e572305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd84fa0e3cd7ab6c61fff87f9379a8d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd84fa0e3cd7ab6c61fff87f9379a8d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_REQ_PORTID_UPPER_OFFSET</b>&#160;&#160;&#160;0x00000040  /* lower 2 bytes */</td></tr>
<tr class="separator:acd84fa0e3cd7ab6c61fff87f9379a8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8b628dc8f266bad27d5114979b0c90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc8b628dc8f266bad27d5114979b0c90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_REQ_PORTID_MID_OFFSET</b>&#160;&#160;&#160;0x00000044</td></tr>
<tr class="separator:afc8b628dc8f266bad27d5114979b0c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4021c062a33008f789def16e7fb1ad5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4021c062a33008f789def16e7fb1ad5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_REQ_PORTID_LOWER_OFFSET</b>&#160;&#160;&#160;0x00000048</td></tr>
<tr class="separator:a4021c062a33008f789def16e7fb1ad5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tx Announce PTP Frame Structure Definitions.</div></td></tr>
<tr class="memitem:abdc810269bdeb90dcd395b6281b3c0c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdc810269bdeb90dcd395b6281b3c0c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_ANNOUNCE_CURR_UTCOFF_OFFSET</b>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="separator:abdc810269bdeb90dcd395b6281b3c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b281733c7caa488988f9789630b6a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17b281733c7caa488988f9789630b6a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_ANNOUNCE_QUAL_LOW_PRI2_GMID_HI_OFFSET</b>&#160;&#160;&#160;0x00000048</td></tr>
<tr class="separator:a17b281733c7caa488988f9789630b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9338f109431eb82188b80c0c49063a52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9338f109431eb82188b80c0c49063a52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_ANNOUNCE_GMID_MID_OFFSET</b>&#160;&#160;&#160;0x0000004C</td></tr>
<tr class="separator:a9338f109431eb82188b80c0c49063a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ca6893f5947674188950ecf39e4cea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3ca6893f5947674188950ecf39e4cea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_ANNOUNCE_GMID_LOW_STEPSREMOVED_HI_OFFSET</b>&#160;&#160;&#160;0x00000050</td></tr>
<tr class="separator:aa3ca6893f5947674188950ecf39e4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204760b5e8668cbb3740f235c4627e80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a204760b5e8668cbb3740f235c4627e80"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_ANNOUNCE_STEPSREMOVED_LOW_TIMESRC_OFFSET</b>&#160;&#160;&#160;0x00000054</td></tr>
<tr class="separator:a204760b5e8668cbb3740f235c4627e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c68d9cc53c49727502b9fbf82cb95f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99c68d9cc53c49727502b9fbf82cb95f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_TX_PKT_ANNOUNCE_TLVLEN_PATHSEQ_START_OFFSET</b>&#160;&#160;&#160;0x00000058</td></tr>
<tr class="separator:a99c68d9cc53c49727502b9fbf82cb95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PTP frame constant definitions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Constant value for the control field and LogMeanMessageInterval field for pDelayResp and pDelayRespFollowUp PTP frames (defined in IEEE802.1 AS) </p>
</div></td></tr>
<tr class="memitem:a73c4fd9a58283e850d8cfb755b7bf3bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c4fd9a58283e850d8cfb755b7bf3bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PDELAY_LOG_MEAN_MESSAGE_INT</b>&#160;&#160;&#160;0x7F050000</td></tr>
<tr class="separator:a73c4fd9a58283e850d8cfb755b7bf3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Default LogMeanInterval values</div></td></tr>
<tr class="memitem:a7c4331dc04a4a13569def43769ba8d93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c4331dc04a4a13569def43769ba8d93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_DEFAULT_LOG_MEAN_SYNC_INTERVAL</b>&#160;&#160;&#160;(-3)      /** 2^(-3) = 125ms */</td></tr>
<tr class="separator:a7c4331dc04a4a13569def43769ba8d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9fd881e160d046c0c5a487a3bdf9e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa9fd881e160d046c0c5a487a3bdf9e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_DEFAULT_LOG_MEAN_PDELAY_REQ_INTERVAL</b>&#160;&#160;&#160;0         /** 128/128 = 2^(0) = 1 s */</td></tr>
<tr class="separator:afa9fd881e160d046c0c5a487a3bdf9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9826ca436da8d60f74f825a8e4d8998f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9826ca436da8d60f74f825a8e4d8998f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_DEFAULT_LOG_MEAN_ANNOUNCE_INTERVAL</b>&#160;&#160;&#160;0         /** 128/128 = 2^(0) = 1 s */</td></tr>
<tr class="separator:a9826ca436da8d60f74f825a8e4d8998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37676668c11318e73cc17bb90ce3a04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af37676668c11318e73cc17bb90ce3a04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PKT_TYPE_DISABLED</b>&#160;&#160;&#160;0xffff</td></tr>
<tr class="separator:af37676668c11318e73cc17bb90ce3a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6895a49055ecc105ac81172201ae3365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6895a49055ecc105ac81172201ae3365"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_MAX_SUPPORTED_LOG_MEAN_INTERVAL</b>&#160;&#160;&#160;8         /** 32768/128 = 256 s */</td></tr>
<tr class="separator:a6895a49055ecc105ac81172201ae3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43efcffd7166dc62623bc007f32717a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab43efcffd7166dc62623bc007f32717a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_MIN_SUPPORTED_LOG_MEAN_INTERVAL</b>&#160;&#160;&#160;(-7)      /** 1/128 s */</td></tr>
<tr class="separator:ab43efcffd7166dc62623bc007f32717a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Announce / Sync Timeout values</div></td></tr>
<tr class="memitem:aafbcc1c1bf07dece3f745f8189740672"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#aafbcc1c1bf07dece3f745f8189740672">XAVB_ANNOUNCE_RECEIPT_TIMEOUT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:aafbcc1c1bf07dece3f745f8189740672"><td class="mdescLeft">&#160;</td><td class="mdescRight">XAVB_ANNOUNCE_RECEIPT_TIMEOUT is the number of announce intervals without the receipt of an Announce message from the GM that are allowed before the GM is assumed to be no longer present and BMCA should be run again.  <a href="#aafbcc1c1bf07dece3f745f8189740672">More...</a><br/></td></tr>
<tr class="separator:aafbcc1c1bf07dece3f745f8189740672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a4a25d453f50c7cdc57b81b91e8aba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a15a4a25d453f50c7cdc57b81b91e8aba">XAVB_SYNC_RECEIPT_TIMEOUT</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a15a4a25d453f50c7cdc57b81b91e8aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">XAVB_SYNC_RECEIPT_TIMEOUT is the number of sync intervals without the receipt of an Sync message from the GM that are allowed before the GM is assumed to be no longer present and BMCA should be run again.  <a href="#a15a4a25d453f50c7cdc57b81b91e8aba">More...</a><br/></td></tr>
<tr class="separator:a15a4a25d453f50c7cdc57b81b91e8aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AS Network Requirements</div></td></tr>
<tr class="memitem:aeee995ca1e92645f113145ca6dbeceda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#aeee995ca1e92645f113145ca6dbeceda">XAVB_NEIGHBOR_PROP_DELAY_THRESH</a>&#160;&#160;&#160;5000</td></tr>
<tr class="memdesc:aeee995ca1e92645f113145ca6dbeceda"><td class="mdescLeft">&#160;</td><td class="mdescRight">XAVB_NEIGHBOR_PROP_DELAY_THRESH is the maximum allowed delay (in nanosecs) across a full duplex link for which the AVB protocol is allowed to function.  <a href="#aeee995ca1e92645f113145ca6dbeceda">More...</a><br/></td></tr>
<tr class="separator:aeee995ca1e92645f113145ca6dbeceda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3182fdfc7befebf2408090b1ab791bcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a3182fdfc7befebf2408090b1ab791bcc">XAVB_ALLOWED_LOST_RESPONSES</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a3182fdfc7befebf2408090b1ab791bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">XAVB_ALLOWED_LOST_RESPONSES is the number of Pdelay_Req messages for which a valid response is not received, above which the Peer should no longer be considered ASCapable.  <a href="#a3182fdfc7befebf2408090b1ab791bcc">More...</a><br/></td></tr>
<tr class="separator:a3182fdfc7befebf2408090b1ab791bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">General Rx PTP Frame Structure Definitions.</div></td></tr>
<tr class="memitem:a8ed2187b6ef8164602ae3b2a44406926"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ed2187b6ef8164602ae3b2a44406926"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_SA_UPPER_OFFSET</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:a8ed2187b6ef8164602ae3b2a44406926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c67c09dddc46adaee4b35648ae8f38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37c67c09dddc46adaee4b35648ae8f38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_SA_LOWER_OFFSET</b>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="separator:a37c67c09dddc46adaee4b35648ae8f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48fc291292cf60d7a05339cbc083057"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac48fc291292cf60d7a05339cbc083057"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_TYPE_OFFSET</b>&#160;&#160;&#160;0x0000000C</td></tr>
<tr class="separator:ac48fc291292cf60d7a05339cbc083057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4099f1711a61cf5f3905ffbb69afa47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4099f1711a61cf5f3905ffbb69afa47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_CORRECTION_FIELD_OFFSET</b>&#160;&#160;&#160;0x00000018</td></tr>
<tr class="separator:ad4099f1711a61cf5f3905ffbb69afa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc7c0ef77ecc3991dd73ec7674a28f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbc7c0ef77ecc3991dd73ec7674a28f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_PORTID_UPPER_OFFSET</b>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="separator:acbc7c0ef77ecc3991dd73ec7674a28f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fa176955e366c679a2e29a192d3d36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23fa176955e366c679a2e29a192d3d36"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_PORTID_MID_OFFSET</b>&#160;&#160;&#160;0x00000024</td></tr>
<tr class="separator:a23fa176955e366c679a2e29a192d3d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7e94a023f47b7d4d2a5ca38e74e0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0af7e94a023f47b7d4d2a5ca38e74e0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_PORTID_LOWER_OFFSET</b>&#160;&#160;&#160;0x00000028</td></tr>
<tr class="separator:a0af7e94a023f47b7d4d2a5ca38e74e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1f05511c5dbe3a7aa7b59da79b33b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc1f05511c5dbe3a7aa7b59da79b33b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_SEQUENCEID_OFFSET</b>&#160;&#160;&#160;0x0000002C</td></tr>
<tr class="separator:abc1f05511c5dbe3a7aa7b59da79b33b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5942048453a535fabe93134def59f7ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5942048453a535fabe93134def59f7ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_TIMESTAMP_UPPER_OFFSET</b>&#160;&#160;&#160;0x00000030</td></tr>
<tr class="separator:a5942048453a535fabe93134def59f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b376ae2c55f4bbfe5b06e8b784a15f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b376ae2c55f4bbfe5b06e8b784a15f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_TIMESTAMP_MID_OFFSET</b>&#160;&#160;&#160;0x00000034</td></tr>
<tr class="separator:a6b376ae2c55f4bbfe5b06e8b784a15f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa517a39f9b73cd46cc314f5313ef32a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa517a39f9b73cd46cc314f5313ef32a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_TIMESTAMP_LOWER_OFFSET</b>&#160;&#160;&#160;0x00000038  /* upper 2 bytes */</td></tr>
<tr class="separator:aa517a39f9b73cd46cc314f5313ef32a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bd04312a99a5f971680acc0569d63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a634bd04312a99a5f971680acc0569d63"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_REQ_PORTID_UPPER_OFFSET</b>&#160;&#160;&#160;0x00000038  /* lower 2 bytes */</td></tr>
<tr class="separator:a634bd04312a99a5f971680acc0569d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b247118476aa7c8100492bff6ba1ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b247118476aa7c8100492bff6ba1ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_REQ_PORTID_MID_OFFSET</b>&#160;&#160;&#160;0x0000003C</td></tr>
<tr class="separator:ae8b247118476aa7c8100492bff6ba1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eae0d12dbfb311e1bd5cb2e3f3b8713"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eae0d12dbfb311e1bd5cb2e3f3b8713"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_REQ_PORTID_LOWER_OFFSET</b>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="separator:a8eae0d12dbfb311e1bd5cb2e3f3b8713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rx Announce PTP Frame Structure Definitions.</div></td></tr>
<tr class="memitem:a2fccd289b66665ab8991ebee447c0dd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fccd289b66665ab8991ebee447c0dd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_ANNOUNCE_PRI1_QUAL_HI_OFFSET</b>&#160;&#160;&#160;0x0000003C</td></tr>
<tr class="separator:a2fccd289b66665ab8991ebee447c0dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09641086ca9fa9b8ee9b7a83677cd281"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09641086ca9fa9b8ee9b7a83677cd281"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_ANNOUNCE_QUAL_LOW_PRI2_GMID_HI_OFFSET</b>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="separator:a09641086ca9fa9b8ee9b7a83677cd281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d1336e8f845acfca92a8e066033650"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30d1336e8f845acfca92a8e066033650"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_ANNOUNCE_GMID_MID_OFFSET</b>&#160;&#160;&#160;0x00000044</td></tr>
<tr class="separator:a30d1336e8f845acfca92a8e066033650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21e5c23ca3f7687926814b1942f649b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab21e5c23ca3f7687926814b1942f649b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_ANNOUNCE_GMID_LOW_STEPSREMOVED_HI_OFFSET</b>&#160;&#160;&#160;0x00000048</td></tr>
<tr class="separator:ab21e5c23ca3f7687926814b1942f649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b843baa211b5fba9c07849a31ef2c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b843baa211b5fba9c07849a31ef2c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_ANNOUNCE_STEPSREMOVED_LOW_TIMESRC_OFFSET</b>&#160;&#160;&#160;0x0000004C</td></tr>
<tr class="separator:ae8b843baa211b5fba9c07849a31ef2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rx Signalling PTP Frame Structure Definitions.</div></td></tr>
<tr class="memitem:a85a30a85db0f3f8f0ec7cb13720a15d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85a30a85db0f3f8f0ec7cb13720a15d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_RX_PKT_SIGNALING_DELAY_INTERVAL_OFFSET</b>&#160;&#160;&#160;0x00000044</td></tr>
<tr class="separator:a85a30a85db0f3f8f0ec7cb13720a15d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard PTP Frame Field Definitions (from IEEE802.1AS specification).</div></td></tr>
<tr class="memitem:a5e9c3aa7c66998789aa928bce147fc25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e9c3aa7c66998789aa928bce147fc25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_ETHERTYPE</b>&#160;&#160;&#160;0x88F7</td></tr>
<tr class="separator:a5e9c3aa7c66998789aa928bce147fc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37fc28a926c3dd53130ce040503d60f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad37fc28a926c3dd53130ce040503d60f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_PTP_VERSION_PTP</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ad37fc28a926c3dd53130ce040503d60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Real Time Clock Definitions.</div></td></tr>
<tr class="memitem:a0e38789f6a2e5cdbf7a2f305c77044dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>&#160;&#160;&#160;1000000000</td></tr>
<tr class="memdesc:a0e38789f6a2e5cdbf7a2f305c77044dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value in ns.  <a href="#a0e38789f6a2e5cdbf7a2f305c77044dd">More...</a><br/></td></tr>
<tr class="separator:a0e38789f6a2e5cdbf7a2f305c77044dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4793b0c7d045e9391746350389ff4ecc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a4793b0c7d045e9391746350389ff4ecc">XAVB_PERIOD_8KHZ</a>&#160;&#160;&#160;125000</td></tr>
<tr class="memdesc:a4793b0c7d045e9391746350389ff4ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value in ns.  <a href="#a4793b0c7d045e9391746350389ff4ecc">More...</a><br/></td></tr>
<tr class="separator:a4793b0c7d045e9391746350389ff4ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Real Time Clock Locked Definitions.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If the Slave error is &gt; this threshold then define PTP to be unlocked and link not asCapable.</p>
<dl class="section note"><dt>Note</dt><dd>: This threshold is not specified in IEEE 802.1as. </dd></dl>
</div></td></tr>
<tr class="memitem:aa7c8e8ce9e50f2b41384c01c7644073b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#aa7c8e8ce9e50f2b41384c01c7644073b">XAVB_CLOCK_LOCK_THRESHOLD</a>&#160;&#160;&#160;1000</td></tr>
<tr class="memdesc:aa7c8e8ce9e50f2b41384c01c7644073b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value in ns.  <a href="#aa7c8e8ce9e50f2b41384c01c7644073b">More...</a><br/></td></tr>
<tr class="separator:aa7c8e8ce9e50f2b41384c01c7644073b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">RTC Increment Value Update Definitions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Define how often to re-calculate the RTC Increment This value indicates how many good Sync/FollowUp message pairs are received before the re-calculation is performed. </p>
</div></td></tr>
<tr class="memitem:a925e7c20ad3c8a220a5f4dc5d959dd96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a925e7c20ad3c8a220a5f4dc5d959dd96"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XAVB_NUM_SYNC_FU_PAIR_CALC_RTC_INCREMENT</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a925e7c20ad3c8a220a5f4dc5d959dd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a89773b9c275933b3c03bbf78179342b5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a89773b9c275933b3c03bbf78179342b5">XAvb_Handler</a> )(void *CallBackRef, u32 TimestampsUncertain)</td></tr>
<tr class="memdesc:a89773b9c275933b3c03bbf78179342b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function.  <a href="#a89773b9c275933b3c03bbf78179342b5">More...</a><br/></td></tr>
<tr class="separator:a89773b9c275933b3c03bbf78179342b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8ddc8d42f610c49547f6cf4778629d1"><td class="memItemLeft" align="right" valign="top">XStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#af8ddc8d42f610c49547f6cf4778629d1">XAvb_CfgInitialize</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, <a class="el" href="struct_x_avb___config.html">XAvb_Config</a> *ConfigPtr, u32 EffectiveAddress)</td></tr>
<tr class="memdesc:af8ddc8d42f610c49547f6cf4778629d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to initialise variables in the data structure records.  <a href="#af8ddc8d42f610c49547f6cf4778629d1">More...</a><br/></td></tr>
<tr class="separator:af8ddc8d42f610c49547f6cf4778629d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24c248c31c6c45cdb8a46f82de175c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:af24c248c31c6c45cdb8a46f82de175c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets all of the AVB device driver functions to the start-up (reset) defaults.  <a href="#af24c248c31c6c45cdb8a46f82de175c5">More...</a><br/></td></tr>
<tr class="separator:af24c248c31c6c45cdb8a46f82de175c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8657704dc9974d465536615ebbeb79d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a8657704dc9974d465536615ebbeb79d9">XAvb_Start</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a8657704dc9974d465536615ebbeb79d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will start the PTP drivers running.  <a href="#a8657704dc9974d465536615ebbeb79d9">More...</a><br/></td></tr>
<tr class="separator:a8657704dc9974d465536615ebbeb79d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5d4a65b18da8805b9a6bf464961f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a5a5d4a65b18da8805b9a6bf464961f25">XAvb_Stop</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a5a5d4a65b18da8805b9a6bf464961f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will stop the PTP drivers from running.  <a href="#a5a5d4a65b18da8805b9a6bf464961f25">More...</a><br/></td></tr>
<tr class="separator:a5a5d4a65b18da8805b9a6bf464961f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab96c1602bda46380e25d0bb03a8ac01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:aab96c1602bda46380e25d0bb03a8ac01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Interrupt subroutine for the "interruptPtpTimer" signal.  <a href="#aab96c1602bda46380e25d0bb03a8ac01">More...</a><br/></td></tr>
<tr class="separator:aab96c1602bda46380e25d0bb03a8ac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99019d3795040dd7110d47aaa598ab7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a99019d3795040dd7110d47aaa598ab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Interrupt subroutine for the "interrupt_ptp_rx" signal.  <a href="#a99019d3795040dd7110d47aaa598ab7b">More...</a><br/></td></tr>
<tr class="separator:a99019d3795040dd7110d47aaa598ab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a970ecc2621c88825ecc3f01ff1c4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a4a970ecc2621c88825ecc3f01ff1c4ad">XAvb_SetupRxFilterControlPcp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 VlanPriority, u8 SrClass)</td></tr>
<tr class="memdesc:a4a970ecc2621c88825ecc3f01ff1c4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to set the VLAN PCP field for either SR A or B traffic in the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter.  <a href="#a4a970ecc2621c88825ecc3f01ff1c4ad">More...</a><br/></td></tr>
<tr class="separator:a4a970ecc2621c88825ecc3f01ff1c4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb10d8fd68257130d0fc50bfe71ad3e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#afb10d8fd68257130d0fc50bfe71ad3e6">XAvb_SetupRxFilterControlVid</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 VlanVid, u8 SrClass)</td></tr>
<tr class="memdesc:afb10d8fd68257130d0fc50bfe71ad3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to set the VLAN VID field for either SR A or B traffic in the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter.  <a href="#afb10d8fd68257130d0fc50bfe71ad3e6">More...</a><br/></td></tr>
<tr class="separator:afb10d8fd68257130d0fc50bfe71ad3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888d220aeb387018ce33558e08d0166e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a888d220aeb387018ce33558e08d0166e">XAvb_SetupRxFilterControlMatchMode</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 VlanMatchMode)</td></tr>
<tr class="memdesc:a888d220aeb387018ce33558e08d0166e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to set the VLAN Match Mode field for the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter.  <a href="#a888d220aeb387018ce33558e08d0166e">More...</a><br/></td></tr>
<tr class="separator:a888d220aeb387018ce33558e08d0166e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664d83b2f34093d6000f3ea2facef449"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord</a> (u32 Data)</td></tr>
<tr class="memdesc:a664d83b2f34093d6000f3ea2facef449"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function switches the bytes in a 4-byte word, swapping the MSB for the LSB, and vice-versa.  <a href="#a664d83b2f34093d6000f3ea2facef449">More...</a><br/></td></tr>
<tr class="separator:a664d83b2f34093d6000f3ea2facef449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03b2f45590d8dabe5ad0eb39430e044"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#aa03b2f45590d8dabe5ad0eb39430e044">XAvb_CompareClockIdentity</a> (u32 BaseAddress, <a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a> Identity1, <a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a> Identity2)</td></tr>
<tr class="memdesc:aa03b2f45590d8dabe5ad0eb39430e044"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to compare two ClockIdentity values.  <a href="#aa03b2f45590d8dabe5ad0eb39430e044">More...</a><br/></td></tr>
<tr class="separator:aa03b2f45590d8dabe5ad0eb39430e044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8231a4001187aaff164037da857cb333"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity</a> (u32 BaseAddress, <a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> Identity1, <a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> Identity2)</td></tr>
<tr class="memdesc:a8231a4001187aaff164037da857cb333"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to compare two PortIdentity values.  <a href="#a8231a4001187aaff164037da857cb333">More...</a><br/></td></tr>
<tr class="separator:a8231a4001187aaff164037da857cb333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fafde8d597983f3e827b93fcc8e3c8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a1fafde8d597983f3e827b93fcc8e3c8a">XAvb_WriteToMultipleTxPtpFrames</a> (u32 BaseAddress, u32 Address, u32 Data, u32 DataBitEnable, u8 BufferEnable)</td></tr>
<tr class="memdesc:a1fafde8d597983f3e827b93fcc8e3c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to write common data (eg the Source Address) to all PTP frames stored in the Tx PTP Packet buffer.  <a href="#a1fafde8d597983f3e827b93fcc8e3c8a">More...</a><br/></td></tr>
<tr class="separator:a1fafde8d597983f3e827b93fcc8e3c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454f4f2c09586f6e787232cb0ae250c2"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a454f4f2c09586f6e787232cb0ae250c2">XAvb_IncSequenceId</a> (u32 BaseAddress, u32 PTPFrameBaseAddress)</td></tr>
<tr class="memdesc:a454f4f2c09586f6e787232cb0ae250c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to increment the sequenceId in a PTP frame template.  <a href="#a454f4f2c09586f6e787232cb0ae250c2">More...</a><br/></td></tr>
<tr class="separator:a454f4f2c09586f6e787232cb0ae250c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2030902e6748712f30a59a62dff010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity</a> (u32 BaseAddress, u32 PtpFrameBaseAddr, u32 PortIdOffset, <a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> *portID)</td></tr>
<tr class="memdesc:a2f2030902e6748712f30a59a62dff010"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to extract portIdentity information from a received PTP frame.  <a href="#a2f2030902e6748712f30a59a62dff010">More...</a><br/></td></tr>
<tr class="separator:a2f2030902e6748712f30a59a62dff010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3695de30c54e17e3c3e0a461ab0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:afcb3695de30c54e17e3c3e0a461ab0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The software drivers are kept simple by only requesting a single PTP frame to be transmitted at a time.  <a href="#afcb3695de30c54e17e3c3e0a461ab0eb">More...</a><br/></td></tr>
<tr class="separator:afcb3695de30c54e17e3c3e0a461ab0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaf9984303a07b8935d4a391f0ca188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#aeeaf9984303a07b8935d4a391f0ca188">XAvb_MasterSendAnnounce</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:aeeaf9984303a07b8935d4a391f0ca188"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP Announce Packet.  <a href="#aeeaf9984303a07b8935d4a391f0ca188">More...</a><br/></td></tr>
<tr class="separator:aeeaf9984303a07b8935d4a391f0ca188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae239544f086bc86572b8e2d7e408a028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:ae239544f086bc86572b8e2d7e408a028"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP Sync Packet.  <a href="#ae239544f086bc86572b8e2d7e408a028">More...</a><br/></td></tr>
<tr class="separator:ae239544f086bc86572b8e2d7e408a028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989d44c98695fd6f286858f8b7976e3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a989d44c98695fd6f286858f8b7976e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP Follow-Up Packet.  <a href="#a989d44c98695fd6f286858f8b7976e3f">More...</a><br/></td></tr>
<tr class="separator:a989d44c98695fd6f286858f8b7976e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3f462007beb73497bbded566d7f364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a2e3f462007beb73497bbded566d7f364"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP PDelay Request Packet.  <a href="#a2e3f462007beb73497bbded566d7f364">More...</a><br/></td></tr>
<tr class="separator:a2e3f462007beb73497bbded566d7f364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63281acd385453959b333154bca2d9c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:a63281acd385453959b333154bca2d9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP PDelay Response Packet.  <a href="#a63281acd385453959b333154bca2d9c7">More...</a><br/></td></tr>
<tr class="separator:a63281acd385453959b333154bca2d9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1081cde03d0c53bc508927111fe87c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a2c1081cde03d0c53bc508927111fe87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to format then request the transmission of a PTP PDelay Response Follow-Up Packet.  <a href="#a2c1081cde03d0c53bc508927111fe87c">More...</a><br/></td></tr>
<tr class="separator:a2c1081cde03d0c53bc508927111fe87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefe66ad0ca9e6af05129765cca4c3df"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#aaefe66ad0ca9e6af05129765cca4c3df">XAvb_IsRxFramePTP</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:aaefe66ad0ca9e6af05129765cca4c3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to check that various fields in the received frame contain the expected values which define it as a valid AVB PTP frame.  <a href="#aaefe66ad0ca9e6af05129765cca4c3df">More...</a><br/></td></tr>
<tr class="separator:aaefe66ad0ca9e6af05129765cca4c3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed6d94f92c94a88dce9444e8a27fe8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:a3ed6d94f92c94a88dce9444e8a27fe8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received PTP Sync Packet.  <a href="#a3ed6d94f92c94a88dce9444e8a27fe8a">More...</a><br/></td></tr>
<tr class="separator:a3ed6d94f92c94a88dce9444e8a27fe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8650c4c94082dc746db9ec0259e1cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:afb8650c4c94082dc746db9ec0259e1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received PTP Follow-up Packet.  <a href="#afb8650c4c94082dc746db9ec0259e1cb">More...</a><br/></td></tr>
<tr class="separator:afb8650c4c94082dc746db9ec0259e1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5beb09f67f655b7eb8eb51b3cd2d8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:acc5beb09f67f655b7eb8eb51b3cd2d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received PDelayResp Packet.  <a href="#acc5beb09f67f655b7eb8eb51b3cd2d8a">More...</a><br/></td></tr>
<tr class="separator:acc5beb09f67f655b7eb8eb51b3cd2d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53beaf90143fc360dc6276ba1c49f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:afd53beaf90143fc360dc6276ba1c49f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received PDelayRespFollowUp Packet.  <a href="#afd53beaf90143fc360dc6276ba1c49f9">More...</a><br/></td></tr>
<tr class="separator:afd53beaf90143fc360dc6276ba1c49f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9afff73e01faafdc8ce9f8e0ee8d4de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:ab9afff73e01faafdc8ce9f8e0ee8d4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to decode a received Signalling Packet and modify the TX PTP Buffers based on the requested values.  <a href="#ab9afff73e01faafdc8ce9f8e0ee8d4de">More...</a><br/></td></tr>
<tr class="separator:ab9afff73e01faafdc8ce9f8e0ee8d4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d81de9521bde263313b2de412f45fe2"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a5d81de9521bde263313b2de412f45fe2">XAvb_UpdateIntervalDuration</a> (u16 currentIntervalDuration, char logMeanVal)</td></tr>
<tr class="memdesc:a5d81de9521bde263313b2de412f45fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to update a PTP message Interval Duration (defined as a fraction of 128 seconds).  <a href="#a5d81de9521bde263313b2de412f45fe2">More...</a><br/></td></tr>
<tr class="separator:a5d81de9521bde263313b2de412f45fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa725e8ddb08a833d10e8554067ac361"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration</a> (char logMeanVal)</td></tr>
<tr class="memdesc:afa725e8ddb08a833d10e8554067ac361"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to convert a logMean (power of 2) value into a fraction of 128 that is compatible with Signalling data.  <a href="#afa725e8ddb08a833d10e8554067ac361">More...</a><br/></td></tr>
<tr class="separator:afa725e8ddb08a833d10e8554067ac361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1539b744b6e5b9c9da652820948241"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a7c1539b744b6e5b9c9da652820948241">XAvb_ConvertDurationToLogMean</a> (u16 fractionalVal)</td></tr>
<tr class="memdesc:a7c1539b744b6e5b9c9da652820948241"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to convert a fraction of 128 value that is compatible with Signalling data into a logMean (power of 2) value;.  <a href="#a7c1539b744b6e5b9c9da652820948241">More...</a><br/></td></tr>
<tr class="separator:a7c1539b744b6e5b9c9da652820948241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3933020b616a2a57b6229bce6f6151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a9c3933020b616a2a57b6229bce6f6151">XAvb_UpdateLogMeanMessageInterval</a> (u32 BaseAddress, u32 PtpFrameBaseAddr, u16 intervalDuration)</td></tr>
<tr class="memdesc:a9c3933020b616a2a57b6229bce6f6151"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to update the logMeanMessageInterval field in a PTP packet.  <a href="#a9c3933020b616a2a57b6229bce6f6151">More...</a><br/></td></tr>
<tr class="separator:a9c3933020b616a2a57b6229bce6f6151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cd78e966447edcb45a0f419cc84cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a42cd78e966447edcb45a0f419cc84cb8">XAvb_SetupSourcePortIdentity</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, <a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> systemIdentity)</td></tr>
<tr class="memdesc:a42cd78e966447edcb45a0f419cc84cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the portIdLocal local copy of the sourcePortIdentity and writes this value into the TX PTP frame buffer templates.  <a href="#a42cd78e966447edcb45a0f419cc84cb8">More...</a><br/></td></tr>
<tr class="separator:a42cd78e966447edcb45a0f419cc84cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4091121232495f00535ca134664b4f7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a4091121232495f00535ca134664b4f7c">XAvb_DecodeTxAnnounceFrame</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a4091121232495f00535ca134664b4f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A New Announce Packet has been written to this device to transmit.  <a href="#a4091121232495f00535ca134664b4f7c">More...</a><br/></td></tr>
<tr class="separator:a4091121232495f00535ca134664b4f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaf575de699cb2f054a43daa8a93849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="memdesc:a5eaf575de699cb2f054a43daa8a93849"><td class="mdescLeft">&#160;</td><td class="mdescRight">A New Announce Packet has been received.  <a href="#a5eaf575de699cb2f054a43daa8a93849">More...</a><br/></td></tr>
<tr class="separator:a5eaf575de699cb2f054a43daa8a93849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c77fd7953811584a36001e5e74165b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a7c77fd7953811584a36001e5e74165b3">XAvb_ReadAnnounceFrame</a> (u32 BaseAddress, u32 PtpFrameBaseAddr, <a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *AnnounceFrame)</td></tr>
<tr class="memdesc:a7c77fd7953811584a36001e5e74165b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A New Announce Packet is to be analyzed.  <a href="#a7c77fd7953811584a36001e5e74165b3">More...</a><br/></td></tr>
<tr class="separator:a7c77fd7953811584a36001e5e74165b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66e9752ef47bf7eafe4784cb59e1093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#aa66e9752ef47bf7eafe4784cb59e1093">XAvb_ReadAnnounceReceiptTimeout</a> (u32 BaseAddress, u32 PtpFrameBaseAddr, <a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *AnnounceFrame)</td></tr>
<tr class="memdesc:aa66e9752ef47bf7eafe4784cb59e1093"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the logMessageinteval from an RX PTP Buffer and updates the AnnounceFrame struct with the value read.  <a href="#aa66e9752ef47bf7eafe4784cb59e1093">More...</a><br/></td></tr>
<tr class="separator:aa66e9752ef47bf7eafe4784cb59e1093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2234b9dec3b039479123f49ee573a14e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a2234b9dec3b039479123f49ee573a14e">XAvb_UpdateBmcRecords</a> (<a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *NewMaster, <a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *CurrentBmc)</td></tr>
<tr class="memdesc:a2234b9dec3b039479123f49ee573a14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will accept the data pointer to the current BMCA records, accept an equivalent pointer to a new (winning) Grand Masters Announce Packet information.  <a href="#a2234b9dec3b039479123f49ee573a14e">More...</a><br/></td></tr>
<tr class="separator:a2234b9dec3b039479123f49ee573a14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38ec83a381d57348fdbaf065c2190eb"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#ae38ec83a381d57348fdbaf065c2190eb">XAvb_BestMasterClockAlgorithm</a> (<a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *AnnounceFrame, <a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *CurrentBmc)</td></tr>
<tr class="memdesc:ae38ec83a381d57348fdbaf065c2190eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will accept the data pointer to the current BMCA records, accept a pointer to an equivalent data structure for the new Announce Packet.  <a href="#ae38ec83a381d57348fdbaf065c2190eb">More...</a><br/></td></tr>
<tr class="separator:ae38ec83a381d57348fdbaf065c2190eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef1c55c51f5781c4395ff20cc07f410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a5ef1c55c51f5781c4395ff20cc07f410">XAvb_BecomeRtcMaster</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u8 txAnnounceHasWon)</td></tr>
<tr class="memdesc:a5ef1c55c51f5781c4395ff20cc07f410"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will make any adjustments needed when the node becomes the Grand Master, including resetting the RTC to its nominal value.  <a href="#a5ef1c55c51f5781c4395ff20cc07f410">More...</a><br/></td></tr>
<tr class="separator:a5ef1c55c51f5781c4395ff20cc07f410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eb3269ef7daea39a316315d903c43c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a52eb3269ef7daea39a316315d903c43c">XAvb_BecomeRtcSlave</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a52eb3269ef7daea39a316315d903c43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will make any adjustments needed when the node becomes a PTP slave.  <a href="#a52eb3269ef7daea39a316315d903c43c">More...</a><br/></td></tr>
<tr class="separator:a52eb3269ef7daea39a316315d903c43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f69b843cd86ca6149c838c478c4e01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a07f69b843cd86ca6149c838c478c4e01">XAvb_ChangePTPLockStatus</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u8 locked)</td></tr>
<tr class="memdesc:a07f69b843cd86ca6149c838c478c4e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations needed when PTP locks or unlocks.  <a href="#a07f69b843cd86ca6149c838c478c4e01">More...</a><br/></td></tr>
<tr class="separator:a07f69b843cd86ca6149c838c478c4e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004f6ae823f2e50f4dd2fac409953537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u8 capable)</td></tr>
<tr class="memdesc:a004f6ae823f2e50f4dd2fac409953537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations needed when the peer's AS capability changes.  <a href="#a004f6ae823f2e50f4dd2fac409953537">More...</a><br/></td></tr>
<tr class="separator:a004f6ae823f2e50f4dd2fac409953537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8e2297936bf5abb7f206b365611b30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a3c8e2297936bf5abb7f206b365611b30">XAvb_SetGMDiscontinuityHandler</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, <a class="el" href="xavb_8h.html#a89773b9c275933b3c03bbf78179342b5">XAvb_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:a3c8e2297936bf5abb7f206b365611b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handler that will be called when a GM discontinuity event is identified by the driver.  <a href="#a3c8e2297936bf5abb7f206b365611b30">More...</a><br/></td></tr>
<tr class="separator:a3c8e2297936bf5abb7f206b365611b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce07f766a1033fab5a1981e947db52e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a3ce07f766a1033fab5a1981e947db52e">XAvb_CaptureNanoSec</a> (u32 BaseAddress, u32 PtpFrameBaseAddr)</td></tr>
<tr class="separator:a3ce07f766a1033fab5a1981e947db52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7814f965d4141992654954f1243679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a6d7814f965d4141992654954f1243679">XAvb_CalcDelay</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="separator:a6d7814f965d4141992654954f1243679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee8dd26b932ff82daa0dc87fd6d38d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a5ee8dd26b932ff82daa0dc87fd6d38d8">XAvb_CalcRtcOffset</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr, u32 PtpFrameBaseAddr)</td></tr>
<tr class="separator:a5ee8dd26b932ff82daa0dc87fd6d38d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9dd75eb576b0e600686514fbea45e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#ada9dd75eb576b0e600686514fbea45e3">XAvb_UpdateRtcIncrement</a> (<a class="el" href="struct_x_avb.html">XAvb</a> *InstancePtr)</td></tr>
<tr class="separator:ada9dd75eb576b0e600686514fbea45e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a46d84127016dacb2823b953acbfd20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xavb_8h.html#a2a46d84127016dacb2823b953acbfd20">XAvb_Adjust8kClock</a> (u32 BaseAddress, u32 NewOffset)</td></tr>
<tr class="separator:a2a46d84127016dacb2823b953acbfd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3182fdfc7befebf2408090b1ab791bcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAVB_ALLOWED_LOST_RESPONSES&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XAVB_ALLOWED_LOST_RESPONSES is the number of Pdelay_Req messages for which a valid response is not received, above which the Peer should no longer be considered ASCapable. </p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="aafbcc1c1bf07dece3f745f8189740672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAVB_ANNOUNCE_RECEIPT_TIMEOUT&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XAVB_ANNOUNCE_RECEIPT_TIMEOUT is the number of announce intervals without the receipt of an Announce message from the GM that are allowed before the GM is assumed to be no longer present and BMCA should be run again. </p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7c8e8ce9e50f2b41384c01c7644073b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAVB_CLOCK_LOCK_THRESHOLD&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value in ns. </p>

<p>Referenced by <a class="el" href="xavb_8h.html#ada9dd75eb576b0e600686514fbea45e3">XAvb_UpdateRtcIncrement()</a>.</p>

</div>
</div>
<a class="anchor" id="aeee995ca1e92645f113145ca6dbeceda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAVB_NEIGHBOR_PROP_DELAY_THRESH&#160;&#160;&#160;5000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XAVB_NEIGHBOR_PROP_DELAY_THRESH is the maximum allowed delay (in nanosecs) across a full duplex link for which the AVB protocol is allowed to function. </p>
<p>Although this parameter is defined in the IEEE spec, no default is defined. </p>

<p>Referenced by <a class="el" href="xavb_8h.html#a6d7814f965d4141992654954f1243679">XAvb_CalcDelay()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e38789f6a2e5cdbf7a2f305c77044dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAVB_ONE_SECOND&#160;&#160;&#160;1000000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value in ns. </p>

<p>Referenced by <a class="el" href="xavb_8h.html#a6d7814f965d4141992654954f1243679">XAvb_CalcDelay()</a>, <a class="el" href="xavb_8h.html#a5ee8dd26b932ff82daa0dc87fd6d38d8">XAvb_CalcRtcOffset()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp()</a>, and <a class="el" href="xavb_8h.html#ada9dd75eb576b0e600686514fbea45e3">XAvb_UpdateRtcIncrement()</a>.</p>

</div>
</div>
<a class="anchor" id="a4793b0c7d045e9391746350389ff4ecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAVB_PERIOD_8KHZ&#160;&#160;&#160;125000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value in ns. </p>

<p>Referenced by <a class="el" href="xavb_8h.html#a2a46d84127016dacb2823b953acbfd20">XAvb_Adjust8kClock()</a>.</p>

</div>
</div>
<a class="anchor" id="a15a4a25d453f50c7cdc57b81b91e8aba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAVB_SYNC_RECEIPT_TIMEOUT&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XAVB_SYNC_RECEIPT_TIMEOUT is the number of sync intervals without the receipt of an Sync message from the GM that are allowed before the GM is assumed to be no longer present and BMCA should be run again. </p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a89773b9c275933b3c03bbf78179342b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XAvb_Handler)(void *CallBackRef, u32 TimestampsUncertain)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function. </p>
<p>The first argument is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. The second argument is a '1' if a Grandmaster Discontinuity event has occurred otherwise it is '0'. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a2a46d84127016dacb2823b953acbfd20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_Adjust8kClock </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>NewOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the previous offset</p>
<p>Calculate the change in the previous and current RTC ns offset</p>
<p>Is the adjustment "large"? "large" is chosen here to be one 8k clock period which is a somewhat arbitrary figure</p>
<p>The value XAVB_PERIOD_8KHZ is one 8k clock period in ns. We divide the RTC ns offset change by this to get the offset change in a multiple of 8k clock periods, the add 1 so that we always round up. Then multiply this by XAVB_PERIOD_8KHZ again so that we are always phased aligned to the RTC master (only evey adjust in a multiple of 8k periods.</p>
<p>Write the results to the 8K clock logic Offset register </p>

<p>References <a class="el" href="xavb_8h.html#a4793b0c7d045e9391746350389ff4ecc">XAVB_PERIOD_8KHZ</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#af86466362cc51296ae22fd1cb6c1d6ad">XAVB_RTC_8K_OFFSET_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a17b4489a857a0fcb761a529b749d5ad3">XAVB_RTC_NANOSEC_OFFSET</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a5ee8dd26b932ff82daa0dc87fd6d38d8">XAvb_CalcRtcOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ef1c55c51f5781c4395ff20cc07f410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_BecomeRtcMaster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>txAnnounceHasWon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will make any adjustments needed when the node becomes the Grand Master, including resetting the RTC to its nominal value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
    <tr><td class="paramname">txAnnounceHasWon</td><td>indicates that this function has been called from the function <a class="el" href="xavb_8h.html#a4091121232495f00535ca134664b4f7c" title="A New Announce Packet has been written to this device to transmit. ">XAvb_DecodeTxAnnounceFrame()</a>. Is this is set then this function has no need to repeat actions that have been already performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Update the BMCA records to this device's information</p>
<p>Read the attributes in the Tx PTP buffer</p>
<p>Update records</p>
<p>reset the RTC to a nominal value</p>
<p>set timestamp uncertainty if new status</p>
<p>inform the rest of the system </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb.html#a6f2483d14031dc855c8cf27c796c122e">XAvb::GMDiscCallBackRef</a>, <a class="el" href="struct_x_avb.html#adaa9fca5f2df9e76794cb97f8bd1f307">XAvb::GMDiscHandler</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="xavb_8h.html#a7c77fd7953811584a36001e5e74165b3">XAvb_ReadAnnounceFrame()</a>, <a class="el" href="xavb__hw_8h.html#aca5791394dd0b429d4c49559d0e1503c">XAVB_RTC_INCREMENT_NOMINAL_RATE</a>, <a class="el" href="xavb__hw_8h.html#a48d76d16f8d685a65a1216614e548071">XAVB_RTC_INCREMENT_OFFSET</a>, <a class="el" href="xavb_8h.html#a2234b9dec3b039479123f49ee573a14e">XAvb_UpdateBmcRecords()</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a4091121232495f00535ca134664b4f7c">XAvb_DecodeTxAnnounceFrame()</a>, <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>, and <a class="el" href="xavb_8h.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a52eb3269ef7daea39a316315d903c43c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_BecomeRtcSlave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will make any adjustments needed when the node becomes a PTP slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>set timestamp uncertainty if new status </p>

<p>References <a class="el" href="struct_x_avb___counters.html#a33a32af6ca968fac37957cbe9435f1db">XAvb_Counters::CounterSyncInterval</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb.html#a6f2483d14031dc855c8cf27c796c122e">XAvb::GMDiscCallBackRef</a>, <a class="el" href="struct_x_avb.html#adaa9fca5f2df9e76794cb97f8bd1f307">XAvb::GMDiscHandler</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, and <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="ae38ec83a381d57348fdbaf065c2190eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_BestMasterClockAlgorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *&#160;</td>
          <td class="paramname"><em>AnnounceFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *&#160;</td>
          <td class="paramname"><em>CurrentBmc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will accept the data pointer to the current BMCA records, accept a pointer to an equivalent data structure for the new Announce Packet. </p>
<p>The Best Master Clock Algorithm (BMCA) is then performed on these two data structures by comparing the data fields</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CurrentBmc</td><td>is a pointer to a suitable data structure, designed to record the current fields from the current Grand Master's Announce Packet. </td></tr>
    <tr><td class="paramname">AnnounceFrame</td><td>is a pointer to a suitable data structure, designed to record the useful fields from the received Announce Packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An updated True/False decision as to whether there is to be a change of Grand Master in the network.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Priority1 takes precedence over all over priorites</p>
<p>we have found a better master!</p>
<p>convert structs to u32 values for easy comparison</p>
<p>ClockQuality has the next priority</p>
<p>we have found a better master!</p>
<p>Priority2 provides fine grained ordering amongst otherwise equal clocks</p>
<p>we have found a better master!</p>
<p>Next compare the Clock Identities</p>
<p>we have found a better master!</p>
<p>we have found a better master!</p>
<p>Next compare stepsRemoved</p>
<p>we have found a better master!</p>
<p>Next compare SourcePortIdentity</p>
<p>we have found a better master!</p>
<p>we have found a better master!</p>
<p>If all else fails, the SourcePortIdentity Port Number must act as the tie-breaker</p>
<p>A new master has won on the tie-break! </p>

<p>References <a class="el" href="struct_x_avb___clock_quality.html#ad4d7a7873966a1b940f6de4a7f3b5074">XAvb_ClockQuality::clockAccuracy</a>, <a class="el" href="struct_x_avb___clock_quality.html#a4102e4f3919f5ed91b62d45c2545c793">XAvb_ClockQuality::clockClass</a>, <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6119ed21ae13fc8002df3ea89701a710">XAvb_ClockIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6d7f51bcff1917d372465c04a2f36d7b">XAvb_ClockIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___bmc_data.html#a463904e4270ced5a6c437e68fad3b98f">XAvb_BmcData::ClockQuality</a>, <a class="el" href="struct_x_avb___bmc_data.html#aa842c05dfde7a1dccd0a48c906c742d9">XAvb_BmcData::GrandmasterIdentity</a>, <a class="el" href="struct_x_avb___bmc_data.html#a206dca9ffafe9d7fbf0019402127e6dd">XAvb_BmcData::GrandmasterPriority1</a>, <a class="el" href="struct_x_avb___bmc_data.html#ab345aec9e45cac47fddee9e48724c9ef">XAvb_BmcData::GrandmasterPriority2</a>, <a class="el" href="struct_x_avb___clock_quality.html#a8034a2fc43c4dcaadca3577cc7e9a7be">XAvb_ClockQuality::offsetScaledLogVariance</a>, <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae60a5e9cd8c572d2db805650287483f7">XAvb_BmcData::SourcePortIdentity</a>, and <a class="el" href="struct_x_avb___bmc_data.html#aa82e09ae59ed634e54fdcfebe78d10d2">XAvb_BmcData::stepsRemoved</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, and <a class="el" href="xavb__ptp__bmca_8c.html#a4091121232495f00535ca134664b4f7c">XAvb_DecodeTxAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d7814f965d4141992654954f1243679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_CalcDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since we are only using the nanoseconds field here we need to account for wrap. So we add one second to the T4 and T3 terms to ensure that the T4MinusT1 and T3MinusT2 results cannot be negative. These two additional seconds then cancel each other out in the T4MinusT1 - T3MinusT2 equation.</p>
<p>If the nanoseconds count has wrapped, add on 1 second to ensure we get the right answer</p>
<p>If the nanoseconds count has wrapped, add on 1 second to ensure we get the right answer</p>
<p>For now we are simply going to throw out any absurdly large link delays.</p>
<p>The peer has responded to the pDelay_Req and the measured delay is within tolerance: the peer is deemed to be AS capable </p>

<p>References <a class="el" href="struct_x_avb___ptp_struct.html#ac88180ae256193d6ab58d964da0a15b8">XAvb_PtpStruct::LinkDelay</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a3452c4beb43254ece9773c99e03e629f">XAvb_PtpStruct::PDelayTimestampT1</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a031c19b7b7227814202cc7472fc0269a">XAvb_PtpStruct::PDelayTimestampT2</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a3cbb26037696645f50c29addc3f6da46">XAvb_PtpStruct::PDelayTimestampT3</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ad4a5d5d897b354ab5bae245a08459c27">XAvb_PtpStruct::PDelayTimestampT4</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, <a class="el" href="xavb_8h.html#aeee995ca1e92645f113145ca6dbeceda">XAVB_NEIGHBOR_PROP_DELAY_THRESH</a>, and <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ee8dd26b932ff82daa0dc87fd6d38d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_CalcRtcOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2>Capture the Slave Time </h2>
<p>We do this immediately to get the slave time ASAP (since processing time is uncertain and the RTC does not stand still).</p>
<h2>Capture the Master Origin Timestamp (from received FollowUp Frame) </h2>
<p>read the Words from the PTP frame buffer containing the RTC seconds field</p>
<p>Now re-arrange the required data from the Words to obtain the required seconds field timestamp in binary format</p>
<h2>Correct the Nanoseconds </h2>
<p>NOTE: we are trying to compare the value of the slave RTC nano- seconds field timestamp with the nano-seconds value of the Masters RTC nanosecond field at exactly that time.</p>
<p>Sync Frame routing delay is equal to the value of the correction field (sum of correction fields in Sync and FollowUp frames) plus the link delay measurement made by this slave.</p>
<p>MasterNsCorrected time here is the calculated time that the master will be at the point in time when the sync frame is received (and timestamped) at the slave. This is calculated from the originTimeStamp (from the FollowUpframe), plus the Sync Frame routing delay. A direct comparison can then be made between master and slave.</p>
<p>Check for ns wrap-around condition</p>
<p>Make the Master and Slave comparison and discover the difference!</p>
<p>Check for ns wrap-around condition</p>
<p>Return these comparison figures in the form of a pointer (RTC increment rate adjust function also needs to know this information)</p>
<p>Adjust the 8k clock logic (if necessary)</p>
<h2>Correct the Seconds and Epoch </h2>
<p>NOTE: we are trying to compare the value of the slave RTC seconds field at the exact time when the timestamp was taken with the RTC seconds value of the Master at that time.</p>
<p>We need to know the value of the slaves synchronised nano-seconds field at the time when the timestamp was taken (since timestamps use the syntonised time). So we add the current nanosecond field offset value:</p>
<p>Check for ns wrap-around condition</p>
<p>Even though we read the slave RTC value at the beginning of this function, there would have been processing delay between the actual reception (and timestamping) of the FollowUp frame and the start of this function. During this time, the slave RTC seconds field could have wrapped around. We need to detect this and if it has done, the slave seconds field would also have incremented (so it needs to be set back).</p>
<p>slave_nanosec has wrapped since timestamp so decrement the seconds field</p>
<p>If the Master nano seconds field wrapped during the Sync frame routing delay, then we need to increment the seconds field.</p>
<p>Calculate the slave RTC error: the master time minus the timestamp taken by this slave for Sync Frame reception.</p>
<h2>Write the results to the RTC Offset registers </h2>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ac88180ae256193d6ab58d964da0a15b8">XAvb_PtpStruct::LinkDelay</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a9ccce78c48aeb38e81ccfe20f4fcbf14">XAvb_PtpStruct::MasterCorrectionField</a>, <a class="el" href="struct_x_avb___rtc_format.html#ad30a5df1748ad71907d830893f23cbba">XAvb_RtcFormat::NanoSeconds</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a05590438022ee2dff39492654cfe3285">XAvb_PtpStruct::NewMasterTime</a>, <a class="el" href="struct_x_avb___ptp_struct.html#aecd30621bf3e8988ea4bebf59ab4d031">XAvb_PtpStruct::NewSlaveTime</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___rtc_format.html#a5015cb1ee0a5eb14ef15e03225450a81">XAvb_RtcFormat::SecondsLower</a>, <a class="el" href="struct_x_avb___rtc_format.html#a84452962f60d5528bbb9da1df3c1bf7d">XAvb_RtcFormat::SecondsUpper</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ad6c2a017ae8f7df3d77654ffbb8a9955">XAvb_PtpStruct::SlaveSyncTimestamp</a>, <a class="el" href="xavb_8h.html#a2a46d84127016dacb2823b953acbfd20">XAvb_Adjust8kClock()</a>, <a class="el" href="xavb_8h.html#a3ce07f766a1033fab5a1981e947db52e">XAvb_CaptureNanoSec()</a>, <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8c.html#adbb46fbeb6b3bb40e8067ea6f8a0776c">XAvb_ReadRtc()</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#a17b4489a857a0fcb761a529b749d5ad3">XAVB_RTC_NANOSEC_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#aa71292011b875c192d09141638c3a4e1">XAVB_RTC_SEC_LOWER_VALUE_OFFSET</a>, and <a class="el" href="xavb__hw_8c.html#a07f6e740f5623df870beea331507baf3">XAvb_WriteRtcOffset()</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce07f766a1033fab5a1981e947db52e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_CaptureNanoSec </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The timestamp is located over several 32-bit Words of the PTP frame buffer Read the relevant Words containing the ns timestamp:</p>
<p>Now re-arrange the data from the Words to obtain the required ns Timestamp in binrary format </p>

<p>References <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a5ee8dd26b932ff82daa0dc87fd6d38d8">XAvb_CalcRtcOffset()</a>, <a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>.</p>

</div>
</div>
<a class="anchor" id="af8ddc8d42f610c49547f6cf4778629d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XStatus XAvb_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___config.html">XAvb_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EffectiveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to initialise variables in the data structure records. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">ConfigPtr</td><td>is the Configuration Pointer </td></tr>
    <tr><td class="paramname">EffectiveAddress</td><td>is the base address of the Configuration Pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_NOT_FOUND if device configuration information was not found for a device with the supplied device ID.* </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>The component is not yet ready to use</p>
<p>Clear instance memory</p>
<p>Lookup the device configuration in the temporary CROM table. Use this configuration info down below when initializing this component.</p>
<p>Populate Base Address field using the base address value in the configuration structure.</p>
<p>Indicate the component is now ready to use.</p>
<p>Set the callback handler to a stub</p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb.html#adaa9fca5f2df9e76794cb97f8bd1f307">XAvb::GMDiscHandler</a>, and <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a004f6ae823f2e50f4dd2fac409953537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_ChangePeerASCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>capable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operations needed when the peer's AS capability changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">capable</td><td>is 1 if the peer is ASCapable, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb.html#a8311fd4524732cca626191f25591bfba">XAvb::PeerASCapable</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a6d7814f965d4141992654954f1243679">XAvb_CalcDelay()</a>, <a class="el" href="xavb__ptp__bmca_8c.html#a07f69b843cd86ca6149c838c478c4e01">XAvb_ChangePTPLockStatus()</a>, <a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>, <a class="el" href="xavb_8h.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset()</a>, and <a class="el" href="xavb_8h.html#a8657704dc9974d465536615ebbeb79d9">XAvb_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="a07f69b843cd86ca6149c838c478c4e01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_ChangePTPLockStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operations needed when PTP locks or unlocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">locked</td><td>is 1 if changing to locked status, zero if unlocked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>set status variable</p>
<p>set timestamp uncertainty if necessary </p>

<p>References <a class="el" href="struct_x_avb.html#a6f2483d14031dc855c8cf27c796c122e">XAvb::GMDiscCallBackRef</a>, <a class="el" href="struct_x_avb.html#adaa9fca5f2df9e76794cb97f8bd1f307">XAvb::GMDiscHandler</a>, <a class="el" href="struct_x_avb.html#a9ae7367366022ccb6d467da689de8e09">XAvb::PTPLocked</a>, and <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#ada9dd75eb576b0e600686514fbea45e3">XAvb_UpdateRtcIncrement()</a>.</p>

</div>
</div>
<a class="anchor" id="aa03b2f45590d8dabe5ad0eb39430e044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_CompareClockIdentity </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a>&#160;</td>
          <td class="paramname"><em>Identity1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___clock_identity.html">XAvb_ClockIdentity</a>&#160;</td>
          <td class="paramname"><em>Identity2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to compare two ClockIdentity values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">Identity1</td><td>is the first ClockIdentity to be compared </td></tr>
    <tr><td class="paramname">Identity2</td><td>is the second ClockIdentity to be compared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the two values are equal, 0 if not equal</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>values are equal </p>

<p>References <a class="el" href="struct_x_avb___clock_identity.html#a6119ed21ae13fc8002df3ea89701a710">XAvb_ClockIdentity::ClockIdentityLower</a>, and <a class="el" href="struct_x_avb___clock_identity.html#a6d7f51bcff1917d372465c04a2f36d7b">XAvb_ClockIdentity::ClockIdentityUpper</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="a8231a4001187aaff164037da857cb333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_ComparePortIdentity </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a>&#160;</td>
          <td class="paramname"><em>Identity1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a>&#160;</td>
          <td class="paramname"><em>Identity2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to compare two PortIdentity values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">Identity1</td><td>is the first sourcePortIdentity to be compared </td></tr>
    <tr><td class="paramname">Identity2</td><td>is the second sourcePortIdentity to be compared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the two values are equal, 0 if not equal</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>values are equal </p>

<p>References <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, and <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c1539b744b6e5b9c9da652820948241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char XAvb_ConvertDurationToLogMean </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>fractionalVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to convert a fraction of 128 value that is compatible with Signalling data into a logMean (power of 2) value;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fractionalVal</td><td>is the Signalling data value that is to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fractionalVal represented as logMean (power of 2) value</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>just in case fractionalVal is not a power of 2, we'll only look at the most significant bit Count how many shifts it takes for most significant set bit to be in the highest (16th) bit location</p>
<p>logMeanVal = 0 = 2^0 = 128/128 would give us a numShifts result of 8, so 8 will be our base</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#a9c3933020b616a2a57b6229bce6f6151">XAvb_UpdateLogMeanMessageInterval()</a>.</p>

</div>
</div>
<a class="anchor" id="afa725e8ddb08a833d10e8554067ac361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XAvb_ConvertLogMeanToDuration </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>logMeanVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to convert a logMean (power of 2) value into a fraction of 128 that is compatible with Signalling data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logMeanVal</td><td>is the base2 value that is to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>logMeanVal represented as a fraction of 128</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>, <a class="el" href="xavb_8h.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a5d81de9521bde263313b2de412f45fe2">XAvb_UpdateIntervalDuration()</a>.</p>

</div>
</div>
<a class="anchor" id="a5eaf575de699cb2f054a43daa8a93849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxAnnounceFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A New Announce Packet has been received. </p>
<p>We need to decode it and rerun the Best Master Clock Algorithm (BMCA)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But an updated True/False decision as to whether this device should operate as a clock master or a slave is written into the CurrentBmc data structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read the attributes for the new Announce frame received</p>
<p>If the received packet's clockIdentity matches our clockIdentity, ignore the packet</p>
<p>If the received packet's stepsRemoved field is &gt;= 255, ignore the packet</p>
<p>If the Announce packet's GMID matches that of our current GM record, then update its records based on the current packet, just in case something (such as priority) has changed.</p>
<p>update timeout information</p>
<p>Compare against this device's information to see if we should be GM</p>
<p>run BMCA on this announce to see if it is better than me</p>
<p>Update records with the NEW best master</p>
<p>Capture the Announce Receipt Timeout Interval. Reset the announce receipt timeout interval to use the new value.</p>
<p>New Rx Announce Packet has won - so this device cannot be a master </p>

<p>References <a class="el" href="struct_x_avb___bmc_data.html#af3bcc274ccdd364fe5983d586b5cff62">XAvb_BmcData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb___clock_quality.html#a4102e4f3919f5ed91b62d45c2545c793">XAvb_ClockQuality::clockClass</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6119ed21ae13fc8002df3ea89701a710">XAvb_ClockIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6d7f51bcff1917d372465c04a2f36d7b">XAvb_ClockIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___bmc_data.html#a463904e4270ced5a6c437e68fad3b98f">XAvb_BmcData::ClockQuality</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#af9de244165a5492b2ee9b90a625a7922">XAvb_Counters::CounterAnnounceInterval</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb___bmc_data.html#aa842c05dfde7a1dccd0a48c906c742d9">XAvb_BmcData::GrandmasterIdentity</a>, <a class="el" href="struct_x_avb___bmc_data.html#a206dca9ffafe9d7fbf0019402127e6dd">XAvb_BmcData::GrandmasterPriority1</a>, <a class="el" href="struct_x_avb___bmc_data.html#ab345aec9e45cac47fddee9e48724c9ef">XAvb_BmcData::GrandmasterPriority2</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae1a43181c99b74fbac809dc9b833509e">XAvb_BmcData::logMessageInterval</a>, <a class="el" href="struct_x_avb.html#afa0f0b3779f43a549fc63b1c9d6e9f23">XAvb::portIdLocal</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae60a5e9cd8c572d2db805650287483f7">XAvb_BmcData::SourcePortIdentity</a>, <a class="el" href="struct_x_avb___bmc_data.html#aa82e09ae59ed634e54fdcfebe78d10d2">XAvb_BmcData::stepsRemoved</a>, <a class="el" href="xavb_8h.html#a52eb3269ef7daea39a316315d903c43c">XAvb_BecomeRtcSlave()</a>, <a class="el" href="xavb_8h.html#ae38ec83a381d57348fdbaf065c2190eb">XAvb_BestMasterClockAlgorithm()</a>, <a class="el" href="xavb_8h.html#aa03b2f45590d8dabe5ad0eb39430e044">XAvb_CompareClockIdentity()</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration()</a>, <a class="el" href="xavb_8h.html#a4091121232495f00535ca134664b4f7c">XAvb_DecodeTxAnnounceFrame()</a>, <a class="el" href="xavb_8h.html#a7c77fd7953811584a36001e5e74165b3">XAvb_ReadAnnounceFrame()</a>, <a class="el" href="xavb_8h.html#aa66e9752ef47bf7eafe4784cb59e1093">XAvb_ReadAnnounceReceiptTimeout()</a>, and <a class="el" href="xavb_8h.html#a2234b9dec3b039479123f49ee573a14e">XAvb_UpdateBmcRecords()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="afb8650c4c94082dc746db9ec0259e1cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxFollowUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received PTP Follow-up Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read sourcePortIdentity from packet</p>
<p>Only decode if configured for a slave and if SA is that of the RTC Clock Master</p>
<p>Capture the Follow Up SequenceID</p>
<p>SequenceID in Follow Up Frame should always match that of the Sync Frame</p>
<p>Capture the correction field from follow up frame</p>
<p>Perform the Course RTC Offset correction for every Sync / FollowUp pair</p>
<p>Every n Sync / FollowUp pairs, we are going to calculate a corrected increment rate of RTC</p>
<p>Reset the CounterSyncEvents Counter</p>
<p>Capture the Sequence ID of the Follow Up frame</p>
<p>Perform the RTC increment rate adjustment calculation</p>
<p>Sample Sync Frame Time sent (as estimated by the slave) for comparison in ten more repetition's time</p>
<p>Sample Sync Frame Time sent (as calculated by the master) for comparison in ten more repetition's time</p>
<p>Sample the current Follow Up Sequence ID for comparison in ten more repetition's time </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#a9228c57c4b090294bf8f034f94fbba06">XAvb_Counters::CounterSyncEvents</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a518f0eba3028ced57a8b6824df25692a">XAvb_SequenceIdStruct::FollowUpSequenceId</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a9ccce78c48aeb38e81ccfe20f4fcbf14">XAvb_PtpStruct::MasterCorrectionField</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a05590438022ee2dff39492654cfe3285">XAvb_PtpStruct::NewMasterTime</a>, <a class="el" href="struct_x_avb___ptp_struct.html#aecd30621bf3e8988ea4bebf59ab4d031">XAvb_PtpStruct::NewSlaveTime</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a689e9f68ca62fd5f25c4ba60be3419cc">XAvb_SequenceIdStruct::NewSyncSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a92f212eedbc5375293d822d97a56b11a">XAvb_PtpStruct::OldMasterTime</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a5f843941b210edca7edb0824ba342652">XAvb_PtpStruct::OldSlaveTime</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a6905c062e37474a276a80955ebe565b5">XAvb_SequenceIdStruct::OldSyncSequenceId</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae60a5e9cd8c572d2db805650287483f7">XAvb_BmcData::SourcePortIdentity</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a6128e3e436ca3a95f1735d4c49498b5a">XAvb_SequenceIdStruct::SyncSequenceId</a>, <a class="el" href="xavb_8h.html#a5ee8dd26b932ff82daa0dc87fd6d38d8">XAvb_CalcRtcOffset()</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, and <a class="el" href="xavb_8h.html#ada9dd75eb576b0e600686514fbea45e3">XAvb_UpdateRtcIncrement()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="acc5beb09f67f655b7eb8eb51b3cd2d8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxPDelayResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received PDelayResp Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Have we already seen a PDelayResp since the last PDelayReq was sent? If so, ignore the packet</p>
<p>Find the ClockIdentity of the Sender</p>
<p>Is the PDelayResp message from ourself? If so, the Peer is most likely a dumb hub and should be considered not ASCapable</p>
<p>Capture the requestingPortIdentity</p>
<p>Capture the PDelayResp SequenceID</p>
<p>Verify that the requestingPortIdentity matches our portIdentity</p>
<p>Only process if the received frame's sequenceId matches the sequenceId sent in the last pDelay_Req packet</p>
<p>Mark this as a valid PDelayResp packet</p>
<p>Capture timestamp for receipt time of PDelayReq at Master (t2)</p>
<p>Capture timestamp for receipt time of PDelayResp at Slave (t4) and adjust it for MAC receive latency </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a7dbe45bce7442efd949b26ec1e3e491a">XAvb_SequenceIdStruct::PDelayReqSequenceId</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a1cac4a458112f001f588b916a08582ae">XAvb_SequenceIdStruct::PDelayRespSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a031c19b7b7227814202cc7472fc0269a">XAvb_PtpStruct::PDelayTimestampT2</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ad4a5d5d897b354ab5bae245a08459c27">XAvb_PtpStruct::PDelayTimestampT4</a>, <a class="el" href="struct_x_avb.html#afa0f0b3779f43a549fc63b1c9d6e9f23">XAvb::portIdLocal</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad668575ffd6c4bbdc6b4c683137ba893">XAvb_StateMachineData::rcvdPDelayResp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#afd7c69f91db48d400d0e218eb41d4c21">XAvb_StateMachineData::respPortIdentity</a>, <a class="el" href="struct_x_avb___state_machine_data.html#a7e7ed5f180f67ac237f156753aa0e059">XAvb_StateMachineData::respReqPortIdentity</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="struct_x_avb.html#a779ce95ec439713b953c0fbf89cd818e">XAvb::StateMachineData</a>, <a class="el" href="xavb_8h.html#a3ce07f766a1033fab5a1981e947db52e">XAvb_CaptureNanoSec()</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="afd53beaf90143fc360dc6276ba1c49f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxPDelayRespFollowUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received PDelayRespFollowUp Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Has a valid PDelayResp packet been received since the last PDelayReq packet was sent?</p>
<p>Capture the PDelayRespFollowUp SequenceID</p>
<p>Get the sourcePortIdentity of the sender</p>
<p>The sourcePortIdentity of the PDelayRespFollowUp should match that of the last PDelayResp packet received</p>
<p>Get the requestingPortIdentity of the sender</p>
<p>The requestingPortIdentity of the PDelayRespFollowUp should match that of the last PDelayResp packet received</p>
<p>SequenceID of PDelayRespFollowUp Frame should always match that of the PDelayResp Frame and the original PDelayReq Frame.</p>
<p>Mark this as a valid PDelayRespFollowUp packet</p>
<p>Capture the timestamp for transmit time of PDelayResp at Master (t3)</p>
<p>Now we know t1, t2, t3 and t4, calculate the link delay </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#ad3a2d748388270eebdc20ae8d419f4d9">XAvb_SequenceIdStruct::PDelayFollowUpSequenceId</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a1cac4a458112f001f588b916a08582ae">XAvb_SequenceIdStruct::PDelayRespSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a3cbb26037696645f50c29addc3f6da46">XAvb_PtpStruct::PDelayTimestampT3</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad668575ffd6c4bbdc6b4c683137ba893">XAvb_StateMachineData::rcvdPDelayResp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#aef3a1d747515c6c5af274ac32281d1ee">XAvb_StateMachineData::rcvdPDelayRespFollowUp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#afd7c69f91db48d400d0e218eb41d4c21">XAvb_StateMachineData::respPortIdentity</a>, <a class="el" href="struct_x_avb___state_machine_data.html#a7e7ed5f180f67ac237f156753aa0e059">XAvb_StateMachineData::respReqPortIdentity</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="struct_x_avb.html#a779ce95ec439713b953c0fbf89cd818e">XAvb::StateMachineData</a>, <a class="el" href="xavb_8h.html#a6d7814f965d4141992654954f1243679">XAvb_CalcDelay()</a>, <a class="el" href="xavb_8h.html#a3ce07f766a1033fab5a1981e947db52e">XAvb_CaptureNanoSec()</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9afff73e01faafdc8ce9f8e0ee8d4de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxSignaling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received Signalling Packet and modify the TX PTP Buffers based on the requested values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Signaling Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read the requested logMeanMessage durations from the Signalling frame</p>
<p>update linkDelayInterval</p>
<p>don't change the interval</p>
<p>currently only support the default value</p>
<p>set the interval to initial value</p>
<p>Update logMeanMessageInterval in the pre-loaded TX PDELAYREQ message buffer</p>
<p>stop sending pDelay messages</p>
<p>update timeSyncInterval</p>
<p>don't change the interval</p>
<p>set the interval to initial value</p>
<p>Update logMeanMessageInterval in the pre-loaded TX SYNC message buffer</p>
<p>Update logMeanMessageInterval in the pre-loaded TX FOLLOW_UP message buffer</p>
<p>stop sending sync messages</p>
<p>update announceInterval</p>
<p>don't change the interval</p>
<p>set the interval to initial value</p>
<p>Update logMeanMessageInterval in the pre-loaded TX ANNOUNCE message buffer</p>
<p>stop sending Announce messages </p>

<p>References <a class="el" href="struct_x_avb___signalling_frame_data.html#ac149d8b00d1c397cf52784a7213bd5b6">XAvb_SignallingFrameData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a32e2ddf2ae1a19a457c9bd64516796e1">XAvb_SignallingFrameData::LinkDelayIntervalDuration</a>, <a class="el" href="struct_x_avb.html#a0594bd4664c37ed685bb007113e8e2b6">XAvb::SignallingFrameData</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a59ba334a92e4849faf31579ef5221b77">XAvb_SignallingFrameData::SyncIntervalDuration</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb_8h.html#a5d81de9521bde263313b2de412f45fe2">XAvb_UpdateIntervalDuration()</a>, and <a class="el" href="xavb_8h.html#a9c3933020b616a2a57b6229bce6f6151">XAvb_UpdateLogMeanMessageInterval()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ed6d94f92c94a88dce9444e8a27fe8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeRxSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to decode a received PTP Sync Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read sourcePortIdentity from packet</p>
<p>Only decode if configured for a slave and if SourcePortID is that of the RTC Clock Master</p>
<p>Reset Sync Interval Counter as we have received a valid Sync</p>
<p>Capture the local Timestamp for receipt of this frame and adjust it for MAC receive latency</p>
<p>Capture the Sync SequenceID</p>
<p>Capture the logMeanMessageInterval and convert into a useful duration (NOTE: there is an implicit conversion from u32 to char here)</p>
<p>We don't need to capture the correction field - unless we want to check that it is 0. </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#a33a32af6ca968fac37957cbe9435f1db">XAvb_Counters::CounterSyncInterval</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="struct_x_avb.html#a42340ba979c53633a3cf53628c7eaec9">XAvb::latestMDSyncReceive</a>, <a class="el" href="struct_x_avb___m_d_sync_receive.html#a2216e32e52d75fbd0fce66973bfb0d0f">XAvb_MDSyncReceive::logMessageInterval</a>, <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ad6c2a017ae8f7df3d77654ffbb8a9955">XAvb_PtpStruct::SlaveSyncTimestamp</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae60a5e9cd8c572d2db805650287483f7">XAvb_BmcData::SourcePortIdentity</a>, <a class="el" href="struct_x_avb___m_d_sync_receive.html#a944032b9d928ba8760663d512d56432f">XAvb_MDSyncReceive::SyncIntervalDuration</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a6128e3e436ca3a95f1735d4c49498b5a">XAvb_SequenceIdStruct::SyncSequenceId</a>, <a class="el" href="xavb_8h.html#a8231a4001187aaff164037da857cb333">XAvb_ComparePortIdentity()</a>, <a class="el" href="xavb_8h.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration()</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a4091121232495f00535ca134664b4f7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_DecodeTxAnnounceFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A New Announce Packet has been written to this device to transmit. </p>
<p>We need to decode it and rerun the Best Master Clock Algorithm (BMCA)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But an updated True/False decision as to whether this device should operate as a clock master or a slave is written into the CurrentBmc data structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read the attributes for the new Announce frame in the Tx PTP buffer</p>
<p>Compare the clock attributes between then new Announce frame and the current master</p>
<p>Update records with the NEW best master</p>
<p>Our new Tx Announce Packet has won - so this device must be the master </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb___clock_quality.html#a4102e4f3919f5ed91b62d45c2545c793">XAvb_ClockQuality::clockClass</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6119ed21ae13fc8002df3ea89701a710">XAvb_ClockIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6d7f51bcff1917d372465c04a2f36d7b">XAvb_ClockIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___bmc_data.html#a463904e4270ced5a6c437e68fad3b98f">XAvb_BmcData::ClockQuality</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb___bmc_data.html#aa842c05dfde7a1dccd0a48c906c742d9">XAvb_BmcData::GrandmasterIdentity</a>, <a class="el" href="struct_x_avb___bmc_data.html#a206dca9ffafe9d7fbf0019402127e6dd">XAvb_BmcData::GrandmasterPriority1</a>, <a class="el" href="struct_x_avb___bmc_data.html#ab345aec9e45cac47fddee9e48724c9ef">XAvb_BmcData::GrandmasterPriority2</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="xavb_8h.html#a5ef1c55c51f5781c4395ff20cc07f410">XAvb_BecomeRtcMaster()</a>, <a class="el" href="xavb_8h.html#ae38ec83a381d57348fdbaf065c2190eb">XAvb_BestMasterClockAlgorithm()</a>, <a class="el" href="xavb_8h.html#a7c77fd7953811584a36001e5e74165b3">XAvb_ReadAnnounceFrame()</a>, and <a class="el" href="xavb_8h.html#a2234b9dec3b039479123f49ee573a14e">XAvb_UpdateBmcRecords()</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, and <a class="el" href="xavb_8h.html#a8657704dc9974d465536615ebbeb79d9">XAvb_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f2030902e6748712f30a59a62dff010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_GetPortIdentity </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PortIdOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a> *&#160;</td>
          <td class="paramname"><em>portID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to extract portIdentity information from a received PTP frame. </p>
<p>This can be any portIdentity field (header portIdentity, requestingPortIdentity, etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer </td></tr>
    <tr><td class="paramname">PortIdOffset</td><td>is the packet offset of the first byte of the portIdentity field to be parsed </td></tr>
    <tr><td class="paramname">portID</td><td>is the <a class="el" href="struct_x_avb___port_identity.html" title="This typedef defines the format for a data structure which stores the Port Identity information from ...">XAvb_PortIdentity</a> struct that the data will be written to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None, but portID will be updated with the portIdentity information</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>, and <a class="el" href="xavb__ptp__bmca_8c.html#a7c77fd7953811584a36001e5e74165b3">XAvb_ReadAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="a454f4f2c09586f6e787232cb0ae250c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_IncSequenceId </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to increment the sequenceId in a PTP frame template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddress</td><td>is the base address of the TX PTP Buffer whose SequenceID is to be incremented</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant TX PTP Packet Buffer is written to with the updated SequenceID</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Read the 32-bit BufferWord containing the SequenceId from the PTP buffer</p>
<p>Swap byte order into correct binary and increment the SequenceId</p>
<p>Swap back the byte order into frame storage order</p>
<p>Write the 32-bit BufferWord variable containing the updated SequenceId </p>

<p>References <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, and <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#aeeaf9984303a07b8935d4a391f0ca188">XAvb_MasterSendAnnounce()</a>, <a class="el" href="xavb__ptp__packets_8c.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq()</a>.</p>

</div>
</div>
<a class="anchor" id="aaefe66ad0ca9e6af05129765cca4c3df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_IsRxFramePTP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to check that various fields in the received frame contain the expected values which define it as a valid AVB PTP frame. </p>
<p>If this check does not pass then the frame should not be decoded and used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An updated True/False decision as to whether this received frame really is a valid PTP type.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Start by assuming that it is a valid PTP frame</p>
<p>Perform a 32-bit read from the relevant position in the frame</p>
<p>Check the Length/Type field for a valid Ethertype</p>
<p>Check the versionPTP </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="aeeaf9984303a07b8935d4a391f0ca188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_MasterSendAnnounce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP Announce Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<p>Increment the sequenceId</p>
<p>Send the Announce Frame! </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb_8h.html#a454f4f2c09586f6e787232cb0ae250c2">XAvb_IncSequenceId()</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#a59f550eaa57148613974c4aa5628bfb4">XAVB_RTC_NANOSEC_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#aa71292011b875c192d09141638c3a4e1">XAVB_RTC_SEC_LOWER_VALUE_OFFSET</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a989d44c98695fd6f286858f8b7976e3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_MasterSendFollowUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP Follow-Up Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<p>Read the current RTC offset</p>
<p>Read the Timestamp and adjust it for the MAC transmit latency</p>
<p>Adjust the Timestamp with current RTC ns offset</p>
<p>Calculate the Correction Field</p>
<p>Format the Correction Field into correct byte positioning for PTP frame storage in the buffer</p>
<p>Write the Correction Field to the Follow Up frame</p>
<p>Send the Follow Up Frame! </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a0fec4235a69761ed87eb29790cd8a7d2">XAvb_PtpStruct::Nanosec</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#a17b4489a857a0fcb761a529b749d5ad3">XAVB_RTC_NANOSEC_OFFSET</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ae239544f086bc86572b8e2d7e408a028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_MasterSendSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP Sync Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<p>Increment the sequenceId in the Sync frame</p>
<p>Read the current RTC Offset values</p>
<p>Send the Sync Frame!</p>
<h2>Now some pre-work on the Follow-Up Frame </h2>
<p>Write the same sequenceId to the Follow-up frame</p>
<p>Format the Timestamp (RTC) into correct byte positioning. Note: this is how the Timestamp is stored in the PTP frame itself (transmitted MSB of Epoch first):</p>
<p>|----------&mdash;&mdash;|----------&mdash;&mdash;|----------&mdash;&mdash;|----------&mdash;&mdash;| </p>
<table class="doxtable">
<tr>
<th>seconds[23:16] </th><th>seconds[31:24] </th><th>epoch[7:0] </th><th>epoch[15:8]  </th></tr>
<tr>
<td>nanosec[23:16] </td><td>nanosec[31:24] </td><td>seconds[7:0] </td><td>seconds[15:8] </td></tr>
<tr>
<td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash; </td></tr>
<tr>
<td>0's </td><td>0's </td><td>nanosec[7:0] </td><td>nanosec[15:8] </td></tr>
<tr>
<td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash;</td><td>----------&mdash;&mdash; </td></tr>
</table>
<p>Write the Timestamp (RTC) to the Follow-up frame </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a0fec4235a69761ed87eb29790cd8a7d2">XAvb_PtpStruct::Nanosec</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="xavb_8h.html#a454f4f2c09586f6e787232cb0ae250c2">XAvb_IncSequenceId()</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#a59f550eaa57148613974c4aa5628bfb4">XAVB_RTC_NANOSEC_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#aa71292011b875c192d09141638c3a4e1">XAVB_RTC_SEC_LOWER_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#ae38e8307c8da64ba9f42516168855a8f">XAVB_RTC_SEC_UPPER_VALUE_OFFSET</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a99019d3795040dd7110d47aaa598ab7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_PtpRxInterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Interrupt subroutine for the "interrupt_ptp_rx" signal. </p>
<p>This interrupt fires whenever a PTP frame has been received. The main function is to identify, decode, and act on the type of PTP frame received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>RxPtpHardPointer indicates the bin location of the last frame to be received and written into the Rx PTP buffer in hardware. This read will also clear the interrupt.</p>
<p>If PTP functions are marked as not running, then take no further action</p>
<p>RxPtpSoftPointer indicates the bin location of the last frame to be processed in software.</p>
<p>decode the rx'd frames until RxPtpHardPointer = RxPtpSoftPointer</p>
<p>Set the base address of the current PTP frame in the Buffer</p>
<p>Perform very basic sanity checking of the frame : is it a PTP?</p>
<p>Determine which PTP frame was received.</p>
<p>Now act on the received frame</p>
<h2>Sync Frame </h2>
<h2>Follow Up Frame </h2>
<h2>PDelayReq Frame </h2>
<p>Send a send PDelayResp frame after receiving a PDelayReq Frame</p>
<p>Send a send PDelayRespFollowUp frame after a PDelayResp Frame</p>
<h2>PDelayResp Frame </h2>
<h2>PDelayRespFollowUp Frame </h2>
<h2>Announce Frame </h2>
<h2>Signaling Frame </h2>
<h2>Unknown Frame </h2>
<p>PTP is not running so just consume the packets so they are not left in the queue and cause problems when we actually start</p>
<p>RxPtpSoftPointer indicates the bin location of the last frame to be processed in software.</p>
<p>decode the rx'd frames until RxPtpHardPointer = RxPtpSoftPointer </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a194197130a475d3183dc70f1319d73dc">XAvb::PtpIsRunning</a>, <a class="el" href="struct_x_avb___counters.html#a736ce9a6afef4a9305cdd6e2e2ba28dc">XAvb_Counters::RxPtpHardPointer</a>, <a class="el" href="struct_x_avb___counters.html#a4efdfe9a00248e2adfae1c7015d1a5fa">XAvb_Counters::RxPtpSoftPointer</a>, <a class="el" href="xavb_8h.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, <a class="el" href="xavb_8h.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>, <a class="el" href="xavb_8h.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb_8h.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>, <a class="el" href="xavb_8h.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling()</a>, <a class="el" href="xavb_8h.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>, <a class="el" href="xavb_8h.html#aaefe66ad0ca9e6af05129765cca4c3df">XAvb_IsRxFramePTP()</a>, <a class="el" href="xavb__hw_8h.html#ad0d33dc36a4a6b1f046d7ad862775922">XAVB_PTP_RX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb_8h.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp()</a>, and <a class="el" href="xavb_8h.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp()</a>.</p>

</div>
</div>
<a class="anchor" id="aab96c1602bda46380e25d0bb03a8ac01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_PtpTimerInterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Interrupt subroutine for the "interruptPtpTimer" signal. </p>
<p>This interrupt fires reguarly on a 1/128 second period (based on the RTC).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Clear Interrupt</p>
<p>If PTP functions are marked as not running, then take no further action</p>
<p>If the Link Partner is not AS capable, then take no further action</p>
<p>If a Master, then initiate Sync Frames and Announce frames at the correct intervals</p>
<p>Master will initiate a Sync Frame when the SyncIntervalDuration expires (SyncIntervalDuration is used to count/time the duration)</p>
<ul>
<li>unless a Signalling frame has told us not to send Sync Frames</li>
</ul>
<p>Following a Sync Frame, a Follow Up frame should always be sent</p>
<p>Master will initiate an Announce Frame when the AnnounceIntervalDuration expires (CounterAnnounceInterval is used to count/time the duration)</p>
<ul>
<li>unless a Signalling frame has told us not to send Announce Frames</li>
</ul>
<p>If a Slave, monitor Announce/Sync Packet reception from the Master</p>
<p>Timeout for Announce Packet reception: XAVB_ANNOUNCE_RECEIPT_TIMEOUT The AnnounceIntervalDuration is stored with the GrandMaster BMCA data as it is captured from the last Announce frame that was received.</p>
<p>No Announce received from GM for timeout interval: we become the master</p>
<p>Timeout for Sync Packet reception: XAVB_SYNC_RECEIPT_TIMEOUT * The SyncIntervalDuration is stored with the Received Sync data as it is captured from the last Sync frame that was received.</p>
<p>No Syncs received from GM for timeout interval: we become the master</p>
<p>Both Master and Slave will initiate a link delay measurement when the LinkDelayIntervalDuration expires (LinkDelayIntervalDuration is used to count/time the duration)</p>
<ul>
<li>unless a Signalling frame has told us not to send PdelayReq Frames</li>
</ul>
<p>Check to see if we've received PDelayResp and PDelayRespFollowUp messages since the last PDelayReq was sent</p>
<p>the peer is no longer ASCapable</p>
<p>avoid potential overflow</p>
<p>end of 'if (InstancePtr-&gt;PtpIsRunning == 1)' </p>

<p>References <a class="el" href="struct_x_avb___bmc_data.html#af3bcc274ccdd364fe5983d586b5cff62">XAvb_BmcData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#ac149d8b00d1c397cf52784a7213bd5b6">XAvb_SignallingFrameData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#af9de244165a5492b2ee9b90a625a7922">XAvb_Counters::CounterAnnounceInterval</a>, <a class="el" href="struct_x_avb___counters.html#a618c3216d8806db71be2a72d24d5d9ac">XAvb_Counters::CounterLinkDelayInterval</a>, <a class="el" href="struct_x_avb___counters.html#a33a32af6ca968fac37957cbe9435f1db">XAvb_Counters::CounterSyncInterval</a>, <a class="el" href="struct_x_avb.html#a81e68bbc2d63aab5e4d6a36bf7039f03">XAvb::CurrentBmc</a>, <a class="el" href="struct_x_avb___bmc_data.html#a7d3619e11c42446854d5438dab27e84a">XAvb_BmcData::IAmTheRtcMaster</a>, <a class="el" href="struct_x_avb.html#a42340ba979c53633a3cf53628c7eaec9">XAvb::latestMDSyncReceive</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a32e2ddf2ae1a19a457c9bd64516796e1">XAvb_SignallingFrameData::LinkDelayIntervalDuration</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad6a63a3cd991e1b350b8622921b88089">XAvb_StateMachineData::lostResponses</a>, <a class="el" href="struct_x_avb.html#a8311fd4524732cca626191f25591bfba">XAvb::PeerASCapable</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a194197130a475d3183dc70f1319d73dc">XAvb::PtpIsRunning</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad668575ffd6c4bbdc6b4c683137ba893">XAvb_StateMachineData::rcvdPDelayResp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#aef3a1d747515c6c5af274ac32281d1ee">XAvb_StateMachineData::rcvdPDelayRespFollowUp</a>, <a class="el" href="struct_x_avb.html#a0594bd4664c37ed685bb007113e8e2b6">XAvb::SignallingFrameData</a>, <a class="el" href="struct_x_avb.html#a779ce95ec439713b953c0fbf89cd818e">XAvb::StateMachineData</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a59ba334a92e4849faf31579ef5221b77">XAvb_SignallingFrameData::SyncIntervalDuration</a>, <a class="el" href="struct_x_avb___m_d_sync_receive.html#a944032b9d928ba8760663d512d56432f">XAvb_MDSyncReceive::SyncIntervalDuration</a>, <a class="el" href="xavb_8h.html#a3182fdfc7befebf2408090b1ab791bcc">XAVB_ALLOWED_LOST_RESPONSES</a>, <a class="el" href="xavb_8h.html#aafbcc1c1bf07dece3f745f8189740672">XAVB_ANNOUNCE_RECEIPT_TIMEOUT</a>, <a class="el" href="xavb_8h.html#a5ef1c55c51f5781c4395ff20cc07f410">XAvb_BecomeRtcMaster()</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, <a class="el" href="xavb_8h.html#aeeaf9984303a07b8935d4a391f0ca188">XAvb_MasterSendAnnounce()</a>, <a class="el" href="xavb_8h.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp()</a>, <a class="el" href="xavb_8h.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync()</a>, <a class="el" href="xavb__hw_8h.html#a2f724f6845f2fc8b62dc841ef36525d5">XAVB_RTC_CLEAR_INT_OFFSET</a>, <a class="el" href="xavb_8h.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq()</a>, <a class="el" href="xavb_8h.html#a15a4a25d453f50c7cdc57b81b91e8aba">XAVB_SYNC_RECEIPT_TIMEOUT</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a7c77fd7953811584a36001e5e74165b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_ReadAnnounceFrame </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *&#160;</td>
          <td class="paramname"><em>AnnounceFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A New Announce Packet is to be analyzed. </p>
<p>This function will read in the packet, decode it, and extract the relevent information fields to the "AnnounceFrame" data pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer </td></tr>
    <tr><td class="paramname">AnnounceFrame</td><td>is a pointer to a suitable data structure, designed to record the useful fields from the received Announce Packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The AnnounceFrame data structure is updated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Get the Source Port Identity of the port sending the Announce Packet</p>
<p>Read priority1 and top half of ClockQuality</p>
<p>Read bottom half of ClockQuality, priority2, and top byte of GMID</p>
<p>Read bytes 4-7 of GMID</p>
<p>Read bytes 1-3 of GMID and high byte of stepsRemoved</p>
<p>Read low byte of stepsRemoved </p>

<p>References <a class="el" href="struct_x_avb___clock_quality.html#ad4d7a7873966a1b940f6de4a7f3b5074">XAvb_ClockQuality::clockAccuracy</a>, <a class="el" href="struct_x_avb___clock_quality.html#a4102e4f3919f5ed91b62d45c2545c793">XAvb_ClockQuality::clockClass</a>, <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6119ed21ae13fc8002df3ea89701a710">XAvb_ClockIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6d7f51bcff1917d372465c04a2f36d7b">XAvb_ClockIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___bmc_data.html#a463904e4270ced5a6c437e68fad3b98f">XAvb_BmcData::ClockQuality</a>, <a class="el" href="struct_x_avb___bmc_data.html#aa842c05dfde7a1dccd0a48c906c742d9">XAvb_BmcData::GrandmasterIdentity</a>, <a class="el" href="struct_x_avb___bmc_data.html#a206dca9ffafe9d7fbf0019402127e6dd">XAvb_BmcData::GrandmasterPriority1</a>, <a class="el" href="struct_x_avb___bmc_data.html#ab345aec9e45cac47fddee9e48724c9ef">XAvb_BmcData::GrandmasterPriority2</a>, <a class="el" href="struct_x_avb___clock_quality.html#a8034a2fc43c4dcaadca3577cc7e9a7be">XAvb_ClockQuality::offsetScaledLogVariance</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae60a5e9cd8c572d2db805650287483f7">XAvb_BmcData::SourcePortIdentity</a>, <a class="el" href="struct_x_avb___bmc_data.html#aa82e09ae59ed634e54fdcfebe78d10d2">XAvb_BmcData::stepsRemoved</a>, <a class="el" href="xavb_8h.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5ef1c55c51f5781c4395ff20cc07f410">XAvb_BecomeRtcMaster()</a>, <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, and <a class="el" href="xavb__ptp__bmca_8c.html#a4091121232495f00535ca134664b4f7c">XAvb_DecodeTxAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="aa66e9752ef47bf7eafe4784cb59e1093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_ReadAnnounceReceiptTimeout </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *&#160;</td>
          <td class="paramname"><em>AnnounceFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the logMessageinteval from an RX PTP Buffer and updates the AnnounceFrame struct with the value read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer </td></tr>
    <tr><td class="paramname">AnnounceFrame</td><td>is a pointer to a suitable data structure, designed to record the useful fields from the received Announce Packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The AnnounceFrame data structure is updated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___bmc_data.html#ae1a43181c99b74fbac809dc9b833509e">XAvb_BmcData::logMessageInterval</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="a664d83b2f34093d6000f3ea2facef449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAvb_ReorderWord </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function switches the bytes in a 4-byte word, swapping the MSB for the LSB, and vice-versa. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Data</td><td>is the 4-byte input data word</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input data word with the bytes swapped (most significant down to least significant</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="xavb_8h.html#a5ee8dd26b932ff82daa0dc87fd6d38d8">XAvb_CalcRtcOffset()</a>, <a class="el" href="xavb_8h.html#a3ce07f766a1033fab5a1981e947db52e">XAvb_CaptureNanoSec()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#acc5beb09f67f655b7eb8eb51b3cd2d8a">XAvb_DecodeRxPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#afd53beaf90143fc360dc6276ba1c49f9">XAvb_DecodeRxPDelayRespFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a3ed6d94f92c94a88dce9444e8a27fe8a">XAvb_DecodeRxSync()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2f2030902e6748712f30a59a62dff010">XAvb_GetPortIdentity()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a99e7a11b4a2960e116891ba88bbb6c84">XAvb_IncSequenceId()</a>, <a class="el" href="xavb__ptp__packets_8c.html#aaefe66ad0ca9e6af05129765cca4c3df">XAvb_IsRxFramePTP()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync()</a>, <a class="el" href="xavb__ptp__bmca_8c.html#a7c77fd7953811584a36001e5e74165b3">XAvb_ReadAnnounceFrame()</a>, <a class="el" href="xavb__ptp__bmca_8c.html#aa66e9752ef47bf7eafe4784cb59e1093">XAvb_ReadAnnounceReceiptTimeout()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a42cd78e966447edcb45a0f419cc84cb8">XAvb_SetupSourcePortIdentity()</a>.</p>

</div>
</div>
<a class="anchor" id="af24c248c31c6c45cdb8a46f82de175c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets all of the AVB device driver functions to the start-up (reset) defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Xavb instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Assert bad arguments and conditions</p>
<p>Perform a Software Reset of the AVB Core. This will reset both the transmitter and receiver paths. The RTC counter is not reset here.</p>
<p>Set IEEE specification default values in the device's data structure</p>
<p>Update logMeanMessageInterval in the pre-loaded TX SYNC message buffer</p>
<p>Update logMeanMessageInterval in the pre-loaded TX FOLLOW_UP message buffer</p>
<p>Update logMeanMessageInterval in the pre-loaded TX PDELAYREQ message buffer</p>
<p>Update logMeanMessageInterval in the pre-loaded TX ANNOUNCE message buffer</p>
<p>Initialise other driver variables in the device's data structure</p>

<p>References <a class="el" href="struct_x_avb___signalling_frame_data.html#ac149d8b00d1c397cf52784a7213bd5b6">XAvb_SignallingFrameData::AnnounceIntervalDuration</a>, <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___counters.html#af9de244165a5492b2ee9b90a625a7922">XAvb_Counters::CounterAnnounceInterval</a>, <a class="el" href="struct_x_avb___counters.html#a618c3216d8806db71be2a72d24d5d9ac">XAvb_Counters::CounterLinkDelayInterval</a>, <a class="el" href="struct_x_avb___counters.html#a9228c57c4b090294bf8f034f94fbba06">XAvb_Counters::CounterSyncEvents</a>, <a class="el" href="struct_x_avb___counters.html#a33a32af6ca968fac37957cbe9435f1db">XAvb_Counters::CounterSyncInterval</a>, <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>, <a class="el" href="struct_x_avb.html#a42340ba979c53633a3cf53628c7eaec9">XAvb::latestMDSyncReceive</a>, <a class="el" href="struct_x_avb___ptp_struct.html#ac88180ae256193d6ab58d964da0a15b8">XAvb_PtpStruct::LinkDelay</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a32e2ddf2ae1a19a457c9bd64516796e1">XAvb_SignallingFrameData::LinkDelayIntervalDuration</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad6a63a3cd991e1b350b8622921b88089">XAvb_StateMachineData::lostResponses</a>, <a class="el" href="struct_x_avb.html#adfddd0be1695d91532dd7dc2ee5614e2">XAvb::PtpCounters</a>, <a class="el" href="struct_x_avb.html#a194197130a475d3183dc70f1319d73dc">XAvb::PtpIsRunning</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___state_machine_data.html#ad668575ffd6c4bbdc6b4c683137ba893">XAvb_StateMachineData::rcvdPDelayResp</a>, <a class="el" href="struct_x_avb___state_machine_data.html#aef3a1d747515c6c5af274ac32281d1ee">XAvb_StateMachineData::rcvdPDelayRespFollowUp</a>, <a class="el" href="struct_x_avb___counters.html#a736ce9a6afef4a9305cdd6e2e2ba28dc">XAvb_Counters::RxPtpHardPointer</a>, <a class="el" href="struct_x_avb___counters.html#a4efdfe9a00248e2adfae1c7015d1a5fa">XAvb_Counters::RxPtpSoftPointer</a>, <a class="el" href="struct_x_avb.html#a0594bd4664c37ed685bb007113e8e2b6">XAvb::SignallingFrameData</a>, <a class="el" href="struct_x_avb.html#a779ce95ec439713b953c0fbf89cd818e">XAvb::StateMachineData</a>, <a class="el" href="struct_x_avb___signalling_frame_data.html#a59ba334a92e4849faf31579ef5221b77">XAvb_SignallingFrameData::SyncIntervalDuration</a>, <a class="el" href="struct_x_avb___m_d_sync_receive.html#a944032b9d928ba8760663d512d56432f">XAvb_MDSyncReceive::SyncIntervalDuration</a>, <a class="el" href="xavb_8h.html#a5ef1c55c51f5781c4395ff20cc07f410">XAvb_BecomeRtcMaster()</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, <a class="el" href="xavb_8h.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration()</a>, <a class="el" href="xavb__hw_8h.html#ae9e3a0562e191d4ea8eb166f5deadef3">XAVB_SW_RESET_OFFSET</a>, <a class="el" href="xavb_8h.html#a9c3933020b616a2a57b6229bce6f6151">XAvb_UpdateLogMeanMessageInterval()</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="xavb_8h.html#a5a5d4a65b18da8805b9a6bf464961f25">XAvb_Stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e3f462007beb73497bbded566d7f364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SendPDelayReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP PDelay Request Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<p>Increment the SequenceId</p>
<p>Send the PDelayReq Frame!</p>
<p>Wait for the frame to be transmitted</p>
<p>Capture the Timestamp for Tx of PDelayReq (t1) and adjust it for MAC transmit latency</p>
<p>Capture the SequenceID of the the PDelayReq </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a7dbe45bce7442efd949b26ec1e3e491a">XAvb_SequenceIdStruct::PDelayReqSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a3452c4beb43254ece9773c99e03e629f">XAvb_PtpStruct::PDelayTimestampT1</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="xavb_8h.html#a454f4f2c09586f6e787232cb0ae250c2">XAvb_IncSequenceId()</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#aab96c1602bda46380e25d0bb03a8ac01">XAvb_PtpTimerInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a63281acd385453959b333154bca2d9c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SendPDelayResp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP PDelay Response Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the received Announce Packet in the Rx PTP Packet Buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<h2>Format the Timestamp </h2>
<p>Capture the current Synchronised time</p>
<p>Read the current RTC offset</p>
<p>Read the TimestampT2 for PDelayReq reception and adjust it for MAC receive latency</p>
<p>The TimestampT2 was captured using syntonised ns time. We need to convert this into synchronised time by adding on the current offset</p>
<p>Check for ns wrap-around condition</p>
<p>Even though we read the RTC value at the beginning of this function, there would have been processing delay between the actual reception (and timestamping) of the PDelayReq frame and the start of this function. During this time, the RTC Seconds field could have wrapped around. We need to detect this and if it has done, the slave Seconds field would also have incremented (so it needs to be set back).</p>
<p>NanoSec has wrapped since timestamp was taken so decrement the Seconds field</p>
<p>Format the Timestamp (t2) into correct byte positioning for PTP frame storage, then write the Timestamp (t2) to the PDelayResp frame</p>
<h2>Format the SequenceId </h2>
<p>Set the SequenceId in the PDelayResp and PDelayRespFollowUp frame to be that of the received PDelayReq frame</p>
<h2>Format the sourcePortIdentity </h2>
<p>Copy the sourcePortIdentity field from the PDelayReq into the PDelayResp and PDelayRespFollowUp frame</p>
<h2>Send the PDelayResp Frame! </h2>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a810daa5475d7da25976222f9c9728337">XAvb_PtpStruct::NsOffsetForPDelayResp</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#a17b4489a857a0fcb761a529b749d5ad3">XAVB_RTC_NANOSEC_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a59f550eaa57148613974c4aa5628bfb4">XAVB_RTC_NANOSEC_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#aa71292011b875c192d09141638c3a4e1">XAVB_RTC_SEC_LOWER_VALUE_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#ae38e8307c8da64ba9f42516168855a8f">XAVB_RTC_SEC_UPPER_VALUE_OFFSET</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c1081cde03d0c53bc508927111fe87c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SendPDelayRespFollowUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to format then request the transmission of a PTP PDelay Response Follow-Up Packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated PTP fields, and then the Tx PTP Packet Buffer Control Register is written to request the frame transmission.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until there are no PTP frames to be transmitted</p>
<h2>Format the Timestamp </h2>
<p>Capture the current Synchronised time</p>
<p>Read the TimestampT3 for PDelayResp transmission and adjust it for MAC transmit latency</p>
<p>The TimestampT3 was captured using syntonised ns time. We need to convert this into synchronised time by adding on the ns offset. We use the same offset here as for the PDelayResp frame since if a ns offset change had been made between PDelayResp and , PDelayRespFollowUp, this would result in an error in the link delay measurement.</p>
<p>Check for ns wrap-around condition</p>
<p>Even though we read the RTC value at the beginning of this function, there would have been processing delay between the actual reception (and timestamping) of the PDelayReq frame and the start of this function. During this time, the RTC seconds field could have wrapped around. We need to detect this and if it has done, the slave seconds field would also have incremented (so it needs to be set back).</p>
<p>nanosec has wrapped since timestamp was taken so decrement the seconds field</p>
<p>Format the Timestamp (t3) into correct byte positioning for PTP frame storage, the write the Timestamp (t3) to the PDelayRespFollowUp frame</p>
<h2>Send the PDelayRespFollowUp Frame! </h2>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___rtc_format.html#ad30a5df1748ad71907d830893f23cbba">XAvb_RtcFormat::NanoSeconds</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a810daa5475d7da25976222f9c9728337">XAvb_PtpStruct::NsOffsetForPDelayResp</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb___rtc_format.html#a5015cb1ee0a5eb14ef15e03225450a81">XAvb_RtcFormat::SecondsLower</a>, <a class="el" href="struct_x_avb___rtc_format.html#a84452962f60d5528bbb9da1df3c1bf7d">XAvb_RtcFormat::SecondsUpper</a>, <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb__hw_8c.html#adbb46fbeb6b3bb40e8067ea6f8a0776c">XAvb_ReadRtc()</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb_8h.html#afcb3695de30c54e17e3c3e0a461ab0eb">XAvb_WaitOnTxPtpQueue()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb_8h.html#a99019d3795040dd7110d47aaa598ab7b">XAvb_PtpRxInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c8e2297936bf5abb7f206b365611b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetGMDiscontinuityHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xavb_8h.html#a89773b9c275933b3c03bbf78179342b5">XAvb_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the handler that will be called when a GM discontinuity event is identified by the driver. </p>
<p>The purpose of the handler is to allow application specific processing to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance. </td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

<p>References <a class="el" href="struct_x_avb.html#a6f2483d14031dc855c8cf27c796c122e">XAvb::GMDiscCallBackRef</a>, <a class="el" href="struct_x_avb.html#adaa9fca5f2df9e76794cb97f8bd1f307">XAvb::GMDiscHandler</a>, and <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a888d220aeb387018ce33558e08d0166e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetupRxFilterControlMatchMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>VlanMatchMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to set the VLAN Match Mode field for the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
    <tr><td class="paramname">VlanMatchMode</td><td>contains the 1-bit value to be written to the register in the correct bit position as defined in the address map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#aeb18774c7074b8558f6f3d92ee894308">XAVB_RX_FILTER_CONTROL</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a4a970ecc2621c88825ecc3f01ff1c4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetupRxFilterControlPcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>VlanPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SrClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to set the VLAN PCP field for either SR A or B traffic in the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
    <tr><td class="paramname">VlanPriority</td><td>contains the 3-bit value to be written to the register in the correct bit positions as defined in the address map</td></tr>
    <tr><td class="paramname">SrClass</td><td>is '0' if VLAN Priority (PCP) A is to be updated and is '1' if VLAN Priority (PCP) B is to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#aeb18774c7074b8558f6f3d92ee894308">XAVB_RX_FILTER_CONTROL</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="afb10d8fd68257130d0fc50bfe71ad3e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetupRxFilterControlVid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>VlanVid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SrClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to set the VLAN VID field for either SR A or B traffic in the RX Filtering Control Register - such that AV traffic is correctly filtered by the RX Splitter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
    <tr><td class="paramname">VlanVid</td><td>contains the 12-bit value to be written to the register in the correct bit positions as defined in the address map</td></tr>
    <tr><td class="paramname">SrClass</td><td>is '0' if VLAN VID A is to be updated and is '1' if VLAN VID B is to be updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#aeb18774c7074b8558f6f3d92ee894308">XAVB_RX_FILTER_CONTROL</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a42cd78e966447edcb45a0f419cc84cb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_SetupSourcePortIdentity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___port_identity.html">XAvb_PortIdentity</a>&#160;</td>
          <td class="paramname"><em>systemIdentity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the portIdLocal local copy of the sourcePortIdentity and writes this value into the TX PTP frame buffer templates. </p>
<p>The fields that are written are: o sourcePortIdentity for all default PTP frames o Announce:: grandmasterIdentity o Announce:: TLV clockIdentity</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on </td></tr>
    <tr><td class="paramname">systemIdentity</td><td>is the clockIdentity and portNumber for this endpoint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Announce::TLV. By default the tlvType and length field are set up in the BRAM, assuming that N = 1. </dd></dl>
<p>Write the sourcePortIdentity into the header for all TX PTP buffers except the empty default buffer AND write the GMID for TX announce AND Write the ClockIdentity into the TX Announce TLV</p>
<p>(a) Write the upper 2 bytes of the ClockIdentityUpper</p>
<ul>
<li>REM: Swap back the byte order into frame storage order</li>
</ul>
<p>(b) Write the lower 2 bytes of the ClockIdentityUpper and upper 2 bytes of the ClockIdentityLower.</p>
<ul>
<li>REM: Swap back the byte order into frame storage order</li>
</ul>
<p>(c) Write the lower 2 bytes of the ClockIdentityLower and the portNumber</p>
<ul>
<li>REM: Swap back the byte order into frame storage order</li>
</ul>
<p>Write the grandmasterIdentity into the header for the TX Announce PTP buffer</p>
<p>(a) Write 1 byte of GMID (Upper)</p>
<p>(b) Write 3 bytes of GMID (Upper) and 1 byte of GMID (Lower)</p>
<p>(c) Write 3 bytes of GMID (Lower) </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb.html#afa0f0b3779f43a549fc63b1c9d6e9f23">XAvb::portIdLocal</a>, <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, <a class="el" href="xavb_8h.html#a664d83b2f34093d6000f3ea2facef449">XAvb_ReorderWord()</a>, <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>, and <a class="el" href="xavb_8h.html#a1fafde8d597983f3e827b93fcc8e3c8a">XAvb_WriteToMultipleTxPtpFrames()</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a8657704dc9974d465536615ebbeb79d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will start the PTP drivers running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Xavb instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Assert bad arguments and conditions</p>
<p>Re-run the BMCA algorithm with the current PTP buffer Announce Packet</p>
<p>Set to PTP running in the PTP data structure</p>
<p>Assume that the Peer is not AS capable until it replies to a pDelay_Req frame </p>

<p>References <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>, <a class="el" href="struct_x_avb.html#a194197130a475d3183dc70f1319d73dc">XAvb::PtpIsRunning</a>, <a class="el" href="xavb_8h.html#a004f6ae823f2e50f4dd2fac409953537">XAvb_ChangePeerASCapability()</a>, and <a class="el" href="xavb_8h.html#a4091121232495f00535ca134664b4f7c">XAvb_DecodeTxAnnounceFrame()</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a5d4a65b18da8805b9a6bf464961f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will stop the PTP drivers from running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Xavb instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Assert bad arguments and conditions </p>

<p>References <a class="el" href="struct_x_avb.html#aced8bd4c1c2fe81821504bc65e8774eb">XAvb::IsReady</a>, and <a class="el" href="xavb_8c.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a2234b9dec3b039479123f49ee573a14e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_UpdateBmcRecords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *&#160;</td>
          <td class="paramname"><em>NewMaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_avb___bmc_data.html">XAvb_BmcData</a> *&#160;</td>
          <td class="paramname"><em>CurrentBmc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will accept the data pointer to the current BMCA records, accept an equivalent pointer to a new (winning) Grand Masters Announce Packet information. </p>
<p>The CurrentBmc data structure is then updated with the information from the NewMaster.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewMaster</td><td>is a pointer to a suitable data structure which has recorded the relevent Announce Packet fields of the new (winning) Grand Master. </td></tr>
    <tr><td class="paramname">CurrentBmc</td><td>is a pointer to a suitable data structure which has recorded the current fields of the current Grand Master's Announce Packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The CurrentBmc data structure is updated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_avb___port_identity.html#ad7e78ca34d8fcbecf410f8d748177e0e">XAvb_PortIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6119ed21ae13fc8002df3ea89701a710">XAvb_ClockIdentity::ClockIdentityLower</a>, <a class="el" href="struct_x_avb___port_identity.html#aa1435c872067f98c7998a4b98b792112">XAvb_PortIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___clock_identity.html#a6d7f51bcff1917d372465c04a2f36d7b">XAvb_ClockIdentity::ClockIdentityUpper</a>, <a class="el" href="struct_x_avb___bmc_data.html#a463904e4270ced5a6c437e68fad3b98f">XAvb_BmcData::ClockQuality</a>, <a class="el" href="struct_x_avb___bmc_data.html#aa842c05dfde7a1dccd0a48c906c742d9">XAvb_BmcData::GrandmasterIdentity</a>, <a class="el" href="struct_x_avb___bmc_data.html#a206dca9ffafe9d7fbf0019402127e6dd">XAvb_BmcData::GrandmasterPriority1</a>, <a class="el" href="struct_x_avb___bmc_data.html#ab345aec9e45cac47fddee9e48724c9ef">XAvb_BmcData::GrandmasterPriority2</a>, <a class="el" href="struct_x_avb___port_identity.html#adbb184a9b5875775835442cf06a25800">XAvb_PortIdentity::PortNumber</a>, <a class="el" href="struct_x_avb___bmc_data.html#ae60a5e9cd8c572d2db805650287483f7">XAvb_BmcData::SourcePortIdentity</a>, and <a class="el" href="struct_x_avb___bmc_data.html#aa82e09ae59ed634e54fdcfebe78d10d2">XAvb_BmcData::stepsRemoved</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__bmca_8c.html#a5ef1c55c51f5781c4395ff20cc07f410">XAvb_BecomeRtcMaster()</a>, <a class="el" href="xavb__ptp__bmca_8c.html#a5eaf575de699cb2f054a43daa8a93849">XAvb_DecodeRxAnnounceFrame()</a>, and <a class="el" href="xavb__ptp__bmca_8c.html#a4091121232495f00535ca134664b4f7c">XAvb_DecodeTxAnnounceFrame()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d81de9521bde263313b2de412f45fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XAvb_UpdateIntervalDuration </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>currentIntervalDuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>logMeanVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to update a PTP message Interval Duration (defined as a fraction of 128 seconds). </p>
<p>If the endpoint cannot support a requested logMeanVal then do not perform the conversion - return the current value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentIntervalDuration</td><td>is the Interval Duration to be updated </td></tr>
    <tr><td class="paramname">logMeanVal</td><td>is the base2 value that is to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>logMeanVal represented as a fraction of 128</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This endpoint only supports logMeanValues &gt;=-7 and &lt;=8. </dd></dl>

<p>References <a class="el" href="xavb_8h.html#afa725e8ddb08a833d10e8554067ac361">XAvb_ConvertLogMeanToDuration()</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c3933020b616a2a57b6229bce6f6151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_UpdateLogMeanMessageInterval </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFrameBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>intervalDuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to update the logMeanMessageInterval field in a PTP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFrameBaseAddr</td><td>is the base address of the TX PTP Buffer to be updated </td></tr>
    <tr><td class="paramname">intervalDuration</td><td>is the "fraction of 128" value of the data to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the relevant Tx PTP Packet Buffer is written to with the updated logMeanMessageInterval</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Convert intervalDuration to a logMean value</p>
<p>Read the current fields</p>
<p>Update just the logMeanMessageInterval field</p>
<p>Write back </p>

<p>References <a class="el" href="xavb_8h.html#a7c1539b744b6e5b9c9da652820948241">XAvb_ConvertDurationToLogMean()</a>, <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#ab9afff73e01faafdc8ce9f8e0ee8d4de">XAvb_DecodeRxSignaling()</a>, and <a class="el" href="xavb_8h.html#af24c248c31c6c45cdb8a46f82de175c5">XAvb_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ada9dd75eb576b0e600686514fbea45e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_UpdateRtcIncrement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sanity Check that Sync Frames were n apart. This safeguards the calculation against the ethernet cable being pulled out and then replaced, etc.</p>
<p>Measure the time duration, as measured by the RTC master of the M sync delay measurment period.</p>
<p>Measure the time duration, as measured by the RTC slave of the M sync delay measurment period.</p>
<p>Therefore calculate the slave error (in ns)</p>
<p>If the slave error is zero, skip the remainder of function. (Note : a zero error would otherwise get stuck in the while loop further down this function).</p>
<p>Analyse msb of error signal to see which clock is running fastest</p>
<p>This check is in addition to the checks described in IEEE802.1as. If the SlaveError is unexpectedly large, then set asCapable to 0.</p>
<p>SlaveError signal is 32-bits (ns). This can indicate &gt; 4 sec of error: this is too large for 100 ms measurement period. So we expect upper bits to be zero.</p>
<p>This function will shift the 1st none zero bit of SlaveError up to bit 31, so that forthcoming calculation uses maximum accuracy.</p>
<p>This shift is equivalent to a multiply (of the error signal). A shift the opposite way (equivalent to a divide) will follow at end of full calculation.</p>
<p>Calculate the relative error: can be thought of as a scaled ratio of error per time unit</p>
<p>Obtain the current increment value</p>
<p>Calculate the increment adjustment: multiply NormalisedError by the increment time unit. Then shift back the other way to correct the calculation (restore to ns).</p>
<p>Now calculate the new increment value</p>
<p>Add some rails so that recovery is possible after a string of bad pDelay values. The RTC should be able to lock to within 100ppm of the slowest allowable clock (25 MHz). This equates to +/-4ps. Let's arbitrarily set the rails to 400ppm (+/-16ps) just in case someone decides to use a particularly bad oscillator. The lowest 20 bits of NewIncrement are fractions of a nanosecond, which equates to +/- 0x04189</p>
<p>And write the new increment value! </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a05590438022ee2dff39492654cfe3285">XAvb_PtpStruct::NewMasterTime</a>, <a class="el" href="struct_x_avb___ptp_struct.html#aecd30621bf3e8988ea4bebf59ab4d031">XAvb_PtpStruct::NewSlaveTime</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a689e9f68ca62fd5f25c4ba60be3419cc">XAvb_SequenceIdStruct::NewSyncSequenceId</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a92f212eedbc5375293d822d97a56b11a">XAvb_PtpStruct::OldMasterTime</a>, <a class="el" href="struct_x_avb___ptp_struct.html#a5f843941b210edca7edb0824ba342652">XAvb_PtpStruct::OldSlaveTime</a>, <a class="el" href="struct_x_avb___sequence_id_struct.html#a6905c062e37474a276a80955ebe565b5">XAvb_SequenceIdStruct::OldSyncSequenceId</a>, <a class="el" href="struct_x_avb.html#a58aca67d5c17f24eec11e1f2b6361780">XAvb::PtpRecords</a>, <a class="el" href="struct_x_avb.html#a2d58b8df5e9c75db8d9dd7aa6aa8867d">XAvb::SequenceIdRecords</a>, <a class="el" href="xavb_8h.html#a07f69b843cd86ca6149c838c478c4e01">XAvb_ChangePTPLockStatus()</a>, <a class="el" href="xavb_8h.html#aa7c8e8ce9e50f2b41384c01c7644073b">XAVB_CLOCK_LOCK_THRESHOLD</a>, <a class="el" href="xavb_8h.html#a0e38789f6a2e5cdbf7a2f305c77044dd">XAVB_ONE_SECOND</a>, <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>, <a class="el" href="xavb__hw_8h.html#a870c4aa143bd3d85e0b1c48e1871ccb9">XAVB_RTC_400PPM_OFFSET</a>, <a class="el" href="xavb__hw_8h.html#aca5791394dd0b429d4c49559d0e1503c">XAVB_RTC_INCREMENT_NOMINAL_RATE</a>, <a class="el" href="xavb__hw_8h.html#a48d76d16f8d685a65a1216614e548071">XAVB_RTC_INCREMENT_OFFSET</a>, and <a class="el" href="xavb__hw_8h.html#a74f3dcc0fed12b1ee97541a109b8d98c">XAvb_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#afb8650c4c94082dc746db9ec0259e1cb">XAvb_DecodeRxFollowUp()</a>.</p>

</div>
</div>
<a class="anchor" id="afcb3695de30c54e17e3c3e0a461ab0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_WaitOnTxPtpQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_avb.html">XAvb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The software drivers are kept simple by only requesting a single PTP frame to be transmitted at a time. </p>
<p>This function checks (and if necessary waits) until the previously request PTP frame has been transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_avb.html" title="The XAvb driver instance data. ">XAvb</a> instance to be worked on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Wait until any queued PTP frame has been transmitted. This is a software safety feature, not a hardware restriction </p>

<p>References <a class="el" href="struct_x_avb___config.html#a8f161e4fe6ff1843746adbd93a173241">XAvb_Config::BaseAddress</a>, <a class="el" href="struct_x_avb.html#a004789c582ac680a57d708f86c13ab9f">XAvb::Config</a>, <a class="el" href="xavb__hw_8h.html#ad99ca00362bea7facdddcc2cf4b665da">XAVB_PTP_TX_CONTROL_OFFSET</a>, and <a class="el" href="xavb__hw_8h.html#a74fc84434da6ed0d4604020e9bed3a8b">XAvb_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xavb__ptp__packets_8c.html#aeeaf9984303a07b8935d4a391f0ca188">XAvb_MasterSendAnnounce()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a989d44c98695fd6f286858f8b7976e3f">XAvb_MasterSendFollowUp()</a>, <a class="el" href="xavb__ptp__packets_8c.html#ae239544f086bc86572b8e2d7e408a028">XAvb_MasterSendSync()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a2e3f462007beb73497bbded566d7f364">XAvb_SendPDelayReq()</a>, <a class="el" href="xavb__ptp__packets_8c.html#a63281acd385453959b333154bca2d9c7">XAvb_SendPDelayResp()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a2c1081cde03d0c53bc508927111fe87c">XAvb_SendPDelayRespFollowUp()</a>.</p>

</div>
</div>
<a class="anchor" id="a1fafde8d597983f3e827b93fcc8e3c8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAvb_WriteToMultipleTxPtpFrames </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PtpFieldAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DataBitEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>BufferEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function to write common data (eg the Source Address) to all PTP frames stored in the Tx PTP Packet buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">PtpFieldAddress</td><td>is the offset address of the relevant field in PTP frames. </td></tr>
    <tr><td class="paramname">Data</td><td>is the common data to be written to all Tx PTP frame templates </td></tr>
    <tr><td class="paramname">DataBitEnable</td><td>allows only selected bits of the 32-bit Data word to be modified. </td></tr>
    <tr><td class="paramname">BufferEnable</td><td>allows the selected buffer to be seleced: there are 8 PTP buffers - these are encoded as one-hot. For example, 0x3F will write the selected data to the first 6 buffers only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. But the Tx PTP Packet Buffer is written to as requested</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>Write to all 8 PTP frame templates</p>
<p>Only write to selected buffers</p>
<p>Read the current value</p>
<p>Only change the selected data bits</p>
<p>Write the updated value </p>

<p>References <a class="el" href="xavb__hw_8h.html#a072d5c22a5ff3e25e036146d552955bc">XAvb_ReadPtpBuffer</a>, and <a class="el" href="xavb__hw_8h.html#aeab8d086419859c0676c181c38252640">XAvb_WritePtpBuffer</a>.</p>

<p>Referenced by <a class="el" href="xavb__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="xavb__ptp__packets_8c.html#a42cd78e966447edcb45a0f419cc84cb8">XAvb_SetupSourcePortIdentity()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
