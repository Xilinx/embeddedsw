<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>v_hdmirxss: xv_hdmirxss.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">v_hdmirxss
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xv__hdmirxss_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xv_hdmirxss.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This is main code of Xilinx HDMI Receiver Subsystem device driver. </p>
<p>Please see <a class="el" href="xv__hdmirxss_8h.html" title="This is main header file of the Xilinx HDMI RX Subsystem driver. ">xv_hdmirxss.h</a> for more details of the driver.</p>
<pre>
  MODIFICATION HISTORY:</pre><pre>  Ver   Who    Date     Changes
<hr/>

  1.00         10/07/15 Initial release.
  1.1   yh     15/01/16 Added 3D Video support
  1.2   yh     20/01/16 Added remapper support
  1.3   yh     01/02/16 Added set_ppc api
  1.4   yh     01/02/16 Removed xil_print "Cable (dis)connected"
  1.5   yh     01/02/16 Removed xil_printf("Active audio channels...)
  1.6   yh     15/02/16 Added default value to XV_HdmiRxSs_ConfigRemapper
  1.7   MG     03/02/16 Added HDCP support
  1.8   MG     10/02/16 Moved HDCP 2.2 reset from stream up/down callback
                        to connect callback
  1.9   MH     15/03/16 Added HDCP authenticated callback support
  1.10  MH     23/04/16 1. HDCP 1.x driver now uses AXI timer 4.1, so updated
                        to use AXI Timer config structure to determine timer
                        clock frequency
                        2. HDCP 1.x driver has fixed the problem where the
                        reset for the receiver causes the entire DDC peripheral
                        to get reset. Based on this change the driver has been
                        updated to use XV_HdmiRxSs_HdcpReset and
                        XV_HdmiRxSs_HdcpReset functions directly.
                        3. Updated XV_HdmiRxSs_HdcpEnable and
                        XV_HdmiRxSs_HdcpEnable functions to ensure that
                        HDCP 1.4 and 2.2 are mutually exclusive.
                        This fixes the problem where HDCP 1.4 and 2.2
                        state machines are running simultaneously.
  1.11  MG     13/05/16 Added DDC peripheral HDCP mode selection to XV_HdmiRxSs_HdcpEnable
  1.12  MH     23/06/16 Added HDCP repeater support.
  1.13  YH     18/07/16 1. Replace xil_print with xdbg_printf.
                        2. Replace MB_Sleep() with usleep()
  1.14  YH     25/07/16 Used UINTPTR instead of u32 for BaseAddress
                        XV_HdmiRxSs_CfgInitialize
  1.15  MH     26/07/16 Updates for automatic protocol switching
  1.16  MH     05/08/16 Updates to optimize out HDCP when excluded
  1.17  YH     17/08/16 Remove sleep in XV_HdmiRxSs_ResetRemapper
                        squash unused variable compiler warning
                        Added Event Log
  1.18  MH     08/10/16 Improve HDCP 1.4 authentication
  1.19  MG     31/10/16 Fixed issue with reference clock compensation in
                            XV_HdmiRxSS_SetStream
  1.20  YH     14/11/16 Added API to enable/disable YUV420/Pixel Drop Mode
                        for video bridge
  1.21  YH     14/11/16 Remove Remapper APIs
                        Replace XV_HdmiRxSs_ConfigRemapper API with
                        XV_HdmiRxSs_ConfigBridgeMode API as remapper feature is
                            moved to video bridge and controlled by HDMI core
  1.22  MMO    03/01/17 Add compiler option(XV_HDMIRXSS_LOG_ENABLE) to enable
                            Log
                        Move global variable XV_HdmiRx_VSIF VSIF to local
                            XV_HdmiRxSs_RetrieveVSInfoframe API
                        Move HDCP related API's to hdmirxss_hdcp.c
  1.23  MMO    10/02/17 Added Sync Loss and HDMI/DVI Interrupt Support</pre><pre>  1.4   YH     07/07/17 Add new log type XV_HDMIRXSS_LOG_EVT_SETSTREAM_ERR
                        Report HDMI/DVI mode in HDMI example design info log</pre><pre>  1.41  MMO    21/07/17 CR-979900 (Fix)
                        Removed the HDCP Push Event API Call when the
                        Aux Callback event happen
        MH     09/08/17 Added function XV_HdmiRxSs_HdcpSetCapability
  1.42  YH     06/10/17 Added function XV_HdmiRxSs_GetAudioFormat
        EB     10/10/17 Updated function XV_HdmiRxSs_ReportAudio to report
                            audio format
  5.00  YH     16/11/17 Added dedicated reset for each clock domain
               16/11/17 Added bridge overflow interrupt
        EB     16/01/18 Added parsing of InfoFrames during AuxCallback
                        Changed XV_HdmiRxSs_RetrieveVSInfoframe's input
                            parameter type
                        Added function XV_HdmiRxSs_GetAviInfoframe,
                            XV_HdmiRxSs_GetGCP, XV_HdmiRxSs_GetAudioInfoframe,
                            XV_HdmiRxSs_GetVSIF
                        Updated XV_HdmiRxSs_ConfigBridgeMode so Pixel
                            Pepetition is based on received AVI InfoFrame
        SM     28/02/18 Added definition of <a class="el" href="xv__hdmirxss_8c.html#a3c8f4247ffd9a6540e8aed78e23699a7" title="This function will set the major and minor application version in RXSs struct. ">XV_HdmiRxSS_SetAppVersion()</a> API
  5.10  MMO    06/04/18 Updated XV_HdmiRxSs_ToggleHpd and XV_HdmiRxSs_Stop
                            for cleaner HPD flow during transition from HDMI2.0
                            to HDMI1.4
        YH     13/04/18 Fixed a bug in XV_HdmiRxSs_BrdgOverflowCallback
  5.20  EB     03/08/18 Added function XV_HdmiRxSs_AudioMute
                        Added TMDS Clock Ratio callback support
******************************************************************************/</pre><pre>/***************************** Include Files *********************************/</pre><pre><h1>123 "/proj/xhdsswstaff/saddepal/github_2018.3/embeddedsw/XilinxProcessorIPLib/drivers/v_hdmirxss/src/xv_hdmirxss.c" 2</h1>
</pre><pre>
<h1>124 "/proj/xhdsswstaff/saddepal/github_2018.3/embeddedsw/XilinxProcessorIPLib/drivers/v_hdmirxss/src/xv_hdmirxss.c" 2</h1>
</pre><pre></pre><pre>/************************** Constant Definitions *****************************/</pre><pre>/**************************** Type Definitions *******************************/
/**
   This typedef declares the driver instances of all the cores in the subsystem
 */
typedef struct
{</pre><pre>  XV_HdmiRx HdmiRx;
} XV_HdmiRxSs_SubCores;</pre><pre>/**************************** Local Global ***********************************/
/** Define Driver instance of all sub-core included in the design */
XV_HdmiRxSs_SubCores XV_HdmiRxSs_SubCoreRepo[XPAR_XV_HDMIRXSS_NUM_INSTANCES];</pre><pre>/************************** Function Prototypes ******************************/
static void XV_HdmiRxSs_GetIncludedSubcores(<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr,
    u16 DevId);
static void XV_HdmiRxSs_WaitUs(XV_HdmiRxSs *InstancePtr, u32 MicroSeconds);
static void XV_HdmiRxSs_RetrieveVSInfoframe(XV_HdmiRxSs *HdmiRxSs);
static int XV_HdmiRxSs_RegisterSubsysCallbacks(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ConnectCallback(void *CallbackRef);
static void XV_HdmiRxSs_BrdgOverflowCallback(void *CallbackRef);
static void XV_HdmiRxSs_AuxCallback(void *CallbackRef);
static void XV_HdmiRxSs_AudCallback(void *CallbackRef);
static void XV_HdmiRxSs_LnkStaCallback(void *CallbackRef);
static void XV_HdmiRxSs_DdcCallback(void *CallbackRef);
static void XV_HdmiRxSs_StreamDownCallback(void *CallbackRef);
static void XV_HdmiRxSs_StreamInitCallback(void *CallbackRef);
static void XV_HdmiRxSs_StreamUpCallback(void *CallbackRef);
static void XV_HdmiRxSs_SyncLossCallback(void *CallbackRef);
static void XV_HdmiRxSs_ModeCallback(void *CallbackRef);
static void XV_HdmiRxSs_TmdsClkRatioCallback(void *CallbackRef);</pre><pre>static void XV_HdmiRxSs_ReportCoreInfo(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ReportTiming(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ReportLinkQuality(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ReportAudio(XV_HdmiRxSs *InstancePtr);
static void XV_HdmiRxSs_ReportInfoFrame(XV_HdmiRxSs *InstancePtr);
static void <a class="el" href="xv__hdmirxss_8c.html#ab984feecc99028c5ab95d99e7087e329" title="This function prints the HDMI RX SS subcore versions. ">XV_HdmiRxSs_ReportSubcoreVersion(XV_HdmiRxSs *InstancePtr)</a>;</pre><pre>static void XV_HdmiRxSs_ConfigBridgeMode(XV_HdmiRxSs *InstancePtr);</pre><pre>/***************** Macros (Inline Functions) Definitions *********************/
/*****************************************************************************/
/**
  This macros selects the bridge YUV420 mode</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem</td></tr>
  </table>
  </dd>
</dl>
*****************************************************************************/
#define XV_HdmiRxSs_BridgeYuv420(InstancePtr,Enable)</pre><pre>/*****************************************************************************/
/**
  This macros selects the bridge pixel repeat mode</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem</td></tr>
  </table>
  </dd>
</dl>
*****************************************************************************/
#define XV_HdmiRxSs_BridgePixelDrop(InstancePtr,Enable)</pre><pre>/************************** Function Definition ******************************/</pre><pre>void XV_HdmiRxSs_ReportInfo(XV_HdmiRxSs *InstancePtr)
{
    xil_printf("------------\r\n");
    xil_printf("HDMI RX SubSystem\r\n");
    xil_printf("------------\r\n");
    XV_HdmiRxSs_ReportCoreInfo(InstancePtr);
    XV_HdmiRxSs_ReportSubcoreVersion(InstancePtr);
    xil_printf("\r\n");
    xil_printf("HDMI RX Mode - ");
    if (InstancePtr-&gt;HdmiRxPtr-&gt;Stream.IsHdmi == (TRUE)) {
        xil_printf("HDMI\r\n");
    }
    else {
        xil_printf("DVI\r\n");
    }
    xil_printf("------------\r\n");
    xil_printf("HDMI RX timing\r\n");
    xil_printf("------------\r\n");
    XV_HdmiRxSs_ReportTiming(InstancePtr);
    xil_printf("Link quality\r\n");
    xil_printf("---------\r\n");
    XV_HdmiRxSs_ReportLinkQuality(InstancePtr);
    xil_printf("Audio\r\n");
    xil_printf("---------\r\n");
    XV_HdmiRxSs_ReportAudio(InstancePtr);
    xil_printf("Infoframe\r\n");
    xil_printf("---------\r\n");
    XV_HdmiRxSs_ReportInfoFrame(InstancePtr);
    xil_printf("\r\n");
}</pre><pre>/*****************************************************************************/
/**
  This function reports list of cores included in Video Processing Subsystem</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_ReportCoreInfo(XV_HdmiRxSs *InstancePtr)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  xil_printf("\r\n  -&gt;HDMI RX Subsystem Cores\r\n");</pre><pre>  /* Report all the included cores in the subsystem instance */
  if(InstancePtr-&gt;HdmiRxPtr)
  {
    xil_printf("    : HDMI RX \r\n");
  }</pre><pre>}</pre><pre>/******************************************************************************/
/**
   This function installs a custom delay/sleep function to be used by the
    <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> driver.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HdmiSsRx instance.
</td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address to the callback function.
</td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is the user data item (microseconds to delay) that
        will be passed to the custom sleep/delay function when it is
        invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
*******************************************************************************/
void XV_HdmiRxSs_SetUserTimerHandler(<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> <em>InstancePtr,
            XVidC_DelayHandler CallbackFunc, void *CallbackRef)
{
    /</em> Verify arguments. */
    Xil_AssertVoid(InstancePtr != NULL);
    Xil_AssertVoid(CallbackFunc != NULL);
    Xil_AssertVoid(CallbackRef != NULL);</pre><pre>    InstancePtr-&gt;UserTimerWaitUs = CallbackFunc;
    InstancePtr-&gt;UserTimerPtr = CallbackRef;
}</pre><pre>/******************************************************************************/
/**
   This function is the delay/sleep function for the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> driver. For the
   Zynq family, there exists native sleep functionality. For MicroBlaze however,
   there does not exist such functionality. In the MicroBlaze case, the default
   method for delaying is to use a predetermined amount of loop iterations. This
   method is prone to inaccuracy and dependent on system configuration; for
   greater accuracy, the user may supply their own delay/sleep handler, pointed
   to by InstancePtr-&gt;UserTimerWaitUs, which may have better accuracy if a
   hardware timer is used.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HdmiSsRx instance.
</td></tr>
    <tr><td class="paramname">MicroSeconds</td><td>is the number of microseconds to delay/sleep for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
*******************************************************************************/
static void XV_HdmiRxSs_WaitUs(XV_HdmiRxSs &lt;em&gt;InstancePtr, u32 MicroSeconds)
{
    / Verify arguments. */
    Xil_AssertVoid(InstancePtr != NULL);
    Xil_AssertVoid(InstancePtr-&gt;IsReady == XIL_COMPONENT_IS_READY);</pre><pre>    if (MicroSeconds == 0) {
        return;
    }</pre><pre>    if (InstancePtr-&gt;UserTimerWaitUs != NULL) {
        /* Use the timer handler specified by the user for better
           accuracy. */
        InstancePtr-&gt;UserTimerWaitUs(InstancePtr, MicroSeconds);
    }
    else {
        usleep(MicroSeconds);
    }
}</pre><pre>/*****************************************************************************/
/**
   This function calls the interrupt handler for HDMI RX</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem</td></tr>
  </table>
  </dd>
</dl>
*****************************************************************************/
void XV_HdmiRxSS_HdmiRxIntrHandler(XV_HdmiRxSs *InstancePtr)
{
    XV_HdmiRx_IntrHandler(InstancePtr-&gt;HdmiRxPtr);
}</pre><pre>/*****************************************************************************/
/**
   This function register's all sub-core ISR's with interrupt controller and
   any subsystem level call back function with requisite sub-core</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be
         worked on.</td></tr>
  </table>
  </dd>
</dl>
*****************************************************************************/
static int XV_HdmiRxSs_RegisterSubsysCallbacks(XV_HdmiRxSs *InstancePtr)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = InstancePtr;</pre><pre>  //Register HDMI callbacks
  if(HdmiRxSsPtr-&gt;HdmiRxPtr) {
    /*
       Register call back for Rx Core Interrupts.
     */
    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_CONNECT,
                          (void *)XV_HdmiRxSs_ConnectCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_BRDG_OVERFLOW,
                          (void *)XV_HdmiRxSs_BrdgOverflowCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_AUX,
                          (void *)XV_HdmiRxSs_AuxCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_AUD,
                          (void *)XV_HdmiRxSs_AudCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_LNKSTA,
                          (void *)XV_HdmiRxSs_LnkStaCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_DDC,
                          (void *)XV_HdmiRxSs_DdcCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_STREAM_DOWN,
                          (void *)XV_HdmiRxSs_StreamDownCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_STREAM_INIT,
                          (void *)XV_HdmiRxSs_StreamInitCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_STREAM_UP,
                          (void *)XV_HdmiRxSs_StreamUpCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_SYNC_LOSS,
                          (void *)XV_HdmiRxSs_SyncLossCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_MODE,
                          (void *)XV_HdmiRxSs_ModeCallback,
                          (void *)InstancePtr);</pre><pre>    XV_HdmiRx_SetCallback(HdmiRxSsPtr-&gt;HdmiRxPtr,
                          XV_HDMIRX_HANDLER_TMDS_CLK_RATIO,
                          (void *)XV_HdmiRxSs_TmdsClkRatioCallback,
                          (void *)InstancePtr);
  }</pre><pre>  return(XST_SUCCESS);
}</pre><pre>/*****************************************************************************/
/**
  This function queries the subsystem instance configuration to determine
  the included sub-cores. For each sub-core that is present in the design
  the sub-core driver instance is binded with the subsystem sub-core driver
  handle</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">HdmiRxSsPtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_GetIncludedSubcores(XV_HdmiRxSs *HdmiRxSsPtr, u16 DevId)
{
  HdmiRxSsPtr-&gt;HdmiRxPtr   =((HdmiRxSsPtr-&gt;Config.HdmiRx.IsPresent) ?
                            (&amp;XV_HdmiRxSs_SubCoreRepo[DevId].HdmiRx) : NULL);</pre><pre>}</pre><pre>/*****************************************************************************/
/**
  This function initializes the video subsystem and included sub-cores.
  This function must be called prior to using the subsystem. Initialization
  includes setting up the instance data for top level as well as all included
  sub-core therein, and ensuring the hardware is in a known stable state.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.
</td></tr>
    <tr><td class="paramname">CfgPtr</td><td>points to the configuration structure associated with the
          subsystem instance.
</td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the base address of the device. If address
          translation is being used, then this parameter must reflect the
          virtual base address. Otherwise, the physical address should be
          used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if initialization is successful else XST_FAILURE</dd></dl>
******************************************************************************/
int XV_HdmiRxSs_CfgInitialize(<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *InstancePtr,
    <a class="el" href="struct_x_v___hdmi_rx_ss___config.html" title="Video Processing Subsystem configuration structure. ">XV_HdmiRxSs_Config</a> *CfgPtr,
    UINTPTR EffectiveAddr)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = InstancePtr;</pre><pre>  /* Verify arguments */
  Xil_AssertNonvoid(HdmiRxSsPtr != NULL);
  Xil_AssertNonvoid(CfgPtr != NULL);
  Xil_AssertNonvoid(EffectiveAddr != (UINTPTR)NULL);</pre><pre>  /* Setup the instance */
  memcpy((void *)&amp;(HdmiRxSsPtr-&gt;Config), (const void *)CfgPtr,
    sizeof(XV_HdmiRxSs_Config));
  HdmiRxSsPtr-&gt;Config.BaseAddress = EffectiveAddr;</pre><pre>  /* Determine sub-cores included in the provided instance of subsystem */
  XV_HdmiRxSs_GetIncludedSubcores(HdmiRxSsPtr, CfgPtr-&gt;DeviceId);</pre><pre>  /* Initialize all included sub_cores */
  if(HdmiRxSsPtr-&gt;HdmiRxPtr)
  {
    if(XV_HdmiRxSs_SubcoreInitHdmiRx(HdmiRxSsPtr) != XST_SUCCESS)
    {
      return(XST_FAILURE);
    }
  }</pre><pre>  /* Register Callbacks */
  XV_HdmiRxSs_RegisterSubsysCallbacks(HdmiRxSsPtr);</pre><pre>  /* Reset the hardware and set the flag to indicate the
     subsystem is ready
   */
  XV_HdmiRxSs_Reset(HdmiRxSsPtr);
  HdmiRxSsPtr-&gt;IsReady = XIL_COMPONENT_IS_READY;</pre><pre>  /* Initialize the application version with 0 &lt;default value&gt;=""&gt;.
     Application need to set the this variable properly to let driver know
     what version of application is being used.
   */
  HdmiRxSsPtr-&gt;AppMajVer = 0;
  HdmiRxSsPtr-&gt;AppMinVer = 0;</pre><pre>  return(XST_SUCCESS);
}</pre><pre>/****************************************************************************/
/**
  This function starts the HDMI RX subsystem including all sub-cores that are
  included in the processing pipeline for a given use-case. Video pipe is
  started from back to front
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Cores are started only if the corresponding start flag in the scratch
        pad memory is set. This allows to selectively start only those cores
        included in the processing chain
******************************************************************************/
void XV_HdmiRxSs_Start(XV_HdmiRxSs *InstancePtr)
{
  Xil_AssertVoid(InstancePtr != NULL);</dd></dl>
XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_START, 0);</pre><pre>  /* Drive HDMI RX HPD High */
  XV_HdmiRx_SetHpd(InstancePtr-&gt;HdmiRxPtr, TRUE);</pre><pre>  /* Disable Audio Peripheral */
  XV_HdmiRx_AudioDisable(InstancePtr-&gt;HdmiRxPtr);
  XV_HdmiRx_AudioIntrDisable(InstancePtr-&gt;HdmiRxPtr);
}</pre><pre>/*****************************************************************************/
/**
  This function stops the HDMI RX subsystem including all sub-cores
  Stop the video pipe starting from front to back</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
void XV_HdmiRxSs_Stop(XV_HdmiRxSs *InstancePtr)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  /* Clear SCDC variables */
  XV_HdmiRx_DdcScdcClear(InstancePtr-&gt;HdmiRxPtr);</pre><pre>  /* Disable the scrambler */
  XV_HdmiRx_SetScrambler(InstancePtr-&gt;HdmiRxPtr, (FALSE));</pre><pre>  /* Drive HDMI RX HPD Low */
  XV_HdmiRx_SetHpd(InstancePtr-&gt;HdmiRxPtr, (FALSE));</pre><pre>  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_STOP, 0);</pre><pre>}</pre><pre>/*****************************************************************************/
/**
  This function resets the video subsystem sub-cores. There are 2 reset
  networks within the subsystem<ul>
<li>For cores that are on AXIS interface</li>
<li>For cores that are on AXI-MM interface</li>
</ul>
</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
void XV_HdmiRxSs_Reset(XV_HdmiRxSs *InstancePtr)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  XV_HdmiRxSs_LogWrite(InstancePtr, XV_HDMIRXSS_LOG_EVT_RESET, 0);</pre><pre>  /* Assert HDMI RX core resets */
  XV_HdmiRxSs_RXCore_VRST(InstancePtr, TRUE);
  XV_HdmiRxSs_RXCore_LRST(InstancePtr, TRUE);</pre><pre>  /* Assert SYSCLK VID_IN bridge reset */
  XV_HdmiRxSs_SYSRST(InstancePtr, TRUE);</pre><pre>  /* Release HDMI RX core resets */
  XV_HdmiRxSs_RXCore_VRST(InstancePtr, FALSE);
  XV_HdmiRxSs_RXCore_LRST(InstancePtr, FALSE);</pre><pre>  /* Release SYSCLK VID_IN bridge reset */
  XV_HdmiRxSs_SYSRST(InstancePtr, FALSE);
}</pre><pre>/*****************************************************************************/
/**
  This function asserts or releases the Internal Video reset
  of the HDMI subcore within the subsystem</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
void XV_HdmiRxSs_RXCore_VRST(XV_HdmiRxSs *InstancePtr, u8 Reset)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  XV_HdmiRx_INT_VRST(InstancePtr-&gt;HdmiRxPtr, Reset);
}</pre><pre>/*****************************************************************************/
/**
  This function asserts or releases the Internal Link reset
  of the HDMI subcore within the subsystem</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
void XV_HdmiRxSs_RXCore_LRST(XV_HdmiRxSs *InstancePtr, u8 Reset)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  XV_HdmiRx_INT_LRST(InstancePtr-&gt;HdmiRxPtr, Reset);
}</pre><pre>/*****************************************************************************/
/**
  This function asserts or releases the video reset of other
  blocks within the subsystem</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
void XV_HdmiRxSs_VRST(XV_HdmiRxSs *InstancePtr, u8 Reset)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  XV_HdmiRx_EXT_VRST(InstancePtr-&gt;HdmiRxPtr, Reset);
}</pre><pre>/*****************************************************************************/
/**
  This function asserts or releases the system reset of other
  blocks within the subsystem</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the Subsystem instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
******************************************************************************/
void XV_HdmiRxSs_SYSRST(XV_HdmiRxSs *InstancePtr, u8 Reset)
{
  Xil_AssertVoid(InstancePtr != NULL);</pre><pre>  XV_HdmiRx_EXT_SYSRST(InstancePtr-&gt;HdmiRxPtr, Reset);
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a Bridge overflow event has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_BrdgOverflowCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  xdbg_printf(XDBG_DEBUG_GENERAL,
              "\r\nWarning: RX Bridge Overflow\r\n");</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;BrdgOverflowCallback) {
    HdmiRxSsPtr-&gt;BrdgOverflowCallback(HdmiRxSsPtr-&gt;BrdgOverflowRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX connect event has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_ConnectCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // Is the cable connected?
  if (XV_HdmiRx_IsStreamConnected(HdmiRxSsPtr-&gt;HdmiRxPtr)) {</pre><pre>    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_CONNECT, 0);</pre><pre>    // Set RX hot plug detect
    XV_HdmiRx_SetHpd(HdmiRxSsPtr-&gt;HdmiRxPtr, TRUE);</pre><pre>    // Set stream connected flag
    HdmiRxSsPtr-&gt;IsStreamConnected = (TRUE);</pre><pre>  }</pre><pre>  // RX cable is disconnected
  else {</pre><pre>    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_DISCONNECT, 0);</pre><pre>    // Clear RX hot plug detect
    XV_HdmiRx_SetHpd(HdmiRxSsPtr-&gt;HdmiRxPtr, FALSE);</pre><pre>    // Set stream connected flag
    HdmiRxSsPtr-&gt;IsStreamConnected = (FALSE);</pre><pre><pre class="fragment">XV_HdmiRx_SetScrambler(HdmiRxSsPtr-&gt;HdmiRxPtr, (FALSE)); //Disable scrambler
</pre>
  }</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;ConnectCallback) {
    HdmiRxSsPtr-&gt;ConnectCallback(HdmiRxSsPtr-&gt;ConnectRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX AUX IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_AuxCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;
  XHdmiC_Aux *AuxPtr;
  XHdmiC_AVI_InfoFrame *AviInfoFramePtr;
  XHdmiC_GeneralControlPacket *GeneralControlPacketPtr;
  XHdmiC_AudioInfoFrame *AudioInfoFramePtr;</pre><pre>  AviInfoFramePtr = XV_HdmiRxSs_GetAviInfoframe(HdmiRxSsPtr);
  GeneralControlPacketPtr = XV_HdmiRxSs_GetGCP(HdmiRxSsPtr);
  AudioInfoFramePtr = XV_HdmiRxSs_GetAudioInfoframe(HdmiRxSsPtr);
  AuxPtr = XV_HdmiRxSs_GetAuxiliary(HdmiRxSsPtr);</pre><pre>  if(AuxPtr-&gt;Header.Byte[0] == AUX_VSIF_TYPE){
          // Retrieve Vendor Specific Info Frame
          XV_HdmiRxSs_RetrieveVSInfoframe(HdmiRxSsPtr);
  } else if(AuxPtr-&gt;Header.Byte[0] == AUX_AVI_INFOFRAME_TYPE){
          // Reset Avi InfoFrame
          (void)memset((void *)AviInfoFramePtr, 0, sizeof(XHdmiC_AVI_InfoFrame));
          // Parse Aux to retrieve Avi InfoFrame
          XV_HdmiC_ParseAVIInfoFrame(AuxPtr, AviInfoFramePtr);
          HdmiRxSsPtr-&gt;HdmiRxPtr-&gt;Stream.Video.ColorFormatId =
                                XV_HdmiRx_GetAviColorSpace(HdmiRxSsPtr-&gt;HdmiRxPtr);
          HdmiRxSsPtr-&gt;HdmiRxPtr-&gt;Stream.Vic =
                                XV_HdmiRx_GetAviVic(HdmiRxSsPtr-&gt;HdmiRxPtr);
          HdmiRxSsPtr-&gt;HdmiRxPtr-&gt;Stream.Video.AspectRatio =
                                XV_HdmiC_IFAspectRatio_To_XVidC(HdmiRxSsPtr-&gt;AVIInfoframe.PicAspectRatio);
  } else if(AuxPtr-&gt;Header.Byte[0] == AUX_GENERAL_CONTROL_PACKET_TYPE) {
          // Reset General Control Packet
          (void)memset((void *)GeneralControlPacketPtr, 0, sizeof(XHdmiC_GeneralControlPacket));
          // Parse Aux to retrieve General Control Packet
          XV_HdmiC_ParseGCP(AuxPtr, GeneralControlPacketPtr);
          // Stream.Video.ColorDepth is updated from the core during AUX INTR
  } else if(AuxPtr-&gt;Header.Byte[0] == AUX_AUDIO_INFOFRAME_TYPE) {
          // Reset Audio InfoFrame
          (void)memset((void *)AudioInfoFramePtr, 0, sizeof(XHdmiC_AudioInfoFrame));
          // Parse Aux to retrieve Audio InfoFrame
          XV_HdmiC_ParseAudioInfoFrame(AuxPtr, AudioInfoFramePtr);
  }</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;AuxCallback) {
      HdmiRxSsPtr-&gt;AuxCallback(HdmiRxSsPtr-&gt;AuxRef);
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX Sync Loss IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_SyncLossCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  if (HdmiRxSsPtr-&gt;HdmiRxPtr-&gt;Stream.SyncStatus ==
                                                                                                XV_HDMIRX_SYNCSTAT_SYNC_LOSS) {
  // Push sync loss event to HDCP event queue</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_SYNCLOSS, 0);</pre><pre>  }
  // Sync is recovered/establish
  else if (HdmiRxSsPtr-&gt;HdmiRxPtr-&gt;Stream.SyncStatus ==
                                                                                                 XV_HDMIRX_SYNCSTAT_SYNC_EST) {
          // Push sync loss event to HDCP event queue</pre><pre>          XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_SYNCEST, 0);</pre><pre>  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the mode has transitioned from DVI to HDMI or
  vice versa.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_ModeCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // HDMI mode
  if (XV_HdmiRxSs_GetVideoStreamType(HdmiRxSsPtr )) {</pre><pre>    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_HDMIMODE, 0);</pre><pre>  }</pre><pre>  // DVI mode
  else {</pre><pre>    XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_DVIMODE, 0);</pre><pre>  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the TMDS CLK ratio changes.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_TmdsClkRatioCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;TmdsClkRatioCallback) {
      HdmiRxSsPtr-&gt;TmdsClkRatioCallback(HdmiRxSsPtr-&gt;TmdsClkRatioRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function retrieves the Vendor Specific Info Frame.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_RetrieveVSInfoframe(XV_HdmiRxSs *HdmiRxSs)
{
  /** Vendor-Specific InfoFrame structure */
  XHdmiC_VSIF *VSIFPtr;
  VSIFPtr = XV_HdmiRxSs_GetVSIF(HdmiRxSs);</pre><pre>  if (HdmiRxSs-&gt;HdmiRxPtr-&gt;Aux.Header.Byte[0] == AUX_VSIF_TYPE) {
          // Reset Vendor Specific InfoFrame
          (void)memset((void *)VSIFPtr, 0, sizeof(XHdmiC_VSIF));</pre><pre>          XV_HdmiC_VSIF_ParsePacket(&amp;HdmiRxSs-&gt;HdmiRxPtr-&gt;Aux, VSIFPtr);</pre><pre>      // Defaults
      HdmiRxSs-&gt;HdmiRxPtr-&gt;Stream.Video.Is3D = FALSE;
      HdmiRxSs-&gt;HdmiRxPtr-&gt;Stream.Video.Info_3D.Format = XVIDC_3D_UNKNOWN;</pre><pre>      if (VSIFPtr-&gt;Format == XHDMIC_VSIF_VF_3D) {
          HdmiRxSs-&gt;HdmiRxPtr-&gt;Stream.Video.Is3D = TRUE;
          HdmiRxSs-&gt;HdmiRxPtr-&gt;Stream.Video.Info_3D = VSIFPtr-&gt;Info_3D.Stream;
      } else if (VSIFPtr-&gt;Format == XHDMIC_VSIF_VF_EXTRES) {
          switch(VSIFPtr-&gt;HDMI_VIC) {
              case 1 :
                  HdmiRxSs-&gt;HdmiRxPtr-&gt;Stream.Vic = 95;
                  break;</pre><pre>              case 2 :
                  HdmiRxSs-&gt;HdmiRxPtr-&gt;Stream.Vic = 94;
                  break;</pre><pre>              case 3 :
                  HdmiRxSs-&gt;HdmiRxPtr-&gt;Stream.Vic = 93;
                  break;</pre><pre>              case 4 :
                  HdmiRxSs-&gt;HdmiRxPtr-&gt;Stream.Vic = 98;
                  break;</pre><pre>              default :
                  break;
          }
      }
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX Audio IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_AudCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  u8 Channels;</pre><pre>  if (XV_HdmiRx_IsAudioActive(HdmiRxSsPtr-&gt;HdmiRxPtr)) {</pre><pre>    // Get audio channels
    Channels = XV_HdmiRx_GetAudioChannels(HdmiRxSsPtr-&gt;HdmiRxPtr);
    HdmiRxSsPtr-&gt;AudioChannels = Channels;
  }</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;AudCallback) {
      HdmiRxSsPtr-&gt;AudCallback(HdmiRxSsPtr-&gt;AudRef);
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX Link Status IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_LnkStaCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  HdmiRxSsPtr-&gt;IsLinkStatusErrMax =
    XV_HdmiRx_IsLinkStatusErrMax(HdmiRxSsPtr-&gt;HdmiRxPtr);</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_LINKSTATUS, 0);</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;LnkStaCallback) {
      HdmiRxSsPtr-&gt;LnkStaCallback(HdmiRxSsPtr-&gt;LnkStaRef);
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when a RX DDC IRQ has occurred.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_DdcCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;DdcCallback) {
      HdmiRxSsPtr-&gt;DdcCallback(HdmiRxSsPtr-&gt;DdcRef);
  }
}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the RX stream is down.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_StreamDownCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  /* Assert HDMI RX core resets */
  XV_HdmiRxSs_RXCore_VRST(HdmiRxSsPtr, TRUE);
  XV_HdmiRxSs_RXCore_LRST(HdmiRxSsPtr, TRUE);</pre><pre>  /* Assert SYSCLK VID_IN bridge reset */
  XV_HdmiRxSs_SYSRST(HdmiRxSsPtr, TRUE);</pre><pre>  /* Set stream up flag */
  HdmiRxSsPtr-&gt;IsStreamUp = (FALSE);</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMDOWN, 0);</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;StreamDownCallback) {
      HdmiRxSsPtr-&gt;StreamDownCallback(HdmiRxSsPtr-&gt;StreamDownRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the RX stream init .</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_StreamInitCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMINIT, 0);</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;StreamInitCallback) {
      HdmiRxSsPtr-&gt;StreamInitCallback(HdmiRxSsPtr-&gt;StreamInitRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function is called when the RX stream is up.</pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
******************************************************************************/
static void XV_HdmiRxSs_StreamUpCallback(void *CallbackRef)
{
  <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *HdmiRxSsPtr = (<a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> *)CallbackRef;</pre><pre>  /* Clear link Status error counters */
  XV_HdmiRx_ClearLinkStatus(HdmiRxSsPtr-&gt;HdmiRxPtr);</pre><pre>  /* Set stream up flag */
  HdmiRxSsPtr-&gt;IsStreamUp = (TRUE);</pre><pre>  XV_HdmiRxSs_LogWrite(HdmiRxSsPtr, XV_HDMIRXSS_LOG_EVT_STREAMUP, 0);</pre><pre>  /* Configure Remapper according to HW setting and video format */
  XV_HdmiRxSs_ConfigBridgeMode(HdmiRxSsPtr);</pre><pre>  // Check if user callback has been registered
  if (HdmiRxSsPtr-&gt;StreamUpCallback) {
      HdmiRxSsPtr-&gt;StreamUpCallback(HdmiRxSsPtr-&gt;StreamUpRef);
  }</pre><pre>}</pre><pre>/*****************************************************************************/
/**</pre><pre>  This function installs an asynchronous callback function for the given
  HandlerType:</pre><pre>  <pre>
  HandlerType                     Callback Function Type
  -----------------------         --------------------------------------------------
  (XV_HDMIRXSS_HANDLER_CONNECT)             HpdCallback
  (XV_HDMIRXSS_HANDLER_VS)                  VsCallback
  (XV_HDMIRXSS_HANDLER_STREAM_DOWN)         StreamDownCallback
  (XV_HDMIRXSS_HANDLER_STREAM_UP)           StreamUpCallback
  (XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATED)
  (XV_HDMIRXSS_HANDLER_HDCP_UNAUTHENTICATED)
  (XV_HDMIRXSS_HANDLER_HDCP_AUTHENTICATION_REQUEST)
  (XV_HDMIRXSS_HANDLER_HDCP_STREAM_MANAGE_REQUEST)
  (XV_HDMIRXSS_HANDLER_HDCP_TOPOLOGY_UPDATE)
  </pre></pre><pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the HDMI RX Subsystem instance.
</td></tr>
    <tr><td class="paramname">HandlerType</td><td>specifies the type of handler.
</td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the address of the callback function.
</td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a user data item that will be passed to the
        callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if callback function installed successfully.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been
        installed replaces it with the new handler.
</dd></dl>
</pre></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a277acac840c40692bcc133be2137a6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a277acac840c40692bcc133be2137a6e6">XV_HdmiRxSs_SetEdidParam</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 *EdidDataPtr, u16 Length)</td></tr>
<tr class="memdesc:a277acac840c40692bcc133be2137a6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function Sets the EDID parameters in the HDMI RX SS struct.  <a href="#a277acac840c40692bcc133be2137a6e6">More...</a><br /></td></tr>
<tr class="separator:a277acac840c40692bcc133be2137a6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158d8801dd2e574b12230ad44a1bf662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a158d8801dd2e574b12230ad44a1bf662">XV_HdmiRxSs_LoadDefaultEdid</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a158d8801dd2e574b12230ad44a1bf662"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the default EDID to the HDMI RX.  <a href="#a158d8801dd2e574b12230ad44a1bf662">More...</a><br /></td></tr>
<tr class="separator:a158d8801dd2e574b12230ad44a1bf662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd3689aa607f944f9eea1db1d37a2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#abfd3689aa607f944f9eea1db1d37a2f3">XV_HdmiRxSs_LoadEdid</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 *EdidDataPtr, u16 Length)</td></tr>
<tr class="memdesc:abfd3689aa607f944f9eea1db1d37a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the default EDID to the HDMI RX.  <a href="#abfd3689aa607f944f9eea1db1d37a2f3">More...</a><br /></td></tr>
<tr class="separator:abfd3689aa607f944f9eea1db1d37a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f531fa69066bf7cf1491d98b5a16e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a08f531fa69066bf7cf1491d98b5a16e0">XV_HdmiRxSs_SetHpd</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Value)</td></tr>
<tr class="memdesc:a08f531fa69066bf7cf1491d98b5a16e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the HPD on the HDMI RX.  <a href="#a08f531fa69066bf7cf1491d98b5a16e0">More...</a><br /></td></tr>
<tr class="separator:a08f531fa69066bf7cf1491d98b5a16e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e999c689d01ff3559e472f21c9757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a938e999c689d01ff3559e472f21c9757">XV_HdmiRxSs_ToggleHpd</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a938e999c689d01ff3559e472f21c9757"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function toggles the HPD on the HDMI RX.  <a href="#a938e999c689d01ff3559e472f21c9757">More...</a><br /></td></tr>
<tr class="separator:a938e999c689d01ff3559e472f21c9757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461c8c44a3dc58685afd72b911047ec4"><td class="memItemLeft" align="right" valign="top">XHdmiC_Aux *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a461c8c44a3dc58685afd72b911047ec4">XV_HdmiRxSs_GetAuxiliary</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a461c8c44a3dc58685afd72b911047ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS Aux structure.  <a href="#a461c8c44a3dc58685afd72b911047ec4">More...</a><br /></td></tr>
<tr class="separator:a461c8c44a3dc58685afd72b911047ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa671579897f973e1ad154ef39309a218"><td class="memItemLeft" align="right" valign="top">XHdmiC_AVI_InfoFrame *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#aa671579897f973e1ad154ef39309a218">XV_HdmiRxSs_GetAviInfoframe</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:aa671579897f973e1ad154ef39309a218"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS AVI InfoFrame structure.  <a href="#aa671579897f973e1ad154ef39309a218">More...</a><br /></td></tr>
<tr class="separator:aa671579897f973e1ad154ef39309a218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cfe6053ed992c9bd8c77428ad1e226"><td class="memItemLeft" align="right" valign="top">XHdmiC_GeneralControlPacket *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a57cfe6053ed992c9bd8c77428ad1e226">XV_HdmiRxSs_GetGCP</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a57cfe6053ed992c9bd8c77428ad1e226"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS General Control Packet structure.  <a href="#a57cfe6053ed992c9bd8c77428ad1e226">More...</a><br /></td></tr>
<tr class="separator:a57cfe6053ed992c9bd8c77428ad1e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f94117a349e62618cd03cefe3208af"><td class="memItemLeft" align="right" valign="top">XHdmiC_AudioInfoFrame *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a05f94117a349e62618cd03cefe3208af">XV_HdmiRxSs_GetAudioInfoframe</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a05f94117a349e62618cd03cefe3208af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS Audio InfoFrame structure.  <a href="#a05f94117a349e62618cd03cefe3208af">More...</a><br /></td></tr>
<tr class="separator:a05f94117a349e62618cd03cefe3208af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c089191afe311270bc5f83a83e69d5"><td class="memItemLeft" align="right" valign="top">XHdmiC_VSIF *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a76c089191afe311270bc5f83a83e69d5">XV_HdmiRxSs_GetVSIF</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a76c089191afe311270bc5f83a83e69d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS Vendor Specific InfoFrame structure.  <a href="#a76c089191afe311270bc5f83a83e69d5">More...</a><br /></td></tr>
<tr class="separator:a76c089191afe311270bc5f83a83e69d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6156f804fb138799bb3bd9a243dd36cf"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a6156f804fb138799bb3bd9a243dd36cf">XV_HdmiRxSs_SetStream</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u32 Clock, u32 LineRate)</td></tr>
<tr class="memdesc:a6156f804fb138799bb3bd9a243dd36cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set HDMI RX susbsystem stream parameters.  <a href="#a6156f804fb138799bb3bd9a243dd36cf">More...</a><br /></td></tr>
<tr class="separator:a6156f804fb138799bb3bd9a243dd36cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4f848d7fbcea5843ae8bab4d255e2e"><td class="memItemLeft" align="right" valign="top">XVidC_VideoStream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#acf4f848d7fbcea5843ae8bab4d255e2e">XV_HdmiRxSs_GetVideoStream</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:acf4f848d7fbcea5843ae8bab4d255e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS video stream.  <a href="#acf4f848d7fbcea5843ae8bab4d255e2e">More...</a><br /></td></tr>
<tr class="separator:acf4f848d7fbcea5843ae8bab4d255e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6f120b55c78fc21385878b3b930fe"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a3dd6f120b55c78fc21385878b3b930fe">XV_HdmiRxSs_GetVideoIDCode</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a3dd6f120b55c78fc21385878b3b930fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS video Identification code.  <a href="#a3dd6f120b55c78fc21385878b3b930fe">More...</a><br /></td></tr>
<tr class="separator:a3dd6f120b55c78fc21385878b3b930fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aabf114a6d9281ca99d9128a3932cdc"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a9aabf114a6d9281ca99d9128a3932cdc">XV_HdmiRxSs_GetVideoStreamType</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a9aabf114a6d9281ca99d9128a3932cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS video stream type.  <a href="#a9aabf114a6d9281ca99d9128a3932cdc">More...</a><br /></td></tr>
<tr class="separator:a9aabf114a6d9281ca99d9128a3932cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a85190f1a8a689e520e612dd2d57d8"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#ab8a85190f1a8a689e520e612dd2d57d8">XV_HdmiRxSs_GetVideoStreamScramblingFlag</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:ab8a85190f1a8a689e520e612dd2d57d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to HDMI RX SS video stream type.  <a href="#ab8a85190f1a8a689e520e612dd2d57d8">More...</a><br /></td></tr>
<tr class="separator:ab8a85190f1a8a689e520e612dd2d57d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9800e58c46167ce458da016451f88c8d"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a9800e58c46167ce458da016451f88c8d">XV_HdmiRxSs_GetAudioChannels</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a9800e58c46167ce458da016451f88c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the HDMI RX SS number of active audio channels.  <a href="#a9800e58c46167ce458da016451f88c8d">More...</a><br /></td></tr>
<tr class="separator:a9800e58c46167ce458da016451f88c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e45e8b7892c815eab9b50c39790f10"><td class="memItemLeft" align="right" valign="top">XV_HdmiRx_AudioFormatType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a64e45e8b7892c815eab9b50c39790f10">XV_HdmiRxSs_GetAudioFormat</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a64e45e8b7892c815eab9b50c39790f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the HDMI RX SS audio format.  <a href="#a64e45e8b7892c815eab9b50c39790f10">More...</a><br /></td></tr>
<tr class="separator:a64e45e8b7892c815eab9b50c39790f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc056437ab2bb79bc929f7791db5f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#abdc056437ab2bb79bc929f7791db5f95">XV_HdmiRxSs_RefClockChangeInit</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:abdc056437ab2bb79bc929f7791db5f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called when HDMI RX SS TMDS clock changes.  <a href="#abdc056437ab2bb79bc929f7791db5f95">More...</a><br /></td></tr>
<tr class="separator:abdc056437ab2bb79bc929f7791db5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984feecc99028c5ab95d99e7087e329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#ab984feecc99028c5ab95d99e7087e329">XV_HdmiRxSs_ReportSubcoreVersion</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:ab984feecc99028c5ab95d99e7087e329"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the HDMI RX SS subcore versions.  <a href="#ab984feecc99028c5ab95d99e7087e329">More...</a><br /></td></tr>
<tr class="separator:ab984feecc99028c5ab95d99e7087e329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b31675082ff4bc8968c3f4ab5acff4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a0b31675082ff4bc8968c3f4ab5acff4a">XV_HdmiRxSs_IsStreamUp</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a0b31675082ff4bc8968c3f4ab5acff4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the video stream is up.  <a href="#a0b31675082ff4bc8968c3f4ab5acff4a">More...</a><br /></td></tr>
<tr class="separator:a0b31675082ff4bc8968c3f4ab5acff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eb5417ad17c232be0b46588069a330"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a37eb5417ad17c232be0b46588069a330">XV_HdmiRxSs_IsStreamConnected</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr)</td></tr>
<tr class="memdesc:a37eb5417ad17c232be0b46588069a330"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the interface is connected.  <a href="#a37eb5417ad17c232be0b46588069a330">More...</a><br /></td></tr>
<tr class="separator:a37eb5417ad17c232be0b46588069a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b6769e137d23ae6a4fe0d61864f5cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a93b6769e137d23ae6a4fe0d61864f5cd">XV_HdmiRxSs_SetDefaultPpc</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:a93b6769e137d23ae6a4fe0d61864f5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the default in HDF.  <a href="#a93b6769e137d23ae6a4fe0d61864f5cd">More...</a><br /></td></tr>
<tr class="separator:a93b6769e137d23ae6a4fe0d61864f5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7296f98d74b618438a08c0bb4d303350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a7296f98d74b618438a08c0bb4d303350">XV_HdmiRxSs_SetPpc</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Id, u8 Ppc)</td></tr>
<tr class="memdesc:a7296f98d74b618438a08c0bb4d303350"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set PPC specified by user.  <a href="#a7296f98d74b618438a08c0bb4d303350">More...</a><br /></td></tr>
<tr class="separator:a7296f98d74b618438a08c0bb4d303350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8f4247ffd9a6540e8aed78e23699a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#a3c8f4247ffd9a6540e8aed78e23699a7">XV_HdmiRxSS_SetAppVersion</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 maj, u8 min)</td></tr>
<tr class="memdesc:a3c8f4247ffd9a6540e8aed78e23699a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the major and minor application version in RXSs struct.  <a href="#a3c8f4247ffd9a6540e8aed78e23699a7">More...</a><br /></td></tr>
<tr class="separator:a3c8f4247ffd9a6540e8aed78e23699a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf6577a7f6af0c3e2da373f736ca49e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__hdmirxss_8c.html#afbf6577a7f6af0c3e2da373f736ca49e">XV_HdmiRxSs_AudioMute</a> (<a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *InstancePtr, u8 Enable)</td></tr>
<tr class="memdesc:afbf6577a7f6af0c3e2da373f736ca49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set HDMI RX audio parameters.  <a href="#afbf6577a7f6af0c3e2da373f736ca49e">More...</a><br /></td></tr>
<tr class="separator:afbf6577a7f6af0c3e2da373f736ca49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afbf6577a7f6af0c3e2da373f736ca49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf6577a7f6af0c3e2da373f736ca49e">&#9670;&nbsp;</a></span>XV_HdmiRxSs_AudioMute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_AudioMute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function set HDMI RX audio parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Enable</td><td>0: Unmute the audio 1: Mute the audio.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a9800e58c46167ce458da016451f88c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9800e58c46167ce458da016451f88c8d">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetAudioChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRxSs_GetAudioChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the HDMI RX SS number of active audio channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Channels</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a51cc4ea97fa0b2aa6987cd0ef7e8d58a">XV_HdmiRxSs::AudioChannels</a>.</p>

</div>
</div>
<a id="a64e45e8b7892c815eab9b50c39790f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e45e8b7892c815eab9b50c39790f10">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetAudioFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XV_HdmiRx_AudioFormatType XV_HdmiRxSs_GetAudioFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the HDMI RX SS audio format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Channels</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a05f94117a349e62618cd03cefe3208af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f94117a349e62618cd03cefe3208af">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetAudioInfoframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XHdmiC_AudioInfoFrame* XV_HdmiRxSs_GetAudioInfoframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS Audio InfoFrame structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to XV_HdmiRXSs instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XHdmiC_AudioInfoFrame pointer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a59073c58e4cdc43aae7bccbc16019954">XV_HdmiRxSs::AudioInfoframe</a>.</p>

</div>
</div>
<a id="a461c8c44a3dc58685afd72b911047ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461c8c44a3dc58685afd72b911047ec4">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetAuxiliary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XHdmiC_Aux* XV_HdmiRxSs_GetAuxiliary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS Aux structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XVidC_VideoStream pointer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="aa671579897f973e1ad154ef39309a218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa671579897f973e1ad154ef39309a218">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetAviInfoframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XHdmiC_AVI_InfoFrame* XV_HdmiRxSs_GetAviInfoframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS AVI InfoFrame structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to XV_HdmiRXSs instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XHdmiC_AVI_InfoFrame pointer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a4800880ca561a559d9f2c6fcc75a2c32">XV_HdmiRxSs::AVIInfoframe</a>.</p>

</div>
</div>
<a id="a57cfe6053ed992c9bd8c77428ad1e226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cfe6053ed992c9bd8c77428ad1e226">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetGCP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XHdmiC_GeneralControlPacket* XV_HdmiRxSs_GetGCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS General Control Packet structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to XV_HdmiRXSs instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XHdmiC_GeneralControlPacket pointer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a15566d0e8b2bab5ebed734b5ff942748">XV_HdmiRxSs::GCP</a>.</p>

</div>
</div>
<a id="a3dd6f120b55c78fc21385878b3b930fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd6f120b55c78fc21385878b3b930fe">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVideoIDCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRxSs_GetVideoIDCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS video Identification code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VIC</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="acf4f848d7fbcea5843ae8bab4d255e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4f848d7fbcea5843ae8bab4d255e2e">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVideoStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XVidC_VideoStream* XV_HdmiRxSs_GetVideoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS video stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XVidC_VideoStream pointer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="ab8a85190f1a8a689e520e612dd2d57d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a85190f1a8a689e520e612dd2d57d8">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVideoStreamScramblingFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRxSs_GetVideoStreamScramblingFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS video stream type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stream Type 1:IsScrambled 0: not Scrambled</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a9aabf114a6d9281ca99d9128a3932cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aabf114a6d9281ca99d9128a3932cdc">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVideoStreamType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XV_HdmiRxSs_GetVideoStreamType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS video stream type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stream Type 1:HDMI 0:DVI</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a76c089191afe311270bc5f83a83e69d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c089191afe311270bc5f83a83e69d5">&#9670;&nbsp;</a></span>XV_HdmiRxSs_GetVSIF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XHdmiC_VSIF* XV_HdmiRxSs_GetVSIF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to HDMI RX SS Vendor Specific InfoFrame structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XHdmiC_VSIF pointer</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#aed8607cabba43e5efcf59aba9b810ff4">XV_HdmiRxSs::VSIF</a>.</p>

</div>
</div>
<a id="a37eb5417ad17c232be0b46588069a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eb5417ad17c232be0b46588069a330">&#9670;&nbsp;</a></span>XV_HdmiRxSs_IsStreamConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRxSs_IsStreamConnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the interface is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if interface is connected.</li>
<li>FALSE if interface is not connected.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#aec331a506d29a1b33d817ef68c2ad429">XV_HdmiRxSs::IsStreamConnected</a>.</p>

</div>
</div>
<a id="a0b31675082ff4bc8968c3f4ab5acff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b31675082ff4bc8968c3f4ab5acff4a">&#9670;&nbsp;</a></span>XV_HdmiRxSs_IsStreamUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_HdmiRxSs_IsStreamUp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the video stream is up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if stream is up.</li>
<li>FALSE if stream is down.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a56f7512abbb2a096ac259d40132f4628">XV_HdmiRxSs::IsStreamUp</a>.</p>

</div>
</div>
<a id="a158d8801dd2e574b12230ad44a1bf662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158d8801dd2e574b12230ad44a1bf662">&#9670;&nbsp;</a></span>XV_HdmiRxSs_LoadDefaultEdid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_LoadDefaultEdid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads the default EDID to the HDMI RX. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a0275583454eea8db5b073368ae009905">XV_HdmiRxSs::EdidLength</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a2ec65acd67fc707df2287d473f107814">XV_HdmiRxSs::EdidPtr</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="abfd3689aa607f944f9eea1db1d37a2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd3689aa607f944f9eea1db1d37a2f3">&#9670;&nbsp;</a></span>XV_HdmiRxSs_LoadEdid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_LoadEdid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>EdidDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads the default EDID to the HDMI RX. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="abdc056437ab2bb79bc929f7791db5f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc056437ab2bb79bc929f7791db5f95">&#9670;&nbsp;</a></span>XV_HdmiRxSs_RefClockChangeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_RefClockChangeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called when HDMI RX SS TMDS clock changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#aaccf9db2828b2d0ee5f6e05e80665a9d">XV_HdmiRxSs::TMDSClockRatio</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a9703ad76bc27e43a049a13ee81dc235a">XV_HDMIRXSS_LOG_EVT_REFCLOCKCHANGE</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

</div>
</div>
<a id="ab984feecc99028c5ab95d99e7087e329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984feecc99028c5ab95d99e7087e329">&#9670;&nbsp;</a></span>XV_HdmiRxSs_ReportSubcoreVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_ReportSubcoreVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints the HDMI RX SS subcore versions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a3c8f4247ffd9a6540e8aed78e23699a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8f4247ffd9a6540e8aed78e23699a7">&#9670;&nbsp;</a></span>XV_HdmiRxSS_SetAppVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSS_SetAppVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>maj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>min</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set the major and minor application version in RXSs struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> core instance. </td></tr>
    <tr><td class="paramname">maj</td><td>is the major version of the application. </td></tr>
    <tr><td class="paramname">min</td><td>is the minor version of the application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a50546d3a788308c4bfb0becf4ad5788c">XV_HdmiRxSs::AppMajVer</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss.html#a9d621556655d6495476016c5e9e6506a">XV_HdmiRxSs::AppMinVer</a>.</p>

</div>
</div>
<a id="a93b6769e137d23ae6a4fe0d61864f5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b6769e137d23ae6a4fe0d61864f5cd">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetDefaultPpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetDefaultPpc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set the default in HDF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> core instance. </td></tr>
    <tr><td class="paramname">Id</td><td>is the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> ID to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a277acac840c40692bcc133be2137a6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277acac840c40692bcc133be2137a6e6">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetEdidParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetEdidParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>EdidDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function Sets the EDID parameters in the HDMI RX SS struct. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a0275583454eea8db5b073368ae009905">XV_HdmiRxSs::EdidLength</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss.html#a2ec65acd67fc707df2287d473f107814">XV_HdmiRxSs::EdidPtr</a>.</p>

</div>
</div>
<a id="a08f531fa69066bf7cf1491d98b5a16e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f531fa69066bf7cf1491d98b5a16e0">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetHpd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetHpd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the HPD on the HDMI RX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>is a flag used to set the HPD.<ul>
<li>TRUE drives HPD high</li>
<li>FALSE drives HPD low</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
<a id="a7296f98d74b618438a08c0bb4d303350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7296f98d74b618438a08c0bb4d303350">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetPpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_SetPpc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Ppc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will set PPC specified by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> core instance. </td></tr>
    <tr><td class="paramname">Id</td><td>is the <a class="el" href="struct_x_v___hdmi_rx_ss.html" title="The XVprocss driver instance data. ">XV_HdmiRxSs</a> ID to operate on. </td></tr>
    <tr><td class="paramname">Ppc</td><td>is the PPC to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, and <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ae3bc6c803098c13d8b8d6bce5920c10f">XV_HdmiRxSs_Config::Ppc</a>.</p>

</div>
</div>
<a id="a6156f804fb138799bb3bd9a243dd36cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6156f804fb138799bb3bd9a243dd36cf">&#9670;&nbsp;</a></span>XV_HdmiRxSs_SetStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_HdmiRxSs_SetStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>LineRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function set HDMI RX susbsystem stream parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated TMDS Clock</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#af4a869965ee18d575d19b4319be08ff0">XV_HdmiRxSs::Config</a>, <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>, <a class="el" href="struct_x_v___hdmi_rx_ss___config.html#ae3bc6c803098c13d8b8d6bce5920c10f">XV_HdmiRxSs_Config::Ppc</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a86cd289bd97f705a1b5c7327047b928c">XV_HDMIRXSS_LOG_EVT_SETSTREAM</a>, <a class="el" href="xv__hdmirxss_8h.html#a801bb980bfbb34a0663bbe062e040a15a025e9ebc6c9fc794a24b81c71fbaf7ee">XV_HDMIRXSS_LOG_EVT_SETSTREAM_ERR</a>, and <a class="el" href="xv__hdmirxss_8h.html#a56c28560c5de8682b22f96d40fa4e24d">XV_HdmiRxSs_LogWrite()</a>.</p>

</div>
</div>
<a id="a938e999c689d01ff3559e472f21c9757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938e999c689d01ff3559e472f21c9757">&#9670;&nbsp;</a></span>XV_HdmiRxSs_ToggleHpd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_HdmiRxSs_ToggleHpd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v___hdmi_rx_ss.html">XV_HdmiRxSs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function toggles the HPD on the HDMI RX. </p>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_v___hdmi_rx_ss.html#a3d76e27b48746aa888d284583ce9399a">XV_HdmiRxSs::HdmiRxPtr</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
