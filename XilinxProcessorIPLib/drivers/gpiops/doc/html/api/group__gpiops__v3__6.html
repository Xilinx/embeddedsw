<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>gpiops: Gpiops_v3_6</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">gpiops
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__gpiops__v3__6.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Gpiops_v3_6</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_gpio_ps___config.html">XGpioPs_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for a device.  <a href="struct_x_gpio_ps___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_gpio_ps.html">XGpioPs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> driver instance data.  <a href="struct_x_gpio_ps.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1e440e05bbea534ebf6939e88eb1455f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga1e440e05bbea534ebf6939e88eb1455f">XGPIOPS_BANK_MAX_PINS</a>&#160;&#160;&#160;(u32)32</td></tr>
<tr class="memdesc:ga1e440e05bbea534ebf6939e88eb1455f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max pins in a GPIO bank.  <a href="#ga1e440e05bbea534ebf6939e88eb1455f">More...</a><br/></td></tr>
<tr class="separator:ga1e440e05bbea534ebf6939e88eb1455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c6fe277747f034cd30c3f3e770dc5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gac5c6fe277747f034cd30c3f3e770dc5b">XGPIOPS_BANK0</a>&#160;&#160;&#160;0x00U</td></tr>
<tr class="memdesc:gac5c6fe277747f034cd30c3f3e770dc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO Bank 0.  <a href="#gac5c6fe277747f034cd30c3f3e770dc5b">More...</a><br/></td></tr>
<tr class="separator:gac5c6fe277747f034cd30c3f3e770dc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88ebd56b0defc49ebd308951df1eaf0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga88ebd56b0defc49ebd308951df1eaf0e">XGPIOPS_BANK1</a>&#160;&#160;&#160;0x01U</td></tr>
<tr class="memdesc:ga88ebd56b0defc49ebd308951df1eaf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO Bank 1.  <a href="#ga88ebd56b0defc49ebd308951df1eaf0e">More...</a><br/></td></tr>
<tr class="separator:ga88ebd56b0defc49ebd308951df1eaf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57e0fee992d409f0ff32d35e68f6fbc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gae57e0fee992d409f0ff32d35e68f6fbc">XGPIOPS_BANK2</a>&#160;&#160;&#160;0x02U</td></tr>
<tr class="memdesc:gae57e0fee992d409f0ff32d35e68f6fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO Bank 2.  <a href="#gae57e0fee992d409f0ff32d35e68f6fbc">More...</a><br/></td></tr>
<tr class="separator:gae57e0fee992d409f0ff32d35e68f6fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac994de03aa64e2b6b3c6b6da9d76e020"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gac994de03aa64e2b6b3c6b6da9d76e020">XGPIOPS_BANK3</a>&#160;&#160;&#160;0x03U</td></tr>
<tr class="memdesc:gac994de03aa64e2b6b3c6b6da9d76e020"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO Bank 3.  <a href="#gac994de03aa64e2b6b3c6b6da9d76e020">More...</a><br/></td></tr>
<tr class="separator:gac994de03aa64e2b6b3c6b6da9d76e020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8661a0444fd67d2b87a14b3c196e571"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gab8661a0444fd67d2b87a14b3c196e571">XGPIOPS_MAX_BANKS_ZYNQMP</a>&#160;&#160;&#160;0x06U</td></tr>
<tr class="memdesc:gab8661a0444fd67d2b87a14b3c196e571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max banks in a Zynq Ultrascale+ MP GPIO device.  <a href="#gab8661a0444fd67d2b87a14b3c196e571">More...</a><br/></td></tr>
<tr class="separator:gab8661a0444fd67d2b87a14b3c196e571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b466ba78cf142027ca998d0d67d2e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga27b466ba78cf142027ca998d0d67d2e0">XGPIOPS_MAX_BANKS</a>&#160;&#160;&#160;0x04U</td></tr>
<tr class="memdesc:ga27b466ba78cf142027ca998d0d67d2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max banks in a Zynq GPIO device.  <a href="#ga27b466ba78cf142027ca998d0d67d2e0">More...</a><br/></td></tr>
<tr class="separator:ga27b466ba78cf142027ca998d0d67d2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f80173cb28cbac5bab53c4fc7c7dd96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga8f80173cb28cbac5bab53c4fc7c7dd96">XGPIOPS_DEVICE_MAX_PIN_NUM_ZYNQMP</a>&#160;&#160;&#160;(u32)174</td></tr>
<tr class="memdesc:ga8f80173cb28cbac5bab53c4fc7c7dd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max pins in the Zynq Ultrascale+ MP GPIO device 0 - 25, Bank 0 26 - 51, Bank 1 52 - 77, Bank 2 78 - 109, Bank 3 110 - 141, Bank 4 142 - 173, Bank 5.  <a href="#ga8f80173cb28cbac5bab53c4fc7c7dd96">More...</a><br/></td></tr>
<tr class="separator:ga8f80173cb28cbac5bab53c4fc7c7dd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d70822b76e1dd3fda458ed693a082af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga6d70822b76e1dd3fda458ed693a082af">XGPIOPS_DEVICE_MAX_PIN_NUM</a>&#160;&#160;&#160;(u32)118</td></tr>
<tr class="memdesc:ga6d70822b76e1dd3fda458ed693a082af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max pins in the Zynq GPIO device 0 - 31, Bank 0 32 - 53, Bank 1 54 - 85, Bank 2 86 - 117, Bank 3.  <a href="#ga6d70822b76e1dd3fda458ed693a082af">More...</a><br/></td></tr>
<tr class="separator:ga6d70822b76e1dd3fda458ed693a082af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff08ac5be0729f046324cae2706aaf9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>(BaseAddr, RegOffset)&#160;&#160;&#160;Xil_In32((BaseAddr) + (u32)(RegOffset))</td></tr>
<tr class="memdesc:gaff08ac5be0729f046324cae2706aaf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro reads the given register.  <a href="#gaff08ac5be0729f046324cae2706aaf9a">More...</a><br/></td></tr>
<tr class="separator:gaff08ac5be0729f046324cae2706aaf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad586332c0958c5044450d735127337"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>(BaseAddr, RegOffset, Data)&#160;&#160;&#160;Xil_Out32((BaseAddr) + (u32)(RegOffset), (u32)(Data))</td></tr>
<tr class="memdesc:ga3ad586332c0958c5044450d735127337"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro writes to the given register.  <a href="#ga3ad586332c0958c5044450d735127337">More...</a><br/></td></tr>
<tr class="separator:ga3ad586332c0958c5044450d735127337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2349a384fe8a39f89168780f84940efc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga2349a384fe8a39f89168780f84940efc">XGpioPs_Handler</a> )(void *CallBackRef, u32 Bank, u32 Status)</td></tr>
<tr class="memdesc:ga2349a384fe8a39f89168780f84940efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This handler data type allows the user to define a callback function to handle the interrupts for the GPIO device.  <a href="#ga2349a384fe8a39f89168780f84940efc">More...</a><br/></td></tr>
<tr class="separator:ga2349a384fe8a39f89168780f84940efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaac891da3a0b1ed5697644d621483ed62"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gaac891da3a0b1ed5697644d621483ed62">XGpioPs_Read</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank)</td></tr>
<tr class="memdesc:gaac891da3a0b1ed5697644d621483ed62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the Data register of the specified GPIO bank.  <a href="#gaac891da3a0b1ed5697644d621483ed62">More...</a><br/></td></tr>
<tr class="separator:gaac891da3a0b1ed5697644d621483ed62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af7399d35110ae5f71be57316a2b9ee"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga5af7399d35110ae5f71be57316a2b9ee">XGpioPs_ReadPin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:ga5af7399d35110ae5f71be57316a2b9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Data from the specified pin.  <a href="#ga5af7399d35110ae5f71be57316a2b9ee">More...</a><br/></td></tr>
<tr class="separator:ga5af7399d35110ae5f71be57316a2b9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f55b3804d13293880455a79d4f45e37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga0f55b3804d13293880455a79d4f45e37">XGpioPs_Write</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank, u32 Data)</td></tr>
<tr class="memdesc:ga0f55b3804d13293880455a79d4f45e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the Data register of the specified GPIO bank.  <a href="#ga0f55b3804d13293880455a79d4f45e37">More...</a><br/></td></tr>
<tr class="separator:ga0f55b3804d13293880455a79d4f45e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ff633d57fb32cac3424571ba690332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gab9ff633d57fb32cac3424571ba690332">XGpioPs_WritePin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin, u32 Data)</td></tr>
<tr class="memdesc:gab9ff633d57fb32cac3424571ba690332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the specified pin.  <a href="#gab9ff633d57fb32cac3424571ba690332">More...</a><br/></td></tr>
<tr class="separator:gab9ff633d57fb32cac3424571ba690332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9fbd0037438e57fa33d096ac724613"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gaab9fbd0037438e57fa33d096ac724613">XGpioPs_SetDirection</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank, u32 Direction)</td></tr>
<tr class="memdesc:gaab9fbd0037438e57fa33d096ac724613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Direction of the pins of the specified GPIO Bank.  <a href="#gaab9fbd0037438e57fa33d096ac724613">More...</a><br/></td></tr>
<tr class="separator:gaab9fbd0037438e57fa33d096ac724613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbd9e1081b8ed84d38b475fc89271cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga7cbd9e1081b8ed84d38b475fc89271cf">XGpioPs_SetDirectionPin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin, u32 Direction)</td></tr>
<tr class="memdesc:ga7cbd9e1081b8ed84d38b475fc89271cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Direction of the specified pin.  <a href="#ga7cbd9e1081b8ed84d38b475fc89271cf">More...</a><br/></td></tr>
<tr class="separator:ga7cbd9e1081b8ed84d38b475fc89271cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb1bb1c621ea32f0b14c9ee47c23319"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga7eb1bb1c621ea32f0b14c9ee47c23319">XGpioPs_GetDirection</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank)</td></tr>
<tr class="memdesc:ga7eb1bb1c621ea32f0b14c9ee47c23319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Direction of the pins of the specified GPIO Bank.  <a href="#ga7eb1bb1c621ea32f0b14c9ee47c23319">More...</a><br/></td></tr>
<tr class="separator:ga7eb1bb1c621ea32f0b14c9ee47c23319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3bacad17006e4b01ff91f6f14e5d3f7"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gaa3bacad17006e4b01ff91f6f14e5d3f7">XGpioPs_GetDirectionPin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:gaa3bacad17006e4b01ff91f6f14e5d3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Direction of the specified pin.  <a href="#gaa3bacad17006e4b01ff91f6f14e5d3f7">More...</a><br/></td></tr>
<tr class="separator:gaa3bacad17006e4b01ff91f6f14e5d3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1ae54b29cedd921fbe9f6ef503ceef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga7c1ae54b29cedd921fbe9f6ef503ceef">XGpioPs_SetOutputEnable</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank, u32 OpEnable)</td></tr>
<tr class="memdesc:ga7c1ae54b29cedd921fbe9f6ef503ceef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Output Enable of the pins of the specified GPIO Bank.  <a href="#ga7c1ae54b29cedd921fbe9f6ef503ceef">More...</a><br/></td></tr>
<tr class="separator:ga7c1ae54b29cedd921fbe9f6ef503ceef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841cc1098a21bdedec893545f15b025a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga841cc1098a21bdedec893545f15b025a">XGpioPs_SetOutputEnablePin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin, u32 OpEnable)</td></tr>
<tr class="memdesc:ga841cc1098a21bdedec893545f15b025a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Output Enable of the specified pin.  <a href="#ga841cc1098a21bdedec893545f15b025a">More...</a><br/></td></tr>
<tr class="separator:ga841cc1098a21bdedec893545f15b025a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7977b334cb165a1cc2859b1bc1ac43df"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga7977b334cb165a1cc2859b1bc1ac43df">XGpioPs_GetOutputEnable</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank)</td></tr>
<tr class="memdesc:ga7977b334cb165a1cc2859b1bc1ac43df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Output Enable status of the pins of the specified GPIO Bank.  <a href="#ga7977b334cb165a1cc2859b1bc1ac43df">More...</a><br/></td></tr>
<tr class="separator:ga7977b334cb165a1cc2859b1bc1ac43df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17714eeb15fff954fc42d6008e67af17"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga17714eeb15fff954fc42d6008e67af17">XGpioPs_GetOutputEnablePin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:ga17714eeb15fff954fc42d6008e67af17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Output Enable status of the specified pin.  <a href="#ga17714eeb15fff954fc42d6008e67af17">More...</a><br/></td></tr>
<tr class="separator:ga17714eeb15fff954fc42d6008e67af17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d1a36c4d70788e5ebf2ae583fc93e7"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga07d1a36c4d70788e5ebf2ae583fc93e7">XGpioPs_SelfTest</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga07d1a36c4d70788e5ebf2ae583fc93e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function runs a self-test on the GPIO driver/device.  <a href="#ga07d1a36c4d70788e5ebf2ae583fc93e7">More...</a><br/></td></tr>
<tr class="separator:ga07d1a36c4d70788e5ebf2ae583fc93e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46cd4bf296c2706642dec85d0f0752be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga46cd4bf296c2706642dec85d0f0752be">XGpioPs_IntrEnable</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank, u32 Mask)</td></tr>
<tr class="memdesc:ga46cd4bf296c2706642dec85d0f0752be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the interrupts for the specified pins in the specified bank.  <a href="#ga46cd4bf296c2706642dec85d0f0752be">More...</a><br/></td></tr>
<tr class="separator:ga46cd4bf296c2706642dec85d0f0752be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d609e179e7167128bb6517e735c4cf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga6d609e179e7167128bb6517e735c4cf7">XGpioPs_IntrDisable</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank, u32 Mask)</td></tr>
<tr class="memdesc:ga6d609e179e7167128bb6517e735c4cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the interrupts for the specified pins in the specified bank.  <a href="#ga6d609e179e7167128bb6517e735c4cf7">More...</a><br/></td></tr>
<tr class="separator:ga6d609e179e7167128bb6517e735c4cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad995f8c0ff2801d22cc405dacb3ed19"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gaad995f8c0ff2801d22cc405dacb3ed19">XGpioPs_IntrGetEnabled</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank)</td></tr>
<tr class="memdesc:gaad995f8c0ff2801d22cc405dacb3ed19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the interrupt enable status for a bank.  <a href="#gaad995f8c0ff2801d22cc405dacb3ed19">More...</a><br/></td></tr>
<tr class="separator:gaad995f8c0ff2801d22cc405dacb3ed19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47fc6f53355030ef41927f38fe37753f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga47fc6f53355030ef41927f38fe37753f">XGpioPs_IntrGetStatus</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank)</td></tr>
<tr class="memdesc:ga47fc6f53355030ef41927f38fe37753f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns interrupt status read from Interrupt Status Register.  <a href="#ga47fc6f53355030ef41927f38fe37753f">More...</a><br/></td></tr>
<tr class="separator:ga47fc6f53355030ef41927f38fe37753f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8ee040fe190af86afe59ec1bc3201c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gace8ee040fe190af86afe59ec1bc3201c">XGpioPs_IntrClear</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank, u32 Mask)</td></tr>
<tr class="memdesc:gace8ee040fe190af86afe59ec1bc3201c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears pending interrupt(s) with the provided mask.  <a href="#gace8ee040fe190af86afe59ec1bc3201c">More...</a><br/></td></tr>
<tr class="separator:gace8ee040fe190af86afe59ec1bc3201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac729652384b6d04711a9d1f2a62aee1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gac729652384b6d04711a9d1f2a62aee1d">XGpioPs_SetIntrType</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank, u32 IntrType, u32 IntrPolarity, u32 IntrOnAny)</td></tr>
<tr class="memdesc:gac729652384b6d04711a9d1f2a62aee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used for setting the Interrupt Type, Interrupt Polarity and Interrupt On Any for the specified GPIO Bank pins.  <a href="#gac729652384b6d04711a9d1f2a62aee1d">More...</a><br/></td></tr>
<tr class="separator:gac729652384b6d04711a9d1f2a62aee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed18cb81aceda214dba440cf6ff3d0ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gaed18cb81aceda214dba440cf6ff3d0ec">XGpioPs_GetIntrType</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u8 Bank, u32 *IntrType, u32 *IntrPolarity, u32 *IntrOnAny)</td></tr>
<tr class="memdesc:gaed18cb81aceda214dba440cf6ff3d0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used for getting the Interrupt Type, Interrupt Polarity and Interrupt On Any for the specified GPIO Bank pins.  <a href="#gaed18cb81aceda214dba440cf6ff3d0ec">More...</a><br/></td></tr>
<tr class="separator:gaed18cb81aceda214dba440cf6ff3d0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd63e0e5c7ed18517d54104e4ad6dcd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gacd63e0e5c7ed18517d54104e4ad6dcd4">XGpioPs_SetCallbackHandler</a> (<a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, void *CallBackRef, <a class="el" href="group__gpiops__v3__6.html#ga2349a384fe8a39f89168780f84940efc">XGpioPs_Handler</a> FuncPointer)</td></tr>
<tr class="memdesc:gacd63e0e5c7ed18517d54104e4ad6dcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the status callback function.  <a href="#gacd63e0e5c7ed18517d54104e4ad6dcd4">More...</a><br/></td></tr>
<tr class="separator:gacd63e0e5c7ed18517d54104e4ad6dcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0478d095fee0db04a29b43436306ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gafd0478d095fee0db04a29b43436306ef">XGpioPs_IntrHandler</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr)</td></tr>
<tr class="memdesc:gafd0478d095fee0db04a29b43436306ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for GPIO interrupts.It checks the interrupt status registers of all the banks to determine the actual bank in which an interrupt has been triggered.  <a href="#gafd0478d095fee0db04a29b43436306ef">More...</a><br/></td></tr>
<tr class="separator:gafd0478d095fee0db04a29b43436306ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef808e6f8e113ba1371f44c35b1d0d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga4ef808e6f8e113ba1371f44c35b1d0d9">XGpioPs_SetIntrTypePin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin, u8 IrqType)</td></tr>
<tr class="memdesc:ga4ef808e6f8e113ba1371f44c35b1d0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used for setting the IRQ Type of a single GPIO pin.  <a href="#ga4ef808e6f8e113ba1371f44c35b1d0d9">More...</a><br/></td></tr>
<tr class="separator:ga4ef808e6f8e113ba1371f44c35b1d0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga848274dc058043932e802a3caa39db3e"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga848274dc058043932e802a3caa39db3e">XGpioPs_GetIntrTypePin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:ga848274dc058043932e802a3caa39db3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the IRQ Type of a given GPIO pin.  <a href="#ga848274dc058043932e802a3caa39db3e">More...</a><br/></td></tr>
<tr class="separator:ga848274dc058043932e802a3caa39db3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2611a2a677a92a057ec8dd4ae8273766"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga2611a2a677a92a057ec8dd4ae8273766">XGpioPs_IntrEnablePin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:ga2611a2a677a92a057ec8dd4ae8273766"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the interrupt for the specified pin.  <a href="#ga2611a2a677a92a057ec8dd4ae8273766">More...</a><br/></td></tr>
<tr class="separator:ga2611a2a677a92a057ec8dd4ae8273766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975ad0c4e61d3b92c3f9886a24ff2c1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga975ad0c4e61d3b92c3f9886a24ff2c1f">XGpioPs_IntrDisablePin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:ga975ad0c4e61d3b92c3f9886a24ff2c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the interrupts for the specified pin.  <a href="#ga975ad0c4e61d3b92c3f9886a24ff2c1f">More...</a><br/></td></tr>
<tr class="separator:ga975ad0c4e61d3b92c3f9886a24ff2c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323857757f17a313a984de0b522341e3"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga323857757f17a313a984de0b522341e3">XGpioPs_IntrGetEnabledPin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:ga323857757f17a313a984de0b522341e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether interrupts are enabled for the specified pin.  <a href="#ga323857757f17a313a984de0b522341e3">More...</a><br/></td></tr>
<tr class="separator:ga323857757f17a313a984de0b522341e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405556c1d1bc856dd35f8a4a92f50345"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga405556c1d1bc856dd35f8a4a92f50345">XGpioPs_IntrGetStatusPin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:ga405556c1d1bc856dd35f8a4a92f50345"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns interrupt enable status of the specified pin.  <a href="#ga405556c1d1bc856dd35f8a4a92f50345">More...</a><br/></td></tr>
<tr class="separator:ga405556c1d1bc856dd35f8a4a92f50345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7365f4849c4bc37dbd0cee7df2b73b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga1b7365f4849c4bc37dbd0cee7df2b73b">XGpioPs_IntrClearPin</a> (const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *InstancePtr, u32 Pin)</td></tr>
<tr class="memdesc:ga1b7365f4849c4bc37dbd0cee7df2b73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the specified pending interrupt.  <a href="#ga1b7365f4849c4bc37dbd0cee7df2b73b">More...</a><br/></td></tr>
<tr class="separator:ga1b7365f4849c4bc37dbd0cee7df2b73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c49687af4625a0ed49f376d3ff1b045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_gpio_ps___config.html">XGpioPs_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga9c49687af4625a0ed49f376d3ff1b045">XGpioPs_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:ga9c49687af4625a0ed49f376d3ff1b045"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function looks for the device configuration based on the unique device ID.  <a href="#ga9c49687af4625a0ed49f376d3ff1b045">More...</a><br/></td></tr>
<tr class="separator:ga9c49687af4625a0ed49f376d3ff1b045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d754ba2ed6c25f49a456041e109ddc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga2d754ba2ed6c25f49a456041e109ddc1">StubHandler</a> (const void *CallBackRef, u32 Bank, u32 Status)</td></tr>
<tr class="memdesc:ga2d754ba2ed6c25f49a456041e109ddc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a stub for the status callback.  <a href="#ga2d754ba2ed6c25f49a456041e109ddc1">More...</a><br/></td></tr>
<tr class="separator:ga2d754ba2ed6c25f49a456041e109ddc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gadfc4a76613b301ad3af6d2014505e745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_gpio_ps___config.html">XGpioPs_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gadfc4a76613b301ad3af6d2014505e745">XGpioPs_ConfigTable</a> [XPAR_XGPIOPS_NUM_INSTANCES]</td></tr>
<tr class="memdesc:gadfc4a76613b301ad3af6d2014505e745"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each GPIO device in the system.  <a href="#gadfc4a76613b301ad3af6d2014505e745">More...</a><br/></td></tr>
<tr class="separator:gadfc4a76613b301ad3af6d2014505e745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc4a76613b301ad3af6d2014505e745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_gpio_ps___config.html">XGpioPs_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gadfc4a76613b301ad3af6d2014505e745">XGpioPs_ConfigTable</a> [XPAR_XGPIOPS_NUM_INSTANCES]</td></tr>
<tr class="memdesc:gadfc4a76613b301ad3af6d2014505e745"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each GPIO device in the system.  <a href="#gadfc4a76613b301ad3af6d2014505e745">More...</a><br/></td></tr>
<tr class="separator:gadfc4a76613b301ad3af6d2014505e745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interrupt types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp18572496d43f15f681a6844a04f17051"></a>The following constants define the interrupt types that can be set for each GPIO pin. </p>
</td></tr>
<tr class="memitem:ga25b306607f3b370ea355229c21e7db02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga25b306607f3b370ea355229c21e7db02">XGPIOPS_IRQ_TYPE_EDGE_RISING</a>&#160;&#160;&#160;0x00U</td></tr>
<tr class="memdesc:ga25b306607f3b370ea355229c21e7db02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt on Rising edge.  <a href="#ga25b306607f3b370ea355229c21e7db02">More...</a><br/></td></tr>
<tr class="separator:ga25b306607f3b370ea355229c21e7db02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8082ec62bd44c68e3334b77c87fca96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gae8082ec62bd44c68e3334b77c87fca96">XGPIOPS_IRQ_TYPE_EDGE_FALLING</a>&#160;&#160;&#160;0x01U</td></tr>
<tr class="memdesc:gae8082ec62bd44c68e3334b77c87fca96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Falling edge.  <a href="#gae8082ec62bd44c68e3334b77c87fca96">More...</a><br/></td></tr>
<tr class="separator:gae8082ec62bd44c68e3334b77c87fca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0415781a99043db06849daa027d5c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#gaaa0415781a99043db06849daa027d5c5">XGPIOPS_IRQ_TYPE_EDGE_BOTH</a>&#160;&#160;&#160;0x02U</td></tr>
<tr class="memdesc:gaaa0415781a99043db06849daa027d5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt on both edges.  <a href="#gaaa0415781a99043db06849daa027d5c5">More...</a><br/></td></tr>
<tr class="separator:gaaa0415781a99043db06849daa027d5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09bf1d6e818f6f442ba61535f8e855ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga09bf1d6e818f6f442ba61535f8e855ea">XGPIOPS_IRQ_TYPE_LEVEL_HIGH</a>&#160;&#160;&#160;0x03U</td></tr>
<tr class="memdesc:ga09bf1d6e818f6f442ba61535f8e855ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt on high level.  <a href="#ga09bf1d6e818f6f442ba61535f8e855ea">More...</a><br/></td></tr>
<tr class="separator:ga09bf1d6e818f6f442ba61535f8e855ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b599940b75f6e1d6920c7b33fc2789"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gpiops__v3__6.html#ga84b599940b75f6e1d6920c7b33fc2789">XGPIOPS_IRQ_TYPE_LEVEL_LOW</a>&#160;&#160;&#160;0x04U</td></tr>
<tr class="memdesc:ga84b599940b75f6e1d6920c7b33fc2789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt on low level.  <a href="#ga84b599940b75f6e1d6920c7b33fc2789">More...</a><br/></td></tr>
<tr class="separator:ga84b599940b75f6e1d6920c7b33fc2789"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Register offsets for the GPIO. Each register is 32 bits.</h2></td></tr>
<tr class="memitem:ga05aff41166bea96304f2fa71e21362c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05aff41166bea96304f2fa71e21362c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_DATA_LSW_OFFSET</b>&#160;&#160;&#160;0x00000000U  /* Mask and Data Register LSW, WO */</td></tr>
<tr class="separator:ga05aff41166bea96304f2fa71e21362c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b7d35cd223526d8861934f44232284"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05b7d35cd223526d8861934f44232284"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_DATA_MSW_OFFSET</b>&#160;&#160;&#160;0x00000004U  /* Mask and Data Register MSW, WO */</td></tr>
<tr class="separator:ga05b7d35cd223526d8861934f44232284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d795f07c1e9e4bfcac2859112fbbd88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3d795f07c1e9e4bfcac2859112fbbd88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_DATA_OFFSET</b>&#160;&#160;&#160;0x00000040U  /* Data Register, RW */</td></tr>
<tr class="separator:ga3d795f07c1e9e4bfcac2859112fbbd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e4ebe4ad7fef5e1a1fe215f578d8a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29e4ebe4ad7fef5e1a1fe215f578d8a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_DATA_RO_OFFSET</b>&#160;&#160;&#160;0x00000060U  /* Data Register - Input, RO */</td></tr>
<tr class="separator:ga29e4ebe4ad7fef5e1a1fe215f578d8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee82145f62455e2928a5b8fe66553a40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee82145f62455e2928a5b8fe66553a40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_DIRM_OFFSET</b>&#160;&#160;&#160;0x00000204U  /* Direction Mode Register, RW */</td></tr>
<tr class="separator:gaee82145f62455e2928a5b8fe66553a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74dfb9103ef810106a70f8355e319004"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74dfb9103ef810106a70f8355e319004"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_OUTEN_OFFSET</b>&#160;&#160;&#160;0x00000208U  /* Output Enable Register, RW */</td></tr>
<tr class="separator:ga74dfb9103ef810106a70f8355e319004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ee987794c805429f6e0c34b62ae5b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga63ee987794c805429f6e0c34b62ae5b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTMASK_OFFSET</b>&#160;&#160;&#160;0x0000020CU  /* Interrupt Mask Register, RO */</td></tr>
<tr class="separator:ga63ee987794c805429f6e0c34b62ae5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090dab3e38b9493eb63a30c4cc9a9267"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga090dab3e38b9493eb63a30c4cc9a9267"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTEN_OFFSET</b>&#160;&#160;&#160;0x00000210U  /* Interrupt Enable Register, WO */</td></tr>
<tr class="separator:ga090dab3e38b9493eb63a30c4cc9a9267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga457b603b9dda39af3aad037e3fb7fe89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga457b603b9dda39af3aad037e3fb7fe89"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTDIS_OFFSET</b>&#160;&#160;&#160;0x00000214U  /* Interrupt Disable Register, WO*/</td></tr>
<tr class="separator:ga457b603b9dda39af3aad037e3fb7fe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eac2572743836b91aae65e35e2b4ff2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6eac2572743836b91aae65e35e2b4ff2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTSTS_OFFSET</b>&#160;&#160;&#160;0x00000218U  /* Interrupt Status Register, RO */</td></tr>
<tr class="separator:ga6eac2572743836b91aae65e35e2b4ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50a2feb73c4055285aa11d1de90c402"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad50a2feb73c4055285aa11d1de90c402"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTTYPE_OFFSET</b>&#160;&#160;&#160;0x0000021CU  /* Interrupt Type Register, RW */</td></tr>
<tr class="separator:gad50a2feb73c4055285aa11d1de90c402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd48f3262cc46cf828f219edcdb08920"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd48f3262cc46cf828f219edcdb08920"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTPOL_OFFSET</b>&#160;&#160;&#160;0x00000220U  /* Interrupt Polarity Register, RW */</td></tr>
<tr class="separator:gafd48f3262cc46cf828f219edcdb08920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba60ac847a2c6ad66240cf1a849afba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ba60ac847a2c6ad66240cf1a849afba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTANY_OFFSET</b>&#160;&#160;&#160;0x00000224U  /* Interrupt On Any Register, RW */</td></tr>
<tr class="separator:ga9ba60ac847a2c6ad66240cf1a849afba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Register offsets for each Bank.</h2></td></tr>
<tr class="memitem:ga1a0e56e2d9952e68d3737707d7b29581"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a0e56e2d9952e68d3737707d7b29581"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_DATA_MASK_OFFSET</b>&#160;&#160;&#160;0x00000008U  /* Data/Mask Registers offset */</td></tr>
<tr class="separator:ga1a0e56e2d9952e68d3737707d7b29581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2253433045676585190fa543860141d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2253433045676585190fa543860141d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_DATA_BANK_OFFSET</b>&#160;&#160;&#160;0x00000004U  /* Data Registers offset */</td></tr>
<tr class="separator:ga2253433045676585190fa543860141d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba138bbcd05d5e10978166741a8184b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ba138bbcd05d5e10978166741a8184b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_REG_MASK_OFFSET</b>&#160;&#160;&#160;0x00000040U  /* Registers offset */</td></tr>
<tr class="separator:ga9ba138bbcd05d5e10978166741a8184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interrupt type reset values for each bank</h2></td></tr>
<tr class="memitem:ga8c9a16d604addea8146e2672823f1dc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c9a16d604addea8146e2672823f1dc4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTTYPE_BANK0_RESET</b>&#160;&#160;&#160;0xFFFFFFFFU  /* Resets specific to Zynq */</td></tr>
<tr class="separator:ga8c9a16d604addea8146e2672823f1dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7120883729ac7440f9bbc378f21422a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae7120883729ac7440f9bbc378f21422a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTTYPE_BANK1_RESET</b>&#160;&#160;&#160;0x003FFFFFU</td></tr>
<tr class="separator:gae7120883729ac7440f9bbc378f21422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa4d8c9862e1f3af162c56a42b2e5f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8aa4d8c9862e1f3af162c56a42b2e5f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTTYPE_BANK2_RESET</b>&#160;&#160;&#160;0xFFFFFFFFU</td></tr>
<tr class="separator:ga8aa4d8c9862e1f3af162c56a42b2e5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa809c9d03d6939520e98babf4361100"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa809c9d03d6939520e98babf4361100"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTTYPE_BANK3_RESET</b>&#160;&#160;&#160;0xFFFFFFFFU  /* Reset common to both platforms */</td></tr>
<tr class="separator:gafa809c9d03d6939520e98babf4361100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514054481f5f916ee70f5d8ea40d926b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga514054481f5f916ee70f5d8ea40d926b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTTYPE_BANK4_RESET</b>&#160;&#160;&#160;0xFFFFFFFFU  /* Resets specific to Zynq Ultrascale+ MP */</td></tr>
<tr class="separator:ga514054481f5f916ee70f5d8ea40d926b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5904f463885a5fda6141f578da35bea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5904f463885a5fda6141f578da35bea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XGPIOPS_INTTYPE_BANK5_RESET</b>&#160;&#160;&#160;0xFFFFFFFFU</td></tr>
<tr class="separator:gae5904f463885a5fda6141f578da35bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac5c6fe277747f034cd30c3f3e770dc5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_BANK0&#160;&#160;&#160;0x00U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO Bank 0. </p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga07d1a36c4d70788e5ebf2ae583fc93e7">XGpioPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga88ebd56b0defc49ebd308951df1eaf0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_BANK1&#160;&#160;&#160;0x01U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO Bank 1. </p>

</div>
</div>
<a class="anchor" id="gae57e0fee992d409f0ff32d35e68f6fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_BANK2&#160;&#160;&#160;0x02U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO Bank 2. </p>

</div>
</div>
<a class="anchor" id="gac994de03aa64e2b6b3c6b6da9d76e020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_BANK3&#160;&#160;&#160;0x03U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO Bank 3. </p>

</div>
</div>
<a class="anchor" id="ga1e440e05bbea534ebf6939e88eb1455f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_BANK_MAX_PINS&#160;&#160;&#160;(u32)32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Max pins in a GPIO bank. </p>

</div>
</div>
<a class="anchor" id="ga6d70822b76e1dd3fda458ed693a082af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_DEVICE_MAX_PIN_NUM&#160;&#160;&#160;(u32)118</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Max pins in the Zynq GPIO device 0 - 31, Bank 0 32 - 53, Bank 1 54 - 85, Bank 2 86 - 117, Bank 3. </p>

</div>
</div>
<a class="anchor" id="ga8f80173cb28cbac5bab53c4fc7c7dd96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_DEVICE_MAX_PIN_NUM_ZYNQMP&#160;&#160;&#160;(u32)174</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Max pins in the Zynq Ultrascale+ MP GPIO device 0 - 25, Bank 0 26 - 51, Bank 1 52 - 77, Bank 2 78 - 109, Bank 3 110 - 141, Bank 4 142 - 173, Bank 5. </p>

</div>
</div>
<a class="anchor" id="gaaa0415781a99043db06849daa027d5c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_IRQ_TYPE_EDGE_BOTH&#160;&#160;&#160;0x02U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt on both edges. </p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga848274dc058043932e802a3caa39db3e">XGpioPs_GetIntrTypePin()</a>, and <a class="el" href="group__gpiops__v3__6.html#ga4ef808e6f8e113ba1371f44c35b1d0d9">XGpioPs_SetIntrTypePin()</a>.</p>

</div>
</div>
<a class="anchor" id="gae8082ec62bd44c68e3334b77c87fca96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_IRQ_TYPE_EDGE_FALLING&#160;&#160;&#160;0x01U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt Falling edge. </p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga848274dc058043932e802a3caa39db3e">XGpioPs_GetIntrTypePin()</a>, and <a class="el" href="group__gpiops__v3__6.html#ga4ef808e6f8e113ba1371f44c35b1d0d9">XGpioPs_SetIntrTypePin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga25b306607f3b370ea355229c21e7db02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_IRQ_TYPE_EDGE_RISING&#160;&#160;&#160;0x00U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt on Rising edge. </p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga848274dc058043932e802a3caa39db3e">XGpioPs_GetIntrTypePin()</a>, and <a class="el" href="group__gpiops__v3__6.html#ga4ef808e6f8e113ba1371f44c35b1d0d9">XGpioPs_SetIntrTypePin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga09bf1d6e818f6f442ba61535f8e855ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_IRQ_TYPE_LEVEL_HIGH&#160;&#160;&#160;0x03U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt on high level. </p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga848274dc058043932e802a3caa39db3e">XGpioPs_GetIntrTypePin()</a>, and <a class="el" href="group__gpiops__v3__6.html#ga4ef808e6f8e113ba1371f44c35b1d0d9">XGpioPs_SetIntrTypePin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga84b599940b75f6e1d6920c7b33fc2789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_IRQ_TYPE_LEVEL_LOW&#160;&#160;&#160;0x04U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt on low level. </p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga848274dc058043932e802a3caa39db3e">XGpioPs_GetIntrTypePin()</a>, and <a class="el" href="group__gpiops__v3__6.html#ga4ef808e6f8e113ba1371f44c35b1d0d9">XGpioPs_SetIntrTypePin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga27b466ba78cf142027ca998d0d67d2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_MAX_BANKS&#160;&#160;&#160;0x04U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Max banks in a Zynq GPIO device. </p>

</div>
</div>
<a class="anchor" id="gab8661a0444fd67d2b87a14b3c196e571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIOPS_MAX_BANKS_ZYNQMP&#160;&#160;&#160;0x06U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Max banks in a Zynq Ultrascale+ MP GPIO device. </p>

</div>
</div>
<a class="anchor" id="gaff08ac5be0729f046324cae2706aaf9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGpioPs_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;Xil_In32((BaseAddr) + (u32)(RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro reads the given register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddr</td><td>is the base address of the device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit value of the register</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga7eb1bb1c621ea32f0b14c9ee47c23319">XGpioPs_GetDirection()</a>, <a class="el" href="group__gpiops__v3__6.html#gaa3bacad17006e4b01ff91f6f14e5d3f7">XGpioPs_GetDirectionPin()</a>, <a class="el" href="group__gpiops__v3__6.html#gaed18cb81aceda214dba440cf6ff3d0ec">XGpioPs_GetIntrType()</a>, <a class="el" href="group__gpiops__v3__6.html#ga848274dc058043932e802a3caa39db3e">XGpioPs_GetIntrTypePin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga7977b334cb165a1cc2859b1bc1ac43df">XGpioPs_GetOutputEnable()</a>, <a class="el" href="group__gpiops__v3__6.html#ga17714eeb15fff954fc42d6008e67af17">XGpioPs_GetOutputEnablePin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga1b7365f4849c4bc37dbd0cee7df2b73b">XGpioPs_IntrClearPin()</a>, <a class="el" href="group__gpiops__v3__6.html#gaad995f8c0ff2801d22cc405dacb3ed19">XGpioPs_IntrGetEnabled()</a>, <a class="el" href="group__gpiops__v3__6.html#ga323857757f17a313a984de0b522341e3">XGpioPs_IntrGetEnabledPin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga47fc6f53355030ef41927f38fe37753f">XGpioPs_IntrGetStatus()</a>, <a class="el" href="group__gpiops__v3__6.html#ga405556c1d1bc856dd35f8a4a92f50345">XGpioPs_IntrGetStatusPin()</a>, <a class="el" href="group__gpiops__v3__6.html#gaac891da3a0b1ed5697644d621483ed62">XGpioPs_Read()</a>, <a class="el" href="group__gpiops__v3__6.html#ga5af7399d35110ae5f71be57316a2b9ee">XGpioPs_ReadPin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga7cbd9e1081b8ed84d38b475fc89271cf">XGpioPs_SetDirectionPin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga4ef808e6f8e113ba1371f44c35b1d0d9">XGpioPs_SetIntrTypePin()</a>, and <a class="el" href="group__gpiops__v3__6.html#ga841cc1098a21bdedec893545f15b025a">XGpioPs_SetOutputEnablePin()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ad586332c0958c5044450d735127337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGpioPs_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;Xil_Out32((BaseAddr) + (u32)(RegOffset), (u32)(Data))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro writes to the given register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddr</td><td>is the base address of the device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the offset of the register to be written. </td></tr>
    <tr><td class="paramname">Data</td><td>is the 32-bit value to write to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#gace8ee040fe190af86afe59ec1bc3201c">XGpioPs_IntrClear()</a>, <a class="el" href="group__gpiops__v3__6.html#ga1b7365f4849c4bc37dbd0cee7df2b73b">XGpioPs_IntrClearPin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga6d609e179e7167128bb6517e735c4cf7">XGpioPs_IntrDisable()</a>, <a class="el" href="group__gpiops__v3__6.html#ga975ad0c4e61d3b92c3f9886a24ff2c1f">XGpioPs_IntrDisablePin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga46cd4bf296c2706642dec85d0f0752be">XGpioPs_IntrEnable()</a>, <a class="el" href="group__gpiops__v3__6.html#ga2611a2a677a92a057ec8dd4ae8273766">XGpioPs_IntrEnablePin()</a>, <a class="el" href="group__gpiops__v3__6.html#gaab9fbd0037438e57fa33d096ac724613">XGpioPs_SetDirection()</a>, <a class="el" href="group__gpiops__v3__6.html#ga7cbd9e1081b8ed84d38b475fc89271cf">XGpioPs_SetDirectionPin()</a>, <a class="el" href="group__gpiops__v3__6.html#gac729652384b6d04711a9d1f2a62aee1d">XGpioPs_SetIntrType()</a>, <a class="el" href="group__gpiops__v3__6.html#ga4ef808e6f8e113ba1371f44c35b1d0d9">XGpioPs_SetIntrTypePin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga7c1ae54b29cedd921fbe9f6ef503ceef">XGpioPs_SetOutputEnable()</a>, <a class="el" href="group__gpiops__v3__6.html#ga841cc1098a21bdedec893545f15b025a">XGpioPs_SetOutputEnablePin()</a>, <a class="el" href="group__gpiops__v3__6.html#ga0f55b3804d13293880455a79d4f45e37">XGpioPs_Write()</a>, and <a class="el" href="group__gpiops__v3__6.html#gab9ff633d57fb32cac3424571ba690332">XGpioPs_WritePin()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2349a384fe8a39f89168780f84940efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XGpioPs_Handler)(void *CallBackRef, u32 Bank, u32 Status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This handler data type allows the user to define a callback function to handle the interrupts for the GPIO device. </p>
<p>The application using this driver is expected to define a handler of this type, to support interrupt driven mode. The handler executes in an interrupt context such that minimal processing should be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is a callback reference passed in by the upper layer when setting the callback functions for a GPIO bank. It is passed back to the upper layer when the callback is invoked. Its type is not important to the driver component, so it is a void pointer. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank for which the interrupt status has changed. </td></tr>
    <tr><td class="paramname">Status</td><td>is the Interrupt status of the GPIO bank. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2d754ba2ed6c25f49a456041e109ddc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StubHandler </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a stub for the status callback. </p>
<p>The stub is here in case the upper layers do not set the handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is a pointer to the upper layer callback reference </td></tr>
    <tr><td class="paramname">Bank</td><td>is the GPIO Bank in which an interrupt occurred. </td></tr>
    <tr><td class="paramname">Status</td><td>is the Interrupt status of the GPIO bank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7eb1bb1c621ea32f0b14c9ee47c23319"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_GetDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Direction of the pins of the specified GPIO Bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a 32 bit mask of the Direction register. Bits with 0 are in Input mode, bits with 1 are in Output Mode.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gaa3bacad17006e4b01ff91f6f14e5d3f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_GetDirectionPin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Direction of the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number for which the Direction is to be retrieved. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direction of the specified pin.<ul>
<li>0 for Input Direction</li>
<li>1 for Output Direction</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gaed18cb81aceda214dba440cf6ff3d0ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_GetIntrType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>IntrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>IntrPolarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>IntrOnAny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used for getting the Interrupt Type, Interrupt Polarity and Interrupt On Any for the specified GPIO Bank pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">IntrType</td><td>returns the 32 bit mask of the interrupt type. 0 means Level Sensitive and 1 means Edge Sensitive. </td></tr>
    <tr><td class="paramname">IntrPolarity</td><td>returns the 32 bit mask of the interrupt polarity. 0 means Active Low or Falling Edge and 1 means Active High or Rising Edge. </td></tr>
    <tr><td class="paramname">IntrOnAny</td><td>returns the 32 bit mask of the interrupt trigger for edge triggered interrupts. 0 means trigger on single edge using the configured interrupt polarity and 1 means trigger on both edges.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga07d1a36c4d70788e5ebf2ae583fc93e7">XGpioPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga848274dc058043932e802a3caa39db3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XGpioPs_GetIntrTypePin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the IRQ Type of a given GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number whose IRQ type is to be obtained. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use XGPIOPS_IRQ_TYPE_* defined in <a class="el" href="xgpiops_8h.html">xgpiops.h</a> for the IRQ type returned by this function. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="group__gpiops__v3__6.html#gaaa0415781a99043db06849daa027d5c5">XGPIOPS_IRQ_TYPE_EDGE_BOTH</a>, <a class="el" href="group__gpiops__v3__6.html#gae8082ec62bd44c68e3334b77c87fca96">XGPIOPS_IRQ_TYPE_EDGE_FALLING</a>, <a class="el" href="group__gpiops__v3__6.html#ga25b306607f3b370ea355229c21e7db02">XGPIOPS_IRQ_TYPE_EDGE_RISING</a>, <a class="el" href="group__gpiops__v3__6.html#ga09bf1d6e818f6f442ba61535f8e855ea">XGPIOPS_IRQ_TYPE_LEVEL_HIGH</a>, <a class="el" href="group__gpiops__v3__6.html#ga84b599940b75f6e1d6920c7b33fc2789">XGPIOPS_IRQ_TYPE_LEVEL_LOW</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga7977b334cb165a1cc2859b1bc1ac43df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_GetOutputEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Output Enable status of the pins of the specified GPIO Bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a a 32 bit mask of the Output Enable register. Bits with 0 are in Disabled state, bits with 1 are in Enabled State.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga17714eeb15fff954fc42d6008e67af17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_GetOutputEnablePin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Output Enable status of the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number for which the Output Enable status is to be retrieved. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output Enable of the specified pin.<ul>
<li>0 if Output Enable is disabled for this pin</li>
<li>1 if Output Enable is enabled for this pin</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gace8ee040fe190af86afe59ec1bc3201c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_IntrClear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears pending interrupt(s) with the provided mask. </p>
<p>This function should be called after the software has serviced the interrupts that are pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the mask of the interrupts to be cleared. Bit positions of 1 will be cleared. Bit positions of 0 will not change the previous interrupt status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#gafd0478d095fee0db04a29b43436306ef">XGpioPs_IntrHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b7365f4849c4bc37dbd0cee7df2b73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_IntrClearPin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the specified pending interrupt. </p>
<p>This function should be called after the software has serviced the interrupts that are pending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number for which the interrupt status is to be cleared. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d609e179e7167128bb6517e735c4cf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_IntrDisable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the interrupts for the specified pins in the specified bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the bit mask of the pins for which interrupts are to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga07d1a36c4d70788e5ebf2ae583fc93e7">XGpioPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga975ad0c4e61d3b92c3f9886a24ff2c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_IntrDisablePin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the interrupts for the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number for which the interrupt is to be disabled. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga46cd4bf296c2706642dec85d0f0752be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_IntrEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the interrupts for the specified pins in the specified bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the bit mask of the pins for which interrupts are to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga07d1a36c4d70788e5ebf2ae583fc93e7">XGpioPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2611a2a677a92a057ec8dd4ae8273766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_IntrEnablePin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the interrupt for the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number for which the interrupt is to be enabled. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gaad995f8c0ff2801d22cc405dacb3ed19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_IntrGetEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the interrupt enable status for a bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enabled interrupt(s) in a 32-bit format. Bit positions with 1 indicate that the interrupt for that pin is enabled, bit positions with 0 indicate that the interrupt for that pin is disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#gafd0478d095fee0db04a29b43436306ef">XGpioPs_IntrHandler()</a>, and <a class="el" href="group__gpiops__v3__6.html#ga07d1a36c4d70788e5ebf2ae583fc93e7">XGpioPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga323857757f17a313a984de0b522341e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_IntrGetEnabledPin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether interrupts are enabled for the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number for which the interrupt enable status is to be known. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if the interrupt is enabled.</li>
<li>FALSE if the interrupt is disabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga47fc6f53355030ef41927f38fe37753f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_IntrGetStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns interrupt status read from Interrupt Status Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value read from Interrupt Status Register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#gafd0478d095fee0db04a29b43436306ef">XGpioPs_IntrHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga405556c1d1bc856dd35f8a4a92f50345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_IntrGetStatusPin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns interrupt enable status of the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number for which the interrupt enable status is to be known. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if the interrupt has occurred.</li>
<li>FALSE if the interrupt has not occurred.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gafd0478d095fee0db04a29b43436306ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_IntrHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for GPIO interrupts.It checks the interrupt status registers of all the banks to determine the actual bank in which an interrupt has been triggered. </p>
<p>It then calls the upper layer callback handler set by the function XGpioPs_SetBankHandler(). The callback is called when an interrupt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not save and restore the processor context such that the user must provide this processing. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps.html#aca8b8269a2bd384f19de77e312de684a">XGpioPs::Handler</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#aea00d5eac94a0ae4b17d3ec0061afba1">XGpioPs::MaxBanks</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, <a class="el" href="group__gpiops__v3__6.html#gace8ee040fe190af86afe59ec1bc3201c">XGpioPs_IntrClear()</a>, <a class="el" href="group__gpiops__v3__6.html#gaad995f8c0ff2801d22cc405dacb3ed19">XGpioPs_IntrGetEnabled()</a>, and <a class="el" href="group__gpiops__v3__6.html#ga47fc6f53355030ef41927f38fe37753f">XGpioPs_IntrGetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c49687af4625a0ed49f376d3ff1b045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_gpio_ps___config.html">XGpioPs_Config</a> * XGpioPs_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function looks for the device configuration based on the unique device ID. </p>
<p>The table XGpioPs_ConfigTable[] contains the configuration information for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="xgpiops__polled__example_8c.html#ab92c6abab68712971c3b15511c0b6f24">GpioPolledExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gaac891da3a0b1ed5697644d621483ed62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_Read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the Data register of the specified GPIO bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current value of the Data register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is used for reading the state of all the GPIO pins of specified bank. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga5af7399d35110ae5f71be57316a2b9ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpioPs_ReadPin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Data from the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number for which the data has to be read. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP. See <a class="el" href="xgpiops_8h.html">xgpiops.h</a> for the mapping of the pin numbers in the banks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current value of the Pin (0 or 1).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is used for reading the state of the specified GPIO pin. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, and <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga07d1a36c4d70788e5ebf2ae583fc93e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XGpioPs_SelfTest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function runs a self-test on the GPIO driver/device. </p>
<p>This function does a register read/write test on some of the Interrupt Registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the self-test passed.<ul>
<li>XST_FAILURE otherwise. </li>
</ul>
</li>
</ul>
</dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="group__gpiops__v3__6.html#gac5c6fe277747f034cd30c3f3e770dc5b">XGPIOPS_BANK0</a>, <a class="el" href="group__gpiops__v3__6.html#gaed18cb81aceda214dba440cf6ff3d0ec">XGpioPs_GetIntrType()</a>, <a class="el" href="group__gpiops__v3__6.html#ga6d609e179e7167128bb6517e735c4cf7">XGpioPs_IntrDisable()</a>, <a class="el" href="group__gpiops__v3__6.html#ga46cd4bf296c2706642dec85d0f0752be">XGpioPs_IntrEnable()</a>, <a class="el" href="group__gpiops__v3__6.html#gaad995f8c0ff2801d22cc405dacb3ed19">XGpioPs_IntrGetEnabled()</a>, and <a class="el" href="group__gpiops__v3__6.html#gac729652384b6d04711a9d1f2a62aee1d">XGpioPs_SetIntrType()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd63e0e5c7ed18517d54104e4ad6dcd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_SetCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__gpiops__v3__6.html#ga2349a384fe8a39f89168780f84940efc">XGpioPs_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the status callback function. </p>
<p>The callback function is called by the XGpioPs_IntrHandler when an interrupt occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td class="paramname">FuncPointer</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The handler is called within interrupt context, so it should do its work quickly and queue potentially time-consuming work to a task-level thread. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps.html#a7bb5325d472614845866cb7abf370ce9">XGpioPs::CallBackRef</a>, <a class="el" href="struct_x_gpio_ps.html#aca8b8269a2bd384f19de77e312de684a">XGpioPs::Handler</a>, and <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gaab9fbd0037438e57fa33d096ac724613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_SetDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Direction of the pins of the specified GPIO Bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">Direction</td><td>is the 32 bit mask of the Pin direction to be set for all the pins in the Bank. Bits with 0 are set to Input mode, bits with 1 are set to Output Mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is used for setting the direction of all the pins in the specified bank. The previous state of the pins is not maintained. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cbd9e1081b8ed84d38b475fc89271cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_SetDirectionPin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Direction of the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number to which the Data is to be written. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">Direction</td><td>is the direction to be set for the specified pin. Valid values are 0 for Input Direction, 1 for Output Direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gac729652384b6d04711a9d1f2a62aee1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_SetIntrType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IntrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IntrPolarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IntrOnAny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used for setting the Interrupt Type, Interrupt Polarity and Interrupt On Any for the specified GPIO Bank pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">IntrType</td><td>is the 32 bit mask of the interrupt type. 0 means Level Sensitive and 1 means Edge Sensitive. </td></tr>
    <tr><td class="paramname">IntrPolarity</td><td>is the 32 bit mask of the interrupt polarity. 0 means Active Low or Falling Edge and 1 means Active High or Rising Edge. </td></tr>
    <tr><td class="paramname">IntrOnAny</td><td>is the 32 bit mask of the interrupt trigger for edge triggered interrupts. 0 means trigger on single edge using the configured interrupt polarity and 1 means trigger on both edges.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is used for setting the interrupt related properties of all the pins in the specified bank. The previous state of the pins is not maintained. To change the Interrupt properties of a single GPIO pin, use the function XGpioPs_SetPinIntrType(). </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__gpiops__v3__6.html#ga07d1a36c4d70788e5ebf2ae583fc93e7">XGpioPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ef808e6f8e113ba1371f44c35b1d0d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_SetIntrTypePin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>IrqType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used for setting the IRQ Type of a single GPIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number whose IRQ type is to be set. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">IrqType</td><td>is the IRQ type for GPIO Pin. Use XGPIOPS_IRQ_TYPE_* defined in <a class="el" href="xgpiops_8h.html">xgpiops.h</a> to specify the IRQ type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>
<p>&lt; Default statement is added for MISRA C compliance. </p>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="group__gpiops__v3__6.html#gaaa0415781a99043db06849daa027d5c5">XGPIOPS_IRQ_TYPE_EDGE_BOTH</a>, <a class="el" href="group__gpiops__v3__6.html#gae8082ec62bd44c68e3334b77c87fca96">XGPIOPS_IRQ_TYPE_EDGE_FALLING</a>, <a class="el" href="group__gpiops__v3__6.html#ga25b306607f3b370ea355229c21e7db02">XGPIOPS_IRQ_TYPE_EDGE_RISING</a>, <a class="el" href="group__gpiops__v3__6.html#ga09bf1d6e818f6f442ba61535f8e855ea">XGPIOPS_IRQ_TYPE_LEVEL_HIGH</a>, <a class="el" href="group__gpiops__v3__6.html#ga84b599940b75f6e1d6920c7b33fc2789">XGPIOPS_IRQ_TYPE_LEVEL_LOW</a>, <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c1ae54b29cedd921fbe9f6ef503ceef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_SetOutputEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>OpEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Output Enable of the pins of the specified GPIO Bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">OpEnable</td><td>is the 32 bit mask of the Output Enables to be set for all the pins in the Bank. The Output Enable of bits with 0 are disabled, the Output Enable of bits with 1 are enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is used for setting the Output Enables of all the pins in the specified bank. The previous state of the Output Enables is not maintained. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga841cc1098a21bdedec893545f15b025a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_SetOutputEnablePin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>OpEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Output Enable of the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number to which the Data is to be written. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">OpEnable</td><td>specifies whether the Output Enable for the specified pin should be enabled. Valid values are 0 for Disabling Output Enable, 1 for Enabling Output Enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="group__gpiops__v3__6.html#gaff08ac5be0729f046324cae2706aaf9a">XGpioPs_ReadReg</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f55b3804d13293880455a79d4f45e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_Write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the Data register of the specified GPIO bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Bank</td><td>is the bank number of the GPIO to operate on. Valid values are 0-3 in Zynq and 0-5 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">Data</td><td>is the value to be written to the Data register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is used for writing to all the GPIO pins of the bank. The previous state of the pins is not maintained. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, <a class="el" href="struct_x_gpio_ps.html#a50fe90cdd869323ac83d27f1439c58ea">XGpioPs::PmcGpio</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gab9ff633d57fb32cac3424571ba690332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpioPs_WritePin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_gpio_ps.html">XGpioPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the specified pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_gpio_ps.html" title="The XGpioPs driver instance data. ">XGpioPs</a> instance. </td></tr>
    <tr><td class="paramname">Pin</td><td>is the pin number to which the Data is to be written. Valid values are 0-117 in Zynq and 0-173 in Zynq Ultrascale+ MP. </td></tr>
    <tr><td class="paramname">Data</td><td>is the data to be written to the specified pin (0 or 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does a masked write to the specified pin of the specified GPIO bank. The previous state of other pins is maintained. </dd></dl>

<p>References <a class="el" href="struct_x_gpio_ps___config.html#af6895118cd185deea6b71ff3b67c65da">XGpioPs_Config::BaseAddr</a>, <a class="el" href="struct_x_gpio_ps.html#a312cec02e6e2550ba15824fad0596921">XGpioPs::GpioConfig</a>, <a class="el" href="struct_x_gpio_ps.html#a3acad7612d69a3b801cea87a78aaa60b">XGpioPs::IsReady</a>, and <a class="el" href="group__gpiops__v3__6.html#ga3ad586332c0958c5044450d735127337">XGpioPs_WriteReg</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gadfc4a76613b301ad3af6d2014505e745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_gpio_ps___config.html">XGpioPs_Config</a> XGpioPs_ConfigTable[XPAR_XGPIOPS_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This table contains configuration information for each GPIO device in the system. </p>

</div>
</div>
<a class="anchor" id="gadfc4a76613b301ad3af6d2014505e745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_gpio_ps___config.html">XGpioPs_Config</a> XGpioPs_ConfigTable[XPAR_XGPIOPS_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        {</div>
<div class="line">                (u16)XPAR_XGPIOPS_0_DEVICE_ID,  </div>
<div class="line">                (u32)XPAR_XGPIOPS_0_BASEADDR            </div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This table contains configuration information for each GPIO device in the system. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
