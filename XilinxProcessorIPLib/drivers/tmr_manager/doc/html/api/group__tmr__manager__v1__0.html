<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>tmr_manager: Tmr_manager_v1_0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">tmr_manager
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__tmr__manager__v1__0.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Tmr_manager_v1_0</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_t_m_r___manager___stats.html">XTMR_Manager_Stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> driver.  <a href="struct_x_t_m_r___manager___stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_t_m_r___manager___config.html">XTMR_Manager_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for the device.  <a href="struct_x_t_m_r___manager___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> driver instance data.  <a href="struct_x_t_m_r___manager.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaed2dede73cee6aea5d17d5a417807d99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>(BaseAddress, RegOffset, Data)&#160;&#160;&#160;XTMR_Manager_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td></tr>
<tr class="memdesc:gaed2dede73cee6aea5d17d5a417807d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a TMRManager register.  <a href="#gaed2dede73cee6aea5d17d5a417807d99"></a><br/></td></tr>
<tr class="separator:gaed2dede73cee6aea5d17d5a417807d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c918e69e2db4e9aafa6aad8e01c091"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gae9c918e69e2db4e9aafa6aad8e01c091">XTMR_Manager_ReadReg</a>(BaseAddress, RegOffset)&#160;&#160;&#160;XTMR_Manager_In32((BaseAddress) + (RegOffset))</td></tr>
<tr class="memdesc:gae9c918e69e2db4e9aafa6aad8e01c091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a TMRManager register.  <a href="#gae9c918e69e2db4e9aafa6aad8e01c091"></a><br/></td></tr>
<tr class="separator:gae9c918e69e2db4e9aafa6aad8e01c091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118a93e90f95b79257d33cded7a3d85d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga118a93e90f95b79257d33cded7a3d85d">XTMR_Manager_SetControlReg</a>(BaseAddress, Mask)&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>((BaseAddress), XTM_CONTROL_OFFSET, (Mask))</td></tr>
<tr class="memdesc:ga118a93e90f95b79257d33cded7a3d85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the contents of the control register.  <a href="#ga118a93e90f95b79257d33cded7a3d85d"></a><br/></td></tr>
<tr class="separator:ga118a93e90f95b79257d33cded7a3d85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae097f0b81faa2914c3609fa800b971f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gae097f0b81faa2914c3609fa800b971f5">XTMR_Manager_GetFirstFailingReg</a>(BaseAddress)&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gae9c918e69e2db4e9aafa6aad8e01c091">XTMR_Manager_ReadReg</a>((BaseAddress), XTM_FFR_OFFSET)</td></tr>
<tr class="memdesc:gae097f0b81faa2914c3609fa800b971f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of the first failing register.  <a href="#gae097f0b81faa2914c3609fa800b971f5"></a><br/></td></tr>
<tr class="separator:gae097f0b81faa2914c3609fa800b971f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec324f514b4bd419c5dbdccb3c0bc0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga4ec324f514b4bd419c5dbdccb3c0bc0c">XTMR_Manager_ClearFirstFailingReg</a>(BaseAddress)&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>((BaseAddress), XTM_FFR_OFFSET, 0)</td></tr>
<tr class="memdesc:ga4ec324f514b4bd419c5dbdccb3c0bc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the contents of the first failing register.  <a href="#ga4ec324f514b4bd419c5dbdccb3c0bc0c"></a><br/></td></tr>
<tr class="separator:ga4ec324f514b4bd419c5dbdccb3c0bc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae595b05de96f37f1499e5f4b5538bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga2ae595b05de96f37f1499e5f4b5538bf">XTMR_Manager_IsLockstepMismatch</a>(BaseAddress)</td></tr>
<tr class="memdesc:ga2ae595b05de96f37f1499e5f4b5538bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a lockstep mismatch has occurred.  <a href="#ga2ae595b05de96f37f1499e5f4b5538bf"></a><br/></td></tr>
<tr class="separator:ga2ae595b05de96f37f1499e5f4b5538bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a9d6158755ca9bedfd0bcf2cdf8652"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gae5a9d6158755ca9bedfd0bcf2cdf8652">XTMR_Manager_EnableIntr</a>(BaseAddress, Mask)&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>((BaseAddress), XTM_SEMIMR_OFFSET, Mask)</td></tr>
<tr class="memdesc:gae5a9d6158755ca9bedfd0bcf2cdf8652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the SEM interrupt.  <a href="#gae5a9d6158755ca9bedfd0bcf2cdf8652"></a><br/></td></tr>
<tr class="separator:gae5a9d6158755ca9bedfd0bcf2cdf8652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa104ec8c3c8be004c16f6e6879effa0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gaaa104ec8c3c8be004c16f6e6879effa0">XTMR_Manager_DisableIntr</a>(BaseAddress)&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>((BaseAddress), XTM_SEMIMR_OFFSET, 0)</td></tr>
<tr class="memdesc:gaaa104ec8c3c8be004c16f6e6879effa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the SEM interrupt.  <a href="#gaaa104ec8c3c8be004c16f6e6879effa0"></a><br/></td></tr>
<tr class="separator:gaaa104ec8c3c8be004c16f6e6879effa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8c9619c50a362b87f1d210c31ef76d15"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a> )(void *CallBackRef)</td></tr>
<tr class="memdesc:ga8c9619c50a362b87f1d210c31ef76d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function.  <a href="#ga8c9619c50a362b87f1d210c31ef76d15"></a><br/></td></tr>
<tr class="separator:ga8c9619c50a362b87f1d210c31ef76d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga09e58678fd2da7ffea2012d1f25ee42e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga09e58678fd2da7ffea2012d1f25ee42e">XTMR_Manager_CfgInitialize</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr, <a class="el" href="struct_x_t_m_r___manager___config.html">XTMR_Manager_Config</a> *Config, UINTPTR EffectiveAddr)</td></tr>
<tr class="memdesc:ga09e58678fd2da7ffea2012d1f25ee42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.  <a href="#ga09e58678fd2da7ffea2012d1f25ee42e"></a><br/></td></tr>
<tr class="separator:ga09e58678fd2da7ffea2012d1f25ee42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacdfc6e51dad27fff3bd1b362f4c2a6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gaacdfc6e51dad27fff3bd1b362f4c2a6e">XTMR_Manager_Initialize</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr class="memdesc:gaacdfc6e51dad27fff3bd1b362f4c2a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.  <a href="#gaacdfc6e51dad27fff3bd1b362f4c2a6e"></a><br/></td></tr>
<tr class="separator:gaacdfc6e51dad27fff3bd1b362f4c2a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07912dd332bd8ef68ca0c91cf06ef4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gab07912dd332bd8ef68ca0c91cf06ef4b">XTMR_Manager_SetRecoveryHandler</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr, <a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:gab07912dd332bd8ef68ca0c91cf06ef4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user recovery handler, which can replace the pre-defined handler completely, to do custom recovery.  <a href="#gab07912dd332bd8ef68ca0c91cf06ef4b"></a><br/></td></tr>
<tr class="separator:gab07912dd332bd8ef68ca0c91cf06ef4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b07ba47bffb32613157e5ae9d8c38eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga9b07ba47bffb32613157e5ae9d8c38eb">XTMR_Manager_SetPreResetHandler</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr, <a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:ga9b07ba47bffb32613157e5ae9d8c38eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user pre-reset handler, which can be used to save context before reset in a recovery sequence.  <a href="#ga9b07ba47bffb32613157e5ae9d8c38eb"></a><br/></td></tr>
<tr class="separator:ga9b07ba47bffb32613157e5ae9d8c38eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a316389f148733636ce902586b3635a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga4a316389f148733636ce902586b3635a">XTMR_Manager_SetPostResetHandler</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr, <a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:ga4a316389f148733636ce902586b3635a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user post-reset handler, which can be used to restore context after reset in a recovery sequence.  <a href="#ga4a316389f148733636ce902586b3635a"></a><br/></td></tr>
<tr class="separator:ga4a316389f148733636ce902586b3635a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c7f0c8ee8e35d6358f7e93aaacb6c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga97c7f0c8ee8e35d6358f7e93aaacb6c2">XTMR_Manager_GetStats</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr, <a class="el" href="struct_x_t_m_r___manager___stats.html">XTMR_Manager_Stats</a> *StatsPtr)</td></tr>
<tr class="memdesc:ga97c7f0c8ee8e35d6358f7e93aaacb6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a snapshot of the current statistics in the structure specified.  <a href="#ga97c7f0c8ee8e35d6358f7e93aaacb6c2"></a><br/></td></tr>
<tr class="separator:ga97c7f0c8ee8e35d6358f7e93aaacb6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6328ba6cbb2bab523942eb82a3515a8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga6328ba6cbb2bab523942eb82a3515a8d">XTMR_Manager_ClearStats</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga6328ba6cbb2bab523942eb82a3515a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function zeros the statistics for the given instance.  <a href="#ga6328ba6cbb2bab523942eb82a3515a8d"></a><br/></td></tr>
<tr class="separator:ga6328ba6cbb2bab523942eb82a3515a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3712c905face19b5734a4807ad5e2814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga3712c905face19b5734a4807ad5e2814">XTMR_Manager_EnableInterrupt</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:ga3712c905face19b5734a4807ad5e2814"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the core interrupt such that an interrupt will occur when any of the SEM status signals indicated by the mask are changed.  <a href="#ga3712c905face19b5734a4807ad5e2814"></a><br/></td></tr>
<tr class="separator:ga3712c905face19b5734a4807ad5e2814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9c760a09f6060be524c4724149aeb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gabd9c760a09f6060be524c4724149aeb1">XTMR_Manager_DisableInterrupt</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr)</td></tr>
<tr class="memdesc:gabd9c760a09f6060be524c4724149aeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the core interrupt.  <a href="#gabd9c760a09f6060be524c4724149aeb1"></a><br/></td></tr>
<tr class="separator:gabd9c760a09f6060be524c4724149aeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc411afbbc8a1bd33eb216be609b57b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga6dc411afbbc8a1bd33eb216be609b57b">XTMR_Manager_SetHandler</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr, <a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:ga6dc411afbbc8a1bd33eb216be609b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handler that will be called when an event (interrupt) occurs in the driver.  <a href="#ga6dc411afbbc8a1bd33eb216be609b57b"></a><br/></td></tr>
<tr class="separator:ga6dc411afbbc8a1bd33eb216be609b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a70c2dc4f54f69f80a13b972b6d8d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gad5a70c2dc4f54f69f80a13b972b6d8d3">XTMR_Manager_SelfTest</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr)</td></tr>
<tr class="memdesc:gad5a70c2dc4f54f69f80a13b972b6d8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a self-test on the device hardware.  <a href="#gad5a70c2dc4f54f69f80a13b972b6d8d3"></a><br/></td></tr>
<tr class="separator:gad5a70c2dc4f54f69f80a13b972b6d8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f61f159bf5788b191d818190b890673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga8f61f159bf5788b191d818190b890673">XTMR_Manager_InterruptHandler</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga8f61f159bf5788b191d818190b890673"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the TMR Manager driver.  <a href="#ga8f61f159bf5788b191d818190b890673"></a><br/></td></tr>
<tr class="separator:ga8f61f159bf5788b191d818190b890673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eda042057cb93a92372914efcc95370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga8eda042057cb93a92372914efcc95370">XTMR_Manager_BreakHandler</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga8eda042057cb93a92372914efcc95370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break occurred signalling that a recovery should be performed.  <a href="#ga8eda042057cb93a92372914efcc95370"></a><br/></td></tr>
<tr class="separator:ga8eda042057cb93a92372914efcc95370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bf0628effa71127914a170724b7e74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#ga35bf0628effa71127914a170724b7e74">XTMR_Manager_ResetHandler</a> (<a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga35bf0628effa71127914a170724b7e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and handle recovery reset or cold reset.  <a href="#ga35bf0628effa71127914a170724b7e74"></a><br/></td></tr>
<tr class="separator:ga35bf0628effa71127914a170724b7e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad24de1aa423a2db29d027fd88f97845c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_t_m_r___manager___config.html">XTMR_Manager_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gad24de1aa423a2db29d027fd88f97845c">XTMR_Manager_ConfigTable</a> [XPAR_XTMR_MANAGER_NUM_INSTANCES]</td></tr>
<tr class="memdesc:gad24de1aa423a2db29d027fd88f97845c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration table for TMR Manager devices.  <a href="#gad24de1aa423a2db29d027fd88f97845c"></a><br/></td></tr>
<tr class="separator:gad24de1aa423a2db29d027fd88f97845c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb554e9f74397f104b26f0cd6fef0ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_t_m_r___manager___config.html">XTMR_Manager_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tmr__manager__v1__0.html#gabeb554e9f74397f104b26f0cd6fef0ee">XTMR_Manager_ConfigTable</a> []</td></tr>
<tr class="memdesc:gabeb554e9f74397f104b26f0cd6fef0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration table for TMR Manager devices.  <a href="#gabeb554e9f74397f104b26f0cd6fef0ee"></a><br/></td></tr>
<tr class="separator:gabeb554e9f74397f104b26f0cd6fef0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga4ec324f514b4bd419c5dbdccb3c0bc0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTMR_Manager_ClearFirstFailingReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>((BaseAddress), XTM_FFR_OFFSET, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the contents of the first failing register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the status register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: u32 <a class="el" href="group__tmr__manager__v1__0.html#ga4ec324f514b4bd419c5dbdccb3c0bc0c" title="Clear the contents of the first failing register.">XTMR_Manager_ClearFirstFailingReg(u32 BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__tmr__manager__v1__0.html#ga35bf0628effa71127914a170724b7e74">XTMR_Manager_ResetHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa104ec8c3c8be004c16f6e6879effa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTMR_Manager_DisableIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>((BaseAddress), XTM_SEMIMR_OFFSET, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the SEM interrupt. </p>
<p>We cannot read the SEM Interrupt Mask Register, so we just clear all bits. Since the register only defines the interrupt mask, this works without side effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: void <a class="el" href="group__tmr__manager__v1__0.html#gaaa104ec8c3c8be004c16f6e6879effa0" title="Disable the SEM interrupt.">XTMR_Manager_DisableIntr(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="gae5a9d6158755ca9bedfd0bcf2cdf8652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTMR_Manager_EnableIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>((BaseAddress), XTM_SEMIMR_OFFSET, Mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the SEM interrupt. </p>
<p>We cannot read the SEM Interrupt Mask Register, so we just write the enabled interrupt bits and clear all others. Since the register only defines the interrupt mask, this works without side effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: void <a class="el" href="group__tmr__manager__v1__0.html#gae5a9d6158755ca9bedfd0bcf2cdf8652" title="Enable the SEM interrupt.">XTMR_Manager_EnableIntr(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="gae097f0b81faa2914c3609fa800b971f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTMR_Manager_GetFirstFailingReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gae9c918e69e2db4e9aafa6aad8e01c091">XTMR_Manager_ReadReg</a>((BaseAddress), XTM_FFR_OFFSET)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the contents of the first failing register. </p>
<p>Use the XTM_FFR_* constants defined above to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the status register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: u32 <a class="el" href="group__tmr__manager__v1__0.html#gae097f0b81faa2914c3609fa800b971f5" title="Get the contents of the first failing register.">XTMR_Manager_GetFirstFailingReg(u32 BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__tmr__manager__v1__0.html#ga35bf0628effa71127914a170724b7e74">XTMR_Manager_ResetHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ae595b05de96f37f1499e5f4b5538bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTMR_Manager_IsLockstepMismatch</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__tmr__manager__v1__0.html#gae097f0b81faa2914c3609fa800b971f5" title="Get the contents of the first failing register.">XTMR_Manager_GetFirstFailingReg</a>((BaseAddress)) &amp; \</div>
<div class="line">    ((1 &lt;&lt; XTM_FFR_LM12) | (1 &lt;&lt; XTM_FFR_LM13)| (1 &lt;&lt; XTM_FFR_LM23)) != 0)</div>
</div><!-- fragment -->
<p>Check to see if a lockstep mismatch has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a lockstep mismatch has occurred, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: int <a class="el" href="group__tmr__manager__v1__0.html#ga2ae595b05de96f37f1499e5f4b5538bf" title="Check to see if a lockstep mismatch has occurred.">XTMR_Manager_IsLockstepMismatch(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="gae9c918e69e2db4e9aafa6aad8e01c091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTMR_Manager_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XTMR_Manager_In32((BaseAddress) + (RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a TMRManager register. </p>
<p>A 32 bit read is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the TMRManager device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset from the base to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data read from the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__tmr__manager__v1__0.html#gae9c918e69e2db4e9aafa6aad8e01c091" title="Read a value from a TMRManager register.">XTMR_Manager_ReadReg(u32 BaseAddress, u32 RegOffset)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__tmr__manager__v1__0.html#gad5a70c2dc4f54f69f80a13b972b6d8d3">XTMR_Manager_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga118a93e90f95b79257d33cded7a3d85d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTMR_Manager_SetControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>((BaseAddress), XTM_CONTROL_OFFSET, (Mask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the contents of the control register. </p>
<p>Use the XTM_CR_* constants defined above to create the bit-mask to be written to the register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 32-bit value to write to the control register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: void <a class="el" href="group__tmr__manager__v1__0.html#ga118a93e90f95b79257d33cded7a3d85d" title="Set the contents of the control register.">XTMR_Manager_SetControlReg(u32 BaseAddress, u32 Mask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="gaed2dede73cee6aea5d17d5a417807d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTMR_Manager_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XTMR_Manager_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a TMRManager register. </p>
<p>A 32 bit write is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the TMRManager device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset from the base to write to. </td></tr>
    <tr><td class="paramname">Data</td><td>is the data written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void XTMR_Manager_WriteReg(u32 BaseAddress, u32 RegOffset, u32 Data) </dd></dl>

<p>Referenced by <a class="el" href="group__tmr__manager__v1__0.html#ga09e58678fd2da7ffea2012d1f25ee42e">XTMR_Manager_CfgInitialize()</a>, <a class="el" href="group__tmr__manager__v1__0.html#gabd9c760a09f6060be524c4724149aeb1">XTMR_Manager_DisableInterrupt()</a>, and <a class="el" href="group__tmr__manager__v1__0.html#ga3712c905face19b5734a4807ad5e2814">XTMR_Manager_EnableInterrupt()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga8c9619c50a362b87f1d210c31ef76d15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XTMR_Manager_Handler)(void *CallBackRef)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function. </p>
<p>The first argument is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8eda042057cb93a92372914efcc95370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_BreakHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break occurred signalling that a recovery should be performed. </p>
<p>Call the prerecovery user handler, and then suspend the processor, to signal to the TMR Manager hardware that it should reset the TMR sub-system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called from break vector, with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09e58678fd2da7ffea2012d1f25ee42e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XTMR_Manager_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager___config.html">XTMR_Manager_Config</a> *&#160;</td>
          <td class="paramname"><em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance. </p>
<p>The receive and transmit FIFOs of the core are not flushed, so the user may want to flush them. The hardware device does not have any way to disable the receiver such that any valid data may be present in the receive FIFO. This function disables the core interrupt. The baudrate and format of the data are fixed in the hardware at hardware build time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance. </td></tr>
    <tr><td class="paramname">Config</td><td>is a reference to a structure containing information about a specific TMR Manager device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if everything starts up as expected.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Config pointer argument is not used by this function, but is provided to keep the function signature consistent with other drivers. </dd></dl>

<p>References <a class="el" href="struct_x_t_m_r___manager___config.html#ab5028443b50f20268cdbaa3505434587">XTMR_Manager_Config::BrkDelayRstValue</a>, <a class="el" href="struct_x_t_m_r___manager___config.html#aea5febd4b3d76611b3ead50ba72cc664">XTMR_Manager_Config::BrkDelayWidth</a>, <a class="el" href="struct_x_t_m_r___manager___config.html#a5638cd043ab056eab8ac0f3b1e86f6cd">XTMR_Manager_Config::ComparatorsMask</a>, <a class="el" href="struct_x_t_m_r___manager___config.html#a2c2492ecb0c3e378b52e354cb96e4889">XTMR_Manager_Config::Magic1</a>, <a class="el" href="struct_x_t_m_r___manager___config.html#a401aee407942cb10d557e9fc482359f0">XTMR_Manager_Config::MaskRstValue</a>, <a class="el" href="struct_x_t_m_r___manager___config.html#ab1be7d71a20060985cf8d28e0f29735a">XTMR_Manager_Config::SemInterface</a>, <a class="el" href="struct_x_t_m_r___manager___config.html#a94861f845e23a09e1e96a8f976325b6e">XTMR_Manager_Config::TestComparator</a>, <a class="el" href="group__tmr__manager__v1__0.html#ga6328ba6cbb2bab523942eb82a3515a8d">XTMR_Manager_ClearStats()</a>, and <a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__tmr__manager__v1__0.html#gaacdfc6e51dad27fff3bd1b362f4c2a6e">XTMR_Manager_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6328ba6cbb2bab523942eb82a3515a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function zeros the statistics for the given instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_t_m_r___manager___stats.html#ada777980dd034c3f1eef945e94570c93">XTMR_Manager_Stats::InterruptCount</a>, and <a class="el" href="struct_x_t_m_r___manager___stats.html#a14ac6c281296762e87103e4193ac4cf3">XTMR_Manager_Stats::RecoveryCount</a>.</p>

<p>Referenced by <a class="el" href="group__tmr__manager__v1__0.html#ga09e58678fd2da7ffea2012d1f25ee42e">XTMR_Manager_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gabd9c760a09f6060be524c4724149aeb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_DisableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the core interrupt. </p>
<p>After calling this function, data may still be received by the core but no interrupt will be generated since the hardware device has no way to disable the receiver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga3712c905face19b5734a4807ad5e2814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_EnableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the core interrupt such that an interrupt will occur when any of the SEM status signals indicated by the mask are changed. </p>
<p>This function enables the core interrupt such that an interrupt will occur when an unmasked SEM status input changes value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is a mask indicating bits that should give an interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__tmr__manager__v1__0.html#gaed2dede73cee6aea5d17d5a417807d99">XTMR_Manager_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xtmr__manager__intr__tapp__example_8c.html#a60c2bfb18233bdc7f3259844a04f6950">TMR_ManagerIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga97c7f0c8ee8e35d6358f7e93aaacb6c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager___stats.html">XTMR_Manager_Stats</a> *&#160;</td>
          <td class="paramname"><em>StatsPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a snapshot of the current statistics in the structure specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance. </td></tr>
    <tr><td class="paramname">StatsPtr</td><td>is a pointer to a XTMR_ManagerStats structure to where the statistics are to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_t_m_r___manager___stats.html#ada777980dd034c3f1eef945e94570c93">XTMR_Manager_Stats::InterruptCount</a>, and <a class="el" href="struct_x_t_m_r___manager___stats.html#a14ac6c281296762e87103e4193ac4cf3">XTMR_Manager_Stats::RecoveryCount</a>.</p>

</div>
</div>
<a class="anchor" id="gaacdfc6e51dad27fff3bd1b362f4c2a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XTMR_Manager_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance. </p>
<p>The receive and transmit FIFOs of the core are not flushed, so the user may want to flush them. The hardware device does not have any way to disable the receiver such that any valid data may be present in the receive FIFO. This function disables the core interrupt. The baudrate and format of the data are fixed in the hardware at hardware build time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance. </td></tr>
    <tr><td class="paramname">DeviceId</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if everything starts up as expected.</li>
<li>XST_DEVICE_NOT_FOUND if the device is not found in the configuration table.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_t_m_r___manager___config.html#a9956aa0740b61010392479fbace5a73d">XTMR_Manager_Config::RegBaseAddr</a>, and <a class="el" href="group__tmr__manager__v1__0.html#ga09e58678fd2da7ffea2012d1f25ee42e">XTMR_Manager_CfgInitialize()</a>.</p>

<p>Referenced by <a class="el" href="xtmr__manager__intr__tapp__example_8c.html#a60c2bfb18233bdc7f3259844a04f6950">TMR_ManagerIntrExample()</a>, <a class="el" href="xtmr__manager__polled__example_8c.html#a7688ea71ed5d17239d180a953a60d287">TMR_ManagerPolledExample()</a>, and <a class="el" href="xtmr__manager__selftest__example_8c.html#a0f8b98a02515beddf9f92adae568520f">TMR_ManagerSelfTestExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f61f159bf5788b191d818190b890673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for the TMR Manager driver. </p>
<p>It must be connected to an interrupt system by the user such that it is called when an interrupt for any TMR Manager occurs. This function does not save or restore the processor context such that the user must ensure this occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>contains a pointer to the instance of the core that the interrupt is for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga35bf0628effa71127914a170724b7e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XTMR_Manager_ResetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect and handle recovery reset or cold reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the reset was recovery reset (1) or cold reset (0).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called from assembler context. The assembler routine ensures that the context is restored when doing a recovery reset. </dd></dl>

<p>References <a class="el" href="struct_x_t_m_r___manager___stats.html#a14ac6c281296762e87103e4193ac4cf3">XTMR_Manager_Stats::RecoveryCount</a>, <a class="el" href="group__tmr__manager__v1__0.html#ga4ec324f514b4bd419c5dbdccb3c0bc0c">XTMR_Manager_ClearFirstFailingReg</a>, and <a class="el" href="group__tmr__manager__v1__0.html#gae097f0b81faa2914c3609fa800b971f5">XTMR_Manager_GetFirstFailingReg</a>.</p>

</div>
</div>
<a class="anchor" id="gad5a70c2dc4f54f69f80a13b972b6d8d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XTMR_Manager_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a self-test on the device hardware. </p>
<p>Since there is no way to perform a loopback in the hardware, this test can only check the state of the status register to verify it is correct. This test assumes that the hardware device is still in its reset state, but has been initialized with the Initialize function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the self-test was successful.</li>
<li>XST_FAILURE if the self-test failed, the status register value was not correct</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__tmr__manager__v1__0.html#gae9c918e69e2db4e9aafa6aad8e01c091">XTMR_Manager_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xtmr__manager__intr__tapp__example_8c.html#a60c2bfb18233bdc7f3259844a04f6950">TMR_ManagerIntrExample()</a>, <a class="el" href="xtmr__manager__polled__example_8c.html#a7688ea71ed5d17239d180a953a60d287">TMR_ManagerPolledExample()</a>, and <a class="el" href="xtmr__manager__selftest__example_8c.html#a0f8b98a02515beddf9f92adae568520f">TMR_ManagerSelfTestExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6dc411afbbc8a1bd33eb216be609b57b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_SetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver. </p>
<p>The purpose of the handler is to allow application specific processing to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance. </td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it)</dd></dl>
<p>The purpose of the handler is to allow application specific processing to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance . </td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a316389f148733636ce902586b3635a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_SetPostResetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user post-reset handler, which can be used to restore context after reset in a recovery sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b07ba47bffb32613157e5ae9d8c38eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_SetPreResetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user pre-reset handler, which can be used to save context before reset in a recovery sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is run in interrupt context. </dd></dl>

</div>
</div>
<a class="anchor" id="gab07912dd332bd8ef68ca0c91cf06ef4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTMR_Manager_SetRecoveryHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_t_m_r___manager.html">XTMR_Manager</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tmr__manager__v1__0.html#ga8c9619c50a362b87f1d210c31ef76d15">XTMR_Manager_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user recovery handler, which can replace the pre-defined handler completely, to do custom recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_t_m_r___manager.html" title="The XTMR_Manager driver instance data.">XTMR_Manager</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is run in interrupt context. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gabeb554e9f74397f104b26f0cd6fef0ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_t_m_r___manager___config.html">XTMR_Manager_Config</a> XTMR_Manager_ConfigTable[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The configuration table for TMR Manager devices. </p>

</div>
</div>
<a class="anchor" id="gad24de1aa423a2db29d027fd88f97845c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_t_m_r___manager___config.html">XTMR_Manager_Config</a> XTMR_Manager_ConfigTable[XPAR_XTMR_MANAGER_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">{</div>
<div class="line">    {</div>
<div class="line">        XPAR_TMRMANAGER_0_DEVICE_ID,              </div>
<div class="line">        XPAR_TMRMANAGER_0_BASEADDR,               </div>
<div class="line">        XPAR_TMRMANAGER_0_BRK_DELAY_RST_VALUE,    </div>
<div class="line">        XPAR_TMRMANAGER_0_MASK_RST_VALUE,         </div>
<div class="line">        XPAR_TMRMANAGER_0_MAGIC1,                 </div>
<div class="line">        XPAR_TMRMANAGER_0_MAGIC2,                 </div>
<div class="line">        XPAR_TMRMANAGER_0_UE_IS_FATAL,            </div>
<div class="line">        XPAR_TMRMANAGER_0_UE_WIDTH,               </div>
<div class="line">        XPAR_TMRMANAGER_0_NO_OF_COMPARATORS,      </div>
<div class="line">        XPAR_TMRMANAGER_0_COMPARATORS_MASK,       </div>
<div class="line">        XPAR_TMRMANAGER_0_WATCHDOG,               </div>
<div class="line">        XPAR_TMRMANAGER_0_WATCHDOG_WIDTH,         </div>
<div class="line">        XPAR_TMRMANAGER_0_SEM_INTERFACE,          </div>
<div class="line">        XPAR_TMRMANAGER_0_SEM_HEARTBEAT_WATCHDOG, </div>
<div class="line">        XPAR_TMRMANAGER_0_SEM_HEARTBEAT_WATCHDOG_WIDTH,</div>
<div class="line">                                                  </div>
<div class="line">        XPAR_TMRMANAGER_0_BRK_DELAY_WIDTH,        </div>
<div class="line">        XPAR_TMRMANAGER_0_TMR,                    </div>
<div class="line">        XPAR_TMRMANAGER_0_TEST_COMPARATOR,        </div>
<div class="line">        XPAR_TMRMANAGER_0_STRICT_MISCOMPARE,      </div>
<div class="line">        XPAR_TMRMANAGER_0_USE_DEBUG_DISABLE,      </div>
<div class="line">        XPAR_TMRMANAGER_0_USE_TMR_DISABLE         </div>
<div class="line">    },</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>The configuration table for TMR Manager devices. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
