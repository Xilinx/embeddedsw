<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>mbox: Mbox_v4_3</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">mbox
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__mbox__v4__3.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mbox_v4_3</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_mbox___config.html">XMbox_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for the device.  <a href="struct_x_mbox___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_mbox.html">XMbox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> driver instance data.  <a href="struct_x_mbox.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4f0eb6f00b1c4baf91576f2e6a32af87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a>(BaseAddress, RegOffset)&#160;&#160;&#160;Xil_In32((BaseAddress) + (RegOffset))</td></tr>
<tr class="memdesc:ga4f0eb6f00b1c4baf91576f2e6a32af87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one of the mbox registers.  <a href="#ga4f0eb6f00b1c4baf91576f2e6a32af87"></a><br/></td></tr>
<tr class="separator:ga4f0eb6f00b1c4baf91576f2e6a32af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299c2eb6c04531a5da2202b9968531c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7">XMbox_WriteReg</a>(BaseAddress, RegOffset, ValueToWrite)&#160;&#160;&#160;Xil_Out32(((BaseAddress) + (RegOffset)), (ValueToWrite))</td></tr>
<tr class="memdesc:ga299c2eb6c04531a5da2202b9968531c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a specified value to a register of a mbox.  <a href="#ga299c2eb6c04531a5da2202b9968531c7"></a><br/></td></tr>
<tr class="separator:ga299c2eb6c04531a5da2202b9968531c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267447e4cde5a2e0320ebba438c22a47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga267447e4cde5a2e0320ebba438c22a47">XMbox_WriteMBox</a>(BaseAddress, ValueToWrite)&#160;&#160;&#160;<a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7">XMbox_WriteReg</a> (BaseAddress, <a class="el" href="group__mbox__v4__3.html#ga1cfe8987e8a70162381ff6893967fbd8">XMB_WRITE_REG_OFFSET</a>, ValueToWrite)</td></tr>
<tr class="memdesc:ga267447e4cde5a2e0320ebba438c22a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the mbox write register.  <a href="#ga267447e4cde5a2e0320ebba438c22a47"></a><br/></td></tr>
<tr class="separator:ga267447e4cde5a2e0320ebba438c22a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e3d2cc2c9ecc47fc1ce4420a8b69f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga20e3d2cc2c9ecc47fc1ce4420a8b69f8">XMbox_ReadMBox</a>(BaseAddress)&#160;&#160;&#160;<a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a> (BaseAddress, <a class="el" href="group__mbox__v4__3.html#ga3a1f7a91d465c1e6be224c7f73d8ecea">XMB_READ_REG_OFFSET</a>)</td></tr>
<tr class="memdesc:ga20e3d2cc2c9ecc47fc1ce4420a8b69f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the mbox read FIFO.  <a href="#ga20e3d2cc2c9ecc47fc1ce4420a8b69f8"></a><br/></td></tr>
<tr class="separator:ga20e3d2cc2c9ecc47fc1ce4420a8b69f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa533a34a21931e86fe66cbd144659b87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gaa533a34a21931e86fe66cbd144659b87">XMbox_IsEmptyHw</a>(BaseAddress)&#160;&#160;&#160;((<a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a> (BaseAddress, <a class="el" href="group__mbox__v4__3.html#ga939d1f0b71e575a31a3689ca28cbc749">XMB_STATUS_REG_OFFSET</a>) &amp; <a class="el" href="group__mbox__v4__3.html#gaa79d42f5c0e43f6b6679a42f119f9563">XMB_STATUS_FIFO_EMPTY</a>))</td></tr>
<tr class="memdesc:gaa533a34a21931e86fe66cbd144659b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the Read FIFO is Empty.  <a href="#gaa533a34a21931e86fe66cbd144659b87"></a><br/></td></tr>
<tr class="separator:gaa533a34a21931e86fe66cbd144659b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686ca5f4834e7e613350a2166cd49398"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga686ca5f4834e7e613350a2166cd49398">XMbox_IsFullHw</a>(BaseAddress)&#160;&#160;&#160;((<a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a> (BaseAddress, <a class="el" href="group__mbox__v4__3.html#ga939d1f0b71e575a31a3689ca28cbc749">XMB_STATUS_REG_OFFSET</a>) &amp; <a class="el" href="group__mbox__v4__3.html#ga03cf0e55c079a09632583ac77df57329">XMB_STATUS_FIFO_FULL</a>))</td></tr>
<tr class="memdesc:ga686ca5f4834e7e613350a2166cd49398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is room in the Write FIFO.  <a href="#ga686ca5f4834e7e613350a2166cd49398"></a><br/></td></tr>
<tr class="separator:ga686ca5f4834e7e613350a2166cd49398"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga34fbeaf8de9092cb4d5b00dfbf054426"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga34fbeaf8de9092cb4d5b00dfbf054426">XMbox_CfgInitialize</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, <a class="el" href="struct_x_mbox___config.html">XMbox_Config</a> *ConfigPtr, UINTPTR EffectiveAddress)</td></tr>
<tr class="memdesc:ga34fbeaf8de9092cb4d5b00dfbf054426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a specific mailbox.  <a href="#ga34fbeaf8de9092cb4d5b00dfbf054426"></a><br/></td></tr>
<tr class="separator:ga34fbeaf8de9092cb4d5b00dfbf054426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f68405027d147c68aa53bcb49fbd5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gaa1f68405027d147c68aa53bcb49fbd5a">XMbox_Read</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesRecvdPtr)</td></tr>
<tr class="memdesc:gaa1f68405027d147c68aa53bcb49fbd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads requested bytes from the mailbox referenced by InstancePtr,into the buffer pointed to by the provided pointer.  <a href="#gaa1f68405027d147c68aa53bcb49fbd5a"></a><br/></td></tr>
<tr class="separator:gaa1f68405027d147c68aa53bcb49fbd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab14511b623c1d3c191cdc441b8909006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gab14511b623c1d3c191cdc441b8909006">XMbox_ReadBlocking</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)</td></tr>
<tr class="memdesc:gab14511b623c1d3c191cdc441b8909006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads requested bytes from the mailbox referenced by InstancePtr,into the buffer pointed to by the provided pointer.  <a href="#gab14511b623c1d3c191cdc441b8909006"></a><br/></td></tr>
<tr class="separator:gab14511b623c1d3c191cdc441b8909006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254c4e5a042e34520c3669fbf9651bc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga254c4e5a042e34520c3669fbf9651bc2">XMbox_Write</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesSentPtr)</td></tr>
<tr class="memdesc:ga254c4e5a042e34520c3669fbf9651bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the requested bytes from the buffer pointed to by the provided pointer into the mailbox referenced by InstancePtr.The number of bytes must be a multiple of 4 (bytes).  <a href="#ga254c4e5a042e34520c3669fbf9651bc2"></a><br/></td></tr>
<tr class="separator:ga254c4e5a042e34520c3669fbf9651bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ee00f97807790770f2dab9b2ea3b0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga23ee00f97807790770f2dab9b2ea3b0e">XMbox_WriteBlocking</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)</td></tr>
<tr class="memdesc:ga23ee00f97807790770f2dab9b2ea3b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the requested bytes from the buffer pointed to by the provided pointer into the mailbox referenced by InstancePtr.  <a href="#ga23ee00f97807790770f2dab9b2ea3b0e"></a><br/></td></tr>
<tr class="separator:ga23ee00f97807790770f2dab9b2ea3b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb01fe466ffcd0da315ffee115f4cd60"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gabb01fe466ffcd0da315ffee115f4cd60">XMbox_IsEmpty</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr class="memdesc:gabb01fe466ffcd0da315ffee115f4cd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if there is data available to be read.  <a href="#gabb01fe466ffcd0da315ffee115f4cd60"></a><br/></td></tr>
<tr class="separator:gabb01fe466ffcd0da315ffee115f4cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9db05bc2935bcc2230ff023b5c9cbcc"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gaa9db05bc2935bcc2230ff023b5c9cbcc">XMbox_IsFull</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaa9db05bc2935bcc2230ff023b5c9cbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if there is room in the write FIFO.  <a href="#gaa9db05bc2935bcc2230ff023b5c9cbcc"></a><br/></td></tr>
<tr class="separator:gaa9db05bc2935bcc2230ff023b5c9cbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10691489238a2a1b8515468b416d773e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga10691489238a2a1b8515468b416d773e">XMbox_Flush</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga10691489238a2a1b8515468b416d773e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the mailbox FIFOs by emptying the READ FIFO and making sure the Error Status is zero.  <a href="#ga10691489238a2a1b8515468b416d773e"></a><br/></td></tr>
<tr class="separator:ga10691489238a2a1b8515468b416d773e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf8d6e720149452270eac0493537a233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gacf8d6e720149452270eac0493537a233">XMbox_ResetFifos</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr class="memdesc:gacf8d6e720149452270eac0493537a233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the mailbox FIFOs by clearing the READ and WRITE FIFOs using the hardware control register for memory mapped IO.  <a href="#gacf8d6e720149452270eac0493537a233"></a><br/></td></tr>
<tr class="separator:gacf8d6e720149452270eac0493537a233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e56860ea2cf7f4f1df0f1862d8c4c61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga8e56860ea2cf7f4f1df0f1862d8c4c61">XMbox_SetInterruptEnable</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:ga8e56860ea2cf7f4f1df0f1862d8c4c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt enable register for this mailbox.  <a href="#ga8e56860ea2cf7f4f1df0f1862d8c4c61"></a><br/></td></tr>
<tr class="separator:ga8e56860ea2cf7f4f1df0f1862d8c4c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb96b1964aa476b4d60df4fd2440022c"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gacb96b1964aa476b4d60df4fd2440022c">XMbox_GetInterruptEnable</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr class="memdesc:gacb96b1964aa476b4d60df4fd2440022c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the interrupt enable for the mailbox.  <a href="#gacb96b1964aa476b4d60df4fd2440022c"></a><br/></td></tr>
<tr class="separator:gacb96b1964aa476b4d60df4fd2440022c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73757d06d4cc60466e563ab185a6c07"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gaf73757d06d4cc60466e563ab185a6c07">XMbox_GetInterruptStatus</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaf73757d06d4cc60466e563ab185a6c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the interrupt status for the mailbox.  <a href="#gaf73757d06d4cc60466e563ab185a6c07"></a><br/></td></tr>
<tr class="separator:gaf73757d06d4cc60466e563ab185a6c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93a50b0032e4b6202c23c4201e0591e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gab93a50b0032e4b6202c23c4201e0591e">XMbox_ClearInterrupt</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:gab93a50b0032e4b6202c23c4201e0591e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears pending interrupts with the provided mask.  <a href="#gab93a50b0032e4b6202c23c4201e0591e"></a><br/></td></tr>
<tr class="separator:gab93a50b0032e4b6202c23c4201e0591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb918498d8adc676f4ea554585609d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga4fb918498d8adc676f4ea554585609d2">XMbox_SetSendThreshold</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Value)</td></tr>
<tr class="memdesc:ga4fb918498d8adc676f4ea554585609d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Send Interrupt Threshold.  <a href="#ga4fb918498d8adc676f4ea554585609d2"></a><br/></td></tr>
<tr class="separator:ga4fb918498d8adc676f4ea554585609d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c05b007d0f92ca32702db58573302a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga8c05b007d0f92ca32702db58573302a9">XMbox_SetReceiveThreshold</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Value)</td></tr>
<tr class="memdesc:ga8c05b007d0f92ca32702db58573302a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Receive Interrupt Threshold.  <a href="#ga8c05b007d0f92ca32702db58573302a9"></a><br/></td></tr>
<tr class="separator:ga8c05b007d0f92ca32702db58573302a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8620711a04da0032b216e3f57a80570d"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga8620711a04da0032b216e3f57a80570d">XMbox_GetStatus</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga8620711a04da0032b216e3f57a80570d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Status register contents.  <a href="#ga8620711a04da0032b216e3f57a80570d"></a><br/></td></tr>
<tr class="separator:ga8620711a04da0032b216e3f57a80570d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Register Offset Definitions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp73ef0a73b2ea2db0d81f41505805ece5"></a>Register offsets within a mbox. </p>
</td></tr>
<tr class="memitem:ga1cfe8987e8a70162381ff6893967fbd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga1cfe8987e8a70162381ff6893967fbd8">XMB_WRITE_REG_OFFSET</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga1cfe8987e8a70162381ff6893967fbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox write register.  <a href="#ga1cfe8987e8a70162381ff6893967fbd8"></a><br/></td></tr>
<tr class="separator:ga1cfe8987e8a70162381ff6893967fbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a1f7a91d465c1e6be224c7f73d8ecea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga3a1f7a91d465c1e6be224c7f73d8ecea">XMB_READ_REG_OFFSET</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:ga3a1f7a91d465c1e6be224c7f73d8ecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox read register.  <a href="#ga3a1f7a91d465c1e6be224c7f73d8ecea"></a><br/></td></tr>
<tr class="separator:ga3a1f7a91d465c1e6be224c7f73d8ecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939d1f0b71e575a31a3689ca28cbc749"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga939d1f0b71e575a31a3689ca28cbc749">XMB_STATUS_REG_OFFSET</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:ga939d1f0b71e575a31a3689ca28cbc749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox status reg.  <a href="#ga939d1f0b71e575a31a3689ca28cbc749"></a><br/></td></tr>
<tr class="separator:ga939d1f0b71e575a31a3689ca28cbc749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777c199c53e918c3cbb896187ce28914"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga777c199c53e918c3cbb896187ce28914">XMB_ERROR_REG_OFFSET</a>&#160;&#160;&#160;0x14</td></tr>
<tr class="memdesc:ga777c199c53e918c3cbb896187ce28914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox Error reg.  <a href="#ga777c199c53e918c3cbb896187ce28914"></a><br/></td></tr>
<tr class="separator:ga777c199c53e918c3cbb896187ce28914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf6dc425ab72da28a9f30d37f803ec25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gabf6dc425ab72da28a9f30d37f803ec25">XMB_SIT_REG_OFFSET</a>&#160;&#160;&#160;0x18</td></tr>
<tr class="memdesc:gabf6dc425ab72da28a9f30d37f803ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox send interrupt threshold register.  <a href="#gabf6dc425ab72da28a9f30d37f803ec25"></a><br/></td></tr>
<tr class="separator:gabf6dc425ab72da28a9f30d37f803ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a7132725b8bd47cf0ddfa5e219a63a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gac1a7132725b8bd47cf0ddfa5e219a63a">XMB_RIT_REG_OFFSET</a>&#160;&#160;&#160;0x1C</td></tr>
<tr class="memdesc:gac1a7132725b8bd47cf0ddfa5e219a63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox receive interrupt threshold register.  <a href="#gac1a7132725b8bd47cf0ddfa5e219a63a"></a><br/></td></tr>
<tr class="separator:gac1a7132725b8bd47cf0ddfa5e219a63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24776289ecaec70de8722b0d4e34db6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga24776289ecaec70de8722b0d4e34db6f">XMB_IS_REG_OFFSET</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:ga24776289ecaec70de8722b0d4e34db6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox interrupt status register.  <a href="#ga24776289ecaec70de8722b0d4e34db6f"></a><br/></td></tr>
<tr class="separator:ga24776289ecaec70de8722b0d4e34db6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga992a83c0e5454de142ae0110531e6116"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga992a83c0e5454de142ae0110531e6116">XMB_IE_REG_OFFSET</a>&#160;&#160;&#160;0x24</td></tr>
<tr class="memdesc:ga992a83c0e5454de142ae0110531e6116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox interrupt enable register.  <a href="#ga992a83c0e5454de142ae0110531e6116"></a><br/></td></tr>
<tr class="separator:ga992a83c0e5454de142ae0110531e6116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40250159d7755332fc0e4149b46985d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga40250159d7755332fc0e4149b46985d7">XMB_IP_REG_OFFSET</a>&#160;&#160;&#160;0x28</td></tr>
<tr class="memdesc:ga40250159d7755332fc0e4149b46985d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox interrupt pending register.  <a href="#ga40250159d7755332fc0e4149b46985d7"></a><br/></td></tr>
<tr class="separator:ga40250159d7755332fc0e4149b46985d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12aab471e30140e408a6e9c396b44257"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga12aab471e30140e408a6e9c396b44257">XMB_CTRL_REG_OFFSET</a>&#160;&#160;&#160;0x2C</td></tr>
<tr class="memdesc:ga12aab471e30140e408a6e9c396b44257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mbox control register.  <a href="#ga12aab471e30140e408a6e9c396b44257"></a><br/></td></tr>
<tr class="separator:ga12aab471e30140e408a6e9c396b44257"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Status register bit definitions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp4c206b53a543972e5b035855e4d78291"></a>These status bits are used to poll the FIFOs </p>
</td></tr>
<tr class="memitem:gaa79d42f5c0e43f6b6679a42f119f9563"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gaa79d42f5c0e43f6b6679a42f119f9563">XMB_STATUS_FIFO_EMPTY</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:gaa79d42f5c0e43f6b6679a42f119f9563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive FIFO is Empty.  <a href="#gaa79d42f5c0e43f6b6679a42f119f9563"></a><br/></td></tr>
<tr class="separator:gaa79d42f5c0e43f6b6679a42f119f9563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03cf0e55c079a09632583ac77df57329"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga03cf0e55c079a09632583ac77df57329">XMB_STATUS_FIFO_FULL</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:ga03cf0e55c079a09632583ac77df57329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send FIFO is Full.  <a href="#ga03cf0e55c079a09632583ac77df57329"></a><br/></td></tr>
<tr class="separator:ga03cf0e55c079a09632583ac77df57329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12ee4cdd2f16e453fc3acca51768fb30"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga12ee4cdd2f16e453fc3acca51768fb30">XMB_STATUS_STA</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:ga12ee4cdd2f16e453fc3acca51768fb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send FIFO Threshold Status.  <a href="#ga12ee4cdd2f16e453fc3acca51768fb30"></a><br/></td></tr>
<tr class="separator:ga12ee4cdd2f16e453fc3acca51768fb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5961a437539596663a0f87843d6f04d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga5961a437539596663a0f87843d6f04d7">XMB_STATUS_RTA</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:ga5961a437539596663a0f87843d6f04d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive FIFO Threshold Status.  <a href="#ga5961a437539596663a0f87843d6f04d7"></a><br/></td></tr>
<tr class="separator:ga5961a437539596663a0f87843d6f04d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interrupt Registers(s) bits definitions.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc2f04b1d312c86fb3b1d20cfc942ce5c"></a>The IS, IE, and IP registers all have the same bit definition. </p>
</td></tr>
<tr class="memitem:ga03584ed8fe52cb5f04450bec96f00e51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga03584ed8fe52cb5f04450bec96f00e51">XMB_IX_STA</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ga03584ed8fe52cb5f04450bec96f00e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Threshold Active, when the number of Send FIFO entries is less than and equal to Send Interrupt Threshold.  <a href="#ga03584ed8fe52cb5f04450bec96f00e51"></a><br/></td></tr>
<tr class="separator:ga03584ed8fe52cb5f04450bec96f00e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ca917f4f31be7e899e1adaa4c503aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gac4ca917f4f31be7e899e1adaa4c503aa">XMB_IX_RTA</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:gac4ca917f4f31be7e899e1adaa4c503aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Threshold Active, when the number of Receive FIFO entries is greater than Receive Interrupt Threshold.  <a href="#gac4ca917f4f31be7e899e1adaa4c503aa"></a><br/></td></tr>
<tr class="separator:gac4ca917f4f31be7e899e1adaa4c503aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad879d5982bf753dcf27efc6bb8cca604"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gad879d5982bf753dcf27efc6bb8cca604">XMB_IX_ERR</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:gad879d5982bf753dcf27efc6bb8cca604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mailbox Error, when read on empty or write on full.  <a href="#gad879d5982bf753dcf27efc6bb8cca604"></a><br/></td></tr>
<tr class="separator:gad879d5982bf753dcf27efc6bb8cca604"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Error bits definition.</h2></td></tr>
<tr class="memitem:ga1fc712eb56bcc330c46c5bfe3f3c1583"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga1fc712eb56bcc330c46c5bfe3f3c1583">XMB_ERROR_FIFO_EMPTY</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:ga1fc712eb56bcc330c46c5bfe3f3c1583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive FIFO is Empty.  <a href="#ga1fc712eb56bcc330c46c5bfe3f3c1583"></a><br/></td></tr>
<tr class="separator:ga1fc712eb56bcc330c46c5bfe3f3c1583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90d8c6add066bca7fc234e0908a2ab56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga90d8c6add066bca7fc234e0908a2ab56">XMB_ERROR_FIFO_FULL</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:ga90d8c6add066bca7fc234e0908a2ab56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send FIFO is Full.  <a href="#ga90d8c6add066bca7fc234e0908a2ab56"></a><br/></td></tr>
<tr class="separator:ga90d8c6add066bca7fc234e0908a2ab56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Control register bits definition.</h2></td></tr>
<tr class="memitem:ga9d015e11c5da1e44ab58be839cdf33d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#ga9d015e11c5da1e44ab58be839cdf33d3">XMB_CTRL_RESET_SEND_FIFO</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:ga9d015e11c5da1e44ab58be839cdf33d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Send FIFO.  <a href="#ga9d015e11c5da1e44ab58be839cdf33d3"></a><br/></td></tr>
<tr class="separator:ga9d015e11c5da1e44ab58be839cdf33d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e2e5c1013346efd30bf5ea7314ebd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mbox__v4__3.html#gaf8e2e5c1013346efd30bf5ea7314ebd7">XMB_CTRL_RESET_RECV_FIFO</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:gaf8e2e5c1013346efd30bf5ea7314ebd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Receive FIFO.  <a href="#gaf8e2e5c1013346efd30bf5ea7314ebd7"></a><br/></td></tr>
<tr class="separator:gaf8e2e5c1013346efd30bf5ea7314ebd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga12aab471e30140e408a6e9c396b44257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_CTRL_REG_OFFSET&#160;&#160;&#160;0x2C</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox control register. </p>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#gacf8d6e720149452270eac0493537a233">XMbox_ResetFifos()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8e2e5c1013346efd30bf5ea7314ebd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_CTRL_RESET_RECV_FIFO&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Receive FIFO. </p>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#gacf8d6e720149452270eac0493537a233">XMbox_ResetFifos()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d015e11c5da1e44ab58be839cdf33d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_CTRL_RESET_SEND_FIFO&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Send FIFO. </p>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#gacf8d6e720149452270eac0493537a233">XMbox_ResetFifos()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1fc712eb56bcc330c46c5bfe3f3c1583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_ERROR_FIFO_EMPTY&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive FIFO is Empty. </p>

</div>
</div>
<a class="anchor" id="ga90d8c6add066bca7fc234e0908a2ab56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_ERROR_FIFO_FULL&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send FIFO is Full. </p>

</div>
</div>
<a class="anchor" id="ga777c199c53e918c3cbb896187ce28914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_ERROR_REG_OFFSET&#160;&#160;&#160;0x14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox Error reg. </p>

</div>
</div>
<a class="anchor" id="ga992a83c0e5454de142ae0110531e6116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_IE_REG_OFFSET&#160;&#160;&#160;0x24</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox interrupt enable register. </p>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#gacb96b1964aa476b4d60df4fd2440022c">XMbox_GetInterruptEnable()</a>, and <a class="el" href="group__mbox__v4__3.html#ga8e56860ea2cf7f4f1df0f1862d8c4c61">XMbox_SetInterruptEnable()</a>.</p>

</div>
</div>
<a class="anchor" id="ga40250159d7755332fc0e4149b46985d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_IP_REG_OFFSET&#160;&#160;&#160;0x28</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox interrupt pending register. </p>

</div>
</div>
<a class="anchor" id="ga24776289ecaec70de8722b0d4e34db6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_IS_REG_OFFSET&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox interrupt status register. </p>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#gab93a50b0032e4b6202c23c4201e0591e">XMbox_ClearInterrupt()</a>, and <a class="el" href="group__mbox__v4__3.html#gaf73757d06d4cc60466e563ab185a6c07">XMbox_GetInterruptStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="gad879d5982bf753dcf27efc6bb8cca604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_IX_ERR&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mailbox Error, when read on empty or write on full. </p>

</div>
</div>
<a class="anchor" id="gac4ca917f4f31be7e899e1adaa4c503aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_IX_RTA&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Threshold Active, when the number of Receive FIFO entries is greater than Receive Interrupt Threshold. </p>

</div>
</div>
<a class="anchor" id="ga03584ed8fe52cb5f04450bec96f00e51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_IX_STA&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send Threshold Active, when the number of Send FIFO entries is less than and equal to Send Interrupt Threshold. </p>

</div>
</div>
<a class="anchor" id="ga3a1f7a91d465c1e6be224c7f73d8ecea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_READ_REG_OFFSET&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox read register. </p>

</div>
</div>
<a class="anchor" id="gac1a7132725b8bd47cf0ddfa5e219a63a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_RIT_REG_OFFSET&#160;&#160;&#160;0x1C</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox receive interrupt threshold register. </p>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#ga8c05b007d0f92ca32702db58573302a9">XMbox_SetReceiveThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf6dc425ab72da28a9f30d37f803ec25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_SIT_REG_OFFSET&#160;&#160;&#160;0x18</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox send interrupt threshold register. </p>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#ga4fb918498d8adc676f4ea554585609d2">XMbox_SetSendThreshold()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa79d42f5c0e43f6b6679a42f119f9563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_STATUS_FIFO_EMPTY&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive FIFO is Empty. </p>

</div>
</div>
<a class="anchor" id="ga03cf0e55c079a09632583ac77df57329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_STATUS_FIFO_FULL&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send FIFO is Full. </p>

</div>
</div>
<a class="anchor" id="ga939d1f0b71e575a31a3689ca28cbc749"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_STATUS_REG_OFFSET&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox status reg. </p>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#ga8620711a04da0032b216e3f57a80570d">XMbox_GetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5961a437539596663a0f87843d6f04d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_STATUS_RTA&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive FIFO Threshold Status. </p>

</div>
</div>
<a class="anchor" id="ga12ee4cdd2f16e453fc3acca51768fb30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_STATUS_STA&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send FIFO Threshold Status. </p>

</div>
</div>
<a class="anchor" id="ga1cfe8987e8a70162381ff6893967fbd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMB_WRITE_REG_OFFSET&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mbox write register. </p>

</div>
</div>
<a class="anchor" id="gaa533a34a21931e86fe66cbd144659b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMbox_IsEmptyHw</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a> (BaseAddress, <a class="el" href="group__mbox__v4__3.html#ga939d1f0b71e575a31a3689ca28cbc749">XMB_STATUS_REG_OFFSET</a>) &amp; <a class="el" href="group__mbox__v4__3.html#gaa79d42f5c0e43f6b6679a42f119f9563">XMB_STATUS_FIFO_EMPTY</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the Read FIFO is Empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the mbox device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if the FIFO is empty.</li>
<li>FALSE if there is data to be read from the FIFO.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__mbox__v4__3.html#gaa533a34a21931e86fe66cbd144659b87" title="Checks if the Read FIFO is Empty.">XMbox_IsEmptyHw(u32 BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#ga10691489238a2a1b8515468b416d773e">XMbox_Flush()</a>, <a class="el" href="group__mbox__v4__3.html#gabb01fe466ffcd0da315ffee115f4cd60">XMbox_IsEmpty()</a>, <a class="el" href="group__mbox__v4__3.html#gaa1f68405027d147c68aa53bcb49fbd5a">XMbox_Read()</a>, and <a class="el" href="group__mbox__v4__3.html#gab14511b623c1d3c191cdc441b8909006">XMbox_ReadBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="ga686ca5f4834e7e613350a2166cd49398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMbox_IsFullHw</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a> (BaseAddress, <a class="el" href="group__mbox__v4__3.html#ga939d1f0b71e575a31a3689ca28cbc749">XMB_STATUS_REG_OFFSET</a>) &amp; <a class="el" href="group__mbox__v4__3.html#ga03cf0e55c079a09632583ac77df57329">XMB_STATUS_FIFO_FULL</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if there is room in the Write FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the mbox device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>FALSE if there is room in FIFO,</li>
<li>TRUE if there is no room in the FIFO</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__mbox__v4__3.html#ga686ca5f4834e7e613350a2166cd49398" title="Checks if there is room in the Write FIFO.">XMbox_IsFullHw(u32 BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#gaa9db05bc2935bcc2230ff023b5c9cbcc">XMbox_IsFull()</a>, <a class="el" href="group__mbox__v4__3.html#ga254c4e5a042e34520c3669fbf9651bc2">XMbox_Write()</a>, and <a class="el" href="group__mbox__v4__3.html#ga23ee00f97807790770f2dab9b2ea3b0e">XMbox_WriteBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="ga20e3d2cc2c9ecc47fc1ce4420a8b69f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMbox_ReadMBox</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a> (BaseAddress, <a class="el" href="group__mbox__v4__3.html#ga3a1f7a91d465c1e6be224c7f73d8ecea">XMB_READ_REG_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the mbox read FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the mbox device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value read from the register, a 32 bit value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__mbox__v4__3.html#ga20e3d2cc2c9ecc47fc1ce4420a8b69f8" title="Read the mbox read FIFO.">XMbox_ReadMBox(u32 BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#ga10691489238a2a1b8515468b416d773e">XMbox_Flush()</a>, <a class="el" href="group__mbox__v4__3.html#gaa1f68405027d147c68aa53bcb49fbd5a">XMbox_Read()</a>, and <a class="el" href="group__mbox__v4__3.html#gab14511b623c1d3c191cdc441b8909006">XMbox_ReadBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f0eb6f00b1c4baf91576f2e6a32af87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMbox_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;Xil_In32((BaseAddress) + (RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one of the mbox registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the mbox device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>contains the offset from the 1st register of the mbox to select the specific register of the mbox.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value read from the register, a 32 bit value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87" title="Read one of the mbox registers.">XMbox_ReadReg(u32 BaseAddress, unsigned RegOffset)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#gacb96b1964aa476b4d60df4fd2440022c">XMbox_GetInterruptEnable()</a>, <a class="el" href="group__mbox__v4__3.html#gaf73757d06d4cc60466e563ab185a6c07">XMbox_GetInterruptStatus()</a>, and <a class="el" href="group__mbox__v4__3.html#ga8620711a04da0032b216e3f57a80570d">XMbox_GetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga267447e4cde5a2e0320ebba438c22a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMbox_WriteMBox</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ValueToWrite&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7">XMbox_WriteReg</a> (BaseAddress, <a class="el" href="group__mbox__v4__3.html#ga1cfe8987e8a70162381ff6893967fbd8">XMB_WRITE_REG_OFFSET</a>, ValueToWrite)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the mbox write register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the mbox device. </td></tr>
    <tr><td class="paramname">ValueToWrite</td><td>contains the value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__mbox__v4__3.html#ga267447e4cde5a2e0320ebba438c22a47" title="Write the mbox write register.">XMbox_WriteMBox(u32 BaseAddress, u32 ValueToWrite)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#ga254c4e5a042e34520c3669fbf9651bc2">XMbox_Write()</a>, and <a class="el" href="group__mbox__v4__3.html#ga23ee00f97807790770f2dab9b2ea3b0e">XMbox_WriteBlocking()</a>.</p>

</div>
</div>
<a class="anchor" id="ga299c2eb6c04531a5da2202b9968531c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XMbox_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ValueToWrite&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;Xil_Out32(((BaseAddress) + (RegOffset)), (ValueToWrite))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a specified value to a register of a mbox. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the mbox device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>contain the offset from the 1st register of the mbox to select the specific register of the mbox. </td></tr>
    <tr><td class="paramname">ValueToWrite</td><td>is the 32 bit value to be written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7" title="Write a specified value to a register of a mbox.">XMbox_WriteReg(u32 BaseAddress, unsigned RegOffset, u32 ValueToWrite)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__mbox__v4__3.html#gab93a50b0032e4b6202c23c4201e0591e">XMbox_ClearInterrupt()</a>, <a class="el" href="group__mbox__v4__3.html#gacf8d6e720149452270eac0493537a233">XMbox_ResetFifos()</a>, <a class="el" href="group__mbox__v4__3.html#ga8e56860ea2cf7f4f1df0f1862d8c4c61">XMbox_SetInterruptEnable()</a>, <a class="el" href="group__mbox__v4__3.html#ga8c05b007d0f92ca32702db58573302a9">XMbox_SetReceiveThreshold()</a>, and <a class="el" href="group__mbox__v4__3.html#ga4fb918498d8adc676f4ea554585609d2">XMbox_SetSendThreshold()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga34fbeaf8de9092cb4d5b00dfbf054426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMbox_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_mbox___config.html">XMbox_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a specific mailbox. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">CfgPtr</td><td>is the device configuration structure containing required HW build data. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the Physical address of the hardware in a Virtual Memory operating system environment. It is the Base Address in a stand alone environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, and <a class="el" href="struct_x_mbox.html#ac30a078abf5bafc3b3ff0559894f333f">XMbox::IsReady</a>.</p>

<p>Referenced by <a class="el" href="xmbox__intr__example_8c.html#adf6c143c65ce968f72fc282ec63280e8">MailboxExample()</a>, and <a class="el" href="xmbox__example_8c.html#a29bcf620083d6150359747d6ffcb5562">ProdCon()</a>.</p>

</div>
</div>
<a class="anchor" id="gab93a50b0032e4b6202c23c4201e0591e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears pending interrupts with the provided mask. </p>
<p>This function should be called after the software has serviced the interrupts that are pending. This function clears the corresponding bits of the Interrupt Status Register. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is a logical OR of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#ga24776289ecaec70de8722b0d4e34db6f">XMB_IS_REG_OFFSET</a>, and <a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7">XMbox_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga10691489238a2a1b8515468b416d773e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMbox_Flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the mailbox FIFOs by emptying the READ FIFO and making sure the Error Status is zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XST_FAILURE if there are any outstanding errors.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Data from read FIFO is thrown away. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#a609445dac27b19ef129dd295fc252453">XMbox_Config::RecvID</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#gaa533a34a21931e86fe66cbd144659b87">XMbox_IsEmptyHw</a>, and <a class="el" href="group__mbox__v4__3.html#ga20e3d2cc2c9ecc47fc1ce4420a8b69f8">XMbox_ReadMBox</a>.</p>

</div>
</div>
<a class="anchor" id="gacb96b1964aa476b4d60df4fd2440022c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_GetInterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the interrupt enable for the mailbox. </p>
<p>AND the result of this function with XMB_IX_* to determine which interrupts of this mailbox are enabled. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of interrupt bits made up of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#ga992a83c0e5454de142ae0110531e6116">XMB_IE_REG_OFFSET</a>, and <a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gaf73757d06d4cc60466e563ab185a6c07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the interrupt status for the mailbox. </p>
<p>AND the results of this function with XMB_IX_* to determine which interrupts are currently pending to the processor. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of interrupt bits made up of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#ga24776289ecaec70de8722b0d4e34db6f">XMB_IS_REG_OFFSET</a>, and <a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga8620711a04da0032b216e3f57a80570d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_GetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns Status register contents. </p>
<p>This function can only be used for Non-FSL interface. If not, the function will fail in an assert. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value returns Status Register contents.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#ga939d1f0b71e575a31a3689ca28cbc749">XMB_STATUS_REG_OFFSET</a>, and <a class="el" href="group__mbox__v4__3.html#ga4f0eb6f00b1c4baf91576f2e6a32af87">XMbox_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gabb01fe466ffcd0da315ffee115f4cd60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if there is data available to be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>FALSE if there is data to be read.</li>
<li>TRUE is there no data to be read.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#a609445dac27b19ef129dd295fc252453">XMbox_Config::RecvID</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, and <a class="el" href="group__mbox__v4__3.html#gaa533a34a21931e86fe66cbd144659b87">XMbox_IsEmptyHw</a>.</p>

</div>
</div>
<a class="anchor" id="gaa9db05bc2935bcc2230ff023b5c9cbcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_IsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if there is room in the write FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>FALSE if there is room in write FIFO.</li>
<li>TRUE if there is room in write FIFO.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#a9e08e69be2c504f49b76b7b992701e5f">XMbox_Config::SendID</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, and <a class="el" href="group__mbox__v4__3.html#ga686ca5f4834e7e613350a2166cd49398">XMbox_IsFullHw</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1f68405027d147c68aa53bcb49fbd5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMbox_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>RequestedBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>BytesRecvdPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads requested bytes from the mailbox referenced by InstancePtr,into the buffer pointed to by the provided pointer. </p>
<p>The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.</p>
<p>This function is non blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">BufferPtr</td><td>is the buffer to read the mailbox contents into, aligned to a word boundary. </td></tr>
    <tr><td class="paramname">RequestedBytes</td><td>is the number of bytes of data requested. </td></tr>
    <tr><td class="paramname">BytesRecvdPtr</td><td>is the memory that is updated with the number of bytes of data actually read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XST_NO_DATA ifthere was no data in the mailbox.</li>
</ul>
</dd></dl>
<p>On success, the number of bytes read is returned through the pointer. The call may return with fewer bytes placed in the buffer than requested (not including zero). This is not necessarily an error condition and indicates the amount of data that was currently available in the mailbox.</p>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#a609445dac27b19ef129dd295fc252453">XMbox_Config::RecvID</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#gaa533a34a21931e86fe66cbd144659b87">XMbox_IsEmptyHw</a>, and <a class="el" href="group__mbox__v4__3.html#ga20e3d2cc2c9ecc47fc1ce4420a8b69f8">XMbox_ReadMBox</a>.</p>

<p>Referenced by <a class="el" href="xmbox__intr__example_8c.html#a82d99e5d2c3904a519d03a588ba9e1d8">MailboxExample_Receive()</a>.</p>

</div>
</div>
<a class="anchor" id="gab14511b623c1d3c191cdc441b8909006"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_ReadBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>RequestedBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads requested bytes from the mailbox referenced by InstancePtr,into the buffer pointed to by the provided pointer. </p>
<p>The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">BufferPtr</td><td>is the buffer to read the mailbox contents into, aligned to a word boundary. </td></tr>
    <tr><td class="paramname">RequestedBytes</td><td>is the number of bytes of data requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The call blocks until the number of bytes requested are available. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#a609445dac27b19ef129dd295fc252453">XMbox_Config::RecvID</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#gaa533a34a21931e86fe66cbd144659b87">XMbox_IsEmptyHw</a>, and <a class="el" href="group__mbox__v4__3.html#ga20e3d2cc2c9ecc47fc1ce4420a8b69f8">XMbox_ReadMBox</a>.</p>

<p>Referenced by <a class="el" href="xmbox__intr__example_8c.html#a82d99e5d2c3904a519d03a588ba9e1d8">MailboxExample_Receive()</a>, and <a class="el" href="xmbox__example_8c.html#a29bcf620083d6150359747d6ffcb5562">ProdCon()</a>.</p>

</div>
</div>
<a class="anchor" id="gacf8d6e720149452270eac0493537a233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_ResetFifos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the mailbox FIFOs by clearing the READ and WRITE FIFOs using the hardware control register for memory mapped IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use XMbox_Flush instead for FSL based access. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#ga12aab471e30140e408a6e9c396b44257">XMB_CTRL_REG_OFFSET</a>, <a class="el" href="group__mbox__v4__3.html#gaf8e2e5c1013346efd30bf5ea7314ebd7">XMB_CTRL_RESET_RECV_FIFO</a>, <a class="el" href="group__mbox__v4__3.html#ga9d015e11c5da1e44ab58be839cdf33d3">XMB_CTRL_RESET_SEND_FIFO</a>, and <a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7">XMbox_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga8e56860ea2cf7f4f1df0f1862d8c4c61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_SetInterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt enable register for this mailbox. </p>
<p>This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is a logical OR of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#ga992a83c0e5454de142ae0110531e6116">XMB_IE_REG_OFFSET</a>, and <a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7">XMbox_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c05b007d0f92ca32702db58573302a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_SetReceiveThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Receive Interrupt Threshold. </p>
<p>This function can only be used for Non-FSL interface. If not, the function will fail in an assert. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to set for the RIT. Only lower Log2(FIFO Depth) bits are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#gac1a7132725b8bd47cf0ddfa5e219a63a">XMB_RIT_REG_OFFSET</a>, and <a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7">XMbox_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga4fb918498d8adc676f4ea554585609d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_SetSendThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Send Interrupt Threshold. </p>
<p>This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to set for the SIT. Only lower Log2(FIFO Depth) bits are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#gabf6dc425ab72da28a9f30d37f803ec25">XMB_SIT_REG_OFFSET</a>, and <a class="el" href="group__mbox__v4__3.html#ga299c2eb6c04531a5da2202b9968531c7">XMbox_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga254c4e5a042e34520c3669fbf9651bc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMbox_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>RequestedBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>BytesSentPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the requested bytes from the buffer pointed to by the provided pointer into the mailbox referenced by InstancePtr.The number of bytes must be a multiple of 4 (bytes). </p>
<p>If not, the call will fail in an assert.</p>
<p>This function is non blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">BufferPtr</td><td>is the source data buffer, aligned to a word boundary. </td></tr>
    <tr><td class="paramname">RequestedBytes</td><td>is the number of bytes requested to be written. </td></tr>
    <tr><td class="paramname">BytesRecvdPtr</td><td>points to memory which is updated with the actual number of bytes written, return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><pre class="fragment">    - XST_SUCCESS on success.
    - XST_FIFO_NO_ROOM if the fifo was full.
</pre></dd></dl>
<p>On success, the number of bytes successfully written into the destination mailbox is returned in the provided pointer. The call may return with zero. This is not necessarily an error condition and indicates that the mailbox is currently full.</p>
<dl class="section note"><dt>Note</dt><dd>The provided buffer pointed to by BufferPtr must be aligned to a word boundary. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#a9e08e69be2c504f49b76b7b992701e5f">XMbox_Config::SendID</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#ga686ca5f4834e7e613350a2166cd49398">XMbox_IsFullHw</a>, and <a class="el" href="group__mbox__v4__3.html#ga267447e4cde5a2e0320ebba438c22a47">XMbox_WriteMBox</a>.</p>

<p>Referenced by <a class="el" href="xmbox__intr__example_8c.html#a8906eefcbf88897e5608bc257daeec6f">MailboxExample_Send()</a>.</p>

</div>
</div>
<a class="anchor" id="ga23ee00f97807790770f2dab9b2ea3b0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_WriteBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>RequestedBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the requested bytes from the buffer pointed to by the provided pointer into the mailbox referenced by InstancePtr. </p>
<p>The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html" title="The XMbox driver instance data.">XMbox</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">BufferPtr</td><td>is the source data buffer, aligned to a word boundary. </td></tr>
    <tr><td class="paramname">RequestedBytes</td><td>is the number of bytes requested to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The call blocks until the number of bytes requested are written. The provided buffer pointed to by BufferPtr must be aligned to a word boundary. </dd></dl>

<p>References <a class="el" href="struct_x_mbox___config.html#a7a357a3188be88d9aaba7e8cc60960a8">XMbox_Config::BaseAddress</a>, <a class="el" href="struct_x_mbox.html#ada3e15b402bdd502048b69a87dfd70a8">XMbox::Config</a>, <a class="el" href="struct_x_mbox___config.html#a9e08e69be2c504f49b76b7b992701e5f">XMbox_Config::SendID</a>, <a class="el" href="struct_x_mbox___config.html#ae59a7f14795bc768c36b105863e2efc8">XMbox_Config::UseFSL</a>, <a class="el" href="group__mbox__v4__3.html#ga686ca5f4834e7e613350a2166cd49398">XMbox_IsFullHw</a>, and <a class="el" href="group__mbox__v4__3.html#ga267447e4cde5a2e0320ebba438c22a47">XMbox_WriteMBox</a>.</p>

<p>Referenced by <a class="el" href="xmbox__intr__example_8c.html#a8906eefcbf88897e5608bc257daeec6f">MailboxExample_Send()</a>, and <a class="el" href="xmbox__example_8c.html#a29bcf620083d6150359747d6ffcb5562">ProdCon()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
