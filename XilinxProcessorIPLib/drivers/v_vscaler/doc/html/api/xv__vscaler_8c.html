<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>v_vscaler: xv_vscaler.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">v_vscaler
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xv__vscaler_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xv_vscaler.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a74344a7bbd1a51c11457b21720ff4ae9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a74344a7bbd1a51c11457b21720ff4ae9">XV_vscaler_CfgInitialize</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, <a class="el" href="struct_x_v__vscaler___config.html">XV_vscaler_Config</a> *ConfigPtr, UINTPTR EffectiveAddr)</td></tr>
<tr class="memdesc:a74344a7bbd1a51c11457b21720ff4ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_CfgInitialize - Initialize the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a74344a7bbd1a51c11457b21720ff4ae9">More...</a><br/></td></tr>
<tr class="separator:a74344a7bbd1a51c11457b21720ff4ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93878549b2774a0067b7c9711c3e14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#ac93878549b2774a0067b7c9711c3e14c">XV_vscaler_Start</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:ac93878549b2774a0067b7c9711c3e14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Start - Start the v_vscaler hardware.  <a href="#ac93878549b2774a0067b7c9711c3e14c">More...</a><br/></td></tr>
<tr class="separator:ac93878549b2774a0067b7c9711c3e14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df38322c966a4a17c09ae17c86b1f27"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a8df38322c966a4a17c09ae17c86b1f27">XV_vscaler_IsDone</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a8df38322c966a4a17c09ae17c86b1f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_IsDone - Check if the v_vscaler hardware has finished processing.  <a href="#a8df38322c966a4a17c09ae17c86b1f27">More...</a><br/></td></tr>
<tr class="separator:a8df38322c966a4a17c09ae17c86b1f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9037422243c74fa13b1f3dfdeb1e2db3"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a9037422243c74fa13b1f3dfdeb1e2db3">XV_vscaler_IsIdle</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a9037422243c74fa13b1f3dfdeb1e2db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_IsIdle - Check if the v_vscaler hardware is idle.  <a href="#a9037422243c74fa13b1f3dfdeb1e2db3">More...</a><br/></td></tr>
<tr class="separator:a9037422243c74fa13b1f3dfdeb1e2db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21858dd356b66d377bef6b3b7fa99e5"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#ac21858dd356b66d377bef6b3b7fa99e5">XV_vscaler_IsReady</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:ac21858dd356b66d377bef6b3b7fa99e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_IsReady - Check if the v_vscaler hardware is ready for new input.  <a href="#ac21858dd356b66d377bef6b3b7fa99e5">More...</a><br/></td></tr>
<tr class="separator:ac21858dd356b66d377bef6b3b7fa99e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bee58a9aaeaf7de3f4393044f284445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a4bee58a9aaeaf7de3f4393044f284445">XV_vscaler_EnableAutoRestart</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a4bee58a9aaeaf7de3f4393044f284445"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_EnableAutoRestart - Enable auto-restart for the v_vscaler hardware.  <a href="#a4bee58a9aaeaf7de3f4393044f284445">More...</a><br/></td></tr>
<tr class="separator:a4bee58a9aaeaf7de3f4393044f284445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c36dd3e88c5be95a8c1101cac4a111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#ab2c36dd3e88c5be95a8c1101cac4a111">XV_vscaler_DisableAutoRestart</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:ab2c36dd3e88c5be95a8c1101cac4a111"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_DisableAutoRestart - Disables the auto-restart feature of the V-Scaler hardware instance.  <a href="#ab2c36dd3e88c5be95a8c1101cac4a111">More...</a><br/></td></tr>
<tr class="separator:ab2c36dd3e88c5be95a8c1101cac4a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fe0f47ae9bc0f40c49eb01f1e06763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a30fe0f47ae9bc0f40c49eb01f1e06763">XV_vscaler_Set_HwReg_HeightIn</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:a30fe0f47ae9bc0f40c49eb01f1e06763"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Set_HwReg_HeightIn - Sets the input height hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a30fe0f47ae9bc0f40c49eb01f1e06763">More...</a><br/></td></tr>
<tr class="separator:a30fe0f47ae9bc0f40c49eb01f1e06763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae4d3d419b09bddc9ddcbda73b77f35"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a5ae4d3d419b09bddc9ddcbda73b77f35">XV_vscaler_Get_HwReg_HeightIn</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a5ae4d3d419b09bddc9ddcbda73b77f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Get_HwReg_HeightIn - Retrieves the input height value from the hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a5ae4d3d419b09bddc9ddcbda73b77f35">More...</a><br/></td></tr>
<tr class="separator:a5ae4d3d419b09bddc9ddcbda73b77f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53d59dd268dd2c5a9dea1d89bcf5df8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#ad53d59dd268dd2c5a9dea1d89bcf5df8">XV_vscaler_Set_HwReg_Width</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:ad53d59dd268dd2c5a9dea1d89bcf5df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Set_HwReg_Width - Sets the hardware register width for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#ad53d59dd268dd2c5a9dea1d89bcf5df8">More...</a><br/></td></tr>
<tr class="separator:ad53d59dd268dd2c5a9dea1d89bcf5df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61949acefe534a2488cef9a5abdeea9"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#ab61949acefe534a2488cef9a5abdeea9">XV_vscaler_Get_HwReg_Width</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:ab61949acefe534a2488cef9a5abdeea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Get_HwReg_Width - Retrieves the width value from the hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#ab61949acefe534a2488cef9a5abdeea9">More...</a><br/></td></tr>
<tr class="separator:ab61949acefe534a2488cef9a5abdeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c73450043e36e471579a2d0fd272404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a8c73450043e36e471579a2d0fd272404">XV_vscaler_Set_HwReg_HeightOut</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:a8c73450043e36e471579a2d0fd272404"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Set_HwReg_HeightOut - Sets the output height hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a8c73450043e36e471579a2d0fd272404">More...</a><br/></td></tr>
<tr class="separator:a8c73450043e36e471579a2d0fd272404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf18f5ce31c7d60f4087cc55ec9b67f5"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#adf18f5ce31c7d60f4087cc55ec9b67f5">XV_vscaler_Get_HwReg_HeightOut</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:adf18f5ce31c7d60f4087cc55ec9b67f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Get_HwReg_HeightOut - Retrieves the output height value from the hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#adf18f5ce31c7d60f4087cc55ec9b67f5">More...</a><br/></td></tr>
<tr class="separator:adf18f5ce31c7d60f4087cc55ec9b67f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee2c1ec52df88fdf5cc7b025e950674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#acee2c1ec52df88fdf5cc7b025e950674">XV_vscaler_Set_HwReg_LineRate</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:acee2c1ec52df88fdf5cc7b025e950674"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Set_HwReg_LineRate - Sets the line rate hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#acee2c1ec52df88fdf5cc7b025e950674">More...</a><br/></td></tr>
<tr class="separator:acee2c1ec52df88fdf5cc7b025e950674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af008030d183c88142c8800ab282fe25e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#af008030d183c88142c8800ab282fe25e">XV_vscaler_Get_HwReg_LineRate</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:af008030d183c88142c8800ab282fe25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Get_HwReg_LineRate - Retrieves the line rate value from the hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#af008030d183c88142c8800ab282fe25e">More...</a><br/></td></tr>
<tr class="separator:af008030d183c88142c8800ab282fe25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba1db0e373347f763d1f72a6d3784e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a0ba1db0e373347f763d1f72a6d3784e2">XV_vscaler_Set_HwReg_ColorMode</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:a0ba1db0e373347f763d1f72a6d3784e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Set_HwReg_ColorMode - Sets the hardware register for color mode in the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a0ba1db0e373347f763d1f72a6d3784e2">More...</a><br/></td></tr>
<tr class="separator:a0ba1db0e373347f763d1f72a6d3784e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968c2fdbffb0c931dcc00e698375db6e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a968c2fdbffb0c931dcc00e698375db6e">XV_vscaler_Get_HwReg_ColorMode</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a968c2fdbffb0c931dcc00e698375db6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current color mode hardware register value from the V-Scaler instance.  <a href="#a968c2fdbffb0c931dcc00e698375db6e">More...</a><br/></td></tr>
<tr class="separator:a968c2fdbffb0c931dcc00e698375db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cd1e2d2b08d4d789673cc50020764e"><td class="memItemLeft" align="right" valign="top">UINTPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a70cd1e2d2b08d4d789673cc50020764e">XV_vscaler_Get_HwReg_vfltCoeff_BaseAddress</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a70cd1e2d2b08d4d789673cc50020764e"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Get_HwReg_vfltCoeff_BaseAddress - Get the base address of the vertical filter coefficient hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a70cd1e2d2b08d4d789673cc50020764e">More...</a><br/></td></tr>
<tr class="separator:a70cd1e2d2b08d4d789673cc50020764e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2256cc55b9c80ea2f883c44f9e432d"><td class="memItemLeft" align="right" valign="top">UINTPTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a6a2256cc55b9c80ea2f883c44f9e432d">XV_vscaler_Get_HwReg_vfltCoeff_HighAddress</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a6a2256cc55b9c80ea2f883c44f9e432d"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Get_HwReg_vfltCoeff_HighAddress - Get the high address of the vertical filter coefficient hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a6a2256cc55b9c80ea2f883c44f9e432d">More...</a><br/></td></tr>
<tr class="separator:a6a2256cc55b9c80ea2f883c44f9e432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db48bb8c89558ede058fafd93bf659b"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a7db48bb8c89558ede058fafd93bf659b">XV_vscaler_Get_HwReg_vfltCoeff_TotalBytes</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a7db48bb8c89558ede058fafd93bf659b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the total number of bytes for the vertical filter coefficient hardware register in the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a7db48bb8c89558ede058fafd93bf659b">More...</a><br/></td></tr>
<tr class="separator:a7db48bb8c89558ede058fafd93bf659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2cce0b24a6a394ff0e05f7e3a1b28"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a13f2cce0b24a6a394ff0e05f7e3a1b28">XV_vscaler_Get_HwReg_vfltCoeff_BitWidth</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a13f2cce0b24a6a394ff0e05f7e3a1b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Get_HwReg_vfltCoeff_BitWidth - Retrieves the bit width of the vertical filter coefficient hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a13f2cce0b24a6a394ff0e05f7e3a1b28">More...</a><br/></td></tr>
<tr class="separator:a13f2cce0b24a6a394ff0e05f7e3a1b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa296ed16cfbb8b2cff5a38a3c1db1ed5"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#aa296ed16cfbb8b2cff5a38a3c1db1ed5">XV_vscaler_Get_HwReg_vfltCoeff_Depth</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:aa296ed16cfbb8b2cff5a38a3c1db1ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Get_HwReg_vfltCoeff_Depth - Retrieves the depth of the vertical filter coefficient hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#aa296ed16cfbb8b2cff5a38a3c1db1ed5">More...</a><br/></td></tr>
<tr class="separator:aa296ed16cfbb8b2cff5a38a3c1db1ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e3748f5ec0f48b3d899816619425f9"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a95e3748f5ec0f48b3d899816619425f9">XV_vscaler_Write_HwReg_vfltCoeff_Words</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, int offset, int *data, int length)</td></tr>
<tr class="memdesc:a95e3748f5ec0f48b3d899816619425f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Write_HwReg_vfltCoeff_Words - Writes an array of 32-bit words to the vertical filter coefficient hardware register of the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a95e3748f5ec0f48b3d899816619425f9">More...</a><br/></td></tr>
<tr class="separator:a95e3748f5ec0f48b3d899816619425f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f031627268fa360115b7ed8da123d"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#aa22f031627268fa360115b7ed8da123d">XV_vscaler_Read_HwReg_vfltCoeff_Words</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, int offset, int *data, int length)</td></tr>
<tr class="memdesc:aa22f031627268fa360115b7ed8da123d"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Read_HwReg_vfltCoeff_Words - Reads an array of 32-bit words from the vertical filter coefficient hardware register of the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#aa22f031627268fa360115b7ed8da123d">More...</a><br/></td></tr>
<tr class="separator:aa22f031627268fa360115b7ed8da123d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb8d3cce71f8638c7514d4086ccb341"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#adcb8d3cce71f8638c7514d4086ccb341">XV_vscaler_Write_HwReg_vfltCoeff_Bytes</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, int offset, char *data, int length)</td></tr>
<tr class="memdesc:adcb8d3cce71f8638c7514d4086ccb341"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Function Writes a sequence of bytes to the HWREG_VFLTCOEFF register of the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> hardware instance.  <a href="#adcb8d3cce71f8638c7514d4086ccb341">More...</a><br/></td></tr>
<tr class="separator:adcb8d3cce71f8638c7514d4086ccb341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3743a962d91e0e94d302976fde6ead"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a0c3743a962d91e0e94d302976fde6ead">XV_vscaler_Read_HwReg_vfltCoeff_Bytes</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, int offset, char *data, int length)</td></tr>
<tr class="memdesc:a0c3743a962d91e0e94d302976fde6ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_Read_HwReg_vfltCoeff_Bytes - Reads a sequence of bytes from the HWREG_VFLTCOEFF register of the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> hardware instance.  <a href="#a0c3743a962d91e0e94d302976fde6ead">More...</a><br/></td></tr>
<tr class="separator:a0c3743a962d91e0e94d302976fde6ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef78cf2344a65abb4e19346250270de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#aef78cf2344a65abb4e19346250270de2">XV_vscaler_InterruptGlobalEnable</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:aef78cf2344a65abb4e19346250270de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the global interrupt for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#aef78cf2344a65abb4e19346250270de2">More...</a><br/></td></tr>
<tr class="separator:aef78cf2344a65abb4e19346250270de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f489d24ae0ec8e5e6696fa0c12fa6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#ad7f489d24ae0ec8e5e6696fa0c12fa6e">XV_vscaler_InterruptGlobalDisable</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:ad7f489d24ae0ec8e5e6696fa0c12fa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_InterruptGlobalDisable - Disables the global interrupt for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#ad7f489d24ae0ec8e5e6696fa0c12fa6e">More...</a><br/></td></tr>
<tr class="separator:ad7f489d24ae0ec8e5e6696fa0c12fa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f5ea5f6aeb2f8cb6865a308a75d592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#af0f5ea5f6aeb2f8cb6865a308a75d592">XV_vscaler_InterruptEnable</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:af0f5ea5f6aeb2f8cb6865a308a75d592"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_InterruptEnable - Enables specific interrupts for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#af0f5ea5f6aeb2f8cb6865a308a75d592">More...</a><br/></td></tr>
<tr class="separator:af0f5ea5f6aeb2f8cb6865a308a75d592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ed466b058a18e9b2dfc7f6e4cf9309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a66ed466b058a18e9b2dfc7f6e4cf9309">XV_vscaler_InterruptDisable</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:a66ed466b058a18e9b2dfc7f6e4cf9309"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_InterruptDisable - Disables specific interrupts for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a66ed466b058a18e9b2dfc7f6e4cf9309">More...</a><br/></td></tr>
<tr class="separator:a66ed466b058a18e9b2dfc7f6e4cf9309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc587e811daec6dde1668b00a71267c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a7dc587e811daec6dde1668b00a71267c">XV_vscaler_InterruptClear</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:a7dc587e811daec6dde1668b00a71267c"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_InterruptClear - Clears specific interrupts for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a7dc587e811daec6dde1668b00a71267c">More...</a><br/></td></tr>
<tr class="separator:a7dc587e811daec6dde1668b00a71267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2cb2110f3242b7c5882579fabf3224"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#a5b2cb2110f3242b7c5882579fabf3224">XV_vscaler_InterruptGetEnabled</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:a5b2cb2110f3242b7c5882579fabf3224"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_InterruptGetEnabled - Retrieves the interrupt enable register value for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#a5b2cb2110f3242b7c5882579fabf3224">More...</a><br/></td></tr>
<tr class="separator:a5b2cb2110f3242b7c5882579fabf3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd4d0e55e53545aa0567dcb261ed30a"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xv__vscaler_8c.html#afcd4d0e55e53545aa0567dcb261ed30a">XV_vscaler_InterruptGetStatus</a> (<a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *InstancePtr)</td></tr>
<tr class="memdesc:afcd4d0e55e53545aa0567dcb261ed30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">XV_vscaler_InterruptGetStatus - Retrieves the interrupt status for the given <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.  <a href="#afcd4d0e55e53545aa0567dcb261ed30a">More...</a><br/></td></tr>
<tr class="separator:afcd4d0e55e53545aa0567dcb261ed30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a74344a7bbd1a51c11457b21720ff4ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XV_vscaler_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler___config.html">XV_vscaler_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_CfgInitialize - Initialize the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function initializes an <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance using the provided configuration structure and effective base address. It sets up the instance configuration, assigns the base address, and marks the driver as ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance to initialize. </td></tr>
    <tr><td class="paramname">ConfigPtr,:</td><td>Pointer to the configuration structure. </td></tr>
    <tr><td class="paramname">EffectiveAddr,:</td><td>Physical base address of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if successful. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="xv__vscaler__sinit_8c.html#a5163a0d50be810e8584a0f1f1604269d">XV_vscaler_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c36dd3e88c5be95a8c1101cac4a111"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_DisableAutoRestart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_DisableAutoRestart - Disables the auto-restart feature of the V-Scaler hardware instance. </p>
<p>This function asserts that the provided instance pointer is not NULL and that the instance is ready before writing to the control register to disable auto-restart. After calling this function, the V-Scaler hardware will not automatically restart its operation after completing a task, and must be manually started if further processing is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance to operate on. Must not be NULL and must point to an initialized and ready <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>, and <a class="el" href="xv__vscaler__hw_8h.html#a45e6c51a9633e2e0258d4e33e3bb7785">XV_VSCALER_CTRL_ADDR_AP_CTRL</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga3e8283da952231832e4e222ad6e5db87">XV_VScalerStop()</a>.</p>

</div>
</div>
<a class="anchor" id="a4bee58a9aaeaf7de3f4393044f284445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_EnableAutoRestart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_EnableAutoRestart - Enable auto-restart for the v_vscaler hardware. </p>
<p>This function sets the auto-restart bit (bit 7) in the control register, enabling the hardware to automatically restart after completing its current operation. It asserts that the InstancePtr is not NULL and that the driver is ready before accessing the hardware registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>, and <a class="el" href="xv__vscaler__hw_8h.html#a45e6c51a9633e2e0258d4e33e3bb7785">XV_VSCALER_CTRL_ADDR_AP_CTRL</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga18b042a9e8363a391ea0003cc3161fdd">XV_VScalerStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a968c2fdbffb0c931dcc00e698375db6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Get_HwReg_ColorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current color mode hardware register value from the V-Scaler instance. </p>
<p>This function reads the value of the color mode register from the hardware using the base address specified in the instance configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It must be initialized and ready before calling this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the color mode hardware register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function asserts that the instance pointer is not NULL and that the instance is ready before accessing the hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ae4d3d419b09bddc9ddcbda73b77f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Get_HwReg_HeightIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Get_HwReg_HeightIn - Retrieves the input height value from the hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function reads the value of the input height hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It asserts that the instance pointer is not NULL and that the instance is ready before performing the register read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the input height hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="adf18f5ce31c7d60f4087cc55ec9b67f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Get_HwReg_HeightOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Get_HwReg_HeightOut - Retrieves the output height value from the hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function reads the value of the output height hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It asserts that the instance pointer is not NULL and that the instance is ready before performing the register read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the output height hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="af008030d183c88142c8800ab282fe25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Get_HwReg_LineRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Get_HwReg_LineRate - Retrieves the line rate value from the hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function reads the value of the line rate hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It asserts that the instance pointer is not NULL and that the instance is ready before performing the register read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the line rate hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="a70cd1e2d2b08d4d789673cc50020764e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINTPTR XV_vscaler_Get_HwReg_vfltCoeff_BaseAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Get_HwReg_vfltCoeff_BaseAddress - Get the base address of the vertical filter coefficient hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function returns the base address of the vertical filter coefficient hardware register by adding the base address from the instance configuration to the defined offset for the vertical filter coefficient register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base address of the vertical filter coefficient hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="a13f2cce0b24a6a394ff0e05f7e3a1b28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Get_HwReg_vfltCoeff_BitWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Get_HwReg_vfltCoeff_BitWidth - Retrieves the bit width of the vertical filter coefficient hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function returns the bit width of the HWREG_VFLTCOEFF register as defined by the XV_VSCALER_CTRL_WIDTH_HWREG_VFLTCOEFF macro. It asserts that the instance pointer is not NULL and that the instance is ready before returning the bit width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit width of the vertical filter coefficient hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="aa296ed16cfbb8b2cff5a38a3c1db1ed5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Get_HwReg_vfltCoeff_Depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Get_HwReg_vfltCoeff_Depth - Retrieves the depth of the vertical filter coefficient hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function returns the depth of the HWREG_VFLTCOEFF register as defined by the XV_VSCALER_CTRL_DEPTH_HWREG_VFLTCOEFF macro. It asserts that the instance pointer is not NULL and that the instance is ready before returning the depth value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The depth of the vertical filter coefficient hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="a6a2256cc55b9c80ea2f883c44f9e432d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINTPTR XV_vscaler_Get_HwReg_vfltCoeff_HighAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Get_HwReg_vfltCoeff_HighAddress - Get the high address of the vertical filter coefficient hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function returns the high address of the vertical filter coefficient hardware register by adding the base address from the instance configuration to the defined high offset for the vertical filter coefficient register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The high address of the vertical filter coefficient hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="a7db48bb8c89558ede058fafd93bf659b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Get_HwReg_vfltCoeff_TotalBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the total number of bytes for the vertical filter coefficient hardware register in the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function calculates the total byte size by subtracting the base address of the HWREG_VFLTCOEFF register from its high address and adding one, which gives the total addressable bytes for the coefficient register block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It must be a valid pointer and the instance must be ready.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes allocated for the HWREG_VFLTCOEFF register block. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ab61949acefe534a2488cef9a5abdeea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Get_HwReg_Width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Get_HwReg_Width - Retrieves the width value from the hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function reads the value of the width hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It asserts that the instance pointer is not NULL and that the instance is ready before performing the register read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the width hardware register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="a7dc587e811daec6dde1668b00a71267c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_InterruptClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_InterruptClear - Clears specific interrupts for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function clears the interrupts specified by the Mask parameter for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> hardware instance. It asserts that the provided instance pointer is not NULL and that the instance is ready before writing to the interrupt status register to clear the specified interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
    <tr><td class="paramname">Mask</td><td>Bitmask specifying which interrupts to clear. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="a66ed466b058a18e9b2dfc7f6e4cf9309"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_InterruptDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_InterruptDisable - Disables specific interrupts for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function disables the interrupts specified by the Mask parameter for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> hardware instance. It first asserts that the provided instance pointer is not NULL and that the instance is ready. The function reads the current interrupt enable register, clears the bits specified by Mask, and writes the updated value back to the register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
    <tr><td class="paramname">Mask</td><td>Bitmask specifying which interrupts to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="af0f5ea5f6aeb2f8cb6865a308a75d592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_InterruptEnable - Enables specific interrupts for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function enables the interrupts specified by the Mask parameter for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> hardware instance. It first asserts that the provided instance pointer is not NULL and that the instance is ready. The function reads the current interrupt enable register, sets the bits specified by Mask, and writes the updated value back to the register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
    <tr><td class="paramname">Mask</td><td>Bitmask specifying which interrupts to enable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="a5b2cb2110f3242b7c5882579fabf3224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_InterruptGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_InterruptGetEnabled - Retrieves the interrupt enable register value for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function checks that the provided instance pointer is not NULL and that the instance is ready before reading the interrupt enable register from the hardware. The value returned indicates which interrupts are currently enabled for the scaler hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents of the interrupt enable register, indicating the enabled interrupts. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="afcd4d0e55e53545aa0567dcb261ed30a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_InterruptGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_InterruptGetStatus - Retrieves the interrupt status for the given <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function asserts that the provided instance pointer is not NULL and that the instance is ready before reading the interrupt status register from the hardware. The status is read from the ISR (Interrupt Status Register) at the base address specified in the configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current value of the interrupt status register. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ad7f489d24ae0ec8e5e6696fa0c12fa6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_InterruptGlobalDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_InterruptGlobalDisable - Disables the global interrupt for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function asserts that the provided InstancePtr is not NULL and that the instance is ready. It then writes to the Global Interrupt Enable (GIE) register to disable global interrupts for the scaler hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance for which the global interrupt should be disabled. The instance must be initialized and ready before calling this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="aef78cf2344a65abb4e19346250270de2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_InterruptGlobalEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the global interrupt for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function asserts that the provided InstancePtr is not NULL and that the instance is ready. It then writes to the Global Interrupt Enable (GIE) register to enable global interrupts for the scaler hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance for which the global interrupt should be enabled. The instance must be initialized and ready before calling this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="a8df38322c966a4a17c09ae17c86b1f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_IsDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_IsDone - Check if the v_vscaler hardware has finished processing. </p>
<p>This function reads the control register and checks the ap_done bit (bit 1) to determine if the hardware has completed its operation. It asserts that the InstancePtr is not NULL and that the driver is ready before accessing the hardware registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the hardware is done, 0 otherwise. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>, and <a class="el" href="xv__vscaler__hw_8h.html#a45e6c51a9633e2e0258d4e33e3bb7785">XV_VSCALER_CTRL_ADDR_AP_CTRL</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="a9037422243c74fa13b1f3dfdeb1e2db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_IsIdle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_IsIdle - Check if the v_vscaler hardware is idle. </p>
<p>This function reads the control register and checks the ap_idle bit (bit 2) to determine if the hardware is currently idle. It asserts that the InstancePtr is not NULL and that the driver is ready before accessing the hardware registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the hardware is idle, 0 otherwise. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>, and <a class="el" href="xv__vscaler__hw_8h.html#a45e6c51a9633e2e0258d4e33e3bb7785">XV_VSCALER_CTRL_ADDR_AP_CTRL</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ac21858dd356b66d377bef6b3b7fa99e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_IsReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_IsReady - Check if the v_vscaler hardware is ready for new input. </p>
<p>This function reads the control register and checks the ap_start bit (bit 0) to determine if the hardware is ready to accept new input. It asserts that the InstancePtr is not NULL and that the driver is ready before accessing the hardware registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the hardware is ready for new input, 0 otherwise. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>, and <a class="el" href="xv__vscaler__hw_8h.html#a45e6c51a9633e2e0258d4e33e3bb7785">XV_VSCALER_CTRL_ADDR_AP_CTRL</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga0aec7af5a1af5d07c6d769c0f54e73fd">XV_VScalerDbgReportStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c3743a962d91e0e94d302976fde6ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Read_HwReg_vfltCoeff_Bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Read_HwReg_vfltCoeff_Bytes - Reads a sequence of bytes from the HWREG_VFLTCOEFF register of the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> hardware instance. </p>
<p>This function reads 'length' bytes from the hardware register starting at the specified 'offset' and stores them in the buffer pointed to by 'data'. It ensures that the read operation does not exceed the register's address range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset from the base address of HWREG_VFLTCOEFF where reading starts. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data buffer where read bytes will be stored. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to read from the hardware register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read on success, or 0 if the operation would exceed the register's address range. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, and <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>.</p>

</div>
</div>
<a class="anchor" id="aa22f031627268fa360115b7ed8da123d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Read_HwReg_vfltCoeff_Words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Read_HwReg_vfltCoeff_Words - Reads an array of 32-bit words from the vertical filter coefficient hardware register of the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function reads the specified number of 32-bit words from the HWREG_VFLTCOEFF register block, starting at the given offset, and stores them in the provided data array. It first checks that the instance pointer is valid and that the instance is ready. The function also ensures that the read operation does not exceed the bounds of the register block. If the operation is valid, it reads each word sequentially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
    <tr><td class="paramname">offset,:</td><td>Offset (in words) from the base of the HWREG_VFLTCOEFF register block where reading begins. </td></tr>
    <tr><td class="paramname">data,:</td><td>Pointer to the array where the read 32-bit words will be stored. </td></tr>
    <tr><td class="paramname">length,:</td><td>Number of 32-bit words to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of words read if successful, or 0 if the operation would exceed the register block bounds. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, and <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>.</p>

</div>
</div>
<a class="anchor" id="a0ba1db0e373347f763d1f72a6d3784e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_Set_HwReg_ColorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Set_HwReg_ColorMode - Sets the hardware register for color mode in the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function writes the specified color mode data to the hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It first asserts that the instance pointer is not NULL and that the instance is ready before performing the register write operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
    <tr><td class="paramname">Data,:</td><td>The color mode data to be written to the hardware register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#gaa7b32a54f54e226389a3410ac2e3a669">XV_VScalerSetup()</a>.</p>

</div>
</div>
<a class="anchor" id="a30fe0f47ae9bc0f40c49eb01f1e06763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_Set_HwReg_HeightIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Set_HwReg_HeightIn - Sets the input height hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function writes the specified input height value to the hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It first asserts that the instance pointer is not NULL and that the instance is ready before performing the register write operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
    <tr><td class="paramname">Data,:</td><td>The input height value to be written to the hardware register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#gaa7b32a54f54e226389a3410ac2e3a669">XV_VScalerSetup()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c73450043e36e471579a2d0fd272404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_Set_HwReg_HeightOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Set_HwReg_HeightOut - Sets the output height hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function writes the specified output height value to the hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It asserts that the instance pointer is not NULL and that the instance is ready before performing the register write operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
    <tr><td class="paramname">Data,:</td><td>The output height value to be written to the hardware register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#gaa7b32a54f54e226389a3410ac2e3a669">XV_VScalerSetup()</a>.</p>

</div>
</div>
<a class="anchor" id="acee2c1ec52df88fdf5cc7b025e950674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_Set_HwReg_LineRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Set_HwReg_LineRate - Sets the line rate hardware register for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function writes the specified line rate value to the hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It asserts that the instance pointer is not NULL and that the instance is ready before performing the register write operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
    <tr><td class="paramname">Data,:</td><td>The line rate value to be written to the hardware register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#gaa7b32a54f54e226389a3410ac2e3a669">XV_VScalerSetup()</a>.</p>

</div>
</div>
<a class="anchor" id="ad53d59dd268dd2c5a9dea1d89bcf5df8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_Set_HwReg_Width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Set_HwReg_Width - Sets the hardware register width for the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function writes the specified width value to the hardware register associated with the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. It asserts that the instance pointer is not NULL and that the instance is ready before performing the register write operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized. </td></tr>
    <tr><td class="paramname">Data,:</td><td>The width value to be written to the hardware register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, and <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#gaa7b32a54f54e226389a3410ac2e3a669">XV_VScalerSetup()</a>.</p>

</div>
</div>
<a class="anchor" id="ac93878549b2774a0067b7c9711c3e14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XV_vscaler_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Start - Start the v_vscaler hardware. </p>
<p>This function sets the ap_start bit in the control register to start the hardware. It preserves the auto-restart bit (bit 7) if it was previously set. The function asserts that the InstancePtr is not NULL and that the driver is ready before accessing the hardware registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>, <a class="el" href="struct_x_v__vscaler.html#a6658752e25aabc60b0ab4fa27c075b2d">XV_vscaler::IsReady</a>, and <a class="el" href="xv__vscaler__hw_8h.html#a45e6c51a9633e2e0258d4e33e3bb7785">XV_VSCALER_CTRL_ADDR_AP_CTRL</a>.</p>

<p>Referenced by <a class="el" href="group__v__vscaler.html#ga18b042a9e8363a391ea0003cc3161fdd">XV_VScalerStart()</a>.</p>

</div>
</div>
<a class="anchor" id="adcb8d3cce71f8638c7514d4086ccb341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Write_HwReg_vfltCoeff_Bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This Function Writes a sequence of bytes to the HWREG_VFLTCOEFF register of the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> hardware instance. </p>
<p>This function writes 'length' bytes from the buffer pointed to by 'data' into the hardware register starting at the specified 'offset'. It ensures that the write operation does not exceed the register's address range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset from the base address of HWREG_VFLTCOEFF where writing starts. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data buffer containing bytes to write. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to write from the data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written on success, or 0 if the operation would exceed the register's address range. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, and <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>.</p>

</div>
</div>
<a class="anchor" id="a95e3748f5ec0f48b3d899816619425f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XV_vscaler_Write_HwReg_vfltCoeff_Words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_v__vscaler.html">XV_vscaler</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XV_vscaler_Write_HwReg_vfltCoeff_Words - Writes an array of 32-bit words to the vertical filter coefficient hardware register of the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. </p>
<p>This function writes the specified number of 32-bit words from the provided data array to the HWREG_VFLTCOEFF register block, starting at the given offset. It first checks that the instance pointer is valid and that the instance is ready. The function also ensures that the write operation does not exceed the bounds of the register block. If the operation is valid, it writes each word sequentially.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr,:</td><td>Pointer to the <a class="el" href="struct_x_v__vscaler.html" title="Driver instance data. ">XV_vscaler</a> instance. Must not be NULL and must be initialized and ready. </td></tr>
    <tr><td class="paramname">offset,:</td><td>Offset (in words) from the base of the HWREG_VFLTCOEFF register block where writing begins. </td></tr>
    <tr><td class="paramname">data,:</td><td>Pointer to the array of 32-bit words to write. </td></tr>
    <tr><td class="paramname">length,:</td><td>Number of 32-bit words to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of words written if successful, or 0 if the operation would exceed the register block bounds. </dd></dl>

<p>References <a class="el" href="struct_x_v__vscaler___config.html#af6e93f96db0d7fdb7859bfdca31cb9e7">XV_vscaler_Config::BaseAddress</a>, and <a class="el" href="struct_x_v__vscaler.html#a1622ea62ff6931a74737c9252f6cd7c1">XV_vscaler::Config</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
