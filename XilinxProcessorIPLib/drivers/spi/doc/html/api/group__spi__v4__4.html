<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>spi: Spi_v4_4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">spi
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__spi__v4__4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Spi_v4_4</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> statistics.  <a href="struct_x_spi___stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for the device.  <a href="struct_x_spi___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi.html">XSpi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> driver instance data.  <a href="struct_x_spi.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa9075007c45d749e3b9bd24a37f9d908"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaa9075007c45d749e3b9bd24a37f9d908">XSpi_IntrGlobalEnable</a>(InstancePtr)</td></tr>
<tr class="memdesc:gaa9075007c45d749e3b9bd24a37f9d908"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro writes to the global interrupt enable register to enable interrupts from the device.  <a href="#gaa9075007c45d749e3b9bd24a37f9d908"></a><br/></td></tr>
<tr class="separator:gaa9075007c45d749e3b9bd24a37f9d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5035851f7c130da994d9deec67c89b5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga5035851f7c130da994d9deec67c89b5f">XSpi_IntrGlobalDisable</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr),  <a class="el" href="group__spi__v4__4.html#ga3a66b8345fe53a19c2da1a8162dc366d">XSP_DGIER_OFFSET</a>, 0)</td></tr>
<tr class="memdesc:ga5035851f7c130da994d9deec67c89b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro disables all interrupts for the device by writing to the Global interrupt enable register.  <a href="#ga5035851f7c130da994d9deec67c89b5f"></a><br/></td></tr>
<tr class="separator:ga5035851f7c130da994d9deec67c89b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2210a78f1a4bc86250be33e8093e686c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga2210a78f1a4bc86250be33e8093e686c">XSpi_IsIntrGlobalEnabled</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga2210a78f1a4bc86250be33e8093e686c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines if interrupts are enabled at the global level by reading the global interrupt register.  <a href="#ga2210a78f1a4bc86250be33e8093e686c"></a><br/></td></tr>
<tr class="separator:ga2210a78f1a4bc86250be33e8093e686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01dc10ba2ca5c1e5ff30ecd0cadac140"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga01dc10ba2ca5c1e5ff30ecd0cadac140">XSpi_IntrGetStatus</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga2bc4dc18547b8bdd05c5eb2b73c9ff7d">XSP_IISR_OFFSET</a>)</td></tr>
<tr class="memdesc:ga01dc10ba2ca5c1e5ff30ecd0cadac140"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the contents of the Interrupt Status Register.  <a href="#ga01dc10ba2ca5c1e5ff30ecd0cadac140"></a><br/></td></tr>
<tr class="separator:ga01dc10ba2ca5c1e5ff30ecd0cadac140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab883b734cc9b78985dae611df2f4725a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gab883b734cc9b78985dae611df2f4725a">XSpi_IntrClear</a>(InstancePtr, ClearMask)</td></tr>
<tr class="memdesc:gab883b734cc9b78985dae611df2f4725a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the specified interrupts in the Interrupt status Register.  <a href="#gab883b734cc9b78985dae611df2f4725a"></a><br/></td></tr>
<tr class="separator:gab883b734cc9b78985dae611df2f4725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f2b8305794c31bc41ebd35ffeb4892"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga85f2b8305794c31bc41ebd35ffeb4892">XSpi_IntrEnable</a>(InstancePtr, EnableMask)</td></tr>
<tr class="memdesc:ga85f2b8305794c31bc41ebd35ffeb4892"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the contents of the Interrupt Enable Register.  <a href="#ga85f2b8305794c31bc41ebd35ffeb4892"></a><br/></td></tr>
<tr class="separator:ga85f2b8305794c31bc41ebd35ffeb4892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c1f7712f55bbb65d7b68c92b818f78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga48c1f7712f55bbb65d7b68c92b818f78">XSpi_IntrDisable</a>(InstancePtr, DisableMask)</td></tr>
<tr class="memdesc:ga48c1f7712f55bbb65d7b68c92b818f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the specified Interrupts in the Interrupt Enable Register.  <a href="#ga48c1f7712f55bbb65d7b68c92b818f78"></a><br/></td></tr>
<tr class="separator:ga48c1f7712f55bbb65d7b68c92b818f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049583711085eb8c9c47b2ef7907bf43"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga049583711085eb8c9c47b2ef7907bf43">XSpi_IntrGetEnabled</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr),  <a class="el" href="group__spi__v4__4.html#gace876b867131a62e5407d440c73d6693">XSP_IIER_OFFSET</a>)</td></tr>
<tr class="memdesc:ga049583711085eb8c9c47b2ef7907bf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the contents of the Interrupt Enable Register.  <a href="#ga049583711085eb8c9c47b2ef7907bf43"></a><br/></td></tr>
<tr class="separator:ga049583711085eb8c9c47b2ef7907bf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a33f7848a49e60041668c726eb14110"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>(InstancePtr, Mask)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>, (Mask))</td></tr>
<tr class="memdesc:ga3a33f7848a49e60041668c726eb14110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the contents of the control register.  <a href="#ga3a33f7848a49e60041668c726eb14110"></a><br/></td></tr>
<tr class="separator:ga3a33f7848a49e60041668c726eb14110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7988663ef9d2523ef167413fd6e8ab87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>)</td></tr>
<tr class="memdesc:ga7988663ef9d2523ef167413fd6e8ab87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of the control register.  <a href="#ga7988663ef9d2523ef167413fd6e8ab87"></a><br/></td></tr>
<tr class="separator:ga7988663ef9d2523ef167413fd6e8ab87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf65c9e65699c1746d205a77554d40adb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf65c9e65699c1746d205a77554d40adb">XSpi_GetStatusReg</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#gae4915bf726554a2abf5922129f88542b">XSP_SR_OFFSET</a>)</td></tr>
<tr class="memdesc:gaf65c9e65699c1746d205a77554d40adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of the status register.  <a href="#gaf65c9e65699c1746d205a77554d40adb"></a><br/></td></tr>
<tr class="separator:gaf65c9e65699c1746d205a77554d40adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ec4e1ee207bcb26d5aaf84e0324a9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga91ec4e1ee207bcb26d5aaf84e0324a9e">XSpi_SetXipControlReg</a>(InstancePtr, Mask)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>, (Mask))</td></tr>
<tr class="memdesc:ga91ec4e1ee207bcb26d5aaf84e0324a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the contents of the XIP control register.  <a href="#ga91ec4e1ee207bcb26d5aaf84e0324a9e"></a><br/></td></tr>
<tr class="separator:ga91ec4e1ee207bcb26d5aaf84e0324a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac0eb471df51c6af1a3a0a68b68d3808"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaac0eb471df51c6af1a3a0a68b68d3808">XSpi_GetXipControlReg</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>)</td></tr>
<tr class="memdesc:gaac0eb471df51c6af1a3a0a68b68d3808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of the XIP control register.  <a href="#gaac0eb471df51c6af1a3a0a68b68d3808"></a><br/></td></tr>
<tr class="separator:gaac0eb471df51c6af1a3a0a68b68d3808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b64cb823a81025224b87a5d26a4fa39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga3b64cb823a81025224b87a5d26a4fa39">XSpi_GetXipStatusReg</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#gae4915bf726554a2abf5922129f88542b">XSP_SR_OFFSET</a>)</td></tr>
<tr class="memdesc:ga3b64cb823a81025224b87a5d26a4fa39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of the status register.  <a href="#ga3b64cb823a81025224b87a5d26a4fa39"></a><br/></td></tr>
<tr class="separator:ga3b64cb823a81025224b87a5d26a4fa39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93befb10305b5abccc5483b73e60060"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gae93befb10305b5abccc5483b73e60060">XSpi_SetSlaveSelectReg</a>(InstancePtr, Mask)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga34c2ab4de85d2a3a5659e5446235942c">XSP_SSR_OFFSET</a>, (Mask))</td></tr>
<tr class="memdesc:gae93befb10305b5abccc5483b73e60060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the contents of the slave select register.  <a href="#gae93befb10305b5abccc5483b73e60060"></a><br/></td></tr>
<tr class="separator:gae93befb10305b5abccc5483b73e60060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8ab7387ce196ce3309dc68bd15e489"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga5c8ab7387ce196ce3309dc68bd15e489">XSpi_GetSlaveSelectReg</a>(InstancePtr)&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>((InstancePtr)-&gt;BaseAddr, <a class="el" href="group__spi__v4__4.html#ga34c2ab4de85d2a3a5659e5446235942c">XSP_SSR_OFFSET</a>)</td></tr>
<tr class="memdesc:ga5c8ab7387ce196ce3309dc68bd15e489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of the slave select register.  <a href="#ga5c8ab7387ce196ce3309dc68bd15e489"></a><br/></td></tr>
<tr class="separator:ga5c8ab7387ce196ce3309dc68bd15e489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddf2c25474dac11bd30c9f938bd753d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga1ddf2c25474dac11bd30c9f938bd753d">XSpi_Enable</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga1ddf2c25474dac11bd30c9f938bd753d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the device and uninhibit master transactions.  <a href="#ga1ddf2c25474dac11bd30c9f938bd753d"></a><br/></td></tr>
<tr class="separator:ga1ddf2c25474dac11bd30c9f938bd753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga642e3f4be4784f5823c368a0afdfe078"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga642e3f4be4784f5823c368a0afdfe078">XSpi_Disable</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga642e3f4be4784f5823c368a0afdfe078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the device.  <a href="#ga642e3f4be4784f5823c368a0afdfe078"></a><br/></td></tr>
<tr class="separator:ga642e3f4be4784f5823c368a0afdfe078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e55891344ab473841b6eefc2bda35a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(BaseAddress, RegOffset)&#160;&#160;&#160;XSpi_In32((BaseAddress) + (RegOffset))</td></tr>
<tr class="memdesc:ga5e55891344ab473841b6eefc2bda35a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the specified Spi device register.  <a href="#ga5e55891344ab473841b6eefc2bda35a2"></a><br/></td></tr>
<tr class="separator:ga5e55891344ab473841b6eefc2bda35a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e741800118678aa060ef2a13661e31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(BaseAddress, RegOffset, RegisterValue)&#160;&#160;&#160;XSpi_Out32((BaseAddress) + (RegOffset), (RegisterValue))</td></tr>
<tr class="memdesc:ga32e741800118678aa060ef2a13661e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the specified Spi device register.  <a href="#ga32e741800118678aa060ef2a13661e31"></a><br/></td></tr>
<tr class="separator:ga32e741800118678aa060ef2a13661e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fdfb116f37c7f14403bed57b556c4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga48fdfb116f37c7f14403bed57b556c4c">XSP_SRR_RESET_MASK</a>&#160;&#160;&#160;0x0000000A</td></tr>
<tr class="memdesc:ga48fdfb116f37c7f14403bed57b556c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Software Reset Register (SRR) mask.  <a href="#ga48fdfb116f37c7f14403bed57b556c4c"></a><br/></td></tr>
<tr class="separator:ga48fdfb116f37c7f14403bed57b556c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa9c3c5101d73a626380c46bcc906069e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaa9c3c5101d73a626380c46bcc906069e">XSpi_StatusHandler</a> )(void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)</td></tr>
<tr class="memdesc:gaa9c3c5101d73a626380c46bcc906069e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handler data type allows the user to define a callback function to handle the asynchronous processing of the SPI driver.  <a href="#gaa9c3c5101d73a626380c46bcc906069e"></a><br/></td></tr>
<tr class="separator:gaa9c3c5101d73a626380c46bcc906069e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga44a2dc795761b35ed0ebdd6989675022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga44a2dc795761b35ed0ebdd6989675022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts a transfer in progress by setting the stop bit in the control register, then resetting the FIFOs if present.  <a href="#ga44a2dc795761b35ed0ebdd6989675022"></a><br/></td></tr>
<tr class="separator:ga44a2dc795761b35ed0ebdd6989675022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858155b42d5a1da8efe06c9098e40b2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, <a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *Config, UINTPTR EffectiveAddr)</td></tr>
<tr class="memdesc:ga858155b42d5a1da8efe06c9098e40b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a specific <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance such that the driver is ready to use.  <a href="#ga858155b42d5a1da8efe06c9098e40b2d"></a><br/></td></tr>
<tr class="separator:ga858155b42d5a1da8efe06c9098e40b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87fdaad742a2669200c9b2617e5c86ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga87fdaad742a2669200c9b2617e5c86ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables interrupts for the SPI device.  <a href="#ga87fdaad742a2669200c9b2617e5c86ea"></a><br/></td></tr>
<tr class="separator:ga87fdaad742a2669200c9b2617e5c86ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4bb67cfcfe73844ffb1917b11d5284c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gad4bb67cfcfe73844ffb1917b11d5284c">XSpi_Stop</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr class="memdesc:gad4bb67cfcfe73844ffb1917b11d5284c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the SPI device by disabling interrupts and disabling the device itself.  <a href="#gad4bb67cfcfe73844ffb1917b11d5284c"></a><br/></td></tr>
<tr class="separator:gad4bb67cfcfe73844ffb1917b11d5284c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343938fcdf672bec329d876a146178cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga343938fcdf672bec329d876a146178cd">XSpi_Reset</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga343938fcdf672bec329d876a146178cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the SPI device by writing to the Software Reset register.  <a href="#ga343938fcdf672bec329d876a146178cd"></a><br/></td></tr>
<tr class="separator:ga343938fcdf672bec329d876a146178cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c44c082ef2d2b9cf4ba3db8bcebd954"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned int ByteCount)</td></tr>
<tr class="memdesc:ga4c44c082ef2d2b9cf4ba3db8bcebd954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers the specified data on the SPI bus.  <a href="#ga4c44c082ef2d2b9cf4ba3db8bcebd954"></a><br/></td></tr>
<tr class="separator:ga4c44c082ef2d2b9cf4ba3db8bcebd954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162523a3e9b29f063701db303ac8cf17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga162523a3e9b29f063701db303ac8cf17">XSpi_SetSlaveSelect</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u32 SlaveMask)</td></tr>
<tr class="memdesc:ga162523a3e9b29f063701db303ac8cf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects or deselect the slave with which the master communicates.  <a href="#ga162523a3e9b29f063701db303ac8cf17"></a><br/></td></tr>
<tr class="separator:ga162523a3e9b29f063701db303ac8cf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8043891b8f68a3291bd035be74aa6b94"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga8043891b8f68a3291bd035be74aa6b94">XSpi_GetSlaveSelect</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga8043891b8f68a3291bd035be74aa6b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current slave select bit mask for the SPI device.  <a href="#ga8043891b8f68a3291bd035be74aa6b94"></a><br/></td></tr>
<tr class="separator:ga8043891b8f68a3291bd035be74aa6b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc09f4d503de2a772e5079ac46fc62b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gabc09f4d503de2a772e5079ac46fc62b6">XSpi_SetStatusHandler</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, void *CallBackRef, <a class="el" href="group__spi__v4__4.html#gaa9c3c5101d73a626380c46bcc906069e">XSpi_StatusHandler</a> FuncPtr)</td></tr>
<tr class="memdesc:gabc09f4d503de2a772e5079ac46fc62b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to the higher layer software.  <a href="#gabc09f4d503de2a772e5079ac46fc62b6"></a><br/></td></tr>
<tr class="separator:gabc09f4d503de2a772e5079ac46fc62b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3863f11d27469d8797424319601c980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler</a> (void *InstancePtr)</td></tr>
<tr class="memdesc:gaf3863f11d27469d8797424319601c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interrupt handler for SPI interrupts.  <a href="#gaf3863f11d27469d8797424319601c980"></a><br/></td></tr>
<tr class="separator:gaf3863f11d27469d8797424319601c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1fb3e31ba804cc87dc309847fb02471"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaa1fb3e31ba804cc87dc309847fb02471">XSpi_Initialize</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr class="memdesc:gaa1fb3e31ba804cc87dc309847fb02471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a specific <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance such that the driver is ready to use.  <a href="#gaa1fb3e31ba804cc87dc309847fb02471"></a><br/></td></tr>
<tr class="separator:gaa1fb3e31ba804cc87dc309847fb02471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c4a169e05ad6e040796ae86100fd5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gac2c4a169e05ad6e040796ae86100fd5b">XSpi_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:gac2c4a169e05ad6e040796ae86100fd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the device configuration based on the unique device ID.  <a href="#gac2c4a169e05ad6e040796ae86100fd5b"></a><br/></td></tr>
<tr class="separator:gac2c4a169e05ad6e040796ae86100fd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11b6ebdb6f69c6939176e05600b10e3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga11b6ebdb6f69c6939176e05600b10e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a self-test on the driver/device.  <a href="#ga11b6ebdb6f69c6939176e05600b10e3e"></a><br/></td></tr>
<tr class="separator:ga11b6ebdb6f69c6939176e05600b10e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a40aee30eb6f0240b75e6ccd7596a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga8a40aee30eb6f0240b75e6ccd7596a53">XSpi_GetStats</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, <a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a> *StatsPtr)</td></tr>
<tr class="memdesc:ga8a40aee30eb6f0240b75e6ccd7596a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a copy of the statistics for an SPI device.  <a href="#ga8a40aee30eb6f0240b75e6ccd7596a53"></a><br/></td></tr>
<tr class="separator:ga8a40aee30eb6f0240b75e6ccd7596a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf243ac522e14869af82545ffc11d5821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf243ac522e14869af82545ffc11d5821">XSpi_ClearStats</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaf243ac522e14869af82545ffc11d5821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the statistics for the SPI device.  <a href="#gaf243ac522e14869af82545ffc11d5821"></a><br/></td></tr>
<tr class="separator:gaf243ac522e14869af82545ffc11d5821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c2076b133a55b6f80343642a1ace41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga67c2076b133a55b6f80343642a1ace41">XSpi_SetOptions</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u32 Options)</td></tr>
<tr class="memdesc:ga67c2076b133a55b6f80343642a1ace41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the options for the SPI device driver.  <a href="#ga67c2076b133a55b6f80343642a1ace41"></a><br/></td></tr>
<tr class="separator:ga67c2076b133a55b6f80343642a1ace41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55cfd2072ed2047c0fe0b65bd0fcf6a"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf55cfd2072ed2047c0fe0b65bd0fcf6a">XSpi_GetOptions</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaf55cfd2072ed2047c0fe0b65bd0fcf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the options for the SPI device.  <a href="#gaf55cfd2072ed2047c0fe0b65bd0fcf6a"></a><br/></td></tr>
<tr class="separator:gaf55cfd2072ed2047c0fe0b65bd0fcf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8c36dd59052589f679b9e441507116b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga8c36dd59052589f679b9e441507116b2">XSpi_ConfigTable</a> [XPAR_XSPI_NUM_INSTANCES]</td></tr>
<tr class="memdesc:ga8c36dd59052589f679b9e441507116b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each SPI device in the system.  <a href="#ga8c36dd59052589f679b9e441507116b2"></a><br/></td></tr>
<tr class="separator:ga8c36dd59052589f679b9e441507116b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f3cf000e45e67f36d374906154ac38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga31f3cf000e45e67f36d374906154ac38">XSpi_ConfigTable</a> []</td></tr>
<tr class="memdesc:ga31f3cf000e45e67f36d374906154ac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each SPI device in the system.  <a href="#ga31f3cf000e45e67f36d374906154ac38"></a><br/></td></tr>
<tr class="separator:ga31f3cf000e45e67f36d374906154ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f3cf000e45e67f36d374906154ac38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga31f3cf000e45e67f36d374906154ac38">XSpi_ConfigTable</a> []</td></tr>
<tr class="memdesc:ga31f3cf000e45e67f36d374906154ac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each SPI device in the system.  <a href="#ga31f3cf000e45e67f36d374906154ac38"></a><br/></td></tr>
<tr class="separator:ga31f3cf000e45e67f36d374906154ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Configuration options</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp50f33d14f129e4548c1c270fd6725a78"></a>The following options may be specified or retrieved for the device and enable/disable additional features of the SPI.</p>
<p>Each of the options are bit fields, so more than one may be specified. </p>
</td></tr>
<tr class="memitem:gac2c043a14b04e38a61b1979ccaa8a200"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gac2c043a14b04e38a61b1979ccaa8a200">XSP_MASTER_OPTION</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:gac2c043a14b04e38a61b1979ccaa8a200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae8f6e43593b5e57c47c4834f69a01a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae8f6e43593b5e57c47c4834f69a01a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_CLK_ACTIVE_LOW_OPTION</b>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:gaae8f6e43593b5e57c47c4834f69a01a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac3788ad6ebce692e4b3382c623c329"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabac3788ad6ebce692e4b3382c623c329"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_CLK_PHASE_1_OPTION</b>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:gabac3788ad6ebce692e4b3382c623c329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1124f7ede8e4ebe96f2c764b0dadfea1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1124f7ede8e4ebe96f2c764b0dadfea1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_LOOPBACK_OPTION</b>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:ga1124f7ede8e4ebe96f2c764b0dadfea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb7ff246ee212e9fa1379769aae76f47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb7ff246ee212e9fa1379769aae76f47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_MANUAL_SSELECT_OPTION</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:gaeb7ff246ee212e9fa1379769aae76f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Register Map</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp092729737d14686054aa21531a3582c6"></a>XSPI register offsets</p>
<p>Register offsets for the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> device. </p>
</td></tr>
<tr class="memitem:ga3a66b8345fe53a19c2da1a8162dc366d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga3a66b8345fe53a19c2da1a8162dc366d">XSP_DGIER_OFFSET</a>&#160;&#160;&#160;0x1C</td></tr>
<tr class="memdesc:ga3a66b8345fe53a19c2da1a8162dc366d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global Intr Enable Reg.  <a href="#ga3a66b8345fe53a19c2da1a8162dc366d"></a><br/></td></tr>
<tr class="separator:ga3a66b8345fe53a19c2da1a8162dc366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc4dc18547b8bdd05c5eb2b73c9ff7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga2bc4dc18547b8bdd05c5eb2b73c9ff7d">XSP_IISR_OFFSET</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:ga2bc4dc18547b8bdd05c5eb2b73c9ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt status Reg.  <a href="#ga2bc4dc18547b8bdd05c5eb2b73c9ff7d"></a><br/></td></tr>
<tr class="separator:ga2bc4dc18547b8bdd05c5eb2b73c9ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace876b867131a62e5407d440c73d6693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gace876b867131a62e5407d440c73d6693">XSP_IIER_OFFSET</a>&#160;&#160;&#160;0x28</td></tr>
<tr class="memdesc:gace876b867131a62e5407d440c73d6693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Enable Reg.  <a href="#gace876b867131a62e5407d440c73d6693"></a><br/></td></tr>
<tr class="separator:gace876b867131a62e5407d440c73d6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82028ecd15bcffd8ab361c0c523a7a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaa82028ecd15bcffd8ab361c0c523a7a9">XSP_SRR_OFFSET</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:gaa82028ecd15bcffd8ab361c0c523a7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software Reset register.  <a href="#gaa82028ecd15bcffd8ab361c0c523a7a9"></a><br/></td></tr>
<tr class="separator:gaa82028ecd15bcffd8ab361c0c523a7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a63aa98328d40e3221901143e128da1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>&#160;&#160;&#160;0x60</td></tr>
<tr class="memdesc:ga3a63aa98328d40e3221901143e128da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register.  <a href="#ga3a63aa98328d40e3221901143e128da1"></a><br/></td></tr>
<tr class="separator:ga3a63aa98328d40e3221901143e128da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4915bf726554a2abf5922129f88542b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gae4915bf726554a2abf5922129f88542b">XSP_SR_OFFSET</a>&#160;&#160;&#160;0x64</td></tr>
<tr class="memdesc:gae4915bf726554a2abf5922129f88542b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status Register.  <a href="#gae4915bf726554a2abf5922129f88542b"></a><br/></td></tr>
<tr class="separator:gae4915bf726554a2abf5922129f88542b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02929309d91a658ac28746aee48d0c04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga02929309d91a658ac28746aee48d0c04">XSP_DTR_OFFSET</a>&#160;&#160;&#160;0x68</td></tr>
<tr class="memdesc:ga02929309d91a658ac28746aee48d0c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data transmit.  <a href="#ga02929309d91a658ac28746aee48d0c04"></a><br/></td></tr>
<tr class="separator:ga02929309d91a658ac28746aee48d0c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078846fea7538049312959d15b44a9dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga078846fea7538049312959d15b44a9dd">XSP_DRR_OFFSET</a>&#160;&#160;&#160;0x6C</td></tr>
<tr class="memdesc:ga078846fea7538049312959d15b44a9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data receive.  <a href="#ga078846fea7538049312959d15b44a9dd"></a><br/></td></tr>
<tr class="separator:ga078846fea7538049312959d15b44a9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c2ab4de85d2a3a5659e5446235942c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga34c2ab4de85d2a3a5659e5446235942c">XSP_SSR_OFFSET</a>&#160;&#160;&#160;0x70</td></tr>
<tr class="memdesc:ga34c2ab4de85d2a3a5659e5446235942c"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit slave select  <a href="#ga34c2ab4de85d2a3a5659e5446235942c"></a><br/></td></tr>
<tr class="separator:ga34c2ab4de85d2a3a5659e5446235942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06c80c0767e40c86b2e3fc18457d680"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf06c80c0767e40c86b2e3fc18457d680">XSP_TFO_OFFSET</a>&#160;&#160;&#160;0x74</td></tr>
<tr class="memdesc:gaf06c80c0767e40c86b2e3fc18457d680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tx FIFO occupancy.  <a href="#gaf06c80c0767e40c86b2e3fc18457d680"></a><br/></td></tr>
<tr class="separator:gaf06c80c0767e40c86b2e3fc18457d680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e120064bd2a34a145d54608ccef4107"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga4e120064bd2a34a145d54608ccef4107">XSP_RFO_OFFSET</a>&#160;&#160;&#160;0x78</td></tr>
<tr class="memdesc:ga4e120064bd2a34a145d54608ccef4107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rx FIFO occupancy.  <a href="#ga4e120064bd2a34a145d54608ccef4107"></a><br/></td></tr>
<tr class="separator:ga4e120064bd2a34a145d54608ccef4107"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Global Interrupt Enable Register (GIER) mask(s)</h2></td></tr>
<tr class="memitem:ga492a1b3f6bb367fbb9e88b514722b13c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga492a1b3f6bb367fbb9e88b514722b13c">XSP_GINTR_ENABLE_MASK</a>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:ga492a1b3f6bb367fbb9e88b514722b13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global interrupt enable.  <a href="#ga492a1b3f6bb367fbb9e88b514722b13c"></a><br/></td></tr>
<tr class="separator:ga492a1b3f6bb367fbb9e88b514722b13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SPI Device Interrupt Status/Enable Registers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbaf2f743fc5f6a2c54559ec53730d8bb"></a><b> Interrupt Status Register (IPISR) </b></p>
<p>This register holds the interrupt status flags for the Spi device.</p>
<p><b> Interrupt Enable Register (IPIER) </b></p>
<p>This register is used to enable interrupt sources for the Spi device. Writing a '1' to a bit in this register enables the corresponding Interrupt. Writing a '0' to a bit in this register disables the corresponding Interrupt.</p>
<p>ISR/IER registers have the same bit definitions and are only defined once. </p>
</td></tr>
<tr class="memitem:gae1c1ffa1846ef388873861bf017aec7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gae1c1ffa1846ef388873861bf017aec7a">XSP_INTR_MODE_FAULT_MASK</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:gae1c1ffa1846ef388873861bf017aec7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode fault error.  <a href="#gae1c1ffa1846ef388873861bf017aec7a"></a><br/></td></tr>
<tr class="separator:gae1c1ffa1846ef388873861bf017aec7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f8c52684a188989df6463cfa44e90f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gad8f8c52684a188989df6463cfa44e90f">XSP_INTR_SLAVE_MODE_FAULT_MASK</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:gad8f8c52684a188989df6463cfa44e90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selected as slave while disabled.  <a href="#gad8f8c52684a188989df6463cfa44e90f"></a><br/></td></tr>
<tr class="separator:gad8f8c52684a188989df6463cfa44e90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ec3c2cf6ffb5824012e63935fe94cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaa8ec3c2cf6ffb5824012e63935fe94cf">XSP_INTR_TX_EMPTY_MASK</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:gaa8ec3c2cf6ffb5824012e63935fe94cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">DTR/TxFIFO is empty.  <a href="#gaa8ec3c2cf6ffb5824012e63935fe94cf"></a><br/></td></tr>
<tr class="separator:gaa8ec3c2cf6ffb5824012e63935fe94cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7a08185e86401169c2f810642f08ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga9a7a08185e86401169c2f810642f08ec">XSP_INTR_TX_UNDERRUN_MASK</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:ga9a7a08185e86401169c2f810642f08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">DTR/TxFIFO underrun.  <a href="#ga9a7a08185e86401169c2f810642f08ec"></a><br/></td></tr>
<tr class="separator:ga9a7a08185e86401169c2f810642f08ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154fc50d2dfa52ec08b03a202484f8b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga154fc50d2dfa52ec08b03a202484f8b0">XSP_INTR_RX_FULL_MASK</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:ga154fc50d2dfa52ec08b03a202484f8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">DRR/RxFIFO is full.  <a href="#ga154fc50d2dfa52ec08b03a202484f8b0"></a><br/></td></tr>
<tr class="separator:ga154fc50d2dfa52ec08b03a202484f8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4313597b27da75830905e5510d6c7ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gae4313597b27da75830905e5510d6c7ba">XSP_INTR_RX_OVERRUN_MASK</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:gae4313597b27da75830905e5510d6c7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">DRR/RxFIFO overrun.  <a href="#gae4313597b27da75830905e5510d6c7ba"></a><br/></td></tr>
<tr class="separator:gae4313597b27da75830905e5510d6c7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b6c5a44bb267e1d71293adfc225cc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga17b6c5a44bb267e1d71293adfc225cc4">XSP_INTR_TX_HALF_EMPTY_MASK</a>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:ga17b6c5a44bb267e1d71293adfc225cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">TxFIFO is half empty.  <a href="#ga17b6c5a44bb267e1d71293adfc225cc4"></a><br/></td></tr>
<tr class="separator:ga17b6c5a44bb267e1d71293adfc225cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac9322f55b43ad653b2dd630df73ac6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaaac9322f55b43ad653b2dd630df73ac6">XSP_INTR_SLAVE_MODE_MASK</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:gaaac9322f55b43ad653b2dd630df73ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave select mode.  <a href="#gaaac9322f55b43ad653b2dd630df73ac6"></a><br/></td></tr>
<tr class="separator:gaaac9322f55b43ad653b2dd630df73ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4fa2bf85266797c3806a885144f0a67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf4fa2bf85266797c3806a885144f0a67">XSP_INTR_RX_NOT_EMPTY_MASK</a>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="memdesc:gaf4fa2bf85266797c3806a885144f0a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">RxFIFO not empty.  <a href="#gaf4fa2bf85266797c3806a885144f0a67"></a><br/></td></tr>
<tr class="separator:gaf4fa2bf85266797c3806a885144f0a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4411b96eab10163334a172e8c7fff16e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga4411b96eab10163334a172e8c7fff16e">XSP_INTR_CPOL_CPHA_ERR_MASK</a>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="memdesc:ga4411b96eab10163334a172e8c7fff16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following bits are available only in axi_qspi Interrupt Status and Interrupt Enable registers.  <a href="#ga4411b96eab10163334a172e8c7fff16e"></a><br/></td></tr>
<tr class="separator:ga4411b96eab10163334a172e8c7fff16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02214d826551eaa28053bbe31961d7d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga02214d826551eaa28053bbe31961d7d8">XSP_INTR_SLAVE_MODE_ERR_MASK</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="memdesc:ga02214d826551eaa28053bbe31961d7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave mode error.  <a href="#ga02214d826551eaa28053bbe31961d7d8"></a><br/></td></tr>
<tr class="separator:ga02214d826551eaa28053bbe31961d7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab0807b07832514f750466433646109"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gadab0807b07832514f750466433646109">XSP_INTR_MSB_ERR_MASK</a>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="memdesc:gadab0807b07832514f750466433646109"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSB Error.  <a href="#gadab0807b07832514f750466433646109"></a><br/></td></tr>
<tr class="separator:gadab0807b07832514f750466433646109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab391120a5227047af0568687b386bee9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gab391120a5227047af0568687b386bee9">XSP_INTR_LOOP_BACK_ERR_MASK</a>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="memdesc:gab391120a5227047af0568687b386bee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop back error.  <a href="#gab391120a5227047af0568687b386bee9"></a><br/></td></tr>
<tr class="separator:gab391120a5227047af0568687b386bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78efad507778d0d5fe669486d4ac8558"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga78efad507778d0d5fe669486d4ac8558">XSP_INTR_CMD_ERR_MASK</a>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="memdesc:ga78efad507778d0d5fe669486d4ac8558"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Invalid cmd' error  <a href="#ga78efad507778d0d5fe669486d4ac8558"></a><br/></td></tr>
<tr class="separator:ga78efad507778d0d5fe669486d4ac8558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c321040c3a93daa19aa3fcc77c86e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf2c321040c3a93daa19aa3fcc77c86e8">XSP_INTR_ALL</a></td></tr>
<tr class="memdesc:gaf2c321040c3a93daa19aa3fcc77c86e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for all the interrupts in the IP Interrupt Registers.  <a href="#gaf2c321040c3a93daa19aa3fcc77c86e8"></a><br/></td></tr>
<tr class="separator:gaf2c321040c3a93daa19aa3fcc77c86e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99707579afa353242a403526ddebcb6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga99707579afa353242a403526ddebcb6d">XSP_INTR_DFT_MASK</a></td></tr>
<tr class="memdesc:ga99707579afa353242a403526ddebcb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interrupts we want at startup.  <a href="#ga99707579afa353242a403526ddebcb6d"></a><br/></td></tr>
<tr class="separator:ga99707579afa353242a403526ddebcb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SPI Control Register (CR) masks</h2></td></tr>
<tr class="memitem:ga6a060df48208ca7e56572762233ceadb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga6a060df48208ca7e56572762233ceadb">XSP_CR_LOOPBACK_MASK</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:ga6a060df48208ca7e56572762233ceadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local loopback mode.  <a href="#ga6a060df48208ca7e56572762233ceadb"></a><br/></td></tr>
<tr class="separator:ga6a060df48208ca7e56572762233ceadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c10904273bbeb8fb8fc502c5cc9cdf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga1c10904273bbeb8fb8fc502c5cc9cdf6">XSP_CR_ENABLE_MASK</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:ga1c10904273bbeb8fb8fc502c5cc9cdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">System enable.  <a href="#ga1c10904273bbeb8fb8fc502c5cc9cdf6"></a><br/></td></tr>
<tr class="separator:ga1c10904273bbeb8fb8fc502c5cc9cdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25aabcaa1db090de7cf4aaf3cb05ea6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga25aabcaa1db090de7cf4aaf3cb05ea6b">XSP_CR_MASTER_MODE_MASK</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:ga25aabcaa1db090de7cf4aaf3cb05ea6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable master mode.  <a href="#ga25aabcaa1db090de7cf4aaf3cb05ea6b"></a><br/></td></tr>
<tr class="separator:ga25aabcaa1db090de7cf4aaf3cb05ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522187d5fb382dfa512f02be7fe0068b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga522187d5fb382dfa512f02be7fe0068b">XSP_CR_CLK_POLARITY_MASK</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:ga522187d5fb382dfa512f02be7fe0068b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock polarity high or low.  <a href="#ga522187d5fb382dfa512f02be7fe0068b"></a><br/></td></tr>
<tr class="separator:ga522187d5fb382dfa512f02be7fe0068b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d555bd447b511847632a2fe19b8b04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga87d555bd447b511847632a2fe19b8b04">XSP_CR_CLK_PHASE_MASK</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:ga87d555bd447b511847632a2fe19b8b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock phase 0 or 1.  <a href="#ga87d555bd447b511847632a2fe19b8b04"></a><br/></td></tr>
<tr class="separator:ga87d555bd447b511847632a2fe19b8b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7796329c185988f906256394bc9372f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gab7796329c185988f906256394bc9372f">XSP_CR_TXFIFO_RESET_MASK</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:gab7796329c185988f906256394bc9372f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset transmit FIFO.  <a href="#gab7796329c185988f906256394bc9372f"></a><br/></td></tr>
<tr class="separator:gab7796329c185988f906256394bc9372f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5e5793f12d648025e58f716862bb3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga5b5e5793f12d648025e58f716862bb3e">XSP_CR_RXFIFO_RESET_MASK</a>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:ga5b5e5793f12d648025e58f716862bb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset receive FIFO.  <a href="#ga5b5e5793f12d648025e58f716862bb3e"></a><br/></td></tr>
<tr class="separator:ga5b5e5793f12d648025e58f716862bb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b5a025e603ab87d7987e2220507e6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga68b5a025e603ab87d7987e2220507e6c">XSP_CR_MANUAL_SS_MASK</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:ga68b5a025e603ab87d7987e2220507e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual slave select assert.  <a href="#ga68b5a025e603ab87d7987e2220507e6c"></a><br/></td></tr>
<tr class="separator:ga68b5a025e603ab87d7987e2220507e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d045067441152dbf5729d4dce64032b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga2d045067441152dbf5729d4dce64032b">XSP_CR_TRANS_INHIBIT_MASK</a>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="memdesc:ga2d045067441152dbf5729d4dce64032b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master transaction inhibit.  <a href="#ga2d045067441152dbf5729d4dce64032b"></a><br/></td></tr>
<tr class="separator:ga2d045067441152dbf5729d4dce64032b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9af1189aa0cf7ba871c47201d0721683"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga9af1189aa0cf7ba871c47201d0721683">XSP_CR_LSB_MSB_FIRST_MASK</a>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="memdesc:ga9af1189aa0cf7ba871c47201d0721683"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSB/MSB first data format select.  <a href="#ga9af1189aa0cf7ba871c47201d0721683"></a><br/></td></tr>
<tr class="separator:ga9af1189aa0cf7ba871c47201d0721683"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SPI Control Register (CR) masks for XIP Mode</h2></td></tr>
<tr class="memitem:ga8b1a0aa05d64095856c125f38acb55bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga8b1a0aa05d64095856c125f38acb55bf">XSP_CR_XIP_CLK_PHASE_MASK</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:ga8b1a0aa05d64095856c125f38acb55bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock phase 0 or 1.  <a href="#ga8b1a0aa05d64095856c125f38acb55bf"></a><br/></td></tr>
<tr class="separator:ga8b1a0aa05d64095856c125f38acb55bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e07ebf282cf0dee542bd5a3b9f41641"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga9e07ebf282cf0dee542bd5a3b9f41641">XSP_CR_XIP_CLK_POLARITY_MASK</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:ga9e07ebf282cf0dee542bd5a3b9f41641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock polarity high or low.  <a href="#ga9e07ebf282cf0dee542bd5a3b9f41641"></a><br/></td></tr>
<tr class="separator:ga9e07ebf282cf0dee542bd5a3b9f41641"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Status Register (SR) masks</h2></td></tr>
<tr class="memitem:ga25dfccf25bae24caa237ec3b75825438"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga25dfccf25bae24caa237ec3b75825438">XSP_SR_RX_EMPTY_MASK</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:ga25dfccf25bae24caa237ec3b75825438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Reg/FIFO is empty.  <a href="#ga25dfccf25bae24caa237ec3b75825438"></a><br/></td></tr>
<tr class="separator:ga25dfccf25bae24caa237ec3b75825438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c8077ca32c93bbd7ee52a6a9ab33e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf3c8077ca32c93bbd7ee52a6a9ab33e1">XSP_SR_RX_FULL_MASK</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:gaf3c8077ca32c93bbd7ee52a6a9ab33e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Reg/FIFO is full.  <a href="#gaf3c8077ca32c93bbd7ee52a6a9ab33e1"></a><br/></td></tr>
<tr class="separator:gaf3c8077ca32c93bbd7ee52a6a9ab33e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa5946629075b285ce0c4b90a87f4fec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaaa5946629075b285ce0c4b90a87f4fec">XSP_SR_TX_EMPTY_MASK</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:gaaa5946629075b285ce0c4b90a87f4fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Reg/FIFO is empty.  <a href="#gaaa5946629075b285ce0c4b90a87f4fec"></a><br/></td></tr>
<tr class="separator:gaaa5946629075b285ce0c4b90a87f4fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2666d211089b037853ee6d1f80130ae7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga2666d211089b037853ee6d1f80130ae7">XSP_SR_TX_FULL_MASK</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:ga2666d211089b037853ee6d1f80130ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit Reg/FIFO is full.  <a href="#ga2666d211089b037853ee6d1f80130ae7"></a><br/></td></tr>
<tr class="separator:ga2666d211089b037853ee6d1f80130ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab61ff6d56a82f18573abe33958b27e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga5ab61ff6d56a82f18573abe33958b27e">XSP_SR_MODE_FAULT_MASK</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:ga5ab61ff6d56a82f18573abe33958b27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode fault error.  <a href="#ga5ab61ff6d56a82f18573abe33958b27e"></a><br/></td></tr>
<tr class="separator:ga5ab61ff6d56a82f18573abe33958b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ed84865dc8c3e3d2cb7835b4007159"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gaf6ed84865dc8c3e3d2cb7835b4007159">XSP_SR_SLAVE_MODE_MASK</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:gaf6ed84865dc8c3e3d2cb7835b4007159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave mode select.  <a href="#gaf6ed84865dc8c3e3d2cb7835b4007159"></a><br/></td></tr>
<tr class="separator:gaf6ed84865dc8c3e3d2cb7835b4007159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aeb63586150ee640f93d38bf611e583"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga2aeb63586150ee640f93d38bf611e583">XSP_SR_CPOL_CPHA_ERR_MASK</a>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:ga2aeb63586150ee640f93d38bf611e583"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPOL/CPHA error.  <a href="#ga2aeb63586150ee640f93d38bf611e583"></a><br/></td></tr>
<tr class="separator:ga2aeb63586150ee640f93d38bf611e583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d08afc5481f3746c444b682aa7b1de1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga5d08afc5481f3746c444b682aa7b1de1">XSP_SR_SLAVE_MODE_ERR_MASK</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:ga5d08afc5481f3746c444b682aa7b1de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave mode error.  <a href="#ga5d08afc5481f3746c444b682aa7b1de1"></a><br/></td></tr>
<tr class="separator:ga5d08afc5481f3746c444b682aa7b1de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da5f67ae5a952127614beec3b1556eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga3da5f67ae5a952127614beec3b1556eb">XSP_SR_MSB_ERR_MASK</a>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="memdesc:ga3da5f67ae5a952127614beec3b1556eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSB Error.  <a href="#ga3da5f67ae5a952127614beec3b1556eb"></a><br/></td></tr>
<tr class="separator:ga3da5f67ae5a952127614beec3b1556eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5affffc9ae318a0d1187235d4df45d3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga5affffc9ae318a0d1187235d4df45d3b">XSP_SR_LOOP_BACK_ERR_MASK</a>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="memdesc:ga5affffc9ae318a0d1187235d4df45d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop back error.  <a href="#ga5affffc9ae318a0d1187235d4df45d3b"></a><br/></td></tr>
<tr class="separator:ga5affffc9ae318a0d1187235d4df45d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d94bc7a9205d80dd3024783f0cde82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga05d94bc7a9205d80dd3024783f0cde82">XSP_SR_CMD_ERR_MASK</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="memdesc:ga05d94bc7a9205d80dd3024783f0cde82"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Invalid cmd' error  <a href="#ga05d94bc7a9205d80dd3024783f0cde82"></a><br/></td></tr>
<tr class="separator:ga05d94bc7a9205d80dd3024783f0cde82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Status Register (SR) masks for XIP Mode</h2></td></tr>
<tr class="memitem:ga03c4fc141be312d0f92ea72ba89cac12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga03c4fc141be312d0f92ea72ba89cac12">XSP_SR_XIP_RX_EMPTY_MASK</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:ga03c4fc141be312d0f92ea72ba89cac12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Reg/FIFO is empty.  <a href="#ga03c4fc141be312d0f92ea72ba89cac12"></a><br/></td></tr>
<tr class="separator:ga03c4fc141be312d0f92ea72ba89cac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cbb3b1a05ab5e38813e5ba66f63b751"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga9cbb3b1a05ab5e38813e5ba66f63b751">XSP_SR_XIP_RX_FULL_MASK</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:ga9cbb3b1a05ab5e38813e5ba66f63b751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Reg/FIFO is full.  <a href="#ga9cbb3b1a05ab5e38813e5ba66f63b751"></a><br/></td></tr>
<tr class="separator:ga9cbb3b1a05ab5e38813e5ba66f63b751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d05e2bede7d12b74e6994d8bfaaab8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga82d05e2bede7d12b74e6994d8bfaaab8">XSP_SR_XIP_MASTER_MODF_MASK</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:ga82d05e2bede7d12b74e6994d8bfaaab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive Reg/FIFO is full.  <a href="#ga82d05e2bede7d12b74e6994d8bfaaab8"></a><br/></td></tr>
<tr class="separator:ga82d05e2bede7d12b74e6994d8bfaaab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894c3b5bd8cd47deb1aa84303733d97c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga894c3b5bd8cd47deb1aa84303733d97c">XSP_SR_XIP_CPHPL_ERROR_MASK</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:ga894c3b5bd8cd47deb1aa84303733d97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock Phase,Clock Polarity Error.  <a href="#ga894c3b5bd8cd47deb1aa84303733d97c"></a><br/></td></tr>
<tr class="separator:ga894c3b5bd8cd47deb1aa84303733d97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cabf5324694e10915a45cabf9872a28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga7cabf5324694e10915a45cabf9872a28">XSP_SR_XIP_AXI_ERROR_MASK</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:ga7cabf5324694e10915a45cabf9872a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">AXI Transaction Error.  <a href="#ga7cabf5324694e10915a45cabf9872a28"></a><br/></td></tr>
<tr class="separator:ga7cabf5324694e10915a45cabf9872a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SPI Transmit FIFO Occupancy (TFO) mask</h2></td></tr>
<tr class="memitem:ga44ccf60002ad8192685bdbb409b1eac5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga44ccf60002ad8192685bdbb409b1eac5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_TFO_MASK</b>&#160;&#160;&#160;0x0000001F</td></tr>
<tr class="separator:ga44ccf60002ad8192685bdbb409b1eac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SPI Receive FIFO Occupancy (RFO) mask</h2></td></tr>
<tr class="memitem:gaac20d42377c8de368527a37e39121666"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac20d42377c8de368527a37e39121666"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_RFO_MASK</b>&#160;&#160;&#160;0x0000001F</td></tr>
<tr class="separator:gaac20d42377c8de368527a37e39121666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Data Width Definitions</h2></td></tr>
<tr class="memitem:ga7c85879d831cff400f3919c3283089dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#ga7c85879d831cff400f3919c3283089dc">XSP_DATAWIDTH_BYTE</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga7c85879d831cff400f3919c3283089dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tx/Rx Reg is Byte Wide.  <a href="#ga7c85879d831cff400f3919c3283089dc"></a><br/></td></tr>
<tr class="separator:ga7c85879d831cff400f3919c3283089dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd886cf61eba8074e747ebec9df258dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gabd886cf61eba8074e747ebec9df258dd">XSP_DATAWIDTH_HALF_WORD</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:gabd886cf61eba8074e747ebec9df258dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tx/Rx Reg is Half Word (16 bit) Wide.  <a href="#gabd886cf61eba8074e747ebec9df258dd"></a><br/></td></tr>
<tr class="separator:gabd886cf61eba8074e747ebec9df258dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace732a635dfcd0b6258449945444b31c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi__v4__4.html#gace732a635dfcd0b6258449945444b31c">XSP_DATAWIDTH_WORD</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:gace732a635dfcd0b6258449945444b31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tx/Rx Reg is Word (32 bit) Wide.  <a href="#gace732a635dfcd0b6258449945444b31c"></a><br/></td></tr>
<tr class="separator:gace732a635dfcd0b6258449945444b31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SPI Modes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9125cd2d61f5f9c6e2b02a67707ed944"></a>The following constants define the modes in which qxi_qspi operates. </p>
</td></tr>
<tr class="memitem:gadb9526c0fe208894f41ac9a75a4ae33b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb9526c0fe208894f41ac9a75a4ae33b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_STANDARD_MODE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gadb9526c0fe208894f41ac9a75a4ae33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ffc4a0643a5b408ddc5865cd932679b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ffc4a0643a5b408ddc5865cd932679b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_DUAL_MODE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga2ffc4a0643a5b408ddc5865cd932679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65123199589f10eb456ffc73a0473d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga65123199589f10eb456ffc73a0473d10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XSP_QUAD_MODE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga65123199589f10eb456ffc73a0473d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga87d555bd447b511847632a2fe19b8b04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_CLK_PHASE_MASK&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clock phase 0 or 1. </p>

</div>
</div>
<a class="anchor" id="ga522187d5fb382dfa512f02be7fe0068b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_CLK_POLARITY_MASK&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clock polarity high or low. </p>

</div>
</div>
<a class="anchor" id="ga1c10904273bbeb8fb8fc502c5cc9cdf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_ENABLE_MASK&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System enable. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, <a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start()</a>, and <a class="el" href="group__spi__v4__4.html#gad4bb67cfcfe73844ffb1917b11d5284c">XSpi_Stop()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a060df48208ca7e56572762233ceadb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_LOOPBACK_MASK&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local loopback mode. </p>

<p>Referenced by <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9af1189aa0cf7ba871c47201d0721683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_LSB_MSB_FIRST_MASK&#160;&#160;&#160;0x00000200</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LSB/MSB first data format select. </p>
<p>The default data format is MSB first. The LSB first data format is not available in all versions of the Xilinx Spi Device whereas the MSB first data format is supported by all the versions of the Xilinx Spi Devices. Please check the HW specification to see if this feature is supported or not. </p>

</div>
</div>
<a class="anchor" id="ga68b5a025e603ab87d7987e2220507e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_MANUAL_SS_MASK&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manual slave select assert. </p>

</div>
</div>
<a class="anchor" id="ga25aabcaa1db090de7cf4aaf3cb05ea6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_MASTER_MODE_MASK&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable master mode. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a63aa98328d40e3221901143e128da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_OFFSET&#160;&#160;&#160;0x60</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control register. </p>

<p>Referenced by <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b5e5793f12d648025e58f716862bb3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_RXFIFO_RESET_MASK&#160;&#160;&#160;0x00000040</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset receive FIFO. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort()</a>, <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, and <a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d045067441152dbf5729d4dce64032b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_TRANS_INHIBIT_MASK&#160;&#160;&#160;0x00000100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master transaction inhibit. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort()</a>, <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gab7796329c185988f906256394bc9372f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_TXFIFO_RESET_MASK&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset transmit FIFO. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort()</a>, <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, and <a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b1a0aa05d64095856c125f38acb55bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_XIP_CLK_PHASE_MASK&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clock phase 0 or 1. </p>

</div>
</div>
<a class="anchor" id="ga9e07ebf282cf0dee542bd5a3b9f41641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CR_XIP_CLK_POLARITY_MASK&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clock polarity high or low. </p>

</div>
</div>
<a class="anchor" id="ga7c85879d831cff400f3919c3283089dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_DATAWIDTH_BYTE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tx/Rx Reg is Byte Wide. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gabd886cf61eba8074e747ebec9df258dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_DATAWIDTH_HALF_WORD&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tx/Rx Reg is Half Word (16 bit) Wide. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gace732a635dfcd0b6258449945444b31c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_DATAWIDTH_WORD&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tx/Rx Reg is Word (32 bit) Wide. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a66b8345fe53a19c2da1a8162dc366d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_DGIER_OFFSET&#160;&#160;&#160;0x1C</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global Intr Enable Reg. </p>

</div>
</div>
<a class="anchor" id="ga078846fea7538049312959d15b44a9dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_DRR_OFFSET&#160;&#160;&#160;0x6C</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data receive. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga02929309d91a658ac28746aee48d0c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_DTR_OFFSET&#160;&#160;&#160;0x68</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data transmit. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga492a1b3f6bb367fbb9e88b514722b13c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_GINTR_ENABLE_MASK&#160;&#160;&#160;0x80000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global interrupt enable. </p>

</div>
</div>
<a class="anchor" id="gace876b867131a62e5407d440c73d6693"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_IIER_OFFSET&#160;&#160;&#160;0x28</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt Enable Reg. </p>

</div>
</div>
<a class="anchor" id="ga2bc4dc18547b8bdd05c5eb2b73c9ff7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_IISR_OFFSET&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt status Reg. </p>

</div>
</div>
<a class="anchor" id="gaf2c321040c3a93daa19aa3fcc77c86e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_ALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__spi__v4__4.html#gae1c1ffa1846ef388873861bf017aec7a" title="Mode fault error.">XSP_INTR_MODE_FAULT_MASK</a> | \</div>
<div class="line">                                 XSP_INTR_SLAVE_MODE_FAULT_MASK | \</div>
<div class="line">                                 XSP_INTR_TX_EMPTY_MASK | \</div>
<div class="line">                                 XSP_INTR_TX_UNDERRUN_MASK | \</div>
<div class="line">                                 XSP_INTR_RX_FULL_MASK | \</div>
<div class="line">                                 XSP_INTR_TX_HALF_EMPTY_MASK | \</div>
<div class="line">                                 XSP_INTR_RX_OVERRUN_MASK | \</div>
<div class="line">                                 XSP_INTR_SLAVE_MODE_MASK | \</div>
<div class="line">                                 XSP_INTR_RX_NOT_EMPTY_MASK | \</div>
<div class="line">                                 XSP_INTR_CMD_ERR_MASK | \</div>
<div class="line">                                 XSP_INTR_LOOP_BACK_ERR_MASK | \</div>
<div class="line">                                 XSP_INTR_MSB_ERR_MASK | \</div>
<div class="line">                                 XSP_INTR_SLAVE_MODE_ERR_MASK | \</div>
<div class="line">                                 XSP_INTR_CPOL_CPHA_ERR_MASK)</div>
</div><!-- fragment -->
<p>Mask for all the interrupts in the IP Interrupt Registers. </p>

</div>
</div>
<a class="anchor" id="ga78efad507778d0d5fe669486d4ac8558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_CMD_ERR_MASK&#160;&#160;&#160;0x00002000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'Invalid cmd' error </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4411b96eab10163334a172e8c7fff16e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_CPOL_CPHA_ERR_MASK&#160;&#160;&#160;0x00000200</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following bits are available only in axi_qspi Interrupt Status and Interrupt Enable registers. </p>
<p>CPOL/CPHA error </p>

</div>
</div>
<a class="anchor" id="ga99707579afa353242a403526ddebcb6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_DFT_MASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__spi__v4__4.html#gae1c1ffa1846ef388873861bf017aec7a" title="Mode fault error.">XSP_INTR_MODE_FAULT_MASK</a> |     \</div>
<div class="line">                                 XSP_INTR_TX_UNDERRUN_MASK |    \</div>
<div class="line">                                 XSP_INTR_RX_OVERRUN_MASK |     \</div>
<div class="line">                                 XSP_INTR_SLAVE_MODE_FAULT_MASK | \</div>
<div class="line">                                 XSP_INTR_CMD_ERR_MASK)</div>
</div><!-- fragment -->
<p>The interrupts we want at startup. </p>
<p>We add the TX_EMPTY interrupt in later when we're getting ready to transfer data. The others we don't care about for now. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start()</a>.</p>

</div>
</div>
<a class="anchor" id="gab391120a5227047af0568687b386bee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_LOOP_BACK_ERR_MASK&#160;&#160;&#160;0x00001000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop back error. </p>

</div>
</div>
<a class="anchor" id="gae1c1ffa1846ef388873861bf017aec7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_MODE_FAULT_MASK&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode fault error. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gadab0807b07832514f750466433646109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_MSB_ERR_MASK&#160;&#160;&#160;0x00000800</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MSB Error. </p>

</div>
</div>
<a class="anchor" id="ga154fc50d2dfa52ec08b03a202484f8b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_RX_FULL_MASK&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DRR/RxFIFO is full. </p>

</div>
</div>
<a class="anchor" id="gaf4fa2bf85266797c3806a885144f0a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_RX_NOT_EMPTY_MASK&#160;&#160;&#160;0x00000100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RxFIFO not empty. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gae4313597b27da75830905e5510d6c7ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_RX_OVERRUN_MASK&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DRR/RxFIFO overrun. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga02214d826551eaa28053bbe31961d7d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_SLAVE_MODE_ERR_MASK&#160;&#160;&#160;0x00000400</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave mode error. </p>

</div>
</div>
<a class="anchor" id="gad8f8c52684a188989df6463cfa44e90f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_SLAVE_MODE_FAULT_MASK&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selected as slave while disabled. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaac9322f55b43ad653b2dd630df73ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_SLAVE_MODE_MASK&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave select mode. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa8ec3c2cf6ffb5824012e63935fe94cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_TX_EMPTY_MASK&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DTR/TxFIFO is empty. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga17b6c5a44bb267e1d71293adfc225cc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_TX_HALF_EMPTY_MASK&#160;&#160;&#160;0x00000040</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TxFIFO is half empty. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a7a08185e86401169c2f810642f08ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_INTR_TX_UNDERRUN_MASK&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DTR/TxFIFO underrun. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gac2c043a14b04e38a61b1979ccaa8a200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_MASTER_OPTION&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
The Master option configures the SPI device as a master. By default, the
device is a slave.</pre><pre>The Active Low Clock option configures the device's clock polarity. Setting
this option means the clock is active low and the SCK signal idles high. By
default, the clock is active high and SCK idles low.</pre><pre>The Clock Phase option configures the SPI device for one of two transfer
formats.  A clock phase of 0, the default, means data if valid on the first
SCK edge (rising or falling) after the slave select (SS) signal has been
asserted. A clock phase of 1 means data is valid on the second SCK edge
(rising or falling) after SS has been asserted.</pre><pre>The Loopback option configures the SPI device for loopback mode.  Data is
looped back from the transmitter to the receiver.</pre><pre>The Manual Slave Select option, which is default, causes the device not
to automatically drive the slave select.  The driver selects the device
at the start of a transfer and deselects it at the end of a transfer.
If this option is off, then the device automatically toggles the slave
select signal between bytes in a transfer.
</pre> 
<p>Referenced by <a class="el" href="xspi__atmel__flash__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="xspi__intr__example_8c.html#abd314964daed3d1fb324ef61ed37f276">SpiIntrExample()</a>, <a class="el" href="xspi__polled__example_8c.html#a0dd02b93ca6a7d528f41113065a1e3cb">SpiPolledExample()</a>, and <a class="el" href="group__spi__v4__4.html#ga67c2076b133a55b6f80343642a1ace41">XSpi_SetOptions()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e120064bd2a34a145d54608ccef4107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_RFO_OFFSET&#160;&#160;&#160;0x78</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rx FIFO occupancy. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga05d94bc7a9205d80dd3024783f0cde82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_CMD_ERR_MASK&#160;&#160;&#160;0x00000400</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'Invalid cmd' error </p>

</div>
</div>
<a class="anchor" id="ga2aeb63586150ee640f93d38bf611e583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_CPOL_CPHA_ERR_MASK&#160;&#160;&#160;0x00000040</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CPOL/CPHA error. </p>

</div>
</div>
<a class="anchor" id="ga5affffc9ae318a0d1187235d4df45d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_LOOP_BACK_ERR_MASK&#160;&#160;&#160;0x00000200</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop back error. </p>

</div>
</div>
<a class="anchor" id="ga5ab61ff6d56a82f18573abe33958b27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_MODE_FAULT_MASK&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mode fault error. </p>

</div>
</div>
<a class="anchor" id="ga3da5f67ae5a952127614beec3b1556eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_MSB_ERR_MASK&#160;&#160;&#160;0x00000100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MSB Error. </p>

</div>
</div>
<a class="anchor" id="gae4915bf726554a2abf5922129f88542b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_OFFSET&#160;&#160;&#160;0x64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status Register. </p>

<p>Referenced by <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga25dfccf25bae24caa237ec3b75825438"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_RX_EMPTY_MASK&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Reg/FIFO is empty. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf3c8077ca32c93bbd7ee52a6a9ab33e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_RX_FULL_MASK&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Reg/FIFO is full. </p>

</div>
</div>
<a class="anchor" id="ga5d08afc5481f3746c444b682aa7b1de1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_SLAVE_MODE_ERR_MASK&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave mode error. </p>

</div>
</div>
<a class="anchor" id="gaf6ed84865dc8c3e3d2cb7835b4007159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_SLAVE_MODE_MASK&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave mode select. </p>

</div>
</div>
<a class="anchor" id="gaaa5946629075b285ce0c4b90a87f4fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_TX_EMPTY_MASK&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Reg/FIFO is empty. </p>

<p>Referenced by <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2666d211089b037853ee6d1f80130ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_TX_FULL_MASK&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit Reg/FIFO is full. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cabf5324694e10915a45cabf9872a28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_XIP_AXI_ERROR_MASK&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AXI Transaction Error. </p>

</div>
</div>
<a class="anchor" id="ga894c3b5bd8cd47deb1aa84303733d97c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_XIP_CPHPL_ERROR_MASK&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clock Phase,Clock Polarity Error. </p>

</div>
</div>
<a class="anchor" id="ga82d05e2bede7d12b74e6994d8bfaaab8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_XIP_MASTER_MODF_MASK&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Reg/FIFO is full. </p>

</div>
</div>
<a class="anchor" id="ga03c4fc141be312d0f92ea72ba89cac12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_XIP_RX_EMPTY_MASK&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Reg/FIFO is empty. </p>

</div>
</div>
<a class="anchor" id="ga9cbb3b1a05ab5e38813e5ba66f63b751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SR_XIP_RX_FULL_MASK&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive Reg/FIFO is full. </p>

</div>
</div>
<a class="anchor" id="gaa82028ecd15bcffd8ab361c0c523a7a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SRR_OFFSET&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Software Reset register. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga343938fcdf672bec329d876a146178cd">XSpi_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga48fdfb116f37c7f14403bed57b556c4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SRR_RESET_MASK&#160;&#160;&#160;0x0000000A</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI Software Reset Register (SRR) mask. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga343938fcdf672bec329d876a146178cd">XSpi_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga34c2ab4de85d2a3a5659e5446235942c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_SSR_OFFSET&#160;&#160;&#160;0x70</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit slave select </p>

</div>
</div>
<a class="anchor" id="gaf06c80c0767e40c86b2e3fc18457d680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_TFO_OFFSET&#160;&#160;&#160;0x74</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tx FIFO occupancy. </p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga642e3f4be4784f5823c368a0afdfe078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_Disable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110" title="Set the contents of the control register.">XSpi_SetControlReg</a>((InstancePtr), \</div>
<div class="line">        <a class="code" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87" title="Get the contents of the control register.">XSpi_GetControlReg</a>((InstancePtr)) &amp; ~<a class="code" href="group__spi__v4__4.html#ga1c10904273bbeb8fb8fc502c5cc9cdf6" title="System enable.">XSP_CR_ENABLE_MASK</a>)</div>
</div><!-- fragment -->
<p>Disable the device. </p>
<p>Preserves the current contents of the control register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#ga642e3f4be4784f5823c368a0afdfe078" title="Disable the device.">XSpi_Disable(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ddf2c25474dac11bd30c9f938bd753d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_Enable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">        u16 Control; \</div>
<div class="line">        Control = <a class="code" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87" title="Get the contents of the control register.">XSpi_GetControlReg</a>((InstancePtr)); \</div>
<div class="line">        Control |= <a class="code" href="group__spi__v4__4.html#ga1c10904273bbeb8fb8fc502c5cc9cdf6" title="System enable.">XSP_CR_ENABLE_MASK</a>; \</div>
<div class="line">        Control &amp;= ~<a class="code" href="group__spi__v4__4.html#ga2d045067441152dbf5729d4dce64032b" title="Master transaction inhibit.">XSP_CR_TRANS_INHIBIT_MASK</a>; \</div>
<div class="line">        XSpi_SetControlReg((InstancePtr), Control); \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Enable the device and uninhibit master transactions. </p>
<p>Preserves the current contents of the control register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#ga1ddf2c25474dac11bd30c9f938bd753d" title="Enable the device and uninhibit master transactions.">XSpi_Enable(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ga7988663ef9d2523ef167413fd6e8ab87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the contents of the control register. </p>
<p>Use the XSP_CR_* constants defined above to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the control register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87" title="Get the contents of the control register.">XSpi_GetControlReg(XSpi *InstancePtr)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort()</a>, <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf55cfd2072ed2047c0fe0b65bd0fcf6a">XSpi_GetOptions()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="group__spi__v4__4.html#ga11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest()</a>, <a class="el" href="group__spi__v4__4.html#ga67c2076b133a55b6f80343642a1ace41">XSpi_SetOptions()</a>, <a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start()</a>, <a class="el" href="group__spi__v4__4.html#gad4bb67cfcfe73844ffb1917b11d5284c">XSpi_Stop()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c8ab7387ce196ce3309dc68bd15e489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetSlaveSelectReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>((InstancePtr)-&gt;BaseAddr, <a class="el" href="group__spi__v4__4.html#ga34c2ab4de85d2a3a5659e5446235942c">XSP_SSR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the contents of the slave select register. </p>
<p>Each bit in the mask corresponds to a slave select line. Only one slave should be selected at any one time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit value in the slave select register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spi__v4__4.html#ga5c8ab7387ce196ce3309dc68bd15e489" title="Get the contents of the slave select register.">XSpi_GetSlaveSelectReg(XSpi *InstancePtr)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf65c9e65699c1746d205a77554d40adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetStatusReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#gae4915bf726554a2abf5922129f88542b">XSP_SR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the contents of the status register. </p>
<p>Use the XSP_SR_* constants defined above to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 32-bit value representing the contents of the status register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u8 <a class="el" href="group__spi__v4__4.html#gaf65c9e65699c1746d205a77554d40adb" title="Get the contents of the status register.">XSpi_GetStatusReg(XSpi *InstancePtr)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="group__spi__v4__4.html#ga11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaac0eb471df51c6af1a3a0a68b68d3808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetXipControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the contents of the XIP control register. </p>
<p>Use the XSP_CR_XIP_* constants defined above to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the control register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spi__v4__4.html#gaac0eb471df51c6af1a3a0a68b68d3808" title="Get the contents of the XIP control register.">XSpi_GetXipControlReg(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b64cb823a81025224b87a5d26a4fa39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetXipStatusReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#gae4915bf726554a2abf5922129f88542b">XSP_SR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the contents of the status register. </p>
<p>Use the XSP_SR_XIP_* constants defined above to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 32-bit value representing the contents of the status register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u8 <a class="el" href="group__spi__v4__4.html#ga3b64cb823a81025224b87a5d26a4fa39" title="Get the contents of the status register.">XSpi_GetXipStatusReg(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="gab883b734cc9b78985dae611df2f4725a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrClear</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ClearMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31" title="Write to the specified Spi device register.">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr),  <a class="code" href="group__spi__v4__4.html#ga2bc4dc18547b8bdd05c5eb2b73c9ff7d" title="Interrupt status Reg.">XSP_IISR_OFFSET</a>,      \</div>
<div class="line">                <a class="code" href="group__spi__v4__4.html#ga01dc10ba2ca5c1e5ff30ecd0cadac140" title="This function gets the contents of the Interrupt Status Register.">XSpi_IntrGetStatus</a>(InstancePtr) | (ClearMask))</div>
</div><!-- fragment -->
<p>This function clears the specified interrupts in the Interrupt status Register. </p>
<p>The interrupt is cleared by writing to this register with the bits to be cleared set to a one and all others bits to zero. Setting a bit which is zero within this register causes an interrupt to be generated.</p>
<p>This function writes only the specified value to the register such that some status bits may be set and others cleared. It is the caller's responsibility to get the value of the register prior to setting the value to prevent an destructive behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">ClearMask</td><td>is the Bitmask for interrupts to be cleared. Bit positions of "1" clears the interrupt. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSP_INTR_* bits defined in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#gab883b734cc9b78985dae611df2f4725a" title="This function clears the specified interrupts in the Interrupt status Register.">XSpi_IntrClear(XSpi *InstancePtr, u32 ClearMask)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga48c1f7712f55bbb65d7b68c92b818f78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrDisable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DisableMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31" title="Write to the specified Spi device register.">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="code" href="group__spi__v4__4.html#gace876b867131a62e5407d440c73d6693" title="Interrupt Enable Reg.">XSP_IIER_OFFSET</a>,       \</div>
<div class="line">                <a class="code" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2" title="Read from the specified Spi device register.">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr),                 \</div>
<div class="line">                        <a class="code" href="group__spi__v4__4.html#gace876b867131a62e5407d440c73d6693" title="Interrupt Enable Reg.">XSP_IIER_OFFSET</a>) &amp; (~ ((DisableMask) &amp; <a class="code" href="group__spi__v4__4.html#gaf2c321040c3a93daa19aa3fcc77c86e8" title="Mask for all the interrupts in the IP Interrupt Registers.">XSP_INTR_ALL</a> )))</div>
</div><!-- fragment -->
<p>Disable the specified Interrupts in the Interrupt Enable Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">DisableMask</td><td>is the bitmask of the interrupts to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSP_INTR_* bits defined in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#ga48c1f7712f55bbb65d7b68c92b818f78" title="Disable the specified Interrupts in the Interrupt Enable Register.">XSpi_IntrDisable(XSpi *InstancePtr, u32 DisableMask)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga85f2b8305794c31bc41ebd35ffeb4892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrEnable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EnableMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31" title="Write to the specified Spi device register.">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="code" href="group__spi__v4__4.html#gace876b867131a62e5407d440c73d6693" title="Interrupt Enable Reg.">XSP_IIER_OFFSET</a>,       \</div>
<div class="line">                (<a class="code" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2" title="Read from the specified Spi device register.">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr),                \</div>
<div class="line">                        <a class="code" href="group__spi__v4__4.html#gace876b867131a62e5407d440c73d6693" title="Interrupt Enable Reg.">XSP_IIER_OFFSET</a>)) | (((EnableMask) &amp; <a class="code" href="group__spi__v4__4.html#gaf2c321040c3a93daa19aa3fcc77c86e8" title="Mask for all the interrupts in the IP Interrupt Registers.">XSP_INTR_ALL</a> )))</div>
</div><!-- fragment -->
<p>This function sets the contents of the Interrupt Enable Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">EnableMask</td><td>is the bitmask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSP_INTR_* bits defined in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#ga85f2b8305794c31bc41ebd35ffeb4892" title="This function sets the contents of the Interrupt Enable Register.">XSpi_IntrEnable(XSpi *InstancePtr, u32 EnableMask)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga049583711085eb8c9c47b2ef7907bf43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrGetEnabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr),  <a class="el" href="group__spi__v4__4.html#gace876b867131a62e5407d440c73d6693">XSP_IIER_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the contents of the Interrupt Enable Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The contents read from the Interrupt Enable Register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spi__v4__4.html#ga049583711085eb8c9c47b2ef7907bf43" title="This function gets the contents of the Interrupt Enable Register.">XSpi_IntrGetEnabled(XSpi *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga01dc10ba2ca5c1e5ff30ecd0cadac140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrGetStatus</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga2bc4dc18547b8bdd05c5eb2b73c9ff7d">XSP_IISR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the contents of the Interrupt Status Register. </p>
<p>This register indicates the status of interrupt sources for the device. The status is independent of whether interrupts are enabled such that the status register may also be polled when interrupts are not enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status which contains the value read from the Interrupt Status Register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spi__v4__4.html#ga01dc10ba2ca5c1e5ff30ecd0cadac140" title="This function gets the contents of the Interrupt Status Register.">XSpi_IntrGetStatus(XSpi *InstancePtr)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5035851f7c130da994d9deec67c89b5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrGlobalDisable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr),  <a class="el" href="group__spi__v4__4.html#ga3a66b8345fe53a19c2da1a8162dc366d">XSP_DGIER_OFFSET</a>, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro disables all interrupts for the device by writing to the Global interrupt enable register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#ga5035851f7c130da994d9deec67c89b5f" title="This macro disables all interrupts for the device by writing to the Global interrupt enable register...">XSpi_IntrGlobalDisable(XSpi *InstancePtr)</a>; </dd></dl>

<p>Referenced by <a class="el" href="xspi__polled__example_8c.html#a0dd02b93ca6a7d528f41113065a1e3cb">SpiPolledExample()</a>, <a class="el" href="group__spi__v4__4.html#gad4bb67cfcfe73844ffb1917b11d5284c">XSpi_Stop()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa9075007c45d749e3b9bd24a37f9d908"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrGlobalEnable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31" title="Write to the specified Spi device register.">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr),  <a class="code" href="group__spi__v4__4.html#ga3a66b8345fe53a19c2da1a8162dc366d" title="Global Intr Enable Reg.">XSP_DGIER_OFFSET</a>,     \</div>
<div class="line">                        <a class="code" href="group__spi__v4__4.html#ga492a1b3f6bb367fbb9e88b514722b13c" title="Global interrupt enable.">XSP_GINTR_ENABLE_MASK</a>)</div>
</div><!-- fragment -->
<p>This macro writes to the global interrupt enable register to enable interrupts from the device. </p>
<p>Interrupts enabled using <a class="el" href="group__spi__v4__4.html#ga85f2b8305794c31bc41ebd35ffeb4892" title="This function sets the contents of the Interrupt Enable Register.">XSpi_IntrEnable()</a> will not occur until the global interrupt enable bit is set by using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#gaa9075007c45d749e3b9bd24a37f9d908" title="This macro writes to the global interrupt enable register to enable interrupts from the device...">XSpi_IntrGlobalEnable(XSpi *InstancePtr)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2210a78f1a4bc86250be33e8093e686c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IsIntrGlobalEnabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2" title="Read from the specified Spi device register.">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="code" href="group__spi__v4__4.html#ga3a66b8345fe53a19c2da1a8162dc366d" title="Global Intr Enable Reg.">XSP_DGIER_OFFSET</a>) ==  \</div>
<div class="line">                XSP_GINTR_ENABLE_MASK)</div>
</div><!-- fragment -->
<p>This function determines if interrupts are enabled at the global level by reading the global interrupt register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if global interrupts are enabled.</li>
<li>FALSE if global interrupts are disabled.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: int <a class="el" href="group__spi__v4__4.html#ga2210a78f1a4bc86250be33e8093e686c" title="This function determines if interrupts are enabled at the global level by reading the global interrup...">XSpi_IsIntrGlobalEnabled(XSpi *InstancePtr)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e55891344ab473841b6eefc2bda35a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XSpi_In32((BaseAddress) + (RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from the specified Spi device register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>contains the offset from the 1st register of the device to select the specific register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value read from the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2" title="Read from the specified Spi device register.">XSpi_ReadReg(u32 BaseAddress, u32 RegOffset)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, <a class="el" href="group__spi__v4__4.html#ga11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a33f7848a49e60041668c726eb14110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_SetControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>, (Mask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the contents of the control register. </p>
<p>Use the XSP_CR_* constants defined above to create the bit-mask to be written to the register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 32-bit value to write to the control register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110" title="Set the contents of the control register.">XSpi_SetControlReg(XSpi *InstancePtr, u32 Mask)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort()</a>, <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="group__spi__v4__4.html#ga67c2076b133a55b6f80343642a1ace41">XSpi_SetOptions()</a>, <a class="el" href="group__spi__v4__4.html#ga87fdaad742a2669200c9b2617e5c86ea">XSpi_Start()</a>, <a class="el" href="group__spi__v4__4.html#gad4bb67cfcfe73844ffb1917b11d5284c">XSpi_Stop()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gae93befb10305b5abccc5483b73e60060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_SetSlaveSelectReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga34c2ab4de85d2a3a5659e5446235942c">XSP_SSR_OFFSET</a>, (Mask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the contents of the slave select register. </p>
<p>Each bit in the mask corresponds to a slave select line. Only one slave should be selected at any one time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 32-bit value to write to the slave select register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#gae93befb10305b5abccc5483b73e60060" title="Set the contents of the slave select register.">XSpi_SetSlaveSelectReg(XSpi *InstancePtr, u32 Mask)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga91ec4e1ee207bcb26d5aaf84e0324a9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_SetXipControlReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="el" href="group__spi__v4__4.html#ga3a63aa98328d40e3221901143e128da1">XSP_CR_OFFSET</a>, (Mask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the contents of the XIP control register. </p>
<p>Use the XSP_CR_XIP_* constants defined above to create the bit-mask to be written to the register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 32-bit value to write to the control register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spi__v4__4.html#ga91ec4e1ee207bcb26d5aaf84e0324a9e" title="Set the contents of the XIP control register.">XSpi_SetXipControlReg(XSpi *InstancePtr, u32 Mask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ga32e741800118678aa060ef2a13661e31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegisterValue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XSpi_Out32((BaseAddress) + (RegOffset), (RegisterValue))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the specified Spi device register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>contains the offset from the 1st register of the device to select the specific register. </td></tr>
    <tr><td class="paramname">RegisterValue</td><td>is the value to be written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void XSpi_WriteReg(u32 BaseAddress, u32 RegOffset, u32 RegisterValue); </dd></dl>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, <a class="el" href="xspi__low__level__example_8c.html#a84062f5eec2674a89353f5679b0928a2">XSpi_LowLevelExample()</a>, <a class="el" href="group__spi__v4__4.html#ga343938fcdf672bec329d876a146178cd">XSpi_Reset()</a>, and <a class="el" href="group__spi__v4__4.html#ga4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaa9c3c5101d73a626380c46bcc906069e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XSpi_StatusHandler)(void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The handler data type allows the user to define a callback function to handle the asynchronous processing of the SPI driver. </p>
<p>The application using this driver is expected to define a handler of this type to support interrupt driven mode. The handler executes in an interrupt context such that minimal processing should be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>A callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver component, so it is a void pointer. </td></tr>
    <tr><td class="paramname">StatusEvent</td><td>Indicates one or more status events that occurred. See the <a class="el" href="group__spi__v4__4.html#gabc09f4d503de2a772e5079ac46fc62b6" title="Sets the status callback function, the status handler, which the driver calls when it encounters cond...">XSpi_SetStatusHandler()</a> for details on the status events that can be passed in the callback. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>Indicates how many bytes of data were successfully transferred. This may be less than the number of bytes requested if the status event indicates an error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga44a2dc795761b35ed0ebdd6989675022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_Abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts a transfer in progress by setting the stop bit in the control register, then resetting the FIFOs if present. </p>
<p>The byte counts are cleared and the busy flag is set to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function does a read/modify/write of the control register. The user of this function needs to take care of critical sections. </p>

<p>References <a class="el" href="struct_x_spi.html#a67a6dd9a95f3bef8199dc0186dfb039a">XSpi::HasFifos</a>, <a class="el" href="struct_x_spi.html#a35871d4554b45a9078edfabb763cc1a5">XSpi::IsBusy</a>, <a class="el" href="struct_x_spi.html#a883553e7813c71d61fc1f84de68d9bf4">XSpi::RemainingBytes</a>, <a class="el" href="struct_x_spi.html#a1f78cff15e7571d1db3630834d376877">XSpi::RequestedBytes</a>, <a class="el" href="struct_x_spi.html#a0ba738ff1f34e3e5af78c7437df1073f">XSpi::SlaveSelectMask</a>, <a class="el" href="group__spi__v4__4.html#ga5b5e5793f12d648025e58f716862bb3e">XSP_CR_RXFIFO_RESET_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga2d045067441152dbf5729d4dce64032b">XSP_CR_TRANS_INHIBIT_MASK</a>, <a class="el" href="group__spi__v4__4.html#gab7796329c185988f906256394bc9372f">XSP_CR_TXFIFO_RESET_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>, <a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>, and <a class="el" href="group__spi__v4__4.html#gae93befb10305b5abccc5483b73e60060">XSpi_SetSlaveSelectReg</a>.</p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#gaf3863f11d27469d8797424319601c980">XSpi_InterruptHandler()</a>, and <a class="el" href="group__spi__v4__4.html#ga343938fcdf672bec329d876a146178cd">XSpi_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga858155b42d5a1da8efe06c9098e40b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *&#160;</td>
          <td class="paramname"><em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a specific <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance such that the driver is ready to use. </p>
<p>The state of the device after initialization is:</p>
<ul>
<li>Device is disabled</li>
<li>Slave mode</li>
<li>Active high clock polarity</li>
<li>Clock phase 0</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Config</td><td>is a reference to a structure containing information about a specific SPI device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_DEVICE_IS_STARTED if the device is started. It must be stopped to re-initialize.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi___config.html#a732f0c3380dfadf62ce079b65a9be852">XSpi_Config::AxiFullBaseAddress</a>, <a class="el" href="struct_x_spi.html#aa0669158439f14d3a15ab49795b7139f">XSpi::BaseAddr</a>, <a class="el" href="struct_x_spi___stats.html#a7684cf587c67273ed4d87a912d158363">XSpi_Stats::BytesTransferred</a>, <a class="el" href="struct_x_spi___config.html#a3c3820986a993d515306dd171e299e58">XSpi_Config::DataWidth</a>, <a class="el" href="struct_x_spi.html#aac3d52799cee844afec78ffc203c4b20">XSpi::DataWidth</a>, <a class="el" href="struct_x_spi.html#afcb2a94604b619e207e5590328c3531e">XSpi::FlashBaseAddr</a>, <a class="el" href="struct_x_spi___config.html#a192c8c69aaaf2672a35c9a228b055ffe">XSpi_Config::HasFifos</a>, <a class="el" href="struct_x_spi.html#a67a6dd9a95f3bef8199dc0186dfb039a">XSpi::HasFifos</a>, <a class="el" href="struct_x_spi.html#a35871d4554b45a9078edfabb763cc1a5">XSpi::IsBusy</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#a71a59342f02363d57536aeefd2aa7a3f">XSpi::IsStarted</a>, <a class="el" href="struct_x_spi___stats.html#ac470017b47fe6048e3db36bf4035cf5a">XSpi_Stats::ModeFaults</a>, <a class="el" href="struct_x_spi___stats.html#a6abd7d1f4895aefda31c6f89cf53cf3d">XSpi_Stats::NumInterrupts</a>, <a class="el" href="struct_x_spi___config.html#a94cea54141a5f56ad620234a0583dbcd">XSpi_Config::NumSlaveBits</a>, <a class="el" href="struct_x_spi.html#ab2896a95a00faec5cee34d83093ffb3f">XSpi::NumSlaveBits</a>, <a class="el" href="struct_x_spi.html#acc5a98e31ed6927b50d6bff4c87f5bb9">XSpi::RecvBufferPtr</a>, <a class="el" href="struct_x_spi___stats.html#a2c12f80f85aec2bd5868fd691728f343">XSpi_Stats::RecvOverruns</a>, <a class="el" href="struct_x_spi.html#a883553e7813c71d61fc1f84de68d9bf4">XSpi::RemainingBytes</a>, <a class="el" href="struct_x_spi.html#a1f78cff15e7571d1db3630834d376877">XSpi::RequestedBytes</a>, <a class="el" href="struct_x_spi.html#af85c6077464bc0877fe6334564b9430c">XSpi::SendBufferPtr</a>, <a class="el" href="struct_x_spi___stats.html#ac328aff4f7f93db26eee1113d6cd4537">XSpi_Stats::SlaveModeFaults</a>, <a class="el" href="struct_x_spi___config.html#adb6d1bc96fee4723535aa51bcc0457e5">XSpi_Config::SlaveOnly</a>, <a class="el" href="struct_x_spi.html#a282ea84ad4ceb9e950bb91b66231780b">XSpi::SlaveOnly</a>, <a class="el" href="struct_x_spi.html#a0ba738ff1f34e3e5af78c7437df1073f">XSpi::SlaveSelectMask</a>, <a class="el" href="struct_x_spi.html#a4dda79fe6ae8a3536b0aaaa62be0d8b5">XSpi::SlaveSelectReg</a>, <a class="el" href="struct_x_spi___config.html#a3dd5249965eb8c9957a58ed76bde2bb5">XSpi_Config::SpiMode</a>, <a class="el" href="struct_x_spi.html#a9816437229050cd78cb29c4f762228b7">XSpi::SpiMode</a>, <a class="el" href="struct_x_spi.html#a63d1a1254869f2599e4646388cec0c4c">XSpi::Stats</a>, <a class="el" href="struct_x_spi.html#a032c4db15af79e91cc2fcf564dea1b55">XSpi::StatusHandler</a>, <a class="el" href="struct_x_spi___config.html#a58bbefc01bd6996673fe28065a6cffec">XSpi_Config::Use_Startup</a>, <a class="el" href="struct_x_spi___config.html#af48b4189e5dde7a7bcea3c378a6ff97b">XSpi_Config::XipMode</a>, <a class="el" href="struct_x_spi.html#a36bd7deea43721717288da63415e8fdd">XSpi::XipMode</a>, <a class="el" href="struct_x_spi___stats.html#a4068d7bc8a1e2ee0ac7f51555b4dd2f5">XSpi_Stats::XmitUnderruns</a>, <a class="el" href="group__spi__v4__4.html#ga1c10904273bbeb8fb8fc502c5cc9cdf6">XSP_CR_ENABLE_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga25aabcaa1db090de7cf4aaf3cb05ea6b">XSP_CR_MASTER_MODE_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga5b5e5793f12d648025e58f716862bb3e">XSP_CR_RXFIFO_RESET_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga2d045067441152dbf5729d4dce64032b">XSP_CR_TRANS_INHIBIT_MASK</a>, <a class="el" href="group__spi__v4__4.html#gab7796329c185988f906256394bc9372f">XSP_CR_TXFIFO_RESET_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga7c85879d831cff400f3919c3283089dc">XSP_DATAWIDTH_BYTE</a>, <a class="el" href="group__spi__v4__4.html#ga078846fea7538049312959d15b44a9dd">XSP_DRR_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#ga02929309d91a658ac28746aee48d0c04">XSP_DTR_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#ga25dfccf25bae24caa237ec3b75825438">XSP_SR_RX_EMPTY_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>, <a class="el" href="group__spi__v4__4.html#gaf65c9e65699c1746d205a77554d40adb">XSpi_GetStatusReg</a>, <a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>, <a class="el" href="group__spi__v4__4.html#ga343938fcdf672bec329d876a146178cd">XSpi_Reset()</a>, <a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>, and <a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xspi__atmel__flash__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="xspi__intr__example_8c.html#abd314964daed3d1fb324ef61ed37f276">SpiIntrExample()</a>, <a class="el" href="xspi__polled__example_8c.html#a0dd02b93ca6a7d528f41113065a1e3cb">SpiPolledExample()</a>, <a class="el" href="xspi__selftest__example_8c.html#aa80f2f9d52f6c35db2d43a56802a81c8">SpiSelfTestExample()</a>, <a class="el" href="xspi__winbond__flash__xip__example_8c.html#af3fb7f2668aa93bc45fb9ca9c252f219">SpiXipExample()</a>, and <a class="el" href="group__spi__v4__4.html#gaa1fb3e31ba804cc87dc309847fb02471">XSpi_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf243ac522e14869af82545ffc11d5821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the statistics for the SPI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Statistics are not updated in polled mode of operation. </dd></dl>

<p>References <a class="el" href="struct_x_spi___stats.html#a7684cf587c67273ed4d87a912d158363">XSpi_Stats::BytesTransferred</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi___stats.html#ac470017b47fe6048e3db36bf4035cf5a">XSpi_Stats::ModeFaults</a>, <a class="el" href="struct_x_spi___stats.html#a6abd7d1f4895aefda31c6f89cf53cf3d">XSpi_Stats::NumInterrupts</a>, <a class="el" href="struct_x_spi___stats.html#a2c12f80f85aec2bd5868fd691728f343">XSpi_Stats::RecvOverruns</a>, <a class="el" href="struct_x_spi___stats.html#ac328aff4f7f93db26eee1113d6cd4537">XSpi_Stats::SlaveModeFaults</a>, <a class="el" href="struct_x_spi.html#a63d1a1254869f2599e4646388cec0c4c">XSpi::Stats</a>, and <a class="el" href="struct_x_spi___stats.html#a4068d7bc8a1e2ee0ac7f51555b4dd2f5">XSpi_Stats::XmitUnderruns</a>.</p>

</div>
</div>
<a class="anchor" id="gaf55cfd2072ed2047c0fe0b65bd0fcf6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSpi_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the options for the SPI device. </p>
<p>The options control how the device behaves relative to the SPI bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>Options contains the specified options to be set. This is a bit mask where a 1 means to turn the option on, and a 0 means to turn the option off. One or more bit values may be contained in the mask. See the bit definitions named XSP_*_OPTIONS in the file <a class="el" href="xspi_8h.html">xspi.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, and <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga8043891b8f68a3291bd035be74aa6b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSpi_GetSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current slave select bit mask for the SPI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned is a 32-bit mask with a 1 in the bit position of the slave currently selected. The value may be zero if no slaves are selected.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is used to get the current slave select bit mask that was set using the XSpi_SetSlaveSelect API. This API deos not read the register from the core and returns the slave select register stored in the instance pointer. </dd></dl>

<p>References <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, and <a class="el" href="struct_x_spi.html#a4dda79fe6ae8a3536b0aaaa62be0d8b5">XSpi::SlaveSelectReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a40aee30eb6f0240b75e6ccd7596a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a> *&#160;</td>
          <td class="paramname"><em>StatsPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a copy of the statistics for an SPI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">StatsPtr</td><td>is a pointer to a <a class="el" href="struct_x_spi___stats.html" title="XSpi statistics.">XSpi_Stats</a> structure which will get a copy of current statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Statistics are not updated in polled mode of operation. </dd></dl>

<p>References <a class="el" href="struct_x_spi___stats.html#a7684cf587c67273ed4d87a912d158363">XSpi_Stats::BytesTransferred</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi___stats.html#ac470017b47fe6048e3db36bf4035cf5a">XSpi_Stats::ModeFaults</a>, <a class="el" href="struct_x_spi___stats.html#a6abd7d1f4895aefda31c6f89cf53cf3d">XSpi_Stats::NumInterrupts</a>, <a class="el" href="struct_x_spi___stats.html#a2c12f80f85aec2bd5868fd691728f343">XSpi_Stats::RecvOverruns</a>, <a class="el" href="struct_x_spi___stats.html#ac328aff4f7f93db26eee1113d6cd4537">XSpi_Stats::SlaveModeFaults</a>, <a class="el" href="struct_x_spi.html#a63d1a1254869f2599e4646388cec0c4c">XSpi::Stats</a>, and <a class="el" href="struct_x_spi___stats.html#a4068d7bc8a1e2ee0ac7f51555b4dd2f5">XSpi_Stats::XmitUnderruns</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1fb3e31ba804cc87dc309847fb02471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a specific <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance such that the driver is ready to use. </p>
<p>The state of the device after initialization is:</p>
<ul>
<li>Device is disabled</li>
<li>Slave mode</li>
<li>Active high clock polarity</li>
<li>Clock phase 0</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">DeviceId</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><pre class="fragment">    - XST_SUCCESS if successful.
    - XST_DEVICE_IS_STARTED if the device is started. It must be
      stopped to re-initialize.
    - XST_DEVICE_NOT_FOUND if the device was not found in the
      configuration such that initialization could not be
      accomplished.
</pre></dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi___config.html#a495ec19a4ab441ea59a0e220f0728dd9">XSpi_Config::BaseAddress</a>, <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, and <a class="el" href="group__spi__v4__4.html#gac2c4a169e05ad6e040796ae86100fd5b">XSpi_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf3863f11d27469d8797424319601c980"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The interrupt handler for SPI interrupts. </p>
<p>This function must be connected by the user to an interrupt source. This function does not save and restore the processor context such that the user must provide this processing.</p>
<p>The interrupts that are handled are:</p>
<ul>
<li>Mode Fault Error. This interrupt is generated if this device is selected as a slave when it is configured as a master. The driver aborts any data transfer that is in progress by resetting FIFOs (if present) and resetting its buffer pointers. The upper layer software is informed of the error.</li>
</ul>
<ul>
<li>Data Transmit Register (FIFO) Empty. This interrupt is generated when the transmit register or FIFO is empty. The driver uses this interrupt during a transmission to continually send/receive data until there is no more data to send/receive.</li>
</ul>
<ul>
<li>Data Transmit Register (FIFO) Underrun. This interrupt is generated when the SPI device, when configured as a slave, attempts to read an empty DTR/FIFO. An empty DTR/FIFO usually means that software is not giving the device data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<ul>
<li>Data Receive Register (FIFO) Overrun. This interrupt is generated when the SPI device attempts to write a received byte to an already full DRR/FIFO. A full DRR/FIFO usually means software is not emptying the data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<ul>
<li>Slave Mode Fault Error. This interrupt is generated if a slave device is selected as a slave while it is disabled. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<ul>
<li>Command Error. This interrupt occurs when the first byte in the Tx FIFO, after the CS is asserted, doesn't match any command in the Lookup table. This interrupt is valid only for axi_qspi.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The slave select register is being set to deselect the slave when a transfer is complete. This is being done regardless of whether it is a slave or a master since the hardware does not drive the slave select as a slave. </p>

<p>References <a class="el" href="struct_x_spi.html#aa0669158439f14d3a15ab49795b7139f">XSpi::BaseAddr</a>, <a class="el" href="struct_x_spi___stats.html#a7684cf587c67273ed4d87a912d158363">XSpi_Stats::BytesTransferred</a>, <a class="el" href="struct_x_spi.html#aac3d52799cee844afec78ffc203c4b20">XSpi::DataWidth</a>, <a class="el" href="struct_x_spi.html#a35871d4554b45a9078edfabb763cc1a5">XSpi::IsBusy</a>, <a class="el" href="struct_x_spi___stats.html#ac470017b47fe6048e3db36bf4035cf5a">XSpi_Stats::ModeFaults</a>, <a class="el" href="struct_x_spi___stats.html#a6abd7d1f4895aefda31c6f89cf53cf3d">XSpi_Stats::NumInterrupts</a>, <a class="el" href="struct_x_spi.html#acc5a98e31ed6927b50d6bff4c87f5bb9">XSpi::RecvBufferPtr</a>, <a class="el" href="struct_x_spi___stats.html#a2c12f80f85aec2bd5868fd691728f343">XSpi_Stats::RecvOverruns</a>, <a class="el" href="struct_x_spi.html#a883553e7813c71d61fc1f84de68d9bf4">XSpi::RemainingBytes</a>, <a class="el" href="struct_x_spi.html#a1f78cff15e7571d1db3630834d376877">XSpi::RequestedBytes</a>, <a class="el" href="struct_x_spi.html#af85c6077464bc0877fe6334564b9430c">XSpi::SendBufferPtr</a>, <a class="el" href="struct_x_spi___stats.html#ac328aff4f7f93db26eee1113d6cd4537">XSpi_Stats::SlaveModeFaults</a>, <a class="el" href="struct_x_spi.html#a0ba738ff1f34e3e5af78c7437df1073f">XSpi::SlaveSelectMask</a>, <a class="el" href="struct_x_spi.html#a63d1a1254869f2599e4646388cec0c4c">XSpi::Stats</a>, <a class="el" href="struct_x_spi.html#a032c4db15af79e91cc2fcf564dea1b55">XSpi::StatusHandler</a>, <a class="el" href="struct_x_spi.html#aa4075b1e4be099fe87f575b777628a78">XSpi::StatusRef</a>, <a class="el" href="struct_x_spi___stats.html#a4068d7bc8a1e2ee0ac7f51555b4dd2f5">XSpi_Stats::XmitUnderruns</a>, <a class="el" href="group__spi__v4__4.html#ga2d045067441152dbf5729d4dce64032b">XSP_CR_TRANS_INHIBIT_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga7c85879d831cff400f3919c3283089dc">XSP_DATAWIDTH_BYTE</a>, <a class="el" href="group__spi__v4__4.html#gabd886cf61eba8074e747ebec9df258dd">XSP_DATAWIDTH_HALF_WORD</a>, <a class="el" href="group__spi__v4__4.html#gace732a635dfcd0b6258449945444b31c">XSP_DATAWIDTH_WORD</a>, <a class="el" href="group__spi__v4__4.html#ga078846fea7538049312959d15b44a9dd">XSP_DRR_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#ga02929309d91a658ac28746aee48d0c04">XSP_DTR_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#ga78efad507778d0d5fe669486d4ac8558">XSP_INTR_CMD_ERR_MASK</a>, <a class="el" href="group__spi__v4__4.html#gae1c1ffa1846ef388873861bf017aec7a">XSP_INTR_MODE_FAULT_MASK</a>, <a class="el" href="group__spi__v4__4.html#gaf4fa2bf85266797c3806a885144f0a67">XSP_INTR_RX_NOT_EMPTY_MASK</a>, <a class="el" href="group__spi__v4__4.html#gae4313597b27da75830905e5510d6c7ba">XSP_INTR_RX_OVERRUN_MASK</a>, <a class="el" href="group__spi__v4__4.html#gad8f8c52684a188989df6463cfa44e90f">XSP_INTR_SLAVE_MODE_FAULT_MASK</a>, <a class="el" href="group__spi__v4__4.html#gaaac9322f55b43ad653b2dd630df73ac6">XSP_INTR_SLAVE_MODE_MASK</a>, <a class="el" href="group__spi__v4__4.html#gaa8ec3c2cf6ffb5824012e63935fe94cf">XSP_INTR_TX_EMPTY_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga17b6c5a44bb267e1d71293adfc225cc4">XSP_INTR_TX_HALF_EMPTY_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga9a7a08185e86401169c2f810642f08ec">XSP_INTR_TX_UNDERRUN_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga25dfccf25bae24caa237ec3b75825438">XSP_SR_RX_EMPTY_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga2666d211089b037853ee6d1f80130ae7">XSP_SR_TX_FULL_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort()</a>, <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>, <a class="el" href="group__spi__v4__4.html#gaf65c9e65699c1746d205a77554d40adb">XSpi_GetStatusReg</a>, <a class="el" href="group__spi__v4__4.html#gab883b734cc9b78985dae611df2f4725a">XSpi_IntrClear</a>, <a class="el" href="group__spi__v4__4.html#ga48c1f7712f55bbb65d7b68c92b818f78">XSpi_IntrDisable</a>, <a class="el" href="group__spi__v4__4.html#ga01dc10ba2ca5c1e5ff30ecd0cadac140">XSpi_IntrGetStatus</a>, <a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>, <a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>, <a class="el" href="group__spi__v4__4.html#gae93befb10305b5abccc5483b73e60060">XSpi_SetSlaveSelectReg</a>, and <a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gac2c4a169e05ad6e040796ae86100fd5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> * XSpi_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the device configuration based on the unique device ID. </p>
<p>A table contains the configuration info for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>contains the ID of the device to look up the configuration for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>A pointer to the configuration found or NULL if the specified device ID was not found. See <a class="el" href="xspi_8h.html">xspi.h</a> for the definition of <a class="el" href="struct_x_spi___config.html" title="This typedef contains configuration information for the device.">XSpi_Config</a>.</p>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="xspi__atmel__flash__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="xspi__intr__example_8c.html#abd314964daed3d1fb324ef61ed37f276">SpiIntrExample()</a>, <a class="el" href="xspi__polled__example_8c.html#a0dd02b93ca6a7d528f41113065a1e3cb">SpiPolledExample()</a>, <a class="el" href="xspi__selftest__example_8c.html#aa80f2f9d52f6c35db2d43a56802a81c8">SpiSelfTestExample()</a>, <a class="el" href="xspi__winbond__flash__xip__example_8c.html#af3fb7f2668aa93bc45fb9ca9c252f219">SpiXipExample()</a>, and <a class="el" href="group__spi__v4__4.html#gaa1fb3e31ba804cc87dc309847fb02471">XSpi_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga343938fcdf672bec329d876a146178cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the SPI device by writing to the Software Reset register. </p>
<p>Reset must only be called after the driver has been initialized. The configuration of the device after reset is the same as its configuration after initialization. Refer to the XSpi_Initialize function for more details. This is a hard reset of the device. Any data transfer that is in progress is aborted.</p>
<p>The upper layer software is responsible for re-configuring (if necessary) and restarting the SPI device after the reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi.html#aa0669158439f14d3a15ab49795b7139f">XSpi::BaseAddr</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#a71a59342f02363d57536aeefd2aa7a3f">XSpi::IsStarted</a>, <a class="el" href="struct_x_spi.html#a0ba738ff1f34e3e5af78c7437df1073f">XSpi::SlaveSelectMask</a>, <a class="el" href="struct_x_spi.html#a4dda79fe6ae8a3536b0aaaa62be0d8b5">XSpi::SlaveSelectReg</a>, <a class="el" href="group__spi__v4__4.html#gaa82028ecd15bcffd8ab361c0c523a7a9">XSP_SRR_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#ga48fdfb116f37c7f14403bed57b556c4c">XSP_SRR_RESET_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga44a2dc795761b35ed0ebdd6989675022">XSpi_Abort()</a>, and <a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__spi__v4__4.html#ga858155b42d5a1da8efe06c9098e40b2d">XSpi_CfgInitialize()</a>, and <a class="el" href="group__spi__v4__4.html#ga11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga11b6ebdb6f69c6939176e05600b10e3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a self-test on the driver/device. </p>
<p>The self-test is destructive in that a reset of the device is performed in order to check the reset values of the registers and to get the device into a known state. A simple loopback test is also performed to verify that transmit and receive are working properly. The device is changed to master mode for the loopback test, since only a master can initiate a data transfer.</p>
<p>Upon successful return from the self-test, the device is reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<ul>
<li>XST_REGISTER_ERROR indicates a register did not read or write correctly.<ul>
<li>XST_LOOPBACK_ERROR if a loopback error occurred.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi.html#aa0669158439f14d3a15ab49795b7139f">XSpi::BaseAddr</a>, <a class="el" href="struct_x_spi.html#a67a6dd9a95f3bef8199dc0186dfb039a">XSpi::HasFifos</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#a0ba738ff1f34e3e5af78c7437df1073f">XSpi::SlaveSelectMask</a>, <a class="el" href="struct_x_spi.html#a9816437229050cd78cb29c4f762228b7">XSpi::SpiMode</a>, <a class="el" href="struct_x_spi.html#a36bd7deea43721717288da63415e8fdd">XSpi::XipMode</a>, <a class="el" href="group__spi__v4__4.html#ga4e120064bd2a34a145d54608ccef4107">XSP_RFO_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#gaf06c80c0767e40c86b2e3fc18457d680">XSP_TFO_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>, <a class="el" href="group__spi__v4__4.html#ga5c8ab7387ce196ce3309dc68bd15e489">XSpi_GetSlaveSelectReg</a>, <a class="el" href="group__spi__v4__4.html#gaf65c9e65699c1746d205a77554d40adb">XSpi_GetStatusReg</a>, <a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>, and <a class="el" href="group__spi__v4__4.html#ga343938fcdf672bec329d876a146178cd">XSpi_Reset()</a>.</p>

<p>Referenced by <a class="el" href="xspi__intr__example_8c.html#abd314964daed3d1fb324ef61ed37f276">SpiIntrExample()</a>, <a class="el" href="xspi__polled__example_8c.html#a0dd02b93ca6a7d528f41113065a1e3cb">SpiPolledExample()</a>, and <a class="el" href="xspi__selftest__example_8c.html#aa80f2f9d52f6c35db2d43a56802a81c8">SpiSelfTestExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga67c2076b133a55b6f80343642a1ace41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the options for the SPI device driver. </p>
<p>The options control how the device behaves relative to the SPI bus. The device must be idle rather than busy transferring data before setting these device options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Options</td><td>contains the specified options to be set. This is a bit mask where a 1 means to turn the option on, and a 0 means to turn the option off. One or more bit values may be contained in the mask. See the bit definitions named XSP_*_OPTIONS in the file <a class="el" href="xspi_8h.html">xspi.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-XST_SUCCESS if options are successfully set.<ul>
<li>XST_DEVICE_BUSY if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li>
<li>XST_SPI_SLAVE_ONLY if the caller attempted to configure a slave-only device as a master.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function makes use of internal resources that are shared between the <a class="el" href="group__spi__v4__4.html#gad4bb67cfcfe73844ffb1917b11d5284c" title="This function stops the SPI device by disabling interrupts and disabling the device itself...">XSpi_Stop()</a> and <a class="el" href="group__spi__v4__4.html#ga67c2076b133a55b6f80343642a1ace41" title="This function sets the options for the SPI device driver.">XSpi_SetOptions()</a> functions. So if one task might be setting device options while another is trying to stop the device, the user is required to provide protection of this shared data (typically using a semaphore). </p>

<p>References <a class="el" href="struct_x_spi.html#a35871d4554b45a9078edfabb763cc1a5">XSpi::IsBusy</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#a282ea84ad4ceb9e950bb91b66231780b">XSpi::SlaveOnly</a>, <a class="el" href="group__spi__v4__4.html#gac2c043a14b04e38a61b1979ccaa8a200">XSP_MASTER_OPTION</a>, <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>, and <a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>.</p>

<p>Referenced by <a class="el" href="xspi__atmel__flash__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="xspi__intr__example_8c.html#abd314964daed3d1fb324ef61ed37f276">SpiIntrExample()</a>, and <a class="el" href="xspi__polled__example_8c.html#a0dd02b93ca6a7d528f41113065a1e3cb">SpiPolledExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga162523a3e9b29f063701db303ac8cf17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_SetSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SlaveMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects or deselect the slave with which the master communicates. </p>
<p>Each slave that can be selected is represented in the slave select register by a bit. The argument passed to this function is the bit mask with a 1 in the bit position of the slave being selected. Only one slave can be selected.</p>
<p>The user is not allowed to deselect the slave while a transfer is in progress. If no transfer is in progress, the user can select a new slave, which implicitly deselects the current slave. In order to explicitly deselect the current slave, a zero can be passed in as the argument to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">SlaveMask</td><td>is a 32-bit mask with a 1 in the bit position of the slave being selected. Only one slave can be selected. The SlaveMask can be zero if the slave is being deselected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the slave is selected or deselected successfully.</li>
</ul>
</dd></dl>
<ul>
<li>XST_DEVICE_BUSY if a transfer is in progress, slave cannot be changed</li>
<li>XST_SPI_TOO_MANY_SLAVES if more than one slave is being selected.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function only sets the slave which will be selected when a transfer occurs. The slave is not selected when the SPI is idle. The slave select has no affect when the device is configured as a slave. </p>

<p>References <a class="el" href="struct_x_spi.html#a35871d4554b45a9078edfabb763cc1a5">XSpi::IsBusy</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#ab2896a95a00faec5cee34d83093ffb3f">XSpi::NumSlaveBits</a>, and <a class="el" href="struct_x_spi.html#a4dda79fe6ae8a3536b0aaaa62be0d8b5">XSpi::SlaveSelectReg</a>.</p>

<p>Referenced by <a class="el" href="xspi__atmel__flash__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>.</p>

</div>
</div>
<a class="anchor" id="gabc09f4d503de2a772e5079ac46fc62b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_SetStatusHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__spi__v4__4.html#gaa9c3c5101d73a626380c46bcc906069e">XSpi_StatusHandler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to the higher layer software. </p>
<p>The handler executes in an interrupt context, so it must minimize the amount of processing performed such as transferring data to a thread context. One of the following status events is passed to the status handler. </p>
<pre><ul>
<li>XST_SPI_MODE_FAULT  A mode fault error occurred, meaning another
                        master tried to select this device as a slave
                        when this device was configured to be a master.
                        Any transfer in progress is aborted.</li>
</ul>
</pre><pre><ul>
<li>XST_SPI_TRANSFER_DONE       The requested data transfer is done</li>
</ul>
</pre><pre><ul>
<li>XST_SPI_TRANSMIT_UNDERRUN   As a slave device, the master clocked
                        data but there were none available in the
                        transmit register/FIFO. This typically means the
                        slave application did not issue a transfer
                        request fast enough, or the processor/driver
                        could not fill the transmit register/FIFO fast
                        enough.</li>
</ul>
</pre><pre><ul>
<li>XST_SPI_RECEIVE_OVERRUN     The SPI device lost data. Data was received
                        but the receive data register/FIFO was full.
                        This indicates that the device is receiving data
                        faster than the processor/driver can consume it.</li>
</ul>
</pre><pre><ul>
<li>XST_SPI_SLAVE_MODE_FAULT    A slave SPI device was selected as a slave while
                        it was disabled.  This indicates the master is
                        already transferring data (which is being
                        dropped until the slave application issues a
                        transfer).

<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.
</td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back
        when the callback function is invoked.
</td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
The handler is called within interrupt context, so it should do its work
quickly and queue potentially time-consuming work to a task-level thread.
</li>
</ul>
</pre>
<p>References <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#a032c4db15af79e91cc2fcf564dea1b55">XSpi::StatusHandler</a>, and <a class="el" href="struct_x_spi.html#aa4075b1e4be099fe87f575b777628a78">XSpi::StatusRef</a>.</p>

<p>Referenced by <a class="el" href="xspi__atmel__flash__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, and <a class="el" href="xspi__intr__example_8c.html#abd314964daed3d1fb324ef61ed37f276">SpiIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga87fdaad742a2669200c9b2617e5c86ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables interrupts for the SPI device. </p>
<p>If the Spi driver is used in interrupt mode, it is up to the user to connect the SPI interrupt handler to the interrupt controller before this function is called. If the Spi driver is used in polled mode the user has to disable the Global Interrupts after this function is called. If the device is configured with FIFOs, the FIFOs are reset at this time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the device is successfully started</li>
<li>XST_DEVICE_IS_STARTED if the device was already started.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#a71a59342f02363d57536aeefd2aa7a3f">XSpi::IsStarted</a>, <a class="el" href="group__spi__v4__4.html#ga1c10904273bbeb8fb8fc502c5cc9cdf6">XSP_CR_ENABLE_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga5b5e5793f12d648025e58f716862bb3e">XSP_CR_RXFIFO_RESET_MASK</a>, <a class="el" href="group__spi__v4__4.html#gab7796329c185988f906256394bc9372f">XSP_CR_TXFIFO_RESET_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga99707579afa353242a403526ddebcb6d">XSP_INTR_DFT_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>, <a class="el" href="group__spi__v4__4.html#ga85f2b8305794c31bc41ebd35ffeb4892">XSpi_IntrEnable</a>, <a class="el" href="group__spi__v4__4.html#gaa9075007c45d749e3b9bd24a37f9d908">XSpi_IntrGlobalEnable</a>, and <a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>.</p>

<p>Referenced by <a class="el" href="xspi__atmel__flash__example_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>, <a class="el" href="xspi__intr__example_8c.html#abd314964daed3d1fb324ef61ed37f276">SpiIntrExample()</a>, and <a class="el" href="xspi__polled__example_8c.html#a0dd02b93ca6a7d528f41113065a1e3cb">SpiPolledExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gad4bb67cfcfe73844ffb1917b11d5284c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the SPI device by disabling interrupts and disabling the device itself. </p>
<p>Interrupts are disabled only within the device itself. If desired, the caller is responsible for disabling interrupts in the interrupt controller and disconnecting the interrupt handler from the interrupt controller.</p>
<p>In interrupt mode, if the device is in progress of transferring data on the SPI bus, this function returns a status indicating the device is busy. The user will be notified via the status handler when the transfer is complete, and at that time can again try to stop the device. As a master, we do not allow the device to be stopped while a transfer is in progress because the slave may be left in a bad state. As a slave, we do not allow the device to be stopped while a transfer is in progress because the master is not done with its transfer yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the device is successfully started.</li>
</ul>
</dd></dl>
<ul>
<li>XST_DEVICE_BUSY if a transfer is in progress and cannot be stopped.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function makes use of internal resources that are shared between the <a class="el" href="group__spi__v4__4.html#gad4bb67cfcfe73844ffb1917b11d5284c" title="This function stops the SPI device by disabling interrupts and disabling the device itself...">XSpi_Stop()</a> and <a class="el" href="group__spi__v4__4.html#ga67c2076b133a55b6f80343642a1ace41" title="This function sets the options for the SPI device driver.">XSpi_SetOptions()</a> functions. So if one task might be setting device options while another is trying to stop the device, the user is is required to provide protection of this shared data (typically using a semaphore). </p>

<p>References <a class="el" href="struct_x_spi.html#a35871d4554b45a9078edfabb763cc1a5">XSpi::IsBusy</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#a71a59342f02363d57536aeefd2aa7a3f">XSpi::IsStarted</a>, <a class="el" href="group__spi__v4__4.html#ga1c10904273bbeb8fb8fc502c5cc9cdf6">XSP_CR_ENABLE_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>, <a class="el" href="group__spi__v4__4.html#ga5035851f7c130da994d9deec67c89b5f">XSpi_IntrGlobalDisable</a>, and <a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga4c44c082ef2d2b9cf4ba3db8bcebd954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_Transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfers the specified data on the SPI bus. </p>
<p>If the SPI device is configured to be a master, this function initiates bus communication and sends/receives the data to/from the selected SPI slave. If the SPI device is configured to be a slave, this function prepares the data to be sent/received when selected by a master. For every byte sent, a byte is received.</p>
<p>This function/driver operates in interrupt mode and polled mode.</p>
<ul>
<li>In interrupt mode this function is non-blocking and the transfer is initiated by this function and completed by the interrupt service routine.</li>
<li>In polled mode this function is blocking and the control exits this function only after all the requested data is transferred.</li>
</ul>
<p>The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: </p>
<pre>
      XSpi_Transfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
      The caller wishes to send and receive, and provides two different
      buffers for send and receive.</pre><pre>      XSpi_Transfer(InstancePtr, SendBuf, NULL, ByteCount)
      The caller wishes only to send and does not care about the received
      data. The driver ignores the received data in this case.</pre><pre>      XSpi_Transfer(InstancePtr, SendBuf, SendBuf, ByteCount)
      The caller wishes to send and receive, but provides the same buffer
      for doing both. The driver sends the data and overwrites the send
      buffer with received data as it transfers the data.</pre><pre>      XSpi_Transfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
      The caller wishes to only receive and does not care about sending
      data.  In this case, the caller must still provide a send buffer, but
      it can be the same as the receive buffer if the caller does not care
      what it sends. The device must send N bytes of data if it wishes to
      receive N bytes of data.
</pre><p> In interrupt mode, though this function takes a buffer as an argument, the driver can only transfer a limited number of bytes at time. It transfers only one byte at a time if there are no FIFOs, or it can transfer the number of bytes up to the size of the FIFO if FIFOs exist.</p>
<ul>
<li>In interrupt mode a call to this function only starts the transfer, the subsequent transfer of the data is performed by the interrupt service routine until the entire buffer has been transferred.The status callback function is called when the entire buffer has been sent/received.</li>
<li>In polled mode this function is blocking and the control exits this function only after all the requested data is transferred.</li>
</ul>
<p>As a master, the SetSlaveSelect function must be called prior to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi.html" title="The XSpi driver instance data.">XSpi</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">SendBufPtr</td><td>is a pointer to a buffer of data which is to be sent. This buffer must not be NULL. </td></tr>
    <tr><td class="paramname">RecvBufPtr</td><td>is a pointer to a buffer which will be filled with received data. This argument can be NULL if the caller does not wish to receive data. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-XST_SUCCESS if the buffers are successfully handed off to the driver for transfer. Otherwise, returns:<ul>
<li>XST_DEVICE_IS_STOPPED if the device must be started before transferring data.</li>
<li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li>
<li>XST_SPI_NO_SLAVE indicates the device is configured as a master and a slave has not yet been selected.</li>
</ul>
</dd></dl>
<p>This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the SPI bus at the same time. </p>

<p>References <a class="el" href="struct_x_spi.html#aa0669158439f14d3a15ab49795b7139f">XSpi::BaseAddr</a>, <a class="el" href="struct_x_spi___stats.html#a7684cf587c67273ed4d87a912d158363">XSpi_Stats::BytesTransferred</a>, <a class="el" href="struct_x_spi.html#aac3d52799cee844afec78ffc203c4b20">XSpi::DataWidth</a>, <a class="el" href="struct_x_spi.html#a35871d4554b45a9078edfabb763cc1a5">XSpi::IsBusy</a>, <a class="el" href="struct_x_spi.html#a19847c6916d3d7a325a2cebab966018a">XSpi::IsReady</a>, <a class="el" href="struct_x_spi.html#a71a59342f02363d57536aeefd2aa7a3f">XSpi::IsStarted</a>, <a class="el" href="struct_x_spi.html#acc5a98e31ed6927b50d6bff4c87f5bb9">XSpi::RecvBufferPtr</a>, <a class="el" href="struct_x_spi.html#a883553e7813c71d61fc1f84de68d9bf4">XSpi::RemainingBytes</a>, <a class="el" href="struct_x_spi.html#a1f78cff15e7571d1db3630834d376877">XSpi::RequestedBytes</a>, <a class="el" href="struct_x_spi.html#af85c6077464bc0877fe6334564b9430c">XSpi::SendBufferPtr</a>, <a class="el" href="struct_x_spi.html#a0ba738ff1f34e3e5af78c7437df1073f">XSpi::SlaveSelectMask</a>, <a class="el" href="struct_x_spi.html#a4dda79fe6ae8a3536b0aaaa62be0d8b5">XSpi::SlaveSelectReg</a>, <a class="el" href="struct_x_spi.html#a63d1a1254869f2599e4646388cec0c4c">XSpi::Stats</a>, <a class="el" href="group__spi__v4__4.html#ga6a060df48208ca7e56572762233ceadb">XSP_CR_LOOPBACK_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga25aabcaa1db090de7cf4aaf3cb05ea6b">XSP_CR_MASTER_MODE_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga2d045067441152dbf5729d4dce64032b">XSP_CR_TRANS_INHIBIT_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga7c85879d831cff400f3919c3283089dc">XSP_DATAWIDTH_BYTE</a>, <a class="el" href="group__spi__v4__4.html#gabd886cf61eba8074e747ebec9df258dd">XSP_DATAWIDTH_HALF_WORD</a>, <a class="el" href="group__spi__v4__4.html#gace732a635dfcd0b6258449945444b31c">XSP_DATAWIDTH_WORD</a>, <a class="el" href="group__spi__v4__4.html#ga078846fea7538049312959d15b44a9dd">XSP_DRR_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#ga02929309d91a658ac28746aee48d0c04">XSP_DTR_OFFSET</a>, <a class="el" href="group__spi__v4__4.html#gaa8ec3c2cf6ffb5824012e63935fe94cf">XSP_INTR_TX_EMPTY_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga25dfccf25bae24caa237ec3b75825438">XSP_SR_RX_EMPTY_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga2666d211089b037853ee6d1f80130ae7">XSP_SR_TX_FULL_MASK</a>, <a class="el" href="group__spi__v4__4.html#ga7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>, <a class="el" href="group__spi__v4__4.html#gaf65c9e65699c1746d205a77554d40adb">XSpi_GetStatusReg</a>, <a class="el" href="group__spi__v4__4.html#gab883b734cc9b78985dae611df2f4725a">XSpi_IntrClear</a>, <a class="el" href="group__spi__v4__4.html#ga85f2b8305794c31bc41ebd35ffeb4892">XSpi_IntrEnable</a>, <a class="el" href="group__spi__v4__4.html#ga01dc10ba2ca5c1e5ff30ecd0cadac140">XSpi_IntrGetStatus</a>, <a class="el" href="group__spi__v4__4.html#ga5035851f7c130da994d9deec67c89b5f">XSpi_IntrGlobalDisable</a>, <a class="el" href="group__spi__v4__4.html#gaa9075007c45d749e3b9bd24a37f9d908">XSpi_IntrGlobalEnable</a>, <a class="el" href="group__spi__v4__4.html#ga2210a78f1a4bc86250be33e8093e686c">XSpi_IsIntrGlobalEnabled</a>, <a class="el" href="group__spi__v4__4.html#ga5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>, <a class="el" href="group__spi__v4__4.html#ga3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>, <a class="el" href="group__spi__v4__4.html#gae93befb10305b5abccc5483b73e60060">XSpi_SetSlaveSelectReg</a>, and <a class="el" href="group__spi__v4__4.html#ga32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xspi__eeprom__example_8c.html#af63163cf8fa5318000173043114d45a3">EepromRead()</a>, <a class="el" href="xspi__eeprom__example_8c.html#a6e2e0f5d20d6b8785f6c3323a947ba5d">EepromWrite()</a>, <a class="el" href="xspi__atmel__flash__example_8c.html#a0ed9e112534c36b485c016cc7e87371a">SpiAtmelFlashPageErase()</a>, <a class="el" href="xspi__atmel__flash__example_8c.html#af1f8ff70c5039fe5656c3d9476d3c671">SpiAtmelFlashRead()</a>, <a class="el" href="xspi__atmel__flash__example_8c.html#a6eb43fd87e3cff7189788dba94c3d595">SpiAtmelFlashWrite()</a>, <a class="el" href="xspi__numonyx__flash__quad__example_8c.html#a86d8ebdee181c36e305d15812df9d774">SpiFlashBulkErase()</a>, <a class="el" href="xspi__winbond__flash__quad__example_8c.html#a29b2b437252838fd655646e018a44fa8">SpiFlashEnableHPM()</a>, <a class="el" href="xspi__numonyx__flash__quad__example_8c.html#a4007c2150a6cc4c1f0e890fcb784a52e">SpiFlashGetStatus()</a>, <a class="el" href="xspi__winbond__flash__quad__example_8c.html#aa80e27c647fe6b86b58019a9af60c1b3">SpiFlashQuadEnable()</a>, <a class="el" href="xspi__numonyx__flash__quad__example_8c.html#ac94156992ca0662d45a6a79e77ae5469">SpiFlashRead()</a>, <a class="el" href="xspi__numonyx__flash__quad__example_8c.html#ab9756ea6473f94b75dc9c44df1a55705">SpiFlashSectorErase()</a>, <a class="el" href="xspi__numonyx__flash__quad__example_8c.html#a639435b86afe1f3a18334d679371509b">SpiFlashWrite()</a>, <a class="el" href="xspi__numonyx__flash__quad__example_8c.html#a48599e715e854c930ad7682db64c5716">SpiFlashWriteEnable()</a>, <a class="el" href="xspi__intel__flash__example_8c.html#a504d4dbb0eda6e379a09eceb1c46780b">SpiIntelFlashBulkErase()</a>, <a class="el" href="xspi__intel__flash__example_8c.html#af1df55f074e01da3a431a6b4dffe5906">SpiIntelFlashGetStatus()</a>, <a class="el" href="xspi__intel__flash__example_8c.html#a187ad5a1ce8a9fdd0cfe915aa07c4c68">SpiIntelFlashRead()</a>, <a class="el" href="xspi__intel__flash__example_8c.html#a692a3c13eb25182574d572b40d6f409d">SpiIntelFlashSectorErase()</a>, <a class="el" href="xspi__intel__flash__example_8c.html#a9fc6213c851b1f3156bfe642080ddfa6">SpiIntelFlashWrite()</a>, <a class="el" href="xspi__intel__flash__example_8c.html#afd36247f46468f8a699dbed74b666b6d">SpiIntelFlashWriteEnable()</a>, <a class="el" href="xspi__intel__flash__example_8c.html#add79104b20e650bddfefb137c77a22c7">SpiIntelFlashWriteStatus()</a>, <a class="el" href="xspi__intr__example_8c.html#abd314964daed3d1fb324ef61ed37f276">SpiIntrExample()</a>, <a class="el" href="xspi__polled__example_8c.html#a0dd02b93ca6a7d528f41113065a1e3cb">SpiPolledExample()</a>, <a class="el" href="xspi__stm__flash__example_8c.html#a9cf6f63c9b15b121231880b384d2d6fe">SpiStmFlashBulkErase()</a>, <a class="el" href="xspi__stm__flash__example_8c.html#a7dccfc93abc36cebd86eaeb6aa3ec13e">SpiStmFlashGetStatus()</a>, <a class="el" href="xspi__stm__flash__example_8c.html#a4d6873a7dfd6f962658f9c38c16922bf">SpiStmFlashRead()</a>, <a class="el" href="xspi__stm__flash__example_8c.html#a67e2c3caac23cc5879eb277cdd2476fd">SpiStmFlashSectorErase()</a>, <a class="el" href="xspi__stm__flash__example_8c.html#aa941537bff54666b063ae5d01f2a82e8">SpiStmFlashWrite()</a>, and <a class="el" href="xspi__stm__flash__example_8c.html#acd35c3715d81555e31510cd8e985f4de">SpiStmFlashWriteEnable()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga31f3cf000e45e67f36d374906154ac38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> XSpi_ConfigTable[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This table contains configuration information for each SPI device in the system. </p>

</div>
</div>
<a class="anchor" id="ga31f3cf000e45e67f36d374906154ac38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> XSpi_ConfigTable[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This table contains configuration information for each SPI device in the system. </p>

</div>
</div>
<a class="anchor" id="ga8c36dd59052589f679b9e441507116b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> XSpi_ConfigTable[XPAR_XSPI_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        {</div>
<div class="line">         XPAR_SPI_0_DEVICE_ID,          </div>
<div class="line">         XPAR_SPI_0_BASEADDR,           </div>
<div class="line">         XPAR_SPI_0_FIFO_EXIST,         </div>
<div class="line">         XPAR_SPI_0_SLAVE_ONLY,         </div>
<div class="line">         XPAR_SPI_0_NUM_SS_BITS,        </div>
<div class="line">         XPAR_SPI_0_NUM_TRANSFER_BITS   </div>
<div class="line">         XPAR_SPI_0_SPI_MODE            </div>
<div class="line">         XPAR_SPI_0_USE_STARTUP         </div>
<div class="line">        }</div>
<div class="line">        ,</div>
<div class="line">        {</div>
<div class="line">         XPAR_SPI_1_DEVICE_ID,          </div>
<div class="line">         XPAR_SPI_1_BASEADDR,           </div>
<div class="line">         XPAR_SPI_1_FIFO_EXIST,         </div>
<div class="line">         XPAR_SPI_1_SLAVE_ONLY,         </div>
<div class="line">         XPAR_SPI_1_NUM_SS_BITS,        </div>
<div class="line">         XPAR_SPI_1_NUM_TRANSFER_BITS   </div>
<div class="line">         XPAR_SPI_1_SPI_MODE            </div>
<div class="line">         XPAR_SPI_0_USE_STARTUP         </div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This table contains configuration information for each SPI device in the system. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
