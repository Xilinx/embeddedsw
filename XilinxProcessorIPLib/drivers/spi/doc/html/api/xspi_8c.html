<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xspi.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xspi.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Contains required functions of the <a class="el" href="struct_x_spi.html">XSpi</a> driver component. See xspi.h for a detailed description of the device and driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.00a rpm  10/11/01 First release
 1.00b jhl  03/14/02 Repartitioned driver for smaller files.
 1.00b rpm  04/25/02 Collapsed IPIF and reg base addresses into one
 1.00b rmm  05/14/03 Fixed diab compiler warnings relating to asserts
 1.01a jvb  12/13/05 Changed Initialize() into CfgInitialize(), and made
                     CfgInitialize() take a pointer to a config structure
                     instead of a device id. Moved Initialize() into
                     <a class="el" href="xspi__sinit_8c.html">xspi_sinit.c</a>, and had Initialize() call CfgInitialize()
                     after it retrieved the config structure using the device
                     id. Removed include of xparameters.h along with any
                     dependencies on xparameters.h and the _g.c config table.
 1.11a wgr  03/22/07 Converted to new coding style.
 1.11a rpm  01/22/08 Updated comment on Transfer regarding needing interrupts.
 1.12a sdm  03/27/08 Updated the code to support 16/32 bit transfer width and
                     polled mode of operation. Even for the polled mode of
                     operation the Interrupt Logic in the core should be
                     included. The driver can be put in polled mode of
                     operation by disabling the Global Interrupt after the
                     Spi Initialization is completed.
 2.00a sdm  07/30/08 Updated the code to support 16/32 bit transfer width and
                     polled mode of operation. Even for the polled mode of
                     operation the Interrupt Logic in the core should be
                     included. The driver can be put in polled mode of
                     operation by disabling the Global Interrupt after the
                     Spi Initialization is completed.
 2.01b sdm  04/08/09 Fixed an issue in the XSpi_Transfer function where the
                     Global Interrupt is being enabled in polled mode when a
                     slave is not selected.
 3.00a ktn  10/28/09 Updated all the register accesses as 32 bit access.
		      Updated to use the HAL APIs/macros.
		      Removed the macro XSpi_mReset, XSpi_Reset API should be
		      used in its place.
		      The macros have been renamed to remove _m from the name.
		      Removed an unnecessary read to the core register in the
		      XSpi_GetSlaveSelect API.
 3.01a sdm  04/23/10 Updated the driver to handle new slave mode interrupts
		      and the DTR Half Empty interrupt.
 3.04a bss  03/21/12 Updated XSpi_CfgInitialize to support XIP Mode
 3.05a adk  18/04/13 Updated the code to avoid unused variable 
	              warnings when compiling with the -Wextra -Wall flags
		      In the file <a class="el" href="xspi_8c.html">xspi.c</a>. CR:705005.
 3.06a adk  07/08/13 Added a dummy read in the CfgInitialize(), if startup
		      block is used in the h/w design (CR 721229).
 3.07a adk 11/10/13  In the xspi_transfer function moved the assert slave chip
 		      select after the configuration of the Data Transmit 
		      register inorder to work with CPOL and CPHA High Options.
 		      As per spec (Dual/Quad SPI Transaction instrunction 7,8,9)
 		      CR:732962
 </pre> 
<p>
<code>#include &quot;xspi.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xspi__i_8h.html">xspi_i.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#1afe70dc86403460db288edbfe69548b">XSpi_Abort</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#19d8db4a2a6341ceed512726a4ab8376">XSpi_CfgInitialize</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, <a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *Config, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#67fa2e789e984347a5bc25af93d2172f">XSpi_Start</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#492e33fd55f186a3ccd0b697892896d7">XSpi_Stop</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#6de2ed77deecbdb16c2df71f56e331c6">XSpi_Reset</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#2c3d3713b82e8e0c3c2c73acca7a6ce4">XSpi_Transfer</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned int ByteCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#53f8cb8ed5d14ebe5cb708dd12aa8820">XSpi_SetSlaveSelect</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u32 SlaveMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#616c9b7098231cae59bbbc354134a204">XSpi_GetSlaveSelect</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#0ee8da86d3065f3b9d9132cfc4069ef2">XSpi_SetStatusHandler</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, void *CallBackRef, XSpi_StatusHandler FuncPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8c.html#b00b075da8336846f4cfe835775ab5e0">XSpi_InterruptHandler</a> (void *InstancePtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1afe70dc86403460db288edbfe69548b"></a><!-- doxytag: member="xspi.c::XSpi_Abort" ref="1afe70dc86403460db288edbfe69548b" args="(XSpi *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_Abort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Aborts a transfer in progress by setting the stop bit in the control register, then resetting the FIFOs if present. The byte counts are cleared and the busy flag is set to false.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function does a read/modify/write of the control register. The user of this function needs to take care of critical sections.     </td>
  </tr>
</table>
<a class="anchor" name="19d8db4a2a6341ceed512726a4ab8376"></a><!-- doxytag: member="xspi.c::XSpi_CfgInitialize" ref="19d8db4a2a6341ceed512726a4ab8376" args="(XSpi *InstancePtr, XSpi_Config *Config, u32 EffectiveAddr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>EffectiveAddr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a specific <a class="el" href="struct_x_spi.html">XSpi</a> instance such that the driver is ready to use.<p>
The state of the device after initialization is:<ul>
<li>Device is disabled</li><li>Slave mode</li><li>Active high clock polarity</li><li>Clock phase 0</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific SPI device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_DEVICE_IS_STARTED if the device is started. It must be stopped to re-initialize.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="616c9b7098231cae59bbbc354134a204"></a><!-- doxytag: member="xspi.c::XSpi_GetSlaveSelect" ref="616c9b7098231cae59bbbc354134a204" args="(XSpi *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XSpi_GetSlaveSelect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the current slave select bit mask for the SPI device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value returned is a 32-bit mask with a 1 in the bit position of the slave currently selected. The value may be zero if no slaves are selected.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This API is used to get the current slave select bit mask that was set using the XSpi_SetSlaveSelect API. This API deos not read the register from the core and returns the slave select register stored in the instance pointer. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b00b075da8336846f4cfe835775ab5e0"></a><!-- doxytag: member="xspi.c::XSpi_InterruptHandler" ref="b00b075da8336846f4cfe835775ab5e0" args="(void *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_InterruptHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The interrupt handler for SPI interrupts. This function must be connected by the user to an interrupt source. This function does not save and restore the processor context such that the user must provide this processing.<p>
The interrupts that are handled are:<p>
<ul>
<li>Mode Fault Error. This interrupt is generated if this device is selected as a slave when it is configured as a master. The driver aborts any data transfer that is in progress by resetting FIFOs (if present) and resetting its buffer pointers. The upper layer software is informed of the error.</li></ul>
<p>
<ul>
<li>Data Transmit Register (FIFO) Empty. This interrupt is generated when the transmit register or FIFO is empty. The driver uses this interrupt during a transmission to continually send/receive data until there is no more data to send/receive.</li></ul>
<p>
<ul>
<li>Data Transmit Register (FIFO) Underrun. This interrupt is generated when the SPI device, when configured as a slave, attempts to read an empty DTR/FIFO. An empty DTR/FIFO usually means that software is not giving the device data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li></ul>
<p>
<ul>
<li>Data Receive Register (FIFO) Overrun. This interrupt is generated when the SPI device attempts to write a received byte to an already full DRR/FIFO. A full DRR/FIFO usually means software is not emptying the data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li></ul>
<p>
<ul>
<li>Slave Mode Fault Error. This interrupt is generated if a slave device is selected as a slave while it is disabled. No action is taken by the driver other than to inform the upper layer software of the error.</li></ul>
<p>
<ul>
<li>Command Error. This interrupt occurs when the first byte in the Tx FIFO, after the CS is asserted, doesn't match any command in the Lookup table. This interrupt is valid only for axi_qspi.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The slave select register is being set to deselect the slave when a transfer is complete. This is being done regardless of whether it is a slave or a master since the hardware does not drive the slave select as a slave.     </td>
  </tr>
</table>
<a class="anchor" name="6de2ed77deecbdb16c2df71f56e331c6"></a><!-- doxytag: member="xspi.c::XSpi_Reset" ref="6de2ed77deecbdb16c2df71f56e331c6" args="(XSpi *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_Reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resets the SPI device by writing to the Software Reset register. Reset must only be called after the driver has been initialized. The configuration of the device after reset is the same as its configuration after initialization. Refer to the XSpi_Initialize function for more details. This is a hard reset of the device. Any data transfer that is in progress is aborted.<p>
The upper layer software is responsible for re-configuring (if necessary) and restarting the SPI device after the reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="53f8cb8ed5d14ebe5cb708dd12aa8820"></a><!-- doxytag: member="xspi.c::XSpi_SetSlaveSelect" ref="53f8cb8ed5d14ebe5cb708dd12aa8820" args="(XSpi *InstancePtr, u32 SlaveMask)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_SetSlaveSelect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>SlaveMask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Selects or deselect the slave with which the master communicates. Each slave that can be selected is represented in the slave select register by a bit. The argument passed to this function is the bit mask with a 1 in the bit position of the slave being selected. Only one slave can be selected.<p>
The user is not allowed to deselect the slave while a transfer is in progress. If no transfer is in progress, the user can select a new slave, which implicitly deselects the current slave. In order to explicitly deselect the current slave, a zero can be passed in as the argument to the function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveMask</em>&nbsp;</td><td>is a 32-bit mask with a 1 in the bit position of the slave being selected. Only one slave can be selected. The SlaveMask can be zero if the slave is being deselected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the slave is selected or deselected successfully.</li><li>XST_DEVICE_BUSY if a transfer is in progress, slave cannot be changed</li><li>XST_SPI_TOO_MANY_SLAVES if more than one slave is being selected.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function only sets the slave which will be selected when a transfer occurs. The slave is not selected when the SPI is idle. The slave select has no affect when the device is configured as a slave.     </td>
  </tr>
</table>
<a class="anchor" name="0ee8da86d3065f3b9d9132cfc4069ef2"></a><!-- doxytag: member="xspi.c::XSpi_SetStatusHandler" ref="0ee8da86d3065f3b9d9132cfc4069ef2" args="(XSpi *InstancePtr, void *CallBackRef, XSpi_StatusHandler FuncPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_SetStatusHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XSpi_StatusHandler&nbsp;</td>
          <td class="mdname" nowrap> <em>FuncPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to the higher layer software. The handler executes in an interrupt context, so it must minimize the amount of processing performed such as transferring data to a thread context. One of the following status events is passed to the status handler. <pre><ul>
<li>XST_SPI_MODE_FAULT	A mode fault error occurred, meaning another
				master tried to select this device as a slave
				when this device was configured to be a master.
				Any transfer in progress is aborted.</li></ul>
</pre><p>
<pre><ul>
<li>XST_SPI_TRANSFER_DONE	The requested data transfer is done</li></ul>
</pre><p>
<pre><ul>
<li>XST_SPI_TRANSMIT_UNDERRUN	As a slave device, the master clocked
				data but there were none available in the
				transmit register/FIFO. This typically means the
				slave application did not issue a transfer
				request fast enough, or the processor/driver
				could not fill the transmit register/FIFO fast
				enough.</li></ul>
</pre><p>
<pre><ul>
<li>XST_SPI_RECEIVE_OVERRUN	The SPI device lost data. Data was received
				but the receive data register/FIFO was full.
				This indicates that the device is receiving data
				faster than the processor/driver can consume it.</li></ul>
</pre><p>
<pre><ul>
<li>XST_SPI_SLAVE_MODE_FAULT	A slave SPI device was selected as a slave while
				it was disabled.  This indicates the master is
				already transferring data (which is being
				dropped until the slave application issues a
				transfer).
 
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back
		when the callback function is invoked.
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The handler is called within interrupt context, so it should do its work
 quickly and queue potentially time-consuming work to a task-level thread.
</li></ul>
</pre>    </td>
  </tr>
</table>
<a class="anchor" name="67fa2e789e984347a5bc25af93d2172f"></a><!-- doxytag: member="xspi.c::XSpi_Start" ref="67fa2e789e984347a5bc25af93d2172f" args="(XSpi *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_Start           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function enables interrupts for the SPI device. If the Spi driver is used in interrupt mode, it is up to the user to connect the SPI interrupt handler to the interrupt controller before this function is called. If the Spi driver is used in polled mode the user has to disable the Global Interrupts after this function is called. If the device is configured with FIFOs, the FIFOs are reset at this time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the device is successfully started</li><li>XST_DEVICE_IS_STARTED if the device was already started.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="492e33fd55f186a3ccd0b697892896d7"></a><!-- doxytag: member="xspi.c::XSpi_Stop" ref="492e33fd55f186a3ccd0b697892896d7" args="(XSpi *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_Stop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function stops the SPI device by disabling interrupts and disabling the device itself. Interrupts are disabled only within the device itself. If desired, the caller is responsible for disabling interrupts in the interrupt controller and disconnecting the interrupt handler from the interrupt controller.<p>
In interrupt mode, if the device is in progress of transferring data on the SPI bus, this function returns a status indicating the device is busy. The user will be notified via the status handler when the transfer is complete, and at that time can again try to stop the device. As a master, we do not allow the device to be stopped while a transfer is in progress because the slave may be left in a bad state. As a slave, we do not allow the device to be stopped while a transfer is in progress because the master is not done with its transfer yet.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the device is successfully started.</li><li>XST_DEVICE_BUSY if a transfer is in progress and cannot be stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function makes use of internal resources that are shared between the <a class="el" href="xspi_8c.html#492e33fd55f186a3ccd0b697892896d7">XSpi_Stop()</a> and <a class="el" href="xspi__options_8c.html#c4ec75b1278923ebe476e5a6de04b5c4">XSpi_SetOptions()</a> functions. So if one task might be setting device options while another is trying to stop the device, the user is is required to provide protection of this shared data (typically using a semaphore).     </td>
  </tr>
</table>
<a class="anchor" name="2c3d3713b82e8e0c3c2c73acca7a6ce4"></a><!-- doxytag: member="xspi.c::XSpi_Transfer" ref="2c3d3713b82e8e0c3c2c73acca7a6ce4" args="(XSpi *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned int ByteCount)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_Transfer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ByteCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transfers the specified data on the SPI bus. If the SPI device is configured to be a master, this function initiates bus communication and sends/receives the data to/from the selected SPI slave. If the SPI device is configured to be a slave, this function prepares the data to be sent/received when selected by a master. For every byte sent, a byte is received.<p>
This function/driver operates in interrupt mode and polled mode.<ul>
<li>In interrupt mode this function is non-blocking and the transfer is initiated by this function and completed by the interrupt service routine.</li><li>In polled mode this function is blocking and the control exits this function only after all the requested data is transferred.</li></ul>
<p>
The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: <pre>
	XSpi_Transfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
	The caller wishes to send and receive, and provides two different
	buffers for send and receive.</pre><p>
<pre>	XSpi_Transfer(InstancePtr, SendBuf, NULL, ByteCount)
	The caller wishes only to send and does not care about the received
	data. The driver ignores the received data in this case.</pre><p>
<pre>	XSpi_Transfer(InstancePtr, SendBuf, SendBuf, ByteCount)
	The caller wishes to send and receive, but provides the same buffer
	for doing both. The driver sends the data and overwrites the send
	buffer with received data as it transfers the data.</pre><p>
<pre>	XSpi_Transfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
	The caller wishes to only receive and does not care about sending
	data.  In this case, the caller must still provide a send buffer, but
	it can be the same as the receive buffer if the caller does not care
	what it sends. The device must send N bytes of data if it wishes to
	receive N bytes of data.
 </pre> In interrupt mode, though this function takes a buffer as an argument, the driver can only transfer a limited number of bytes at time. It transfers only one byte at a time if there are no FIFOs, or it can transfer the number of bytes up to the size of the FIFO if FIFOs exist.<ul>
<li>In interrupt mode a call to this function only starts the transfer, the subsequent transfer of the data is performed by the interrupt service routine until the entire buffer has been transferred.The status callback function is called when the entire buffer has been sent/received.</li><li>In polled mode this function is blocking and the control exits this function only after all the requested data is transferred.</li></ul>
<p>
As a master, the SetSlaveSelect function must be called prior to this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SendBufPtr</em>&nbsp;</td><td>is a pointer to a buffer of data which is to be sent. This buffer must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RecvBufPtr</em>&nbsp;</td><td>is a pointer to a buffer which will be filled with received data. This argument can be NULL if the caller does not wish to receive data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>-XST_SUCCESS if the buffers are successfully handed off to the driver for transfer. Otherwise, returns:<ul>
<li>XST_DEVICE_IS_STOPPED if the device must be started before transferring data.</li><li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li><li>XST_SPI_NO_SLAVE indicates the device is configured as a master and a slave has not yet been selected.</li></ul>
</dd></dl>
<p>
This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the SPI bus at the same time.     </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
