<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>iomodule: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">iomodule
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__iomodule.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Overview</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for the device.  <a href="struct_x_i_o_module___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___uart___stats.html">XIOModule_Uart_Stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for the UART.  <a href="struct_x_i_o_module___uart___stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___buffer.html">XIOModule_Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following data type is used to manage the buffers that are handled when sending and receiving UART data in the interrupt mode.  <a href="struct_x_i_o_module___buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___timer___stats.html">XIOModule_Timer_Stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programmable Interval Timer statistics.  <a href="struct_x_i_o_module___timer___stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module.html">XIOModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> driver instance data.  <a href="struct_x_i_o_module.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___vector_table_entry.html">XIOModule_VectorTableEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the number of timer counters within a single hardware device.  <a href="struct_x_i_o_module___vector_table_entry.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga71f9336a3492b8501e09d3a87e2d661a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga71f9336a3492b8501e09d3a87e2d661a">XIOModule_UpdateStats</a>(InstancePtr, StatusRegister)</td></tr>
<tr class="memdesc:ga71f9336a3492b8501e09d3a87e2d661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the statistics of the instance.  <a href="#ga71f9336a3492b8501e09d3a87e2d661a">More...</a><br/></td></tr>
<tr class="separator:ga71f9336a3492b8501e09d3a87e2d661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230620599fe987b03b47e6d04a442e60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga230620599fe987b03b47e6d04a442e60">XIOModule_EnableIntr</a>(BaseAddress, EnableMask)&#160;&#160;&#160;XIomodule_Out32((BaseAddress) + XIN_IER_OFFSET, (EnableMask))</td></tr>
<tr class="memdesc:ga230620599fe987b03b47e6d04a442e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable specific interrupt(s) in the interrupt controller.  <a href="#ga230620599fe987b03b47e6d04a442e60">More...</a><br/></td></tr>
<tr class="separator:ga230620599fe987b03b47e6d04a442e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf77d72d553f17c2696ce54e3149f0d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaaf77d72d553f17c2696ce54e3149f0d0">XIOModule_DisableIntr</a>(BaseAddress, DisableMask)&#160;&#160;&#160;XIomodule_Out32((BaseAddress) + XIN_IER_OFFSET, ~(DisableMask))</td></tr>
<tr class="memdesc:gaaf77d72d553f17c2696ce54e3149f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable specific interrupt(s) in the interrupt controller.  <a href="#gaaf77d72d553f17c2696ce54e3149f0d0">More...</a><br/></td></tr>
<tr class="separator:gaaf77d72d553f17c2696ce54e3149f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3f5aa29d205f6221a017a04712c65f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gac3f5aa29d205f6221a017a04712c65f0">XIOModule_AckIntr</a>(BaseAddress, AckMask)&#160;&#160;&#160;XIomodule_Out32((BaseAddress) + XIN_IAR_OFFSET, (AckMask))</td></tr>
<tr class="memdesc:gac3f5aa29d205f6221a017a04712c65f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge specific interrupt(s) in the interrupt controller.  <a href="#gac3f5aa29d205f6221a017a04712c65f0">More...</a><br/></td></tr>
<tr class="separator:gac3f5aa29d205f6221a017a04712c65f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga128f261df0c50d6e1b090e2a9e9d1874"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga128f261df0c50d6e1b090e2a9e9d1874">XIOModule_GetIntrStatus</a>(BaseAddress)&#160;&#160;&#160;(XIomodule_In32((BaseAddress) + XIN_IPR_OFFSET))</td></tr>
<tr class="memdesc:ga128f261df0c50d6e1b090e2a9e9d1874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interrupt status from the interrupt controller which indicates which interrupts are active and enabled.  <a href="#ga128f261df0c50d6e1b090e2a9e9d1874">More...</a><br/></td></tr>
<tr class="separator:ga128f261df0c50d6e1b090e2a9e9d1874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga313c2576e159fd472cb0b25b7a395837"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>(BaseAddress)&#160;&#160;&#160;XIomodule_In32((BaseAddress) + XUL_STATUS_REG_OFFSET)</td></tr>
<tr class="memdesc:ga313c2576e159fd472cb0b25b7a395837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the contents of the UART status register.  <a href="#ga313c2576e159fd472cb0b25b7a395837">More...</a><br/></td></tr>
<tr class="separator:ga313c2576e159fd472cb0b25b7a395837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c5e48a02c0aba03cb1d8d7583b37f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gad9c5e48a02c0aba03cb1d8d7583b37f6">XIOModule_IsReceiveEmpty</a>(BaseAddress)</td></tr>
<tr class="memdesc:gad9c5e48a02c0aba03cb1d8d7583b37f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the UART receiver has data.  <a href="#gad9c5e48a02c0aba03cb1d8d7583b37f6">More...</a><br/></td></tr>
<tr class="separator:gad9c5e48a02c0aba03cb1d8d7583b37f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c23372164e627f79da9488ea43161a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga93c23372164e627f79da9488ea43161a">XIOModule_IsTransmitFull</a>(BaseAddress)</td></tr>
<tr class="memdesc:ga93c23372164e627f79da9488ea43161a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the transmitter is full.  <a href="#ga93c23372164e627f79da9488ea43161a">More...</a><br/></td></tr>
<tr class="separator:ga93c23372164e627f79da9488ea43161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829c77e3efe996211599f9a2a6bb4890"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>(BaseAddress, RegOffset, Data)&#160;&#160;&#160;XIomodule_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td></tr>
<tr class="memdesc:ga829c77e3efe996211599f9a2a6bb4890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to a GPO register.  <a href="#ga829c77e3efe996211599f9a2a6bb4890">More...</a><br/></td></tr>
<tr class="separator:ga829c77e3efe996211599f9a2a6bb4890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eaff234e65f369a870fca3b92215df4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg</a>(BaseAddress, RegOffset)&#160;&#160;&#160;XIomodule_In32((BaseAddress) + (RegOffset))</td></tr>
<tr class="memdesc:ga4eaff234e65f369a870fca3b92215df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from a GPI register.  <a href="#ga4eaff234e65f369a870fca3b92215df4">More...</a><br/></td></tr>
<tr class="separator:ga4eaff234e65f369a870fca3b92215df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga40a7295554b9483f28c0f004b0c53302"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a> )(void *CallBackRef, unsigned int ByteCount)</td></tr>
<tr class="memdesc:ga40a7295554b9483f28c0f004b0c53302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function.  <a href="#ga40a7295554b9483f28c0f004b0c53302">More...</a><br/></td></tr>
<tr class="separator:ga40a7295554b9483f28c0f004b0c53302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a95e8a205259686d85802168e10cdb3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga3a95e8a205259686d85802168e10cdb3">XIOModule_Timer_Handler</a> )(void *CallBackRef, u8 TimerNumber)</td></tr>
<tr class="memdesc:ga3a95e8a205259686d85802168e10cdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for the timer callback function.  <a href="#ga3a95e8a205259686d85802168e10cdb3">More...</a><br/></td></tr>
<tr class="separator:ga3a95e8a205259686d85802168e10cdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga81cf0087aeb46a8a78030e964e743314"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga81cf0087aeb46a8a78030e964e743314">XIOModule_Initialize</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr class="memdesc:ga81cf0087aeb46a8a78030e964e743314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a specific interrupt controller instance/driver.  <a href="#ga81cf0087aeb46a8a78030e964e743314">More...</a><br/></td></tr>
<tr class="separator:ga81cf0087aeb46a8a78030e964e743314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964f5bae2572929b40d1f630118e36ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga964f5bae2572929b40d1f630118e36ac">XIOModule_HandlerTable_Initialize</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga964f5bae2572929b40d1f630118e36ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes all interrupt handlers to default handler for each interrupt ID.  <a href="#ga964f5bae2572929b40d1f630118e36ac">More...</a><br/></td></tr>
<tr class="separator:ga964f5bae2572929b40d1f630118e36ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2841593e6e312fefe9f190a75e11fdb4"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga2841593e6e312fefe9f190a75e11fdb4">XIOModule_Start</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga2841593e6e312fefe9f190a75e11fdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the IO Module.  <a href="#ga2841593e6e312fefe9f190a75e11fdb4">More...</a><br/></td></tr>
<tr class="separator:ga2841593e6e312fefe9f190a75e11fdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd1ece524eb5fd3d5d255027ad6a01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga4cd1ece524eb5fd3d5d255027ad6a01a">XIOModule_Stop</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga4cd1ece524eb5fd3d5d255027ad6a01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the interrupt controller by disabling the output from the controller so that no interrupts will be caused by the interrupt controller.  <a href="#ga4cd1ece524eb5fd3d5d255027ad6a01a">More...</a><br/></td></tr>
<tr class="separator:ga4cd1ece524eb5fd3d5d255027ad6a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437b891061d1b16758b5e104e7535e6e"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga437b891061d1b16758b5e104e7535e6e">XIOModule_Connect</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id, XInterruptHandler Handler, void *CallBackRef)</td></tr>
<tr class="memdesc:ga437b891061d1b16758b5e104e7535e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized.  <a href="#ga437b891061d1b16758b5e104e7535e6e">More...</a><br/></td></tr>
<tr class="separator:ga437b891061d1b16758b5e104e7535e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga241c2c08f867ee4d03e96248c4a133da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga241c2c08f867ee4d03e96248c4a133da">XIOModule_Disconnect</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga241c2c08f867ee4d03e96248c4a133da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the interrupt table with the Null Handler and NULL arguments at the location pointed at by the Id.  <a href="#ga241c2c08f867ee4d03e96248c4a133da">More...</a><br/></td></tr>
<tr class="separator:ga241c2c08f867ee4d03e96248c4a133da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2fe0ab1367af43b603cd896e306737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga0c2fe0ab1367af43b603cd896e306737">XIOModule_Enable</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga0c2fe0ab1367af43b603cd896e306737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the interrupt source provided as the argument Id.  <a href="#ga0c2fe0ab1367af43b603cd896e306737">More...</a><br/></td></tr>
<tr class="separator:ga0c2fe0ab1367af43b603cd896e306737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab631d859f9fc7b00f3c8367d763c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga2ab631d859f9fc7b00f3c8367d763c49">XIOModule_Disable</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga2ab631d859f9fc7b00f3c8367d763c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the interrupt source provided as the argument Id such that the interrupt controller will not cause interrupts for the specified Id.  <a href="#ga2ab631d859f9fc7b00f3c8367d763c49">More...</a><br/></td></tr>
<tr class="separator:ga2ab631d859f9fc7b00f3c8367d763c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036018140fd9f14af05eec37b3cb2e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga036018140fd9f14af05eec37b3cb2e93">XIOModule_Acknowledge</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:ga036018140fd9f14af05eec37b3cb2e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledges the interrupt source provided as the argument Id.  <a href="#ga036018140fd9f14af05eec37b3cb2e93">More...</a><br/></td></tr>
<tr class="separator:ga036018140fd9f14af05eec37b3cb2e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367989ec098fe548ba62b58640490ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga367989ec098fe548ba62b58640490ec7">XIOModule_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:ga367989ec098fe548ba62b58640490ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the device configuration based on the unique device ID.  <a href="#ga367989ec098fe548ba62b58640490ec7">More...</a><br/></td></tr>
<tr class="separator:ga367989ec098fe548ba62b58640490ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8717545acaa871a5d9ed89702f9173c"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gab8717545acaa871a5d9ed89702f9173c">XIOModule_ConnectFastHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id, XFastInterruptHandler Handler)</td></tr>
<tr class="memdesc:gab8717545acaa871a5d9ed89702f9173c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized.  <a href="#gab8717545acaa871a5d9ed89702f9173c">More...</a><br/></td></tr>
<tr class="separator:gab8717545acaa871a5d9ed89702f9173c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4ddcaf38d655ca70d916c1d5ba96240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gab4ddcaf38d655ca70d916c1d5ba96240">XIOModule_SetNormalIntrMode</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr class="memdesc:gab4ddcaf38d655ca70d916c1d5ba96240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the normal interrupt mode for the specified interrupt in the Interrupt Mode Register, by resetting the vector to (BaseVector &amp; 0xFFFFFF80) | 0x10 and selecting normal mode.  <a href="#gab4ddcaf38d655ca70d916c1d5ba96240">More...</a><br/></td></tr>
<tr class="separator:gab4ddcaf38d655ca70d916c1d5ba96240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87f83bf4cf53aa0e4f972688cb3e4aed"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga87f83bf4cf53aa0e4f972688cb3e4aed">XIOModule_DiscreteRead</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 Channel)</td></tr>
<tr class="memdesc:ga87f83bf4cf53aa0e4f972688cb3e4aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read state of discretes for the specified GPI channel.  <a href="#ga87f83bf4cf53aa0e4f972688cb3e4aed">More...</a><br/></td></tr>
<tr class="separator:ga87f83bf4cf53aa0e4f972688cb3e4aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4876348e378f8b97bdc59b7cfd5b6b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga4876348e378f8b97bdc59b7cfd5b6b8b">XIOModule_DiscreteWrite</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 Channel, u32 Data)</td></tr>
<tr class="memdesc:ga4876348e378f8b97bdc59b7cfd5b6b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to discretes register for the specified GPO channel.  <a href="#ga4876348e378f8b97bdc59b7cfd5b6b8b">More...</a><br/></td></tr>
<tr class="separator:ga4876348e378f8b97bdc59b7cfd5b6b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d32b770ba1aa2fda3d1bb389777212b"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga8d32b770ba1aa2fda3d1bb389777212b">XIOModule_Timer_Initialize</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr class="memdesc:ga8d32b770ba1aa2fda3d1bb389777212b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a specific timer instance/driver.  <a href="#ga8d32b770ba1aa2fda3d1bb389777212b">More...</a><br/></td></tr>
<tr class="separator:ga8d32b770ba1aa2fda3d1bb389777212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga622c3a5cd4e43543cfb445071d01e7a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga622c3a5cd4e43543cfb445071d01e7a9">XIOModule_Timer_Start</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr class="memdesc:ga622c3a5cd4e43543cfb445071d01e7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the specified timer counter of the device such that it starts running.  <a href="#ga622c3a5cd4e43543cfb445071d01e7a9">More...</a><br/></td></tr>
<tr class="separator:ga622c3a5cd4e43543cfb445071d01e7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60bd9ef270b0de7440206326ec1fe710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga60bd9ef270b0de7440206326ec1fe710">XIOModule_Timer_Stop</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr class="memdesc:ga60bd9ef270b0de7440206326ec1fe710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the timer by disabling it.  <a href="#ga60bd9ef270b0de7440206326ec1fe710">More...</a><br/></td></tr>
<tr class="separator:ga60bd9ef270b0de7440206326ec1fe710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826357a58aeda0b2d1bfc42efd6bb94c"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga826357a58aeda0b2d1bfc42efd6bb94c">XIOModule_GetValue</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr class="memdesc:ga826357a58aeda0b2d1bfc42efd6bb94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value of the specified timer counter.  <a href="#ga826357a58aeda0b2d1bfc42efd6bb94c">More...</a><br/></td></tr>
<tr class="separator:ga826357a58aeda0b2d1bfc42efd6bb94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9ed2111d2f53ac88626030d907f374a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaf9ed2111d2f53ac88626030d907f374a">XIOModule_SetResetValue</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber, u32 ResetValue)</td></tr>
<tr class="memdesc:gaf9ed2111d2f53ac88626030d907f374a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reset value for the specified timer counter.  <a href="#gaf9ed2111d2f53ac88626030d907f374a">More...</a><br/></td></tr>
<tr class="separator:gaf9ed2111d2f53ac88626030d907f374a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4281a3f3f5e5620d4e78dc904ab04cf"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaf4281a3f3f5e5620d4e78dc904ab04cf">XIOModule_GetCaptureValue</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr class="memdesc:gaf4281a3f3f5e5620d4e78dc904ab04cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timer counter value that was captured the last time the external capture input was asserted.  <a href="#gaf4281a3f3f5e5620d4e78dc904ab04cf">More...</a><br/></td></tr>
<tr class="separator:gaf4281a3f3f5e5620d4e78dc904ab04cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d1cb85ee2100003b7e2dcc160c47c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gae5d1cb85ee2100003b7e2dcc160c47c0">XIOModule_Reset</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr class="memdesc:gae5d1cb85ee2100003b7e2dcc160c47c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the specified timer counter of the device.  <a href="#gae5d1cb85ee2100003b7e2dcc160c47c0">More...</a><br/></td></tr>
<tr class="separator:gae5d1cb85ee2100003b7e2dcc160c47c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404ac6ebc7137131bf0d277256c07605"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga404ac6ebc7137131bf0d277256c07605">XIOModule_IsExpired</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr class="memdesc:ga404ac6ebc7137131bf0d277256c07605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified timer counter of the device has expired.  <a href="#ga404ac6ebc7137131bf0d277256c07605">More...</a><br/></td></tr>
<tr class="separator:ga404ac6ebc7137131bf0d277256c07605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9939789b5819d1561bebc0eacac28b84"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga9939789b5819d1561bebc0eacac28b84">XIOModule_IoReadWord</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset)</td></tr>
<tr class="memdesc:ga9939789b5819d1561bebc0eacac28b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32-bit word from the IO Bus memory mapped IO.  <a href="#ga9939789b5819d1561bebc0eacac28b84">More...</a><br/></td></tr>
<tr class="separator:ga9939789b5819d1561bebc0eacac28b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff8a4fabcb27bc42957503761602439"><td class="memItemLeft" align="right" valign="top">u16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga7ff8a4fabcb27bc42957503761602439">XIOModule_IoReadHalfword</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset)</td></tr>
<tr class="memdesc:ga7ff8a4fabcb27bc42957503761602439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 16-bit halfword from the IO Bus memory mapped IO.  <a href="#ga7ff8a4fabcb27bc42957503761602439">More...</a><br/></td></tr>
<tr class="separator:ga7ff8a4fabcb27bc42957503761602439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ec0ed139e0e9629ec1b542dfec3989"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gab5ec0ed139e0e9629ec1b542dfec3989">XIOModule_IoReadByte</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset)</td></tr>
<tr class="memdesc:gab5ec0ed139e0e9629ec1b542dfec3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read byte from the IO Bus memory mapped IO.  <a href="#gab5ec0ed139e0e9629ec1b542dfec3989">More...</a><br/></td></tr>
<tr class="separator:gab5ec0ed139e0e9629ec1b542dfec3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf20cdadbf9d5197fd91076a76b7049f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaf20cdadbf9d5197fd91076a76b7049f8">XIOModule_IoWriteWord</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset, u32 Data)</td></tr>
<tr class="memdesc:gaf20cdadbf9d5197fd91076a76b7049f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32-bit word to the IO Bus memory mapped IO.  <a href="#gaf20cdadbf9d5197fd91076a76b7049f8">More...</a><br/></td></tr>
<tr class="separator:gaf20cdadbf9d5197fd91076a76b7049f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c9d9b8fc1d9accc3502b24db3770664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga3c9d9b8fc1d9accc3502b24db3770664">XIOModule_IoWriteHalfword</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset, u16 Data)</td></tr>
<tr class="memdesc:ga3c9d9b8fc1d9accc3502b24db3770664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 16-bit word to the IO Bus memory mapped IO.  <a href="#ga3c9d9b8fc1d9accc3502b24db3770664">More...</a><br/></td></tr>
<tr class="separator:ga3c9d9b8fc1d9accc3502b24db3770664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3b81b7f7e0ebf69c951b2fcf438e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaae3b81b7f7e0ebf69c951b2fcf438e85">XIOModule_IoWriteByte</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset, u8 Data)</td></tr>
<tr class="memdesc:gaae3b81b7f7e0ebf69c951b2fcf438e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 8-bit word to the IO Bus memory mapped IO.  <a href="#gaae3b81b7f7e0ebf69c951b2fcf438e85">More...</a><br/></td></tr>
<tr class="separator:gaae3b81b7f7e0ebf69c951b2fcf438e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52755c9c41e1753703652d7a9c879fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gad52755c9c41e1753703652d7a9c879fa">XIOModule_DiscreteSet</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 Channel, u32 Mask)</td></tr>
<tr class="memdesc:gad52755c9c41e1753703652d7a9c879fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output discrete(s) to logic 1 for the specified GPO channel.  <a href="#gad52755c9c41e1753703652d7a9c879fa">More...</a><br/></td></tr>
<tr class="separator:gad52755c9c41e1753703652d7a9c879fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa314f25c8472dceb0e9021ca8d7b10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga4aa314f25c8472dceb0e9021ca8d7b10">XIOModule_DiscreteClear</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 Channel, u32 Mask)</td></tr>
<tr class="memdesc:ga4aa314f25c8472dceb0e9021ca8d7b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output discrete(s) to logic 0 for the specified GPO channel.  <a href="#ga4aa314f25c8472dceb0e9021ca8d7b10">More...</a><br/></td></tr>
<tr class="separator:ga4aa314f25c8472dceb0e9021ca8d7b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff025dd804b08ec80047b8b17273da84"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaff025dd804b08ec80047b8b17273da84">XIOModule_CfgInitialize</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> *Config, u32 EffectiveAddr)</td></tr>
<tr class="memdesc:gaff025dd804b08ec80047b8b17273da84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance.  <a href="#gaff025dd804b08ec80047b8b17273da84">More...</a><br/></td></tr>
<tr class="separator:gaff025dd804b08ec80047b8b17273da84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadabb5f2e09817afb284173f31f3d7265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gadabb5f2e09817afb284173f31f3d7265">XIOModule_ResetFifos</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:gadabb5f2e09817afb284173f31f3d7265"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does nothing, since the UART doesn't have any FIFOs.  <a href="#gadabb5f2e09817afb284173f31f3d7265">More...</a><br/></td></tr>
<tr class="separator:gadabb5f2e09817afb284173f31f3d7265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe2219bbd76d37299ef7e645133bd74f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gabe2219bbd76d37299ef7e645133bd74f">XIOModule_Send</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 *DataBufferPtr, u32 NumBytes)</td></tr>
<tr class="memdesc:gabe2219bbd76d37299ef7e645133bd74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions sends the specified buffer of data using the UART in either polled or interrupt driven modes.  <a href="#gabe2219bbd76d37299ef7e645133bd74f">More...</a><br/></td></tr>
<tr class="separator:gabe2219bbd76d37299ef7e645133bd74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3840262ec8f698849bf0bba791c978a8"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga3840262ec8f698849bf0bba791c978a8">XIOModule_Recv</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 *DataBufferPtr, u32 NumBytes)</td></tr>
<tr class="memdesc:ga3840262ec8f698849bf0bba791c978a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer.  <a href="#ga3840262ec8f698849bf0bba791c978a8">More...</a><br/></td></tr>
<tr class="separator:ga3840262ec8f698849bf0bba791c978a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e055e6172c30e7acbfde08aeed10fa1"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga0e055e6172c30e7acbfde08aeed10fa1">XIOModule_IsSending</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga0e055e6172c30e7acbfde08aeed10fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines if the specified UART is sending data.  <a href="#ga0e055e6172c30e7acbfde08aeed10fa1">More...</a><br/></td></tr>
<tr class="separator:ga0e055e6172c30e7acbfde08aeed10fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5ebecb3c051addf25c38216b08069a"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaed5ebecb3c051addf25c38216b08069a">XIOModule_SetBaudRate</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 BaudRate)</td></tr>
<tr class="memdesc:gaed5ebecb3c051addf25c38216b08069a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the baud rate for the specified UART.  <a href="#gaed5ebecb3c051addf25c38216b08069a">More...</a><br/></td></tr>
<tr class="separator:gaed5ebecb3c051addf25c38216b08069a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ada8bd0fb0d16976254c228a8924a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga42ada8bd0fb0d16976254c228a8924a2">XIOModule_GetStats</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="struct_x_i_o_module___uart___stats.html">XIOModule_Uart_Stats</a> *StatsPtr)</td></tr>
<tr class="memdesc:ga42ada8bd0fb0d16976254c228a8924a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a snapshot of the current statistics in the structure specified.  <a href="#ga42ada8bd0fb0d16976254c228a8924a2">More...</a><br/></td></tr>
<tr class="separator:ga42ada8bd0fb0d16976254c228a8924a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a582e9785291f7c6e0b91c19c46bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga61a582e9785291f7c6e0b91c19c46bd8">XIOModule_ClearStats</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga61a582e9785291f7c6e0b91c19c46bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function zeros the statistics for the given instance.  <a href="#ga61a582e9785291f7c6e0b91c19c46bd8">More...</a><br/></td></tr>
<tr class="separator:ga61a582e9785291f7c6e0b91c19c46bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga848da9f83ad1188caca777cd324cec10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga848da9f83ad1188caca777cd324cec10">XIOModule_InterruptHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga848da9f83ad1188caca777cd324cec10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interrupt handler for the driver.  <a href="#ga848da9f83ad1188caca777cd324cec10">More...</a><br/></td></tr>
<tr class="separator:ga848da9f83ad1188caca777cd324cec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa805a7f9982d9acc5b3b16849c5d2dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaa805a7f9982d9acc5b3b16849c5d2dfd">XIOModule_Uart_EnableInterrupt</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaa805a7f9982d9acc5b3b16849c5d2dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the UART interrupts such that an interrupt will occur when data is received or data has been transmitted.  <a href="#gaa805a7f9982d9acc5b3b16849c5d2dfd">More...</a><br/></td></tr>
<tr class="separator:gaa805a7f9982d9acc5b3b16849c5d2dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec72d0dd352ad42de494821220e3185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga5ec72d0dd352ad42de494821220e3185">XIOModule_Uart_DisableInterrupt</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga5ec72d0dd352ad42de494821220e3185"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the UART interrupt.  <a href="#ga5ec72d0dd352ad42de494821220e3185">More...</a><br/></td></tr>
<tr class="separator:ga5ec72d0dd352ad42de494821220e3185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ece62521d0d34bd420888ecc876750c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga5ece62521d0d34bd420888ecc876750c">XIOModule_SetRecvHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="group__iomodule.html#ga40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:ga5ece62521d0d34bd420888ecc876750c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART.  <a href="#ga5ece62521d0d34bd420888ecc876750c">More...</a><br/></td></tr>
<tr class="separator:ga5ece62521d0d34bd420888ecc876750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b376ebf11fee3ff027445eaa096261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga07b376ebf11fee3ff027445eaa096261">XIOModule_SetSendHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="group__iomodule.html#ga40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:ga07b376ebf11fee3ff027445eaa096261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART.  <a href="#ga07b376ebf11fee3ff027445eaa096261">More...</a><br/></td></tr>
<tr class="separator:ga07b376ebf11fee3ff027445eaa096261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2a67095f9797403f5c269fdcd7a6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gacf2a67095f9797403f5c269fdcd7a6b2">XIOModule_Uart_InterruptHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:gacf2a67095f9797403f5c269fdcd7a6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the UART.  <a href="#gacf2a67095f9797403f5c269fdcd7a6b2">More...</a><br/></td></tr>
<tr class="separator:gacf2a67095f9797403f5c269fdcd7a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41be199efc8ca8c8d883c5fae98517d6"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga41be199efc8ca8c8d883c5fae98517d6">XIOModule_SetOptions</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 Options)</td></tr>
<tr class="memdesc:ga41be199efc8ca8c8d883c5fae98517d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the options for the interrupt controller driver.  <a href="#ga41be199efc8ca8c8d883c5fae98517d6">More...</a><br/></td></tr>
<tr class="separator:ga41be199efc8ca8c8d883c5fae98517d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab24288979ff867f5e8f98372bddda874"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gab24288979ff867f5e8f98372bddda874">XIOModule_GetOptions</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:gab24288979ff867f5e8f98372bddda874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently set options.  <a href="#gab24288979ff867f5e8f98372bddda874">More...</a><br/></td></tr>
<tr class="separator:gab24288979ff867f5e8f98372bddda874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a295427c84e3c7f0cee3440ba119093"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga4a295427c84e3c7f0cee3440ba119093">XIOModule_SelfTest</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga4a295427c84e3c7f0cee3440ba119093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a self-test on the timer and interrupt controller driver/device.  <a href="#ga4a295427c84e3c7f0cee3440ba119093">More...</a><br/></td></tr>
<tr class="separator:ga4a295427c84e3c7f0cee3440ba119093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719529740fbb19c3ce7d44078a2edcc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga719529740fbb19c3ce7d44078a2edcc1">XIOModule_Timer_SetOptions</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber, u32 Options)</td></tr>
<tr class="memdesc:ga719529740fbb19c3ce7d44078a2edcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the specified options for the specified timer .  <a href="#ga719529740fbb19c3ce7d44078a2edcc1">More...</a><br/></td></tr>
<tr class="separator:ga719529740fbb19c3ce7d44078a2edcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50d24ec7a10fc2b3167d5f3a6070107"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gae50d24ec7a10fc2b3167d5f3a6070107">XIOModel_Timer_GetOptions</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr class="memdesc:gae50d24ec7a10fc2b3167d5f3a6070107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the options for the specified timer.  <a href="#gae50d24ec7a10fc2b3167d5f3a6070107">More...</a><br/></td></tr>
<tr class="separator:gae50d24ec7a10fc2b3167d5f3a6070107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36785024a93e95d38c2b4e7552744aa"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gae36785024a93e95d38c2b4e7552744aa">XIOModule_Timer_SelfTest</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr class="memdesc:gae36785024a93e95d38c2b4e7552744aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a self-test on the timer driver/device.  <a href="#gae36785024a93e95d38c2b4e7552744aa">More...</a><br/></td></tr>
<tr class="separator:gae36785024a93e95d38c2b4e7552744aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadbc5225c2c104a1a09d226e6daf3497"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaadbc5225c2c104a1a09d226e6daf3497">XIOModule_Intc_SelfTest</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaadbc5225c2c104a1a09d226e6daf3497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a self-test on the interrupt controller driver/device.  <a href="#gaadbc5225c2c104a1a09d226e6daf3497">More...</a><br/></td></tr>
<tr class="separator:gaadbc5225c2c104a1a09d226e6daf3497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e5ac3f9e5a286fd376120cb27f545d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gab2e5ac3f9e5a286fd376120cb27f545d">XIOModule_SetHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="group__iomodule.html#ga3a95e8a205259686d85802168e10cdb3">XIOModule_Timer_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr class="memdesc:gab2e5ac3f9e5a286fd376120cb27f545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timer callback function, which the driver calls when the specified timer times out.  <a href="#gab2e5ac3f9e5a286fd376120cb27f545d">More...</a><br/></td></tr>
<tr class="separator:gab2e5ac3f9e5a286fd376120cb27f545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431eb19a0f6aeab9bab0cdb09fdc30ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga431eb19a0f6aeab9bab0cdb09fdc30ce">XIOModule_Timer_InterruptHandler</a> (void *InstancePtr)</td></tr>
<tr class="memdesc:ga431eb19a0f6aeab9bab0cdb09fdc30ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt Service Routine (ISR) for the driver.  <a href="#ga431eb19a0f6aeab9bab0cdb09fdc30ce">More...</a><br/></td></tr>
<tr class="separator:ga431eb19a0f6aeab9bab0cdb09fdc30ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc16de9c0cbaad1d3022d19a0d883cd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga1fc16de9c0cbaad1d3022d19a0d883cd">XIOModule_SendBuffer</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga1fc16de9c0cbaad1d3022d19a0d883cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends a buffer that has been previously specified by setting up the instance variables of the instance.  <a href="#ga1fc16de9c0cbaad1d3022d19a0d883cd">More...</a><br/></td></tr>
<tr class="separator:ga1fc16de9c0cbaad1d3022d19a0d883cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b12729029fff571ad8915dc30897d6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga70b12729029fff571ad8915dc30897d6">XIOModule_ReceiveBuffer</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga70b12729029fff571ad8915dc30897d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function receives a buffer that has been previously specified by setting up the instance variables of the instance.  <a href="#ga70b12729029fff571ad8915dc30897d6">More...</a><br/></td></tr>
<tr class="separator:ga70b12729029fff571ad8915dc30897d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e47bfda481c3ceab60d758f049758ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler</a> (void *DeviceId)</td></tr>
<tr class="memdesc:ga2e47bfda481c3ceab60d758f049758ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the primary interrupt handler for the driver.  <a href="#ga2e47bfda481c3ceab60d758f049758ef">More...</a><br/></td></tr>
<tr class="separator:ga2e47bfda481c3ceab60d758f049758ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b99cc28b7c0282919f3039d8d60e168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga9b99cc28b7c0282919f3039d8d60e168">XIOModule_SetIntrSvcOption</a> (UINTPTR BaseAddress, s32 Option)</td></tr>
<tr class="memdesc:ga9b99cc28b7c0282919f3039d8d60e168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the interrupt service option, which can configure the driver so that it services only a single interrupt at a time when an interrupt occurs, or services all pending interrupts when an interrupt occurs.  <a href="#ga9b99cc28b7c0282919f3039d8d60e168">More...</a><br/></td></tr>
<tr class="separator:ga9b99cc28b7c0282919f3039d8d60e168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55e07c2159c0c0b469503bfac8e20b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gab55e07c2159c0c0b469503bfac8e20b0">XIOModule_RegisterHandler</a> (UINTPTR BaseAddress, s32 InterruptId, XInterruptHandler Handler, void *CallBackRef)</td></tr>
<tr class="memdesc:gab55e07c2159c0c0b469503bfac8e20b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a handler function for a specific interrupt ID.  <a href="#gab55e07c2159c0c0b469503bfac8e20b0">More...</a><br/></td></tr>
<tr class="separator:gab55e07c2159c0c0b469503bfac8e20b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e89f42ede1324eaf70720f6db6783b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga6e89f42ede1324eaf70720f6db6783b4">XIOModule_SendByte</a> (UINTPTR BaseAddress, u8 Data)</td></tr>
<tr class="memdesc:ga6e89f42ede1324eaf70720f6db6783b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions sends a single byte using the UART.  <a href="#ga6e89f42ede1324eaf70720f6db6783b4">More...</a><br/></td></tr>
<tr class="separator:ga6e89f42ede1324eaf70720f6db6783b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5eea17f7c7533affa36870f94f6299"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gaae5eea17f7c7533affa36870f94f6299">XIOModule_RecvByte</a> (UINTPTR BaseAddress)</td></tr>
<tr class="memdesc:gaae5eea17f7c7533affa36870f94f6299"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions receives a single byte using the UART.  <a href="#gaae5eea17f7c7533affa36870f94f6299">More...</a><br/></td></tr>
<tr class="separator:gaae5eea17f7c7533affa36870f94f6299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gafab2167a879586e6baa45e8706ed6a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#gafab2167a879586e6baa45e8706ed6a6a">XIOModule_ConfigTable</a> [XPAR_XIOMODULE_NUM_INSTANCES]</td></tr>
<tr class="memdesc:gafab2167a879586e6baa45e8706ed6a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each iomodule device in the system.  <a href="#gafab2167a879586e6baa45e8706ed6a6a">More...</a><br/></td></tr>
<tr class="separator:gafab2167a879586e6baa45e8706ed6a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b86656d30db376521bc3f4b63985499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iomodule.html#ga9b86656d30db376521bc3f4b63985499">XIOModule_ConfigTable</a> []</td></tr>
<tr class="memdesc:ga9b86656d30db376521bc3f4b63985499"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each iomodule device in the system.  <a href="#ga9b86656d30db376521bc3f4b63985499">More...</a><br/></td></tr>
<tr class="separator:ga9b86656d30db376521bc3f4b63985499"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac3f5aa29d205f6221a017a04712c65f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_AckIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">AckMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XIomodule_Out32((BaseAddress) + XIN_IAR_OFFSET, (AckMask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge specific interrupt(s) in the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">AckMask</td><td>is the 32-bit value to write to the acknowledge register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will acknowledge interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__iomodule.html#gac3f5aa29d205f6221a017a04712c65f0" title="Acknowledge specific interrupt(s) in the interrupt controller. ">XIOModule_AckIntr(UINTPTR BaseAddress, u32 AckMask)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__iomodule.html#ga2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf77d72d553f17c2696ce54e3149f0d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_DisableIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DisableMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XIomodule_Out32((BaseAddress) + XIN_IER_OFFSET, ~(DisableMask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable specific interrupt(s) in the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">DisableMask</td><td>is the 32-bit value to write to enable register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only bits which are set in the mask will disable interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void XIOModule_DisableIntr(UINTPTR BaseAddress, u32 DisableMask); </dd></dl>

</div>
</div>
<a class="anchor" id="ga230620599fe987b03b47e6d04a442e60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_EnableIntr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EnableMask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XIomodule_Out32((BaseAddress) + XIN_IER_OFFSET, (EnableMask))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable specific interrupt(s) in the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">EnableMask</td><td>is the 32-bit value to write to the enable register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will enable interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void XIOModule_EnableIntr(UINTPTR BaseAddress, u32 EnableMask); </dd></dl>

<p>Referenced by <a class="el" href="xiomodule__low__level__example_8c.html#a5f633edf662a9a5739da85d4b21a5c5c">IOModuleLowLevelExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga128f261df0c50d6e1b090e2a9e9d1874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_GetIntrStatus</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;(XIomodule_In32((BaseAddress) + XIN_IPR_OFFSET))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interrupt status from the interrupt controller which indicates which interrupts are active and enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit contents of the interrupt status register. Each bit corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Bits which are set indicate an active interrupt which is also enabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__iomodule.html#ga128f261df0c50d6e1b090e2a9e9d1874" title="Get the interrupt status from the interrupt controller which indicates which interrupts are active an...">XIOModule_GetIntrStatus(UINTPTR BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__iomodule.html#ga2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga313c2576e159fd472cb0b25b7a395837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_GetStatusReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td>&#160;&#160;&#160;XIomodule_In32((BaseAddress) + XUL_STATUS_REG_OFFSET)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the contents of the UART status register. </p>
<p>Use the XUL_SR_* constants defined above to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the status register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: u32 <a class="el" href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837" title="Get the contents of the UART status register. ">XIOModule_GetStatusReg(UINTPTR BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__iomodule.html#ga70b12729029fff571ad8915dc30897d6">XIOModule_ReceiveBuffer()</a>, <a class="el" href="group__iomodule.html#ga1fc16de9c0cbaad1d3022d19a0d883cd">XIOModule_SendBuffer()</a>, and <a class="el" href="group__iomodule.html#gacf2a67095f9797403f5c269fdcd7a6b2">XIOModule_Uart_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gad9c5e48a02c0aba03cb1d8d7583b37f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_IsReceiveEmpty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>((BaseAddress)) &amp; XUL_SR_RX_FIFO_VALID_DATA) != \</div>
<div class="line">        XUL_SR_RX_FIFO_VALID_DATA)</div>
<div class="ttc" id="group__iomodule_html_ga313c2576e159fd472cb0b25b7a395837"><div class="ttname"><a href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a></div><div class="ttdeci">#define XIOModule_GetStatusReg(BaseAddress)</div><div class="ttdoc">Get the contents of the UART status register. </div><div class="ttdef"><b>Definition:</b> xiomodule_l.h:327</div></div>
</div><!-- fragment -->
<p>Check to see if the UART receiver has data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the receiver is empty, FALSE if there is data present.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: int <a class="el" href="group__iomodule.html#gad9c5e48a02c0aba03cb1d8d7583b37f6" title="Check to see if the UART receiver has data. ">XIOModule_IsReceiveEmpty(UINTPTR BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__iomodule.html#gaae5eea17f7c7533affa36870f94f6299">XIOModule_RecvByte()</a>.</p>

</div>
</div>
<a class="anchor" id="ga93c23372164e627f79da9488ea43161a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_IsTransmitFull</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>((BaseAddress)) &amp; XUL_SR_TX_FIFO_FULL) == \</div>
<div class="line">          XUL_SR_TX_FIFO_FULL)</div>
<div class="ttc" id="group__iomodule_html_ga313c2576e159fd472cb0b25b7a395837"><div class="ttname"><a href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a></div><div class="ttdeci">#define XIOModule_GetStatusReg(BaseAddress)</div><div class="ttdoc">Get the contents of the UART status register. </div><div class="ttdef"><b>Definition:</b> xiomodule_l.h:327</div></div>
</div><!-- fragment -->
<p>Check to see if the transmitter is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the transmitter is full, FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style Signature: int <a class="el" href="group__iomodule.html#ga93c23372164e627f79da9488ea43161a" title="Check to see if the transmitter is full. ">XIOModule_IsTransmitFull(UINTPTR BaseAddress)</a>; </dd></dl>

<p>Referenced by <a class="el" href="group__iomodule.html#ga6e89f42ede1324eaf70720f6db6783b4">XIOModule_SendByte()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4eaff234e65f369a870fca3b92215df4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XIomodule_In32((BaseAddress) + (RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a value from a GPI register. </p>
<p>A 32 bit read is performed. If the GPI component is implemented in a smaller width, only the least significant data is read from the register. The most significant data will be read as 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the GPI device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset from the base to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data read from the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__iomodule.html#ga4eaff234e65f369a870fca3b92215df4" title="Read a value from a GPI register. ">XIOModule_ReadReg(UINTPTR BaseAddress, unsigned RegOffset)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__iomodule.html#ga87f83bf4cf53aa0e4f972688cb3e4aed">XIOModule_DiscreteRead()</a>, <a class="el" href="group__iomodule.html#ga826357a58aeda0b2d1bfc42efd6bb94c">XIOModule_GetValue()</a>, <a class="el" href="group__iomodule.html#ga404ac6ebc7137131bf0d277256c07605">XIOModule_IsExpired()</a>, <a class="el" href="group__iomodule.html#ga0e055e6172c30e7acbfde08aeed10fa1">XIOModule_IsSending()</a>, <a class="el" href="group__iomodule.html#ga70b12729029fff571ad8915dc30897d6">XIOModule_ReceiveBuffer()</a>, and <a class="el" href="group__iomodule.html#ga431eb19a0f6aeab9bab0cdb09fdc30ce">XIOModule_Timer_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga71f9336a3492b8501e09d3a87e2d661a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_UpdateStats</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">StatusRegister&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                       \</div>
<div class="line">        if ((StatusRegister) &amp; XUL_SR_OVERRUN_ERROR)                    \</div>
<div class="line">        {                                                               \</div>
<div class="line">                (InstancePtr)-&gt;Uart_Stats.ReceiveOverrunErrors++;       \</div>
<div class="line">        }                                                               \</div>
<div class="line">        if ((StatusRegister) &amp; XUL_SR_PARITY_ERROR)                     \</div>
<div class="line">        {                                                               \</div>
<div class="line">                (InstancePtr)-&gt;Uart_Stats.ReceiveParityErrors++;        \</div>
<div class="line">        }                                                               \</div>
<div class="line">        if ((StatusRegister) &amp; XUL_SR_FRAMING_ERROR)                    \</div>
<div class="line">        {                                                               \</div>
<div class="line">                (InstancePtr)-&gt;Uart_Stats.ReceiveFramingErrors++;       \</div>
<div class="line">        }                                                               \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Update the statistics of the instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XIOMOdule instance. </td></tr>
    <tr><td class="paramname">StatusRegister</td><td>contains the contents of the UART status register to update the statistics with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Signature: void XIOModule_UpdateStats(<a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> *InstancePtr, u32 StatusRegister) </p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga70b12729029fff571ad8915dc30897d6">XIOModule_ReceiveBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga829c77e3efe996211599f9a2a6bb4890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XIomodule_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a value to a GPO register. </p>
<p>A 32 bit write is performed. If the GPO component is implemented in a smaller width, only the least significant data is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the GPO device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>is the register offset from the base to write to. </td></tr>
    <tr><td class="paramname">Data</td><td>is the data written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void XIOModule_WriteReg(UINTPTR BaseAddress, unsigned RegOffset, u32 Data) </dd></dl>

<p>Referenced by <a class="el" href="group__iomodule.html#ga4aa314f25c8472dceb0e9021ca8d7b10">XIOModule_DiscreteClear()</a>, <a class="el" href="group__iomodule.html#gad52755c9c41e1753703652d7a9c879fa">XIOModule_DiscreteSet()</a>, <a class="el" href="group__iomodule.html#ga4876348e378f8b97bdc59b7cfd5b6b8b">XIOModule_DiscreteWrite()</a>, <a class="el" href="group__iomodule.html#gae5d1cb85ee2100003b7e2dcc160c47c0">XIOModule_Reset()</a>, <a class="el" href="group__iomodule.html#ga1fc16de9c0cbaad1d3022d19a0d883cd">XIOModule_SendBuffer()</a>, <a class="el" href="group__iomodule.html#gaed5ebecb3c051addf25c38216b08069a">XIOModule_SetBaudRate()</a>, <a class="el" href="group__iomodule.html#gaf9ed2111d2f53ac88626030d907f374a">XIOModule_SetResetValue()</a>, <a class="el" href="group__iomodule.html#ga8d32b770ba1aa2fda3d1bb389777212b">XIOModule_Timer_Initialize()</a>, <a class="el" href="group__iomodule.html#ga431eb19a0f6aeab9bab0cdb09fdc30ce">XIOModule_Timer_InterruptHandler()</a>, <a class="el" href="group__iomodule.html#ga719529740fbb19c3ce7d44078a2edcc1">XIOModule_Timer_SetOptions()</a>, <a class="el" href="group__iomodule.html#ga622c3a5cd4e43543cfb445071d01e7a9">XIOModule_Timer_Start()</a>, and <a class="el" href="group__iomodule.html#ga60bd9ef270b0de7440206326ec1fe710">XIOModule_Timer_Stop()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga40a7295554b9483f28c0f004b0c53302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XIOModule_Handler)(void *CallBackRef, unsigned int ByteCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function. </p>
<p>The first argument is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. The second argument is the ByteCount which is the number of bytes that actually moved from/to the buffer provided in the _Send/_Receive call. </p>

</div>
</div>
<a class="anchor" id="ga3a95e8a205259686d85802168e10cdb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XIOModule_Timer_Handler)(void *CallBackRef, u8 TimerNumber)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for the timer callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver, so it is a void pointer. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the number of the timer within the device. The device typically contains from one to four timers. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae50d24ec7a10fc2b3167d5f3a6070107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModel_Timer_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the options for the specified timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer of the device to operate on Each device may contain multiple timer. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>The currently set options. An option which is set to a '1' is enabled and set to a '0' is disabled. The options are bit masks such that multiple options may be set or cleared. The options are described in <a class="el" href="xiomodule_8h.html">xiomodule.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#a87d8836bb3fa194998a6ee74364c6bc3">XIOModule::CurrentTCSR</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ga036018140fd9f14af05eec37b3cb2e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Acknowledge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledges the interrupt source provided as the argument Id. </p>
<p>When the interrupt is acknowledged, it causes the interrupt controller to clear its interrupt condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gaff025dd804b08ec80047b8b17273da84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> *&#160;</td>
          <td class="paramname"><em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </p>
<p>This function disables the UART interrupts. The baud rate and format of the data are fixed in the hardware at hardware build time, except if programmable baud rate is selected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">Config</td><td>is a reference to a structure containing information about a specific IO Module device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device register base address. Use Config-&gt;BaseAddress for this parameters, passing the physical address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if everything starts up as expected.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Config and EffectiveAddress arguments are not used by this function, but are provided to keep the function signature consistent with other drivers. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module___buffer.html#a50853264e2e15f5714c35c69e3044110">XIOModule_Buffer::NextBytePtr</a>, <a class="el" href="struct_x_i_o_module.html#a9779459fb73d4db975bdf4d112d63408">XIOModule::ReceiveBuffer</a>, <a class="el" href="struct_x_i_o_module.html#a7d242c9d237f263e9b895b57c827b728">XIOModule::RecvHandler</a>, <a class="el" href="struct_x_i_o_module___buffer.html#af9c6e265f52ba355d454e0b29983889e">XIOModule_Buffer::RemainingBytes</a>, <a class="el" href="struct_x_i_o_module___buffer.html#ad1d8239c6072600ea84bbbf16b6d59fb">XIOModule_Buffer::RequestedBytes</a>, <a class="el" href="struct_x_i_o_module.html#ab43b4d33329f1d1c7685f0123dc37588">XIOModule::SendBuffer</a>, <a class="el" href="struct_x_i_o_module.html#a900c8563fc749f2cb97e5c0bbf1c7af7">XIOModule::SendHandler</a>, and <a class="el" href="group__iomodule.html#ga61a582e9785291f7c6e0b91c19c46bd8">XIOModule_ClearStats()</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga81cf0087aeb46a8a78030e964e743314">XIOModule_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga61a582e9785291f7c6e0b91c19c46bd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function zeros the statistics for the given instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module___uart___stats.html#a6007db24145bcd77eea843689a894999">XIOModule_Uart_Stats::CharactersReceived</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a0e5ff03c225123a482235e43ba8b60f0">XIOModule_Uart_Stats::CharactersTransmitted</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#af4fe5a6370521fcd8eb7cad5644f84a1">XIOModule_Uart_Stats::ReceiveFramingErrors</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a129217276becb44353a60f4d4dafb1c7">XIOModule_Uart_Stats::ReceiveInterrupts</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a8c4abe366c5215270523d5df0d9e1b71">XIOModule_Uart_Stats::ReceiveOverrunErrors</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a8c46d3426903c6709de209550b6286c3">XIOModule_Uart_Stats::ReceiveParityErrors</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#ad2939bb3e9f8fc089a2b0168425b4369">XIOModule_Uart_Stats::TransmitInterrupts</a>, and <a class="el" href="struct_x_i_o_module.html#a012d912c3ca44ef12ff3e9877950912d">XIOModule::Uart_Stats</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#gaff025dd804b08ec80047b8b17273da84">XIOModule_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga437b891061d1b16758b5e104e7535e6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XInterruptHandler&#160;</td>
          <td class="paramname"><em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized. </p>
<p>The argument provided in this call as the Callbackref is used as the argument for the handler when it is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt. </td></tr>
    <tr><td class="paramname">Handler</td><td>to the handler for that interrupt. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the callback reference, usually the instance pointer of the connecting driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the handler was connected correctly.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only used with normal interrupt mode. Does not restore normal interrupt mode.</dd></dl>
<p>WARNING: The handler provided as an argument will overwrite any handler that was previously connected. </p>

<p>References <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a6b66994a547223b1df1886a49562b2a7">XIOModule_VectorTableEntry::CallBackRef</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a48dc3684c70bd12fd9a1fd46c604750a">XIOModule_VectorTableEntry::Handler</a>, <a class="el" href="struct_x_i_o_module___config.html#afcb02fbe1f9b90712964890a1429373d">XIOModule_Config::HandlerTable</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gab8717545acaa871a5d9ed89702f9173c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_ConnectFastHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XFastInterruptHandler&#160;</td>
          <td class="paramname"><em>Handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt. </td></tr>
    <tr><td class="paramname">Handler</td><td>to the handler for that interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the handler was connected correctly.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only used with fast interrupt mode.</dd></dl>
<p>WARNING: The handler provided as an argument will overwrite any handler that was previously connected. </p>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a6b66994a547223b1df1886a49562b2a7">XIOModule_VectorTableEntry::CallBackRef</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module.html#a23dc644971604b9b25ac2e217126de5e">XIOModule::CurrentIMR</a>, <a class="el" href="struct_x_i_o_module___config.html#aeca1391618560858c7824ad421da3ff7">XIOModule_Config::FastIntr</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a48dc3684c70bd12fd9a1fd46c604750a">XIOModule_VectorTableEntry::Handler</a>, <a class="el" href="struct_x_i_o_module___config.html#afcb02fbe1f9b90712964890a1429373d">XIOModule_Config::HandlerTable</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="struct_x_i_o_module___config.html#a3c499ae690e4c97d6b166dc686da484e">XIOModule_Config::VectorAddrWidth</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e47bfda481c3ceab60d758f049758ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_DeviceInterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the primary interrupt handler for the driver. </p>
<p>It must be connected to the interrupt source such that is called when an interrupt of the interrupt controller is active. It will resolve which interrupts are active and enabled and call the appropriate interrupt handler. It uses the AckBeforeService flag in the configuration data to determine when to acknowledge the interrupt. Highest priority interrupts are serviced first. The driver can be configured to service only the highest priority interrupt or all pending interrupts using the {<a class="el" href="group__iomodule.html#ga41be199efc8ca8c8d883c5fae98517d6" title="Set the options for the interrupt controller driver. ">XIOModule_SetOptions()</a>} function or the {XIOModule_SetIntrSrvOption()} function.</p>
<p>This function assumes that an interrupt vector table has been previously initialized. It does not verify that entries in the table are valid before calling an interrupt handler, except skipping null handlers that indicate use of fast interrupts where the hardware directly jumps to the handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the zero-based device ID defined in xparameters.h of the interrupting interrupt controller. It is used as a direct index into the configuration data, which contains the vector table for the interrupt controller. Note that even though the argument is a void pointer, the value is not a pointer but the actual device ID. The void pointer type is necessary to meet the XInterruptHandler typedef for interrupt handlers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The constant XPAR_IOMODULE_MAX_INTR_SIZE must be setup for this to compile. Interrupt IDs range from 0 - 31 and correspond to the interrupt input signals for the interrupt controller. XPAR_IOMODULE_MAX_INTR_SIZE specifies the highest numbered interrupt input signal that is used. </p>

<p>References <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a6b66994a547223b1df1886a49562b2a7">XIOModule_VectorTableEntry::CallBackRef</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a48dc3684c70bd12fd9a1fd46c604750a">XIOModule_VectorTableEntry::Handler</a>, <a class="el" href="group__iomodule.html#gac3f5aa29d205f6221a017a04712c65f0">XIOModule_AckIntr</a>, <a class="el" href="group__iomodule.html#gafab2167a879586e6baa45e8706ed6a6a">XIOModule_ConfigTable</a>, <a class="el" href="group__iomodule.html#ga128f261df0c50d6e1b090e2a9e9d1874">XIOModule_GetIntrStatus</a>, and <a class="el" href="group__iomodule.html#ga367989ec098fe548ba62b58640490ec7">XIOModule_LookupConfig()</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#ad5cc5121d53068e10cc77ae24c6423fc">IOModuleSetupIntrSystem()</a>, and <a class="el" href="group__iomodule.html#ga848da9f83ad1188caca777cd324cec10">XIOModule_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ab631d859f9fc7b00f3c8367d763c49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the interrupt source provided as the argument Id such that the interrupt controller will not cause interrupts for the specified Id. </p>
<p>The interrupt controller will continue to hold an interrupt condition for the Id, but will not cause an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a86fc21e1458de7ebff30e9a959ecd773">IOModuleDisableIntr()</a>.</p>

</div>
</div>
<a class="anchor" id="ga241c2c08f867ee4d03e96248c4a133da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the interrupt table with the Null Handler and NULL arguments at the location pointed at by the Id. </p>
<p>This effectively disconnects that interrupt source from any handler. The interrupt is disabled also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a6b66994a547223b1df1886a49562b2a7">XIOModule_VectorTableEntry::CallBackRef</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a48dc3684c70bd12fd9a1fd46c604750a">XIOModule_VectorTableEntry::Handler</a>, <a class="el" href="struct_x_i_o_module___config.html#afcb02fbe1f9b90712964890a1429373d">XIOModule_Config::HandlerTable</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ga4aa314f25c8472dceb0e9021ca8d7b10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_DiscreteClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output discrete(s) to logic 0 for the specified GPO channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPIO (1, 2, 3 or 4) to operate on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the set of bits that will be set to 0 in the discrete data register. All other bits in the data register are unaffected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#ae52b176be0e933fa2a882feb0e6af143">XIOModule::GpoValue</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga87f83bf4cf53aa0e4f972688cb3e4aed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_DiscreteRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read state of discretes for the specified GPI channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPI (1, 2, 3 or 4) to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current copy of the discretes register. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="gad52755c9c41e1753703652d7a9c879fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_DiscreteSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output discrete(s) to logic 1 for the specified GPO channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPIO (1, 2, 3 or 4) to operate on. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the set of bits that will be set to 1 in the discrete data register. All other bits in the data register are unaffected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#ae52b176be0e933fa2a882feb0e6af143">XIOModule::GpoValue</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga4876348e378f8b97bdc59b7cfd5b6b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_DiscreteWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to discretes register for the specified GPO channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Channel</td><td>contains the channel of the GPO (1, 2, 3 or 4) to operate on. </td></tr>
    <tr><td class="paramname">Data</td><td>is the value to be written to the discretes register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#ae52b176be0e933fa2a882feb0e6af143">XIOModule::GpoValue</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c2fe0ab1367af43b603cd896e306737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the interrupt source provided as the argument Id. </p>
<p>Any pending interrupt condition for the specified Id will occur after this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a00da2c7ac8af84d3cc05ce7f41ad91a6">IOModuleIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4281a3f3f5e5620d4e78dc904ab04cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_GetCaptureValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the timer counter value that was captured the last time the external capture input was asserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current capture value for the indicated timer counter.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#a7cad21513e163c951f47dcc9b4b4a64f">XIOModule::CurrentTLR</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gab24288979ff867f5e8f98372bddda874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the currently set options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The currently set options. The options are described in <a class="el" href="xiomodule_8h.html">xiomodule.h</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="struct_x_i_o_module___config.html#af918e849ecf4c42ea56df244bde6f7e6">XIOModule_Config::Options</a>.</p>

</div>
</div>
<a class="anchor" id="ga42ada8bd0fb0d16976254c228a8924a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module___uart___stats.html">XIOModule_Uart_Stats</a> *&#160;</td>
          <td class="paramname"><em>StatsPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a snapshot of the current statistics in the structure specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">StatsPtr</td><td>is a pointer to a <a class="el" href="struct_x_i_o_module___uart___stats.html" title="Statistics for the UART. ">XIOModule_Uart_Stats</a> structure to where the statistics are to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module___uart___stats.html#a6007db24145bcd77eea843689a894999">XIOModule_Uart_Stats::CharactersReceived</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a0e5ff03c225123a482235e43ba8b60f0">XIOModule_Uart_Stats::CharactersTransmitted</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#af4fe5a6370521fcd8eb7cad5644f84a1">XIOModule_Uart_Stats::ReceiveFramingErrors</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a129217276becb44353a60f4d4dafb1c7">XIOModule_Uart_Stats::ReceiveInterrupts</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a8c4abe366c5215270523d5df0d9e1b71">XIOModule_Uart_Stats::ReceiveOverrunErrors</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a8c46d3426903c6709de209550b6286c3">XIOModule_Uart_Stats::ReceiveParityErrors</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#ad2939bb3e9f8fc089a2b0168425b4369">XIOModule_Uart_Stats::TransmitInterrupts</a>, and <a class="el" href="struct_x_i_o_module.html#a012d912c3ca44ef12ff3e9877950912d">XIOModule::Uart_Stats</a>.</p>

</div>
</div>
<a class="anchor" id="ga826357a58aeda0b2d1bfc42efd6bb94c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_GetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current value of the specified timer counter. </p>
<p>The timer counter may be either incrementing or decrementing based upon the current mode of operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current value for the timer counter.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#gae36785024a93e95d38c2b4e7552744aa">XIOModule_Timer_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga964f5bae2572929b40d1f630118e36ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_HandlerTable_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes all interrupt handlers to default handler for each interrupt ID. </p>
<p>It is necessary for the caller to connect the interrupt handler of this component to the proper interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a6b66994a547223b1df1886a49562b2a7">XIOModule_VectorTableEntry::CallBackRef</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a48dc3684c70bd12fd9a1fd46c604750a">XIOModule_VectorTableEntry::Handler</a>, and <a class="el" href="struct_x_i_o_module___config.html#afcb02fbe1f9b90712964890a1429373d">XIOModule_Config::HandlerTable</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga81cf0087aeb46a8a78030e964e743314">XIOModule_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga81cf0087aeb46a8a78030e964e743314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a specific interrupt controller instance/driver. </p>
<p>The initialization entails: </p>
<pre class="fragment">  - Initialize fields of the XIOModule structure
  - Initial vector table with stub function calls
  - All interrupt sources are disabled
  - Interrupt output is disabled
  - All timers are initialized
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">DeviceId</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started</li>
<li>XST_DEVICE_NOT_FOUND if device configuration information was not found for a device with the supplied device ID.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module___config.html#a96b1120954dbe1fdae2216fa85dac9a8">XIOModule_Config::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module___config.html#ae3d8ffe27a2dca77ef6ac33511f0c109">XIOModule_Config::BaseVector</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module.html#a23dc644971604b9b25ac2e217126de5e">XIOModule::CurrentIMR</a>, <a class="el" href="struct_x_i_o_module___config.html#aeca1391618560858c7824ad421da3ff7">XIOModule_Config::FastIntr</a>, <a class="el" href="struct_x_i_o_module___config.html#a3facc890f389449037d148efbdd8e989">XIOModule_Config::GpoInit</a>, <a class="el" href="struct_x_i_o_module.html#ae52b176be0e933fa2a882feb0e6af143">XIOModule::GpoValue</a>, <a class="el" href="struct_x_i_o_module___config.html#a77ca517b4e792e99d350b41676967abd">XIOModule_Config::IoBaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#ad7e23291bb2fd05ef464f8ee3f446076">XIOModule::IoBaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module.html#abf03d83df86afa14879087ed5f792d9d">XIOModule::IsStarted</a>, <a class="el" href="struct_x_i_o_module___config.html#af918e849ecf4c42ea56df244bde6f7e6">XIOModule_Config::Options</a>, <a class="el" href="struct_x_i_o_module___config.html#a3c499ae690e4c97d6b166dc686da484e">XIOModule_Config::VectorAddrWidth</a>, <a class="el" href="group__iomodule.html#gaff025dd804b08ec80047b8b17273da84">XIOModule_CfgInitialize()</a>, <a class="el" href="group__iomodule.html#ga964f5bae2572929b40d1f630118e36ac">XIOModule_HandlerTable_Initialize()</a>, <a class="el" href="group__iomodule.html#ga367989ec098fe548ba62b58640490ec7">XIOModule_LookupConfig()</a>, and <a class="el" href="group__iomodule.html#ga8d32b770ba1aa2fda3d1bb389777212b">XIOModule_Timer_Initialize()</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a236881c9f534439dd82b030f163d4490">IOModuleInterruptSetup()</a>, <a class="el" href="xiomodule__intr__example_8c.html#a00da2c7ac8af84d3cc05ce7f41ad91a6">IOModuleIntrExample()</a>, and <a class="el" href="xiomodule__selftest__example_8c.html#a2257c4e318cd4d8fc7dd42cbdd607025">IOModuleSelfTestExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gaadbc5225c2c104a1a09d226e6daf3497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_Intc_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a self-test on the interrupt controller driver/device. </p>
<p>This is a destructive test.</p>
<p>This involves forcing interrupts into the controller (if possible, given the IO Module configuration) and verifying that they are recognized and can be acknowledged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if self-test is successful.</li>
<li>XST_INTC_FAIL_SELFTEST if the Interrupt controller fails the self-test. It will fail the self test if the device has previously been started in real mode.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga4a295427c84e3c7f0cee3440ba119093">XIOModule_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga848da9f83ad1188caca777cd324cec10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The interrupt handler for the driver. </p>
<p>This function is provided mostly for backward compatibility. The user should use <a class="el" href="group__iomodule.html#ga2e47bfda481c3ceab60d758f049758ef" title="This function is the primary interrupt handler for the driver. ">XIOModule_DeviceInterruptHandler()</a>, defined in <a class="el" href="xiomodule__l_8c.html">xiomodule_l.c</a> when possible and pass the device ID of the interrupt controller device as its argument.</p>
<p>The user must connect this function to the interrupt system such that it is called whenever the devices which are connected to it cause an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module___config.html#a96b1120954dbe1fdae2216fa85dac9a8">XIOModule_Config::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module___config.html#a810c8e527dc561b0591c40ee8da5e8d5">XIOModule_Config::DeviceId</a>, and <a class="el" href="group__iomodule.html#ga2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5ec0ed139e0e9629ec1b542dfec3989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XIOModule_IoReadByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read byte from the IO Bus memory mapped IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">ByteOffset</td><td>is a byte offset from the beginning of the IO Bus address area</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read from the IO Bus - 8-bit byte </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ad7e23291bb2fd05ef464f8ee3f446076">XIOModule::IoBaseAddress</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ff8a4fabcb27bc42957503761602439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XIOModule_IoReadHalfword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 16-bit halfword from the IO Bus memory mapped IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">ByteOffset</td><td>is a byte offset from the beginning of the IO Bus address area</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read from the IO Bus - 16-bit halfword </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ad7e23291bb2fd05ef464f8ee3f446076">XIOModule::IoBaseAddress</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ga9939789b5819d1561bebc0eacac28b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_IoReadWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 32-bit word from the IO Bus memory mapped IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">ByteOffset</td><td>is a byte offset from the beginning of the IO Bus address area</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value read from the IO Bus - 32-bit word </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ad7e23291bb2fd05ef464f8ee3f446076">XIOModule::IoBaseAddress</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gaae3b81b7f7e0ebf69c951b2fcf438e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_IoWriteByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 8-bit word to the IO Bus memory mapped IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">ByteOffset</td><td>is a byte offset from the beginning of the IO Bus address area </td></tr>
    <tr><td class="paramname">Data</td><td>is the value to be written to the IO Bus - 8-bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ad7e23291bb2fd05ef464f8ee3f446076">XIOModule::IoBaseAddress</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c9d9b8fc1d9accc3502b24db3770664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_IoWriteHalfword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 16-bit word to the IO Bus memory mapped IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">ByteOffset</td><td>is a byte offset from the beginning of the IO Bus address area </td></tr>
    <tr><td class="paramname">Data</td><td>is the value to be written to the IO Bus - 16-bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ad7e23291bb2fd05ef464f8ee3f446076">XIOModule::IoBaseAddress</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gaf20cdadbf9d5197fd91076a76b7049f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_IoWriteWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 32-bit word to the IO Bus memory mapped IO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">ByteOffset</td><td>is a byte offset from the beginning of the IO Bus address area </td></tr>
    <tr><td class="paramname">Data</td><td>is the value to be written to the IO Bus - 32-bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ad7e23291bb2fd05ef464f8ee3f446076">XIOModule::IoBaseAddress</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ga404ac6ebc7137131bf0d277256c07605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_IsExpired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the specified timer counter of the device has expired. </p>
<p>In capture mode, expired is defined as a capture occurred. In compare mode, expired is defined as the timer counter rolled over/under for up/down counting.</p>
<p>When interrupts are enabled, the expiration causes an interrupt. This function is typically used to poll a timer counter to determine when it has expired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the timer has expired, and FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#a87d8836bb3fa194998a6ee74364c6bc3">XIOModule::CurrentTCSR</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module___config.html#a3ada4c4c2e16a8061c5bb91cd15841b4">XIOModule_Config::PitMask</a>, <a class="el" href="struct_x_i_o_module___config.html#ae298eeffae861524bf2c6c28bff619fb">XIOModule_Config::PitReadable</a>, and <a class="el" href="group__iomodule.html#ga4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a3aa1ae68bdc720a276454934186b78ab">IOModuleHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e055e6172c30e7acbfde08aeed10fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_IsSending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines if the specified UART is sending data. </p>
<p>If the transmitter register is not empty, it is sending data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value of TRUE if the UART is sending data, otherwise FALSE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, and <a class="el" href="group__iomodule.html#ga4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga367989ec098fe548ba62b58640490ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> * XIOModule_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the device configuration based on the unique device ID. </p>
<p>A table contains the configuration info for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the unique identifier for a device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> configuration structure for the specified device, or NULL if the device was not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__iomodule.html#gafab2167a879586e6baa45e8706ed6a6a">XIOModule_ConfigTable</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a>, <a class="el" href="group__iomodule.html#ga81cf0087aeb46a8a78030e964e743314">XIOModule_Initialize()</a>, and <a class="el" href="group__iomodule.html#ga8d32b770ba1aa2fda3d1bb389777212b">XIOModule_Timer_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga70b12729029fff571ad8915dc30897d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XIOModule_ReceiveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function receives a buffer that has been previously specified by setting up the instance variables of the instance. </p>
<p>This function is designed to be an internal function for the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> component such that it may be called from a shell function that sets up the buffer or from an interrupt handler.</p>
<p>This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if there is no data has already received by the UART.</p>
<p>In a polled mode, this function will only receive as much data as the UART can buffer, either in the receiver or in the FIFO if present and enabled. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.</p>
<p>In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a6007db24145bcd77eea843689a894999">XIOModule_Uart_Stats::CharactersReceived</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module___buffer.html#a50853264e2e15f5714c35c69e3044110">XIOModule_Buffer::NextBytePtr</a>, <a class="el" href="struct_x_i_o_module.html#a9779459fb73d4db975bdf4d112d63408">XIOModule::ReceiveBuffer</a>, <a class="el" href="struct_x_i_o_module___buffer.html#af9c6e265f52ba355d454e0b29983889e">XIOModule_Buffer::RemainingBytes</a>, <a class="el" href="struct_x_i_o_module.html#a012d912c3ca44ef12ff3e9877950912d">XIOModule::Uart_Stats</a>, <a class="el" href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>, <a class="el" href="group__iomodule.html#ga4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg</a>, and <a class="el" href="group__iomodule.html#ga71f9336a3492b8501e09d3a87e2d661a">XIOModule_UpdateStats</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga3840262ec8f698849bf0bba791c978a8">XIOModule_Recv()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3840262ec8f698849bf0bba791c978a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_Recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>NumBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. </p>
<p>This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if no data has already received by the UART.</p>
<p>In a polled mode, this function will only receive as much data as the UART can buffer in the receiver. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.</p>
<p>In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue receiving data until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">DataBufferPtr</td><td>is pointer to buffer for data to be received into. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is the number of bytes to be received. A value of zero will stop a previous receive operation that is in progress in interrupt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module___buffer.html#a50853264e2e15f5714c35c69e3044110">XIOModule_Buffer::NextBytePtr</a>, <a class="el" href="struct_x_i_o_module.html#a9779459fb73d4db975bdf4d112d63408">XIOModule::ReceiveBuffer</a>, <a class="el" href="struct_x_i_o_module___buffer.html#af9c6e265f52ba355d454e0b29983889e">XIOModule_Buffer::RemainingBytes</a>, <a class="el" href="struct_x_i_o_module___buffer.html#ad1d8239c6072600ea84bbbf16b6d59fb">XIOModule_Buffer::RequestedBytes</a>, and <a class="el" href="group__iomodule.html#ga70b12729029fff571ad8915dc30897d6">XIOModule_ReceiveBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaae5eea17f7c7533affa36870f94f6299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XIOModule_RecvByte </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions receives a single byte using the UART. </p>
<p>It is blocking in that it waits for the receiver to become non-empty before it reads from the receive register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte of data received.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__iomodule.html#gad9c5e48a02c0aba03cb1d8d7583b37f6">XIOModule_IsReceiveEmpty</a>.</p>

</div>
</div>
<a class="anchor" id="gab55e07c2159c0c0b469503bfac8e20b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_RegisterHandler </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>InterruptId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XInterruptHandler&#160;</td>
          <td class="paramname"><em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a handler function for a specific interrupt ID. </p>
<p>The vector table of the interrupt controller is updated, overwriting any previous handler. The handler function will be called when an interrupt occurs for the given interrupt ID.</p>
<p>This function can also be used to remove a handler from the vector table by passing in the XIOModule_DefaultHandler() as the handler and NULL as the callback reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the interrupt controller whose vector table will be modified. </td></tr>
    <tr><td class="paramname">InterruptId</td><td>is the interrupt ID to be associated with the input handler. </td></tr>
    <tr><td class="paramname">Handler</td><td>is the function pointer that will be added to the vector table for the given interrupt ID. It adheres to the XInterruptHandler signature found in xbasic_types.h. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the argument that will be passed to the new handler function when it is called. This is user-specific.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only used with normal interrupt mode. Does not restore normal interrupt mode.</dd></dl>
<p>Note that this function has no effect if the input base address is invalid. </p>

<p>References <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a6b66994a547223b1df1886a49562b2a7">XIOModule_VectorTableEntry::CallBackRef</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a48dc3684c70bd12fd9a1fd46c604750a">XIOModule_VectorTableEntry::Handler</a>, and <a class="el" href="struct_x_i_o_module___config.html#afcb02fbe1f9b90712964890a1429373d">XIOModule_Config::HandlerTable</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__low__level__example_8c.html#a5f633edf662a9a5739da85d4b21a5c5c">IOModuleLowLevelExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gae5d1cb85ee2100003b7e2dcc160c47c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the specified timer counter of the device. </p>
<p>A reset causes the timer counter to set it's value to the reset value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a87d8836bb3fa194998a6ee74364c6bc3">XIOModule::CurrentTCSR</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gadabb5f2e09817afb284173f31f3d7265"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_ResetFifos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function does nothing, since the UART doesn't have any FIFOs. </p>
<p>It is included for compatibility with the UART Lite driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a295427c84e3c7f0cee3440ba119093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a self-test on the timer and interrupt controller driver/device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XIOMOdule instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if self-test was successful</li>
</ul>
</dd></dl>
<ul>
<li>XST_FAILURE if the timer is not incrementing.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This is a destructive test using the provided timer. The current settings of the timer are returned to the initialized values and all settings at the time this function is called are overwritten. </p>

<p>References <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module___config.html#a5c0381d3b8d1e99b208b782614f11f0d">XIOModule_Config::PitPrescaler</a>, <a class="el" href="struct_x_i_o_module___config.html#ae298eeffae861524bf2c6c28bff619fb">XIOModule_Config::PitReadable</a>, <a class="el" href="struct_x_i_o_module___config.html#afa1a7a766b5e49c877ef0a95f78a374f">XIOModule_Config::PitSize</a>, <a class="el" href="struct_x_i_o_module___config.html#a3ebe198577cb922a5427f7d1bb1764bd">XIOModule_Config::PitUsed</a>, <a class="el" href="group__iomodule.html#gaadbc5225c2c104a1a09d226e6daf3497">XIOModule_Intc_SelfTest()</a>, and <a class="el" href="group__iomodule.html#gae36785024a93e95d38c2b4e7552744aa">XIOModule_Timer_SelfTest()</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a236881c9f534439dd82b030f163d4490">IOModuleInterruptSetup()</a>, <a class="el" href="xiomodule__intr__example_8c.html#a00da2c7ac8af84d3cc05ce7f41ad91a6">IOModuleIntrExample()</a>, and <a class="el" href="xiomodule__selftest__example_8c.html#a2257c4e318cd4d8fc7dd42cbdd607025">IOModuleSelfTestExample()</a>.</p>

</div>
</div>
<a class="anchor" id="gabe2219bbd76d37299ef7e645133bd74f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>NumBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions sends the specified buffer of data using the UART in either polled or interrupt driven modes. </p>
<p>This function is non-blocking such that it will return before the data has been sent by the UART. If the UART is busy sending data, it will return and indicate zero bytes were sent.</p>
<p>In a polled mode, this function will only send as much data as the UART can buffer in the transmitter. The application may need to call it repeatedly to send a buffer.</p>
<p>In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue sending data until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">DataBufferPtr</td><td>is pointer to a buffer of data to be sent. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>contains the number of bytes to be sent. A value of zero will stop a previous send operation that is in progress in interrupt mode. Any data that was already put into the transmit FIFO will be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually sent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module___buffer.html#a50853264e2e15f5714c35c69e3044110">XIOModule_Buffer::NextBytePtr</a>, <a class="el" href="struct_x_i_o_module___buffer.html#af9c6e265f52ba355d454e0b29983889e">XIOModule_Buffer::RemainingBytes</a>, <a class="el" href="struct_x_i_o_module___buffer.html#ad1d8239c6072600ea84bbbf16b6d59fb">XIOModule_Buffer::RequestedBytes</a>, <a class="el" href="struct_x_i_o_module.html#ab43b4d33329f1d1c7685f0123dc37588">XIOModule::SendBuffer</a>, and <a class="el" href="group__iomodule.html#ga1fc16de9c0cbaad1d3022d19a0d883cd">XIOModule_SendBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1fc16de9c0cbaad1d3022d19a0d883cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XIOModule_SendBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends a buffer that has been previously specified by setting up the instance variables of the instance. </p>
<p>This function is designed to be an internal function for the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> component such that it may be called from a shell function that sets up the buffer or from an interrupt handler.</p>
<p>This function sends the specified buffer of data to the UART in either polled or interrupt driven modes. This function is non-blocking such that it will return before the data has been sent by the UART.</p>
<p>In a polled mode, this function will only send as much data as the UART can buffer in the transmitter. The application may need to call it repeatedly to send a buffer.</p>
<p>In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NumBytes is the number of bytes actually sent (put into the UART transmitter and/or FIFO).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module___uart___stats.html#a0e5ff03c225123a482235e43ba8b60f0">XIOModule_Uart_Stats::CharactersTransmitted</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module___buffer.html#a50853264e2e15f5714c35c69e3044110">XIOModule_Buffer::NextBytePtr</a>, <a class="el" href="struct_x_i_o_module___buffer.html#af9c6e265f52ba355d454e0b29983889e">XIOModule_Buffer::RemainingBytes</a>, <a class="el" href="struct_x_i_o_module.html#ab43b4d33329f1d1c7685f0123dc37588">XIOModule::SendBuffer</a>, <a class="el" href="struct_x_i_o_module.html#a012d912c3ca44ef12ff3e9877950912d">XIOModule::Uart_Stats</a>, <a class="el" href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#gabe2219bbd76d37299ef7e645133bd74f">XIOModule_Send()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e89f42ede1324eaf70720f6db6783b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SendByte </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions sends a single byte using the UART. </p>
<p>It is blocking in that it waits for the transmitter to become non-full before it writes the byte to the transmit register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device </td></tr>
    <tr><td class="paramname">Data</td><td>is the byte of data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__iomodule.html#ga93c23372164e627f79da9488ea43161a">XIOModule_IsTransmitFull</a>.</p>

</div>
</div>
<a class="anchor" id="gaed5ebecb3c051addf25c38216b08069a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_SetBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the baud rate for the specified UART. </p>
<p>Checks the input value for validity and also verifies that the requested rate can be configured to within the 3 percent error range for RS-232 communications. If the provided rate is not valid, the current setting is unchanged.</p>
<p>This function is designed to be an internal function only used within the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> component. It is necessary for initialization and for the user available function that sets the data format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">BaudRate</td><td>to be set in the hardware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if everything configures as expected<ul>
<li>XST_UART_BAUD_ERROR if the requested rate is not available because there was too much error due to the input clock</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module___config.html#a712c14652d2ff15fe02b91085dc302ad">XIOModule_Config::BaudRate</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#a40ef038a466867f27010e474e5e27aa2">XIOModule::CurrentUBRR</a>, <a class="el" href="struct_x_i_o_module___config.html#af0f55a923987c88258fa20e1e6e24fb3">XIOModule_Config::InputClockHz</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gab2e5ac3f9e5a286fd376120cb27f545d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iomodule.html#ga3a95e8a205259686d85802168e10cdb3">XIOModule_Timer_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timer callback function, which the driver calls when the specified timer times out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The handler is called within interrupt context so the function that is called should either be short or pass the more extensive processing off to another task to allow the interrupt to return and normal processing to continue.</p>
<p>This function is provided for compatibility, and only allows setting a single handler for all Programmable Interval Timers. </p>

<p>References <a class="el" href="struct_x_i_o_module.html#a8b9fe4734807b32893f78a90e8c6a9de">XIOModule::CallBackRef</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a48dc3684c70bd12fd9a1fd46c604750a">XIOModule_VectorTableEntry::Handler</a>, <a class="el" href="struct_x_i_o_module.html#aab92470605904d886037b7dc51b87dec">XIOModule::Handler</a>, <a class="el" href="struct_x_i_o_module___config.html#afcb02fbe1f9b90712964890a1429373d">XIOModule_Config::HandlerTable</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga431eb19a0f6aeab9bab0cdb09fdc30ce">XIOModule_Timer_InterruptHandler()</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a00da2c7ac8af84d3cc05ce7f41ad91a6">IOModuleIntrExample()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b99cc28b7c0282919f3039d8d60e168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetIntrSvcOption </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>Option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the interrupt service option, which can configure the driver so that it services only a single interrupt at a time when an interrupt occurs, or services all pending interrupts when an interrupt occurs. </p>
<p>The default behavior when using the driver interface given in xintc.h file is to service only a single interrupt, whereas the default behavior when using the driver interface given in this file is to service all outstanding interrupts when an interrupt occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the unique identifier for a device. </td></tr>
    <tr><td class="paramname">Option</td><td>is XIN_SVC_SGL_ISR_OPTION if you want only a single interrupt serviced when an interrupt occurs, or XIN_SVC_ALL_ISRS_OPTION if you want all pending interrupts serviced when an interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Note that this function has no effect if the input base address is invalid. </p>

<p>References <a class="el" href="struct_x_i_o_module___config.html#af918e849ecf4c42ea56df244bde6f7e6">XIOModule_Config::Options</a>.</p>

</div>
</div>
<a class="anchor" id="gab4ddcaf38d655ca70d916c1d5ba96240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetNormalIntrMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the normal interrupt mode for the specified interrupt in the Interrupt Mode Register, by resetting the vector to (BaseVector &amp; 0xFFFFFF80) | 0x10 and selecting normal mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">Id</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only used with fast interrupt mode. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module___config.html#ae3d8ffe27a2dca77ef6ac33511f0c109">XIOModule_Config::BaseVector</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a6b66994a547223b1df1886a49562b2a7">XIOModule_VectorTableEntry::CallBackRef</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, <a class="el" href="struct_x_i_o_module.html#a23dc644971604b9b25ac2e217126de5e">XIOModule::CurrentIMR</a>, <a class="el" href="struct_x_i_o_module___config.html#aeca1391618560858c7824ad421da3ff7">XIOModule_Config::FastIntr</a>, <a class="el" href="struct_x_i_o_module___vector_table_entry.html#a48dc3684c70bd12fd9a1fd46c604750a">XIOModule_VectorTableEntry::Handler</a>, <a class="el" href="struct_x_i_o_module___config.html#afcb02fbe1f9b90712964890a1429373d">XIOModule_Config::HandlerTable</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="struct_x_i_o_module___config.html#a3c499ae690e4c97d6b166dc686da484e">XIOModule_Config::VectorAddrWidth</a>.</p>

</div>
</div>
<a class="anchor" id="ga41be199efc8ca8c8d883c5fae98517d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the options for the interrupt controller driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td class="paramname">Options</td><td>to be set. The available options are described in <a class="el" href="xiomodule_8h.html">xiomodule.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully</li>
<li>XST_INVALID_PARAM if the specified option was not valid</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="struct_x_i_o_module___config.html#af918e849ecf4c42ea56df244bde6f7e6">XIOModule_Config::Options</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ece62521d0d34bd420888ecc876750c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetRecvHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iomodule.html#ga40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART. </p>
<p>The purpose of the handler is to allow application specific processing to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module.html#aba9945a4a56cd7d80eddfeb72ec0fa3c">XIOModule::RecvCallBackRef</a>, and <a class="el" href="struct_x_i_o_module.html#a7d242c9d237f263e9b895b57c827b728">XIOModule::RecvHandler</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9ed2111d2f53ac88626030d907f374a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetResetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ResetValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reset value for the specified timer counter. </p>
<p>This is the value that is loaded into the timer counter when it is reset. This value is also loaded when the timer counter is started.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1). </td></tr>
    <tr><td class="paramname">ResetValue</td><td>contains the value to be used to reset the timer counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a7cad21513e163c951f47dcc9b4b4a64f">XIOModule::CurrentTLR</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a00da2c7ac8af84d3cc05ce7f41ad91a6">IOModuleIntrExample()</a>, and <a class="el" href="group__iomodule.html#gae36785024a93e95d38c2b4e7552744aa">XIOModule_Timer_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga07b376ebf11fee3ff027445eaa096261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetSendHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__iomodule.html#ga40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a>&#160;</td>
          <td class="paramname"><em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART. </p>
<p>The purpose of the handler is to allow application specific processing to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance . </td></tr>
    <tr><td class="paramname">FuncPtr</td><td>is the pointer to the callback function. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module.html#a1c7dd2691c80c532a0b2624a91c6b615">XIOModule::SendCallBackRef</a>, and <a class="el" href="struct_x_i_o_module.html#a900c8563fc749f2cb97e5c0bbf1c7af7">XIOModule::SendHandler</a>.</p>

</div>
</div>
<a class="anchor" id="ga2841593e6e312fefe9f190a75e11fdb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the IO Module. </p>
<p>Interrupts may be generated by the IO Module after this function is called.</p>
<p>It is necessary for the caller to connect the interrupt handler of this component to the proper interrupt source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the device was started successfully</li>
<li>XST_FAILURE if simulation mode was specified and it could not be set because real mode has already been entered.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Must be called after <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> initialization is completed. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="struct_x_i_o_module.html#abf03d83df86afa14879087ed5f792d9d">XIOModule::IsStarted</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a236881c9f534439dd82b030f163d4490">IOModuleInterruptSetup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4cd1ece524eb5fd3d5d255027ad6a01a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the interrupt controller by disabling the output from the controller so that no interrupts will be caused by the interrupt controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="struct_x_i_o_module.html#abf03d83df86afa14879087ed5f792d9d">XIOModule::IsStarted</a>.</p>

</div>
</div>
<a class="anchor" id="ga8d32b770ba1aa2fda3d1bb389777212b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_Timer_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a specific timer instance/driver. </p>
<p>Initialize fields of the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> structure, then reset the timer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">DeviceId</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> component. Passing in a device id associates the generic <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> component to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started</li>
<li>XST_DEVICE_NOT_FOUND if the device doesn't exist</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module___config.html#a96b1120954dbe1fdae2216fa85dac9a8">XIOModule_Config::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a8b9fe4734807b32893f78a90e8c6a9de">XIOModule::CallBackRef</a>, <a class="el" href="struct_x_i_o_module.html#a87d8836bb3fa194998a6ee74364c6bc3">XIOModule::CurrentTCSR</a>, <a class="el" href="struct_x_i_o_module.html#a7cad21513e163c951f47dcc9b4b4a64f">XIOModule::CurrentTLR</a>, <a class="el" href="struct_x_i_o_module.html#aab92470605904d886037b7dc51b87dec">XIOModule::Handler</a>, <a class="el" href="struct_x_i_o_module___timer___stats.html#aeea5691ebbd34f15b36be34b1bcf5cc5">XIOModule_Timer_Stats::Interrupts</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module.html#ac6a8d39469df123710c1f280458dc417">XIOModule::Timer_Stats</a>, <a class="el" href="group__iomodule.html#ga367989ec098fe548ba62b58640490ec7">XIOModule_LookupConfig()</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga81cf0087aeb46a8a78030e964e743314">XIOModule_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga431eb19a0f6aeab9bab0cdb09fdc30ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt Service Routine (ISR) for the driver. </p>
<p>This function only performs processing for the Programmable Interval Timere and does not save and restore the interrupt context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>contains a pointer to the IO Module instance for the interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a8b9fe4734807b32893f78a90e8c6a9de">XIOModule::CallBackRef</a>, <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#a23dc644971604b9b25ac2e217126de5e">XIOModule::CurrentIMR</a>, <a class="el" href="struct_x_i_o_module.html#aab92470605904d886037b7dc51b87dec">XIOModule::Handler</a>, <a class="el" href="struct_x_i_o_module___timer___stats.html#aeea5691ebbd34f15b36be34b1bcf5cc5">XIOModule_Timer_Stats::Interrupts</a>, <a class="el" href="struct_x_i_o_module___config.html#a3ebe198577cb922a5427f7d1bb1764bd">XIOModule_Config::PitUsed</a>, <a class="el" href="struct_x_i_o_module.html#ac6a8d39469df123710c1f280458dc417">XIOModule::Timer_Stats</a>, <a class="el" href="group__iomodule.html#ga4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#gab2e5ac3f9e5a286fd376120cb27f545d">XIOModule_SetHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gae36785024a93e95d38c2b4e7552744aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XIOModule_Timer_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a self-test on the timer driver/device. </p>
<p>This test verifies that the specified programmable interval timer of the device can be enabled and increments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the XIOMOdule instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer of the device to operate on. Each device may contain multiple timers. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if self-test was successful</li>
</ul>
</dd></dl>
<ul>
<li>XST_FAILURE if the timer is not incrementing.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This is a destructive test using the provided timer. The current settings of the timer are returned to the initialized values and all settings at the time this function is called are overwritten. </p>

<p>References <a class="el" href="struct_x_i_o_module.html#ad44f07ede4a771acec5e5ae601868957">XIOModule::CfgPtr</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, <a class="el" href="struct_x_i_o_module___config.html#afa1a7a766b5e49c877ef0a95f78a374f">XIOModule_Config::PitSize</a>, <a class="el" href="group__iomodule.html#ga826357a58aeda0b2d1bfc42efd6bb94c">XIOModule_GetValue()</a>, <a class="el" href="group__iomodule.html#gaf9ed2111d2f53ac88626030d907f374a">XIOModule_SetResetValue()</a>, <a class="el" href="group__iomodule.html#ga719529740fbb19c3ce7d44078a2edcc1">XIOModule_Timer_SetOptions()</a>, <a class="el" href="group__iomodule.html#ga622c3a5cd4e43543cfb445071d01e7a9">XIOModule_Timer_Start()</a>, and <a class="el" href="group__iomodule.html#ga60bd9ef270b0de7440206326ec1fe710">XIOModule_Timer_Stop()</a>.</p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga4a295427c84e3c7f0cee3440ba119093">XIOModule_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga719529740fbb19c3ce7d44078a2edcc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the specified options for the specified timer . </p>
<p>This function sets the options without regard to the current options of the driver. To prevent a loss of the current options, the user should call XIOModule_Timer_GetOptions() prior to this function and modify the retrieved options to pass into this function to prevent loss of the current options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer of the device to operate on. Each device may contain multiple timers. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1). </td></tr>
    <tr><td class="paramname">Options</td><td>contains the desired options to be set or cleared. Setting the option to '1' enables the option, clearing the to '0' disables the option. The options are bit masks such that multiple options may be set or cleared. The options are described in <a class="el" href="xiomodule_8h.html">xiomodule.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a87d8836bb3fa194998a6ee74364c6bc3">XIOModule::CurrentTCSR</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a3aa1ae68bdc720a276454934186b78ab">IOModuleHandler()</a>, <a class="el" href="xiomodule__intr__example_8c.html#a00da2c7ac8af84d3cc05ce7f41ad91a6">IOModuleIntrExample()</a>, and <a class="el" href="group__iomodule.html#gae36785024a93e95d38c2b4e7552744aa">XIOModule_Timer_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga622c3a5cd4e43543cfb445071d01e7a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the specified timer counter of the device such that it starts running. </p>
<p>The timer counter is reset before it is started and the reset value is loaded into the timer counter.</p>
<p>If interrupt mode is specified in the options, it is necessary for the caller to connect the interrupt handler of the timer to the interrupt source, typically an interrupt controller, and enable the interrupt within the interrupt controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer of the device to operate on. Each device may contain multiple timers. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a87d8836bb3fa194998a6ee74364c6bc3">XIOModule::CurrentTCSR</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a00da2c7ac8af84d3cc05ce7f41ad91a6">IOModuleIntrExample()</a>, and <a class="el" href="group__iomodule.html#gae36785024a93e95d38c2b4e7552744aa">XIOModule_Timer_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga60bd9ef270b0de7440206326ec1fe710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>TimerNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the timer by disabling it. </p>
<p>It is the callers' responsibility to disconnect the interrupt handler of the timer from the interrupt source, typically an interrupt controller, and disable the interrupt within the interrupt controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance. </td></tr>
    <tr><td class="paramname">TimerNumber</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#a87d8836bb3fa194998a6ee74364c6bc3">XIOModule::CurrentTCSR</a>, <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>, and <a class="el" href="group__iomodule.html#ga829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xiomodule__intr__example_8c.html#a00da2c7ac8af84d3cc05ce7f41ad91a6">IOModuleIntrExample()</a>, and <a class="el" href="group__iomodule.html#gae36785024a93e95d38c2b4e7552744aa">XIOModule_Timer_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ec72d0dd352ad42de494821220e3185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_DisableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the UART interrupt. </p>
<p>After calling this function, data may still be received by the UART but no interrupt will be generated since the hardware device has no way to disable the receiver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gaa805a7f9982d9acc5b3b16849c5d2dfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_EnableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the UART interrupts such that an interrupt will occur when data is received or data has been transmitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module.html#aa587d9b5ceed79935fa1c5cf842531d8">XIOModule::CurrentIER</a>, and <a class="el" href="struct_x_i_o_module.html#a0cee7cfb4687662370f0900c9c0b31d0">XIOModule::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gacf2a67095f9797403f5c269fdcd7a6b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for the UART. </p>
<p>It must be connected to an interrupt system by the user such that it is called when an interrupt for any UART lite occurs. This function does not save or restore the processor context such that the user must ensure this occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>contains a pointer to the instance of the IOModule that the interrupt is for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_i_o_module.html#ae5c5a9e707642378f9e46a235bf7a3c6">XIOModule::BaseAddress</a>, <a class="el" href="struct_x_i_o_module___buffer.html#ad1d8239c6072600ea84bbbf16b6d59fb">XIOModule_Buffer::RequestedBytes</a>, <a class="el" href="struct_x_i_o_module.html#ab43b4d33329f1d1c7685f0123dc37588">XIOModule::SendBuffer</a>, and <a class="el" href="group__iomodule.html#ga313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gafab2167a879586e6baa45e8706ed6a6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> XIOModule_ConfigTable[XPAR_XIOMODULE_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This table contains configuration information for each iomodule device in the system. </p>
<p>The <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> driver must know when to acknowledge the interrupt. The entry which specifies this as a bit mask where each bit corresponds to a specific interrupt. A bit set indicates to ack it before servicing it. Generally, acknowledge before service is used when the interrupt signal is edge-sensitive, and after when the signal is level-sensitive.</p>
<p>Refer to the <a class="el" href="struct_x_i_o_module___config.html" title="This typedef contains configuration information for the device. ">XIOModule_Config</a> data structure in <a class="el" href="xiomodule_8h.html">xiomodule.h</a> for details on how this table should be initialized. </p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a>, and <a class="el" href="group__iomodule.html#ga367989ec098fe548ba62b58640490ec7">XIOModule_LookupConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b86656d30db376521bc3f4b63985499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> XIOModule_ConfigTable[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This table contains configuration information for each iomodule device in the system. </p>
<p>The <a class="el" href="struct_x_i_o_module.html" title="The XIOModule driver instance data. ">XIOModule</a> driver must know when to acknowledge the interrupt. The entry which specifies this as a bit mask where each bit corresponds to a specific interrupt. A bit set indicates to ack it before servicing it. Generally, acknowledge before service is used when the interrupt signal is edge-sensitive, and after when the signal is level-sensitive.</p>
<p>Refer to the <a class="el" href="struct_x_i_o_module___config.html" title="This typedef contains configuration information for the device. ">XIOModule_Config</a> data structure in <a class="el" href="xiomodule_8h.html">xiomodule.h</a> for details on how this table should be initialized. </p>

<p>Referenced by <a class="el" href="group__iomodule.html#ga2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a>, and <a class="el" href="group__iomodule.html#ga367989ec098fe548ba62b58640490ec7">XIOModule_LookupConfig()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
