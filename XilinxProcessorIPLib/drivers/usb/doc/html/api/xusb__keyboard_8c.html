<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>usb: xusb_keyboard.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">usb
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xusb__keyboard_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xusb_keyboard.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This file contains an example for USB keyboard. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The example is tested on ML403 and ML507 evaluation boards. The push buttons SW3,SW4,SW5 and SW7 on the ML403 evaluation board are used in the example for the key action of the USB keyboard.The push buttons SW10, SW11, SW12, SW13 and SW14 are used on the ML507 board. The example sends a character from a fixed sequence of characters from the device as and when any of the SW3 or SW4 or SW5 and SW7 push button is pressed. The fixed sequence of characters is XILINX USB KEYBOARD DEMO. The SW6 push button switch is used to complete the test. SW14 is used on ML507 board to complete the test.</li>
<li>The GPIO device has to be added to the hardware design so that the push buttons on the evaluation board could be used. If we enable the debug statements in the <a class="el" href="xusb__cp9_8c.html" title="This file contains the USB Chapter 9 related functions. ">xusb_cp9.c</a> file, we must add the UARTLite core to the hardware design. Debug messages can be enabled by defining the constant XUSB_DEBUG,</li>
<li>To run this example, the evaluation board is to be connected to a windows Host PC over the USB port.</li>
<li>The example configures the USB device for endpoint 0 and endpoint 1. Endpoint 0 is the control endpoint and is configured for a maximum packet length of 64 bytes. End point 1 is configured for INTERRUPT IN transactions and the maximum packet size is configured as 16 bytes.</li>
<li>The USB keyboard example code has to be compiled along with the <a class="el" href="xusb__cp9_8c.html" title="This file contains the USB Chapter 9 related functions. ">xusb_cp9.c</a> file. The <a class="el" href="xusb__cp9_8c.html" title="This file contains the USB Chapter 9 related functions. ">xusb_cp9.c</a> file contains all the USB enumeration related functions. To compile the code for USB keyboard example, the constant definitions HID_DEVICES and USB_KEYBOARD are to be defined and the definitions the constants USB_MOUSE and MASS_STORAGE_DEVICE are to be undefined. These definitions can be found in the <a class="el" href="xusb__types_8h.html" title="This file contains the constants, type definitions, variables as used in the USB chapter 9 and mass s...">xusb_types.h</a> file.</li>
</ul>
</dd></dl>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who  Date     Changes
<hr/>

1.00a hvm  5/31/07 First release
3.00a hvm  11/18/09 Updated to use HAL processor APIs.
               XUsb_mReadReg is renamed to XUsb_ReadReg and
               XUsb_mWriteReg is renamed to XUsb_WriteReg.
4.00a hvm  08/11/11 Updated the code in gpio isr to increment the index by 4 as
                a dummy byte is added in the Message variable in keyboard.h
                file to handle the address alignment issue.
4.02a bss  11/01/11 Modified UsbIfIntrHandler function to unconditionally
                reset when USB reset is asserted (CR 627574).</pre><pre></pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8f2bcd4c9e30a4811003990864522af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__keyboard_8c.html#aa8f2bcd4c9e30a4811003990864522af">UsbKbdExample</a> (u16 UsbId, u16 GpioId)</td></tr>
<tr class="memdesc:aa8f2bcd4c9e30a4811003990864522af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements the USB Keyboard example.  <a href="#aa8f2bcd4c9e30a4811003990864522af">More...</a><br /></td></tr>
<tr class="separator:aa8f2bcd4c9e30a4811003990864522af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840291bc02cba5474a4cb46a9b9566fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__keyboard_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> (void)</td></tr>
<tr class="memdesc:a840291bc02cba5474a4cb46a9b9566fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the main function of the USB Keyboard example.  <a href="#a840291bc02cba5474a4cb46a9b9566fe">More...</a><br /></td></tr>
<tr class="separator:a840291bc02cba5474a4cb46a9b9566fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b40155d0d9fa44133905dd9f6f02ee7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__keyboard_8c.html#a3b40155d0d9fa44133905dd9f6f02ee7">InitUsbInterface</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr class="memdesc:a3b40155d0d9fa44133905dd9f6f02ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the USB device for Keyboard example.  <a href="#a3b40155d0d9fa44133905dd9f6f02ee7">More...</a><br /></td></tr>
<tr class="separator:a3b40155d0d9fa44133905dd9f6f02ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd3ecc4e2acd07b864ea2392a0394f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__keyboard_8c.html#a8bd3ecc4e2acd07b864ea2392a0394f4">UsbIfIntrHandler</a> (void *CallBackRef, u32 IntrStatus)</td></tr>
<tr class="memdesc:a8bd3ecc4e2acd07b864ea2392a0394f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the USB keyboard example.  <a href="#a8bd3ecc4e2acd07b864ea2392a0394f4">More...</a><br /></td></tr>
<tr class="separator:a8bd3ecc4e2acd07b864ea2392a0394f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243967b329b332dc3503adfc2950fceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__keyboard_8c.html#a243967b329b332dc3503adfc2950fceb">Ep0IntrHandler</a> (void *CallBackRef, u8 EpNum, u32 IntrStatus)</td></tr>
<tr class="memdesc:a243967b329b332dc3503adfc2950fceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the USB End point Zero events.  <a href="#a243967b329b332dc3503adfc2950fceb">More...</a><br /></td></tr>
<tr class="separator:a243967b329b332dc3503adfc2950fceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386bfc503aaebdfd92028284d6fb63f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__keyboard_8c.html#a386bfc503aaebdfd92028284d6fb63f0">Ep1IntrHandler</a> (void *CallBackRef, u8 EpNum, u32 IntrStatus)</td></tr>
<tr class="memdesc:a386bfc503aaebdfd92028284d6fb63f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the USB End point one events.  <a href="#a386bfc503aaebdfd92028284d6fb63f0">More...</a><br /></td></tr>
<tr class="separator:a386bfc503aaebdfd92028284d6fb63f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484c46094f8fbdcb3dbc3639e45a90ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__keyboard_8c.html#a484c46094f8fbdcb3dbc3639e45a90ad">GpioIsr</a> (void *InstancePtr)</td></tr>
<tr class="memdesc:a484c46094f8fbdcb3dbc3639e45a90ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the Interrupt Service Routine for the GPIO device.  <a href="#a484c46094f8fbdcb3dbc3639e45a90ad">More...</a><br /></td></tr>
<tr class="separator:a484c46094f8fbdcb3dbc3639e45a90ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a243967b329b332dc3503adfc2950fceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243967b329b332dc3503adfc2950fceb">&#9670;&nbsp;</a></span>Ep0IntrHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ep0IntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IntrStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for the USB End point Zero events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is the callback reference passed from the interrupt. handler, which in our case is a pointer to the driver instance. </td></tr>
    <tr><td class="paramname">EpNum</td><td>is the end point number. </td></tr>
    <tr><td class="paramname">IntrStatus</td><td>is a bit mask indicating pending interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>EpNum is not used in this function as the handler is attached specific to end point zero. This parameter is useful when a single handler is used for processing all end point interrupts. </dd></dl>

</div>
</div>
<a id="a386bfc503aaebdfd92028284d6fb63f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386bfc503aaebdfd92028284d6fb63f0">&#9670;&nbsp;</a></span>Ep1IntrHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ep1IntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IntrStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for the USB End point one events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is the callback reference passed from the interrupt handler, which in our case is a pointer to the driver instance. </td></tr>
    <tr><td class="paramname">EpNum</td><td>is the end point number. </td></tr>
    <tr><td class="paramname">IntrStatus</td><td>is a bit mask indicating pending interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>EpNum is not used in this function as the handler is attached specific to end point one. This parameter is useful when a single handler is used for processing all end point interrupts. </dd></dl>

</div>
</div>
<a id="a484c46094f8fbdcb3dbc3639e45a90ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484c46094f8fbdcb3dbc3639e45a90ad">&#9670;&nbsp;</a></span>GpioIsr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GpioIsr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the Interrupt Service Routine for the GPIO device. </p>
<p>This function will detect the push button on the board has changed state and then prepare data to be sent to the host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the GPIO component to operate on. It is a void pointer and in this case will be a pointer to the GPIO instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a3b40155d0d9fa44133905dd9f6f02ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b40155d0d9fa44133905dd9f6f02ee7">&#9670;&nbsp;</a></span>InitUsbInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InitUsbInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the USB device for Keyboard example. </p>
<p>This is the USB initialization function.</p>
<p>The following is the configuration.</p><ul>
<li>EP0 : CONTROL end point, Bidirectional, Packet size 64 bytes.</li>
<li>EP1 : NON_ISOCHRONOUS, INTERRUPT_IN, packet size of 16 bytes.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_usb.html" title="The XUsb driver instance data. ">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_usb___device_config.html#a6448bf5499b369be43e341c0edf109ea">XUsb_DeviceConfig::Ep</a>, <a class="el" href="struct_x_usb___ep_config.html#a738bec89a19541ccf5829750050469df">XUsb_EpConfig::EpType</a>, <a class="el" href="struct_x_usb___device_config.html#afabc76c53b986e9ae1c5ae30f52789f9">XUsb_DeviceConfig::NumEndpoints</a>, <a class="el" href="struct_x_usb___ep_config.html#a53a183054dd9dc8866ccfe0584fe3c88">XUsb_EpConfig::OutIn</a>, <a class="el" href="struct_x_usb___ep_config.html#ae435ae7b41b9b695000ac64e1b5734f2">XUsb_EpConfig::RamBase</a>, <a class="el" href="struct_x_usb___ep_config.html#a5c1b641e8deb5d0c115609dc91a51aa1">XUsb_EpConfig::Size</a>, <a class="el" href="group__usb__v5__2.html#ga9c50c0ee6d36d4b87a40018c2ad0fd25">XUsb_ConfigureDevice()</a>, <a class="el" href="group__usb__v5__2.html#gac41572da2aded6fe09ee6b423ddbd50a">XUSB_EP_DIRECTION_IN</a>, <a class="el" href="group__usb__v5__2.html#gaaeed667f160bf00cc1e548a254fc45a3">XUSB_EP_DIRECTION_OUT</a>, and <a class="el" href="group__usb__v5__2.html#gadc3661c9581f9dea4b01873cbaff31a8">XUsb_EpEnable()</a>.</p>

</div>
</div>
<a id="a840291bc02cba5474a4cb46a9b9566fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840291bc02cba5474a4cb46a9b9566fe">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the main function of the USB Keyboard example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful,</li>
<li>XST_FAILURE if unsuccessful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="xusb__keyboard_8c.html#aa8f2bcd4c9e30a4811003990864522af">UsbKbdExample()</a>.</p>

</div>
</div>
<a id="a8bd3ecc4e2acd07b864ea2392a0394f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd3ecc4e2acd07b864ea2392a0394f4">&#9670;&nbsp;</a></span>UsbIfIntrHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsbIfIntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IntrStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for the USB keyboard example. </p>
<p>This function is the interrupt handler for the USB mass storage device application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is the callback reference passed from the interrupt handler, which in our case is a pointer to the driver instance. </td></tr>
    <tr><td class="paramname">IntrStatus</td><td>is a bit mask indicating pending interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each interrupt source is disabled upon reception. This is to avoid the repetitive occurrence of the same event. This is done because these event conditions exist for few milliseconds. </dd></dl>

</div>
</div>
<a id="aa8f2bcd4c9e30a4811003990864522af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f2bcd4c9e30a4811003990864522af">&#9670;&nbsp;</a></span>UsbKbdExample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UsbKbdExample </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>UsbId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>GpioId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements the USB Keyboard example. </p>
<p>The Key board action can be seen on the PC as and when any of the push buttons SW3 or SW4 or SW5 or SW7 on the ML403 evaluation board is pressed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UsbId</td><td>is the USB device id. </td></tr>
    <tr><td class="paramname">GpioId</td><td>is the GPIO device id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if test fails. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">Referenced by <a class="el" href="xusb__keyboard_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
