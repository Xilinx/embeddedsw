<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>dsi2rx: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">dsi2rx
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__dsi.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Overview</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dsi2_rx___config.html">XDsi2Rx_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration structure for DSI Controller This structure passes the hardware building information to the driver.  <a href="struct_x_dsi2_rx___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dsi2_rx___config_parameters.html">XDsi2Rx_ConfigParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure to read DSI controller &amp; Configurable Parameters.  <a href="struct_x_dsi2_rx___config_parameters.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> driver instance data.  <a href="struct_x_dsi2_rx.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga682db3444587540df26e7d626afcca98"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga682db3444587540df26e7d626afcca98">XDsi2Rx_Callback</a> )(void *CallbackRef, u32 Mask)</td></tr>
<tr class="memdesc:ga682db3444587540df26e7d626afcca98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for all interrupts defined.  <a href="#ga682db3444587540df26e7d626afcca98">More...</a><br/></td></tr>
<tr class="separator:ga682db3444587540df26e7d626afcca98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf686ea1f82f4921fad094c881f42468f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_dsi2_rx___config.html">XDsi2Rx_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#gaf686ea1f82f4921fad094c881f42468f">XDsi2Rx_LookupConfig</a> (UINTPTR BaseAddress)</td></tr>
<tr class="memdesc:gaf686ea1f82f4921fad094c881f42468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the hardware configuration for a device instance.  <a href="#gaf686ea1f82f4921fad094c881f42468f">More...</a><br/></td></tr>
<tr class="separator:gaf686ea1f82f4921fad094c881f42468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad952dd5db0493731abdc7745487c129c"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#gad952dd5db0493731abdc7745487c129c">XDsi2Rx_CfgInitialize</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr, <a class="el" href="struct_x_dsi2_rx___config.html">XDsi2Rx_Config</a> *Config, UINTPTR EffectiveAddr)</td></tr>
<tr class="memdesc:gad952dd5db0493731abdc7745487c129c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance provided by the caller based on the given Config structure.  <a href="#gad952dd5db0493731abdc7745487c129c">More...</a><br/></td></tr>
<tr class="separator:gad952dd5db0493731abdc7745487c129c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19af397133295c990ad132a86b515819"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga19af397133295c990ad132a86b515819">XDsi2Rx_Activate</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr, XDsi2Rx_Selection Flag)</td></tr>
<tr class="memdesc:ga19af397133295c990ad132a86b515819"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable/disable the IP Core to start processing.  <a href="#ga19af397133295c990ad132a86b515819">More...</a><br/></td></tr>
<tr class="separator:ga19af397133295c990ad132a86b515819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a43a81fab8a3ad7fcef5f03ad53585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga65a43a81fab8a3ad7fcef5f03ad53585">XDsi2Rx_Reset</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga65a43a81fab8a3ad7fcef5f03ad53585"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will do a reset of the IP.  <a href="#ga65a43a81fab8a3ad7fcef5f03ad53585">More...</a><br/></td></tr>
<tr class="separator:ga65a43a81fab8a3ad7fcef5f03ad53585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2aafbf53090a3e04a8c1fcac80c54e2"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#gad2aafbf53090a3e04a8c1fcac80c54e2">XDsi2Rx_DefaultConfigure</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr)</td></tr>
<tr class="memdesc:gad2aafbf53090a3e04a8c1fcac80c54e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will configure protocol reg with video mode, Blank packet mode, Blank packet Type, End of Transmisstion packet.  <a href="#gad2aafbf53090a3e04a8c1fcac80c54e2">More...</a><br/></td></tr>
<tr class="separator:gad2aafbf53090a3e04a8c1fcac80c54e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9633779add7d621518de100c3361bb41"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga9633779add7d621518de100c3361bb41">XDsi2Rx_SelfTest</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga9633779add7d621518de100c3361bb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a self-test on the driver/device.  <a href="#ga9633779add7d621518de100c3361bb41">More...</a><br/></td></tr>
<tr class="separator:ga9633779add7d621518de100c3361bb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732edd1bd3354efe3715f684a341f873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga732edd1bd3354efe3715f684a341f873">XDsi2Rx_GetConfigParams</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr, <a class="el" href="struct_x_dsi2_rx___config_parameters.html">XDsi2Rx_ConfigParameters</a> *ConfigInfo)</td></tr>
<tr class="memdesc:ga732edd1bd3354efe3715f684a341f873"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function will get the information from the gui settings and other protocol control register values like pixel mode, pixel format.  <a href="#ga732edd1bd3354efe3715f684a341f873">More...</a><br/></td></tr>
<tr class="separator:ga732edd1bd3354efe3715f684a341f873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7572f62d7760d6b34e5711cff0e52c0d"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga7572f62d7760d6b34e5711cff0e52c0d">XDsi2Rx_SetCallback</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr, u32 HandleType, void *CallbackFunc, void *CallbackRef)</td></tr>
<tr class="memdesc:ga7572f62d7760d6b34e5711cff0e52c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine installs an asynchronous callback function for the given HandlerType:  <a href="#ga7572f62d7760d6b34e5711cff0e52c0d">More...</a><br/></td></tr>
<tr class="separator:ga7572f62d7760d6b34e5711cff0e52c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffaee65e23167d38fd3ae1107126a334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#gaffaee65e23167d38fd3ae1107126a334">XDsi2Rx_InterruptEnable</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:gaffaee65e23167d38fd3ae1107126a334"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will enable the interrupts present in the interrupt mask passed onto the function.  <a href="#gaffaee65e23167d38fd3ae1107126a334">More...</a><br/></td></tr>
<tr class="separator:gaffaee65e23167d38fd3ae1107126a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1fdbb4e464f81ccdf0e823d44293ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga6b1fdbb4e464f81ccdf0e823d44293ce">XDsi2Rx_InterruptDisable</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:ga6b1fdbb4e464f81ccdf0e823d44293ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable the interrupts present in the interrupt mask passed onto the function.  <a href="#ga6b1fdbb4e464f81ccdf0e823d44293ce">More...</a><br/></td></tr>
<tr class="separator:ga6b1fdbb4e464f81ccdf0e823d44293ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436fb30a622a80c5d57a6aa34bf8de86"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga436fb30a622a80c5d57a6aa34bf8de86">XDsi2Rx_InterruptGetEnabled</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga436fb30a622a80c5d57a6aa34bf8de86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will get the interrupt mask set (enabled) in the DSI core.  <a href="#ga436fb30a622a80c5d57a6aa34bf8de86">More...</a><br/></td></tr>
<tr class="separator:ga436fb30a622a80c5d57a6aa34bf8de86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9b6cbfd8f8a0e98d2f7421e4ae7b45"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga2c9b6cbfd8f8a0e98d2f7421e4ae7b45">XDsi2Rx_InterruptGetStatus</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga2c9b6cbfd8f8a0e98d2f7421e4ae7b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will get the list of interrupts Invoked in the Interrupt Status Register of the DSI core.  <a href="#ga2c9b6cbfd8f8a0e98d2f7421e4ae7b45">More...</a><br/></td></tr>
<tr class="separator:ga2c9b6cbfd8f8a0e98d2f7421e4ae7b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bca141c9dba1cc9f3fa86f05d049486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga6bca141c9dba1cc9f3fa86f05d049486">XDsi2Rx_InterruptClear</a> (<a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:ga6bca141c9dba1cc9f3fa86f05d049486"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will clear the interrupts set in the Interrupt Status Register of the DSI core.  <a href="#ga6bca141c9dba1cc9f3fa86f05d049486">More...</a><br/></td></tr>
<tr class="separator:ga6bca141c9dba1cc9f3fa86f05d049486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b30c41e3c917badd1eba84e3644fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dsi.html#ga54b30c41e3c917badd1eba84e3644fa9">XDsi2Rx_IntrHandler</a> (void *InstancePtr)</td></tr>
<tr class="memdesc:ga54b30c41e3c917badd1eba84e3644fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the DSI core.  <a href="#ga54b30c41e3c917badd1eba84e3644fa9">More...</a><br/></td></tr>
<tr class="separator:ga54b30c41e3c917badd1eba84e3644fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga682db3444587540df26e7d626afcca98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XDsi2Rx_Callback)(void *CallbackRef, u32 Mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for all interrupts defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. </td></tr>
    <tr><td class="paramname">Mask</td><td>is a bit mask indicating the cause of the event. For current core version, this parameter is "OR" of 0 or more XDSI2RX_ISR_*_MASK constants defined in xdsi_hw.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga19af397133295c990ad132a86b515819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDsi2Rx_Activate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XDsi2Rx_Selection&#160;</td>
          <td class="paramname"><em>Flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will enable/disable the IP Core to start processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance to operate on.</td></tr>
    <tr><td class="paramname">Flag</td><td>will be used to indicate Enable or Disable action.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS On enabling/disabling the core.</li>
</ul>
</dd></dl>
<ul>
<li>XST_INVALID_PARAM if user passes invalid parameter.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dsi2_rx.html#a57889229cf2847a9a249edb2f05213fd">XDsi2Rx::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="gad952dd5db0493731abdc7745487c129c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDsi2Rx_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx___config.html">XDsi2Rx_Config</a> *&#160;</td>
          <td class="paramname"><em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance provided by the caller based on the given Config structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance to operate on. </td></tr>
    <tr><td class="paramname">CfgPtr</td><td>is the device configuration structure containing information about a specific DSI. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the base address of the device. If address translation is being used, then this parameter must reflect the virtual base address. Otherwise, the physical address should be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS Initialization was successful.</li>
<li>XST_FAILURE Initialization was unsuccessful.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dsi2_rx___config.html#a07d0063d512e6ffd4582b60b3a07f884">XDsi2Rx_Config::BaseAddr</a>, <a class="el" href="struct_x_dsi2_rx.html#ad839d6712558a4ba874bdbd23a277b07">XDsi2Rx::Config</a>, <a class="el" href="struct_x_dsi2_rx.html#a57889229cf2847a9a249edb2f05213fd">XDsi2Rx::IsReady</a>, and <a class="el" href="struct_x_dsi2_rx.html#a2b6cd6b63c8fe1358aea1340a9b49029">XDsi2Rx::UnSupportedDataTypeCallback</a>.</p>

</div>
</div>
<a class="anchor" id="gad2aafbf53090a3e04a8c1fcac80c54e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDsi2Rx_DefaultConfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will configure protocol reg with video mode, Blank packet mode, Blank packet Type, End of Transmisstion packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS On enabling the core.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dsi2_rx.html#a57889229cf2847a9a249edb2f05213fd">XDsi2Rx::IsReady</a>, and <a class="el" href="struct_x_dsi2_rx.html#a1f65ac6290f33a82b8d943158c570aa6">XDsi2Rx::PixelMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga732edd1bd3354efe3715f684a341f873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDsi2Rx_GetConfigParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx___config_parameters.html">XDsi2Rx_ConfigParameters</a> *&#160;</td>
          <td class="paramname"><em>ConfigInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function will get the information from the gui settings and other protocol control register values like pixel mode, pixel format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instanceptr</td><td>is the xdsi2rx instance to operate on </td></tr>
    <tr><td class="paramname">configinfo</td><td>is going to be filled up by this function and returned to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>none. </dd></dl>

<p>References <a class="el" href="struct_x_dsi2_rx___config.html#a07d0063d512e6ffd4582b60b3a07f884">XDsi2Rx_Config::BaseAddr</a>, <a class="el" href="struct_x_dsi2_rx___config_parameters.html#ae6843da1fb5e14b90353827fecbcf8c7">XDsi2Rx_ConfigParameters::Config</a>, <a class="el" href="struct_x_dsi2_rx.html#ad839d6712558a4ba874bdbd23a277b07">XDsi2Rx::Config</a>, and <a class="el" href="struct_x_dsi2_rx___config_parameters.html#ac6ca53bfa1d1b660c58b5709f14b81b5">XDsi2Rx_ConfigParameters::PixelMode</a>.</p>

</div>
</div>
<a class="anchor" id="ga6bca141c9dba1cc9f3fa86f05d049486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDsi2Rx_InterruptClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will clear the interrupts set in the Interrupt Status Register of the DSI core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance to operate on </td></tr>
    <tr><td class="paramname">Mask</td><td>is Interrupt Mask with bits set for corresponding interrupt to be cleared in the Interrupt Status register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>Referenced by <a class="el" href="group__dsi.html#ga54b30c41e3c917badd1eba84e3644fa9">XDsi2Rx_IntrHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b1fdbb4e464f81ccdf0e823d44293ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDsi2Rx_InterruptDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will disable the interrupts present in the interrupt mask passed onto the function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the XDsi instance to operate on </td></tr>
    <tr><td class="paramname">Mask</td><td>is the interrupt mask which need to be enabled in core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaffaee65e23167d38fd3ae1107126a334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDsi2Rx_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will enable the interrupts present in the interrupt mask passed onto the function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance to operate on </td></tr>
    <tr><td class="paramname">Mask</td><td>is the interrupt mask which need to be enabled in core</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga436fb30a622a80c5d57a6aa34bf8de86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDsi2Rx_InterruptGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will get the interrupt mask set (enabled) in the DSI core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the XDsi instance to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt Mask with bits set for corresponding interrupt in Interrupt enable register</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c9b6cbfd8f8a0e98d2f7421e4ae7b45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDsi2Rx_InterruptGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will get the list of interrupts Invoked in the Interrupt Status Register of the DSI core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the XDsi instance to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt Mask with bits set for corresponding interrupt in Interrupt Status register</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>Referenced by <a class="el" href="group__dsi.html#ga54b30c41e3c917badd1eba84e3644fa9">XDsi2Rx_IntrHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga54b30c41e3c917badd1eba84e3644fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDsi2Rx_IntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for the DSI core. </p>
<p>This handler reads the Invoked interrupt from the Interrupt Status register determines the source of the interrupts and calls the respective callbacks for the interrupts that are enabled in Interrupt Enable register and finally clears the interrupts.</p>
<p>The application is responsible for connecting this function to the interrupt system. Application beyond this core is also responsible for providing callbacks to handle interrupts and installing the callbacks using <a class="el" href="group__dsi.html#ga7572f62d7760d6b34e5711cff0e52c0d" title="This routine installs an asynchronous callback function for the given HandlerType: ...">XDsi2Rx_SetCallback()</a> during initialization phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> core instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Interrupt should be enabled to execute interrupt handler. </dd></dl>

<p>References <a class="el" href="struct_x_dsi2_rx.html#a57889229cf2847a9a249edb2f05213fd">XDsi2Rx::IsReady</a>, <a class="el" href="struct_x_dsi2_rx.html#aed3bbcc1f3132eaec0fbfd8b696b3b7c">XDsi2Rx::UnsupportDataTypeRef</a>, <a class="el" href="struct_x_dsi2_rx.html#a2b6cd6b63c8fe1358aea1340a9b49029">XDsi2Rx::UnSupportedDataTypeCallback</a>, <a class="el" href="group__dsi.html#ga6bca141c9dba1cc9f3fa86f05d049486">XDsi2Rx_InterruptClear()</a>, and <a class="el" href="group__dsi.html#ga2c9b6cbfd8f8a0e98d2f7421e4ae7b45">XDsi2Rx_InterruptGetStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf686ea1f82f4921fad094c881f42468f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_dsi2_rx___config.html">XDsi2Rx_Config</a> * XDsi2Rx_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>BaseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the hardware configuration for a device instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the unique device ID of the device to lookup for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference to the configuration record in the configuration table (in xdsi2rx_g.c) corresponding to the BaseAddress or if not found, a NULL pointer is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga65a43a81fab8a3ad7fcef5f03ad53585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDsi2Rx_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will do a reset of the IP. </p>
<p>Register ISR gets reset. Internal FIFO(command queue) gets flushed. FSM stops processing further packets. Controller gracefully ends by waiting for the current sub-block in operation to complete its task and mark next byte as LP byte to end the transfer. Once soft reset is released, controller start from VSS packet. (that is new video frame)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9633779add7d621518de100c3361bb41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDsi2Rx_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a self-test on the driver/device. </p>
<p>This test checks if the Pixel mode has been set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dsi2_rx.html" title="The XDsi2Rx driver instance data. ">XDsi2Rx</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if self-test was successful</li>
<li>XST_FAILURE if the read value was not equal to GUI parameter</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dsi2_rx___config.html#a07d0063d512e6ffd4582b60b3a07f884">XDsi2Rx_Config::BaseAddr</a>, <a class="el" href="struct_x_dsi2_rx.html#ad839d6712558a4ba874bdbd23a277b07">XDsi2Rx::Config</a>, and <a class="el" href="struct_x_dsi2_rx.html#a57889229cf2847a9a249edb2f05213fd">XDsi2Rx::IsReady</a>.</p>

</div>
</div>
<a class="anchor" id="ga7572f62d7760d6b34e5711cff0e52c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XDsi2Rx_SetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dsi2_rx.html">XDsi2Rx</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>HandleType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallbackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine installs an asynchronous callback function for the given HandlerType: </p>
<pre></pre><pre>HandlerType                     Invoked by this driver when:
-----------------------  --------------------------------------------------
XDSI2RX_HANDLER_UNSUPPORT_DATATYPE      Unsupported data type
XDSI2RX_HANDLER_CRC_ERROR               CRC error
XDSI2RX_HANDLER_ECC1_BIT_ERROR  ECC 1 bit error
XDSI2RX_HANDLER_ECC2_BIT_ERROR  ECC 2 bit error
XDSI2RX_HANDLER_SOT_SYNC_ERR_LANE1      SOT sync error on line 1
XDSI2RX_HANDLER_SOT_ERR_LANE1           SOT error on line 1
XDSI2RX_HANDLER_SOT_SYNC_ERR_LANE2      SOT sync error on line 2
XDSI2RX_HANDLER_SOT_ERR_LANE2           SOT error on line 2
XDSI2RX_HANDLER_SOT_SYNC_ERR_LANE3      SOT sync error on line 3
XDSI2RX_HANDLER_SOT_ERR_LANE3           SOT error on line 3
XDSI2RX_HANDLER_SOT_SYNC_ERR_LANE4      SOT sync error on line 4
XDSI2RX_HANDLER_SOT_ERR_LANE4           SOT error on line 4
XDSI2RX_HANDLER_STOP_STATE              STOP state
XDSI2RX_HANDLER_LM_ASYNC_FIFO_FULL      Long msg asyn fifo full.
XDSI2RX_HANDLER_STREAM_ASYNC_FIFO_FULL stream async fifo full
XDSI2RX_HANDLER_GSP_FIFO_NE             generic short packet fifo not empty
XDSI2RX_HANDLER_GSP_FIFO_FULL           generic short packet fifo full
XDSI2RX_HANDLER_FRAME_STARTED           frame started</pre><pre></pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the XDsi instance to operate on </td></tr>
    <tr><td class="paramname">HandleType</td><td>is the type of call back to be registered. </td></tr>
    <tr><td class="paramname">CallbackFunc</td><td>is the pointer to a call back funtion which is called when a particular event occurs. </td></tr>
    <tr><td class="paramname">CallbackRef</td><td>is a void pointer to data to be referenced to by the CallbackFunc</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS when handler is installed.</li>
</ul>
</dd></dl>
<ul>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. </dd></dl>

<p>References <a class="el" href="struct_x_dsi2_rx.html#a57889229cf2847a9a249edb2f05213fd">XDsi2Rx::IsReady</a>, <a class="el" href="struct_x_dsi2_rx.html#aed3bbcc1f3132eaec0fbfd8b696b3b7c">XDsi2Rx::UnsupportDataTypeRef</a>, and <a class="el" href="struct_x_dsi2_rx.html#a2b6cd6b63c8fe1358aea1340a9b49029">XDsi2Rx::UnSupportedDataTypeCallback</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
