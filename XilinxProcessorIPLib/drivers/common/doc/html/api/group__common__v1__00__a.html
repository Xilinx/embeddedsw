<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>common: Common_v1_00_a</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">common
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__common__v1__00__a.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Common_v1_00_a</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_e_n_v___t_i_m_e___s_t_a_m_p.html">XENV_TIME_STAMP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that contains a time stamp used by other time stamp macros defined below.  <a href="struct_x_e_n_v___t_i_m_e___s_t_a_m_p.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7ba08d136437c7da95f6825b2e976632"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga7ba08d136437c7da95f6825b2e976632">XNULL</a>&#160;&#160;&#160;NULL</td></tr>
<tr class="memdesc:ga7ba08d136437c7da95f6825b2e976632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xilinx NULL, TRUE and FALSE legacy support.  <a href="#ga7ba08d136437c7da95f6825b2e976632"></a><br/></td></tr>
<tr class="separator:ga7ba08d136437c7da95f6825b2e976632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e439aeef84a0f2e1f0ad0937d3ccba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gaf1e439aeef84a0f2e1f0ad0937d3ccba">XCOMPONENT_IS_READY</a>&#160;&#160;&#160;0x11111111</td></tr>
<tr class="memdesc:gaf1e439aeef84a0f2e1f0ad0937d3ccba"><td class="mdescLeft">&#160;</td><td class="mdescRight">component has been initialized  <a href="#gaf1e439aeef84a0f2e1f0ad0937d3ccba"></a><br/></td></tr>
<tr class="separator:gaf1e439aeef84a0f2e1f0ad0937d3ccba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8146fba914623632ff0d9edc2acc6a01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga8146fba914623632ff0d9edc2acc6a01">XCOMPONENT_IS_STARTED</a>&#160;&#160;&#160;0x22222222</td></tr>
<tr class="memdesc:ga8146fba914623632ff0d9edc2acc6a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">component has been started  <a href="#ga8146fba914623632ff0d9edc2acc6a01"></a><br/></td></tr>
<tr class="separator:ga8146fba914623632ff0d9edc2acc6a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f27d6c408105d63266828613c6c3e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga88f27d6c408105d63266828613c6c3e1">XUINT64_MSW</a>(x)&#160;&#160;&#160;((x).Upper)</td></tr>
<tr class="memdesc:ga88f27d6c408105d63266828613c6c3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the most significant half of the 64 bit data type.  <a href="#ga88f27d6c408105d63266828613c6c3e1"></a><br/></td></tr>
<tr class="separator:ga88f27d6c408105d63266828613c6c3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga733ac6be9c7e9571dcea62d2ce65522c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga733ac6be9c7e9571dcea62d2ce65522c">XUINT64_LSW</a>(x)&#160;&#160;&#160;((x).Lower)</td></tr>
<tr class="memdesc:ga733ac6be9c7e9571dcea62d2ce65522c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least significant half of the 64 bit data type.  <a href="#ga733ac6be9c7e9571dcea62d2ce65522c"></a><br/></td></tr>
<tr class="separator:ga733ac6be9c7e9571dcea62d2ce65522c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a59ff109b7b674b214f40e07361215"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gab1a59ff109b7b674b214f40e07361215">XASSERT_VOID</a>(expression)</td></tr>
<tr class="memdesc:gab1a59ff109b7b674b214f40e07361215"><td class="mdescLeft">&#160;</td><td class="mdescRight">This assert macro is to be used for functions that do not return anything (void).  <a href="#gab1a59ff109b7b674b214f40e07361215"></a><br/></td></tr>
<tr class="separator:gab1a59ff109b7b674b214f40e07361215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga237c4df94339dabd56c08bfa8ef55cff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga237c4df94339dabd56c08bfa8ef55cff">XASSERT_NONVOID</a>(expression)</td></tr>
<tr class="memdesc:ga237c4df94339dabd56c08bfa8ef55cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This assert macro is to be used for functions that do return a value.  <a href="#ga237c4df94339dabd56c08bfa8ef55cff"></a><br/></td></tr>
<tr class="separator:ga237c4df94339dabd56c08bfa8ef55cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f21b82ff570989a66c1addca6fe862a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga4f21b82ff570989a66c1addca6fe862a">XASSERT_VOID_ALWAYS</a>()</td></tr>
<tr class="memdesc:ga4f21b82ff570989a66c1addca6fe862a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always assert.  <a href="#ga4f21b82ff570989a66c1addca6fe862a"></a><br/></td></tr>
<tr class="separator:ga4f21b82ff570989a66c1addca6fe862a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb9e456a42a06ee1b516bd939dd3750"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gabeb9e456a42a06ee1b516bd939dd3750">XASSERT_NONVOID_ALWAYS</a>()</td></tr>
<tr class="memdesc:gabeb9e456a42a06ee1b516bd939dd3750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always assert.  <a href="#gabeb9e456a42a06ee1b516bd939dd3750"></a><br/></td></tr>
<tr class="separator:gabeb9e456a42a06ee1b516bd939dd3750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga23d8f4edc8649a0ba9deded0dbb7b05b">XENV_MEM_COPY</a>(DestPtr, SrcPtr, Bytes)&#160;&#160;&#160;memcpy(DestPtr, SrcPtr, Bytes)</td></tr>
<tr class="memdesc:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a non-overlapping block of memory.  <a href="#ga23d8f4edc8649a0ba9deded0dbb7b05b"></a><br/></td></tr>
<tr class="separator:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29b4ad1407af9659a9295b4fab3e64e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gad29b4ad1407af9659a9295b4fab3e64e">XENV_MEM_FILL</a>(DestPtr, Data, Bytes)&#160;&#160;&#160;memset(DestPtr, Data, Bytes)</td></tr>
<tr class="memdesc:gad29b4ad1407af9659a9295b4fab3e64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an area of memory with constant data.  <a href="#gad29b4ad1407af9659a9295b4fab3e64e"></a><br/></td></tr>
<tr class="separator:gad29b4ad1407af9659a9295b4fab3e64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga21fae7ca3043fbd3f73cd6b761afa230">XENV_TIME_STAMP_GET</a>(StampPtr)</td></tr>
<tr class="memdesc:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time is derived from the 64 bit PPC timebase register.  <a href="#ga21fae7ca3043fbd3f73cd6b761afa230"></a><br/></td></tr>
<tr class="separator:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gaa82c22bd74a502e0cdf081cd2b15f47d">XENV_TIME_STAMP_DELTA_US</a>(Stamp1Ptr, Stamp2Ptr)&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is not yet implemented and always returns 0.  <a href="#gaa82c22bd74a502e0cdf081cd2b15f47d"></a><br/></td></tr>
<tr class="separator:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e216393c2fbf374018da12bb110fc88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga4e216393c2fbf374018da12bb110fc88">XENV_TIME_STAMP_DELTA_MS</a>(Stamp1Ptr, Stamp2Ptr)&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga4e216393c2fbf374018da12bb110fc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is not yet implemented and always returns 0.  <a href="#ga4e216393c2fbf374018da12bb110fc88"></a><br/></td></tr>
<tr class="separator:ga4e216393c2fbf374018da12bb110fc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga45edf2c1128d69e881f9c54d8dcd6a26">XENV_USLEEP</a>(delay)&#160;&#160;&#160;udelay(delay)</td></tr>
<tr class="memdesc:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay the specified number of microseconds.  <a href="#ga45edf2c1128d69e881f9c54d8dcd6a26"></a><br/></td></tr>
<tr class="separator:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga23d8f4edc8649a0ba9deded0dbb7b05b">XENV_MEM_COPY</a>(DestPtr, SrcPtr, Bytes)&#160;&#160;&#160;memcpy((void *) DestPtr, (const void *) SrcPtr, (size_t) Bytes)</td></tr>
<tr class="memdesc:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a non-overlapping block of memory.  <a href="#ga23d8f4edc8649a0ba9deded0dbb7b05b"></a><br/></td></tr>
<tr class="separator:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29b4ad1407af9659a9295b4fab3e64e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gad29b4ad1407af9659a9295b4fab3e64e">XENV_MEM_FILL</a>(DestPtr, Data, Bytes)&#160;&#160;&#160;memset((void *) DestPtr, (int) Data, (size_t) Bytes)</td></tr>
<tr class="memdesc:gad29b4ad1407af9659a9295b4fab3e64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an area of memory with constant data.  <a href="#gad29b4ad1407af9659a9295b4fab3e64e"></a><br/></td></tr>
<tr class="separator:gad29b4ad1407af9659a9295b4fab3e64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga21fae7ca3043fbd3f73cd6b761afa230">XENV_TIME_STAMP_GET</a>(StampPtr)</td></tr>
<tr class="memdesc:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time is derived from the 64 bit PPC timebase register.  <a href="#ga21fae7ca3043fbd3f73cd6b761afa230"></a><br/></td></tr>
<tr class="separator:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gaa82c22bd74a502e0cdf081cd2b15f47d">XENV_TIME_STAMP_DELTA_US</a>(Stamp1Ptr, Stamp2Ptr)&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is not yet implemented and always returns 0.  <a href="#gaa82c22bd74a502e0cdf081cd2b15f47d"></a><br/></td></tr>
<tr class="separator:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e216393c2fbf374018da12bb110fc88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga4e216393c2fbf374018da12bb110fc88">XENV_TIME_STAMP_DELTA_MS</a>(Stamp1Ptr, Stamp2Ptr)&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga4e216393c2fbf374018da12bb110fc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is not yet implemented and always returns 0.  <a href="#ga4e216393c2fbf374018da12bb110fc88"></a><br/></td></tr>
<tr class="separator:ga4e216393c2fbf374018da12bb110fc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga45edf2c1128d69e881f9c54d8dcd6a26">XENV_USLEEP</a>(delay)</td></tr>
<tr class="memdesc:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__common__v1__00__a.html#ga45edf2c1128d69e881f9c54d8dcd6a26" title="XENV_USLEEP(unsigned delay)">XENV_USLEEP(unsigned delay)</a>  <a href="#ga45edf2c1128d69e881f9c54d8dcd6a26"></a><br/></td></tr>
<tr class="separator:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga23d8f4edc8649a0ba9deded0dbb7b05b">XENV_MEM_COPY</a>(DestPtr, SrcPtr, Bytes)&#160;&#160;&#160;memcpy((void *) DestPtr, (const void *) SrcPtr, (size_t) Bytes)</td></tr>
<tr class="memdesc:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a non-overlapping block of memory.  <a href="#ga23d8f4edc8649a0ba9deded0dbb7b05b"></a><br/></td></tr>
<tr class="separator:ga23d8f4edc8649a0ba9deded0dbb7b05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29b4ad1407af9659a9295b4fab3e64e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gad29b4ad1407af9659a9295b4fab3e64e">XENV_MEM_FILL</a>(DestPtr, Data, Bytes)&#160;&#160;&#160;memset((void *) DestPtr, (int) Data, (size_t) Bytes)</td></tr>
<tr class="memdesc:gad29b4ad1407af9659a9295b4fab3e64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an area of memory with constant data.  <a href="#gad29b4ad1407af9659a9295b4fab3e64e"></a><br/></td></tr>
<tr class="separator:gad29b4ad1407af9659a9295b4fab3e64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga21fae7ca3043fbd3f73cd6b761afa230">XENV_TIME_STAMP_GET</a>(StampPtr)</td></tr>
<tr class="memdesc:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time is derived from the 64 bit PPC timebase register.  <a href="#ga21fae7ca3043fbd3f73cd6b761afa230"></a><br/></td></tr>
<tr class="separator:ga21fae7ca3043fbd3f73cd6b761afa230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gaa82c22bd74a502e0cdf081cd2b15f47d">XENV_TIME_STAMP_DELTA_US</a>(Stamp1Ptr, Stamp2Ptr)&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is not yet implemented and always returns 0.  <a href="#gaa82c22bd74a502e0cdf081cd2b15f47d"></a><br/></td></tr>
<tr class="separator:gaa82c22bd74a502e0cdf081cd2b15f47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e216393c2fbf374018da12bb110fc88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga4e216393c2fbf374018da12bb110fc88">XENV_TIME_STAMP_DELTA_MS</a>(Stamp1Ptr, Stamp2Ptr)&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga4e216393c2fbf374018da12bb110fc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is not yet implemented and always returns 0.  <a href="#ga4e216393c2fbf374018da12bb110fc88"></a><br/></td></tr>
<tr class="separator:ga4e216393c2fbf374018da12bb110fc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga45edf2c1128d69e881f9c54d8dcd6a26">XENV_USLEEP</a>(delay)&#160;&#160;&#160;sysUsDelay(delay)</td></tr>
<tr class="memdesc:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay the specified number of microseconds.  <a href="#ga45edf2c1128d69e881f9c54d8dcd6a26"></a><br/></td></tr>
<tr class="separator:ga45edf2c1128d69e881f9c54d8dcd6a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa5d4da94c76dca492aa80a9966bf1aad"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gaa5d4da94c76dca492aa80a9966bf1aad">XInterruptHandler</a> )(void *InstancePtr)</td></tr>
<tr class="memdesc:gaa5d4da94c76dca492aa80a9966bf1aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data type defines an interrupt handler for a device.  <a href="#gaa5d4da94c76dca492aa80a9966bf1aad"></a><br/></td></tr>
<tr class="separator:gaa5d4da94c76dca492aa80a9966bf1aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac91a7cf7c023c61cd52058caeb4cdb"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gafac91a7cf7c023c61cd52058caeb4cdb">XExceptionHandler</a> )(void *InstancePtr)</td></tr>
<tr class="memdesc:gafac91a7cf7c023c61cd52058caeb4cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data type defines an exception handler for a processor.  <a href="#gafac91a7cf7c023c61cd52058caeb4cdb"></a><br/></td></tr>
<tr class="separator:gafac91a7cf7c023c61cd52058caeb4cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1b7db368107ff6ebddb3a463dd786b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga5b1b7db368107ff6ebddb3a463dd786b">XAssertCallback</a> )(char *FilenamePtr, int LineNumber)</td></tr>
<tr class="memdesc:ga5b1b7db368107ff6ebddb3a463dd786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data type defines a callback to be invoked when an assert occurs.  <a href="#ga5b1b7db368107ff6ebddb3a463dd786b"></a><br/></td></tr>
<tr class="separator:ga5b1b7db368107ff6ebddb3a463dd786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13dfc6253d3809555cb87f1ac76737a"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gae13dfc6253d3809555cb87f1ac76737a">XENV_TIME_STAMP</a></td></tr>
<tr class="memdesc:gae13dfc6253d3809555cb87f1ac76737a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that contains a time stamp used by other time stamp macros defined below.  <a href="#gae13dfc6253d3809555cb87f1ac76737a"></a><br/></td></tr>
<tr class="separator:gae13dfc6253d3809555cb87f1ac76737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13dfc6253d3809555cb87f1ac76737a"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gae13dfc6253d3809555cb87f1ac76737a">XENV_TIME_STAMP</a></td></tr>
<tr class="memdesc:gae13dfc6253d3809555cb87f1ac76737a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that contains a time stamp used by other time stamp macros defined below.  <a href="#gae13dfc6253d3809555cb87f1ac76737a"></a><br/></td></tr>
<tr class="separator:gae13dfc6253d3809555cb87f1ac76737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga15bbfbbbf84cb3f772dbbf22f7b07b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga15bbfbbbf84cb3f772dbbf22f7b07b75">XAssert</a> (char *File, int Line)</td></tr>
<tr class="memdesc:ga15bbfbbbf84cb3f772dbbf22f7b07b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements assert.  <a href="#ga15bbfbbbf84cb3f772dbbf22f7b07b75"></a><br/></td></tr>
<tr class="separator:ga15bbfbbbf84cb3f772dbbf22f7b07b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6843e75f679abd8d57f070219aa86fa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga6843e75f679abd8d57f070219aa86fa1">XAssertSetCallback</a> (<a class="el" href="group__common__v1__00__a.html#ga5b1b7db368107ff6ebddb3a463dd786b">XAssertCallback</a> Routine)</td></tr>
<tr class="memdesc:ga6843e75f679abd8d57f070219aa86fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up a callback function to be invoked when an assert occurs.  <a href="#ga6843e75f679abd8d57f070219aa86fa1"></a><br/></td></tr>
<tr class="separator:ga6843e75f679abd8d57f070219aa86fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaecaabeb8ae29619054af3e4a0d6f508"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gaaecaabeb8ae29619054af3e4a0d6f508">XNullHandler</a> (void *NullParameter)</td></tr>
<tr class="memdesc:gaaecaabeb8ae29619054af3e4a0d6f508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null handler function.  <a href="#gaaecaabeb8ae29619054af3e4a0d6f508"></a><br/></td></tr>
<tr class="separator:gaaecaabeb8ae29619054af3e4a0d6f508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab898ebdd11950907ac66e978d2bd8d92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gab898ebdd11950907ac66e978d2bd8d92">XUtil_MemoryTest32</a> (u32 *Addr, u32 Words, u32 Pattern, u8 Subtest)</td></tr>
<tr class="memdesc:gab898ebdd11950907ac66e978d2bd8d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a destructive 32-bit wide memory test.  <a href="#gab898ebdd11950907ac66e978d2bd8d92"></a><br/></td></tr>
<tr class="separator:gab898ebdd11950907ac66e978d2bd8d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c11abd9381dbdec3f55a97b41323ddd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga5c11abd9381dbdec3f55a97b41323ddd">XUtil_MemoryTest16</a> (u16 *Addr, u32 Words, u16 Pattern, u8 Subtest)</td></tr>
<tr class="memdesc:ga5c11abd9381dbdec3f55a97b41323ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a destructive 16-bit wide memory test.  <a href="#ga5c11abd9381dbdec3f55a97b41323ddd"></a><br/></td></tr>
<tr class="separator:ga5c11abd9381dbdec3f55a97b41323ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777417fa2028d84d0f03ebb3570ea90f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga777417fa2028d84d0f03ebb3570ea90f">XUtil_MemoryTest8</a> (u8 *Addr, u32 Words, u8 Pattern, u8 Subtest)</td></tr>
<tr class="memdesc:ga777417fa2028d84d0f03ebb3570ea90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a destructive 8-bit wide memory test.  <a href="#ga777417fa2028d84d0f03ebb3570ea90f"></a><br/></td></tr>
<tr class="separator:ga777417fa2028d84d0f03ebb3570ea90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f04afc32d43f30b3d20498f7387b868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga0f04afc32d43f30b3d20498f7387b868">XVersion_UnPack</a> (XVersion *InstancePtr, u16 PackedVersion)</td></tr>
<tr class="memdesc:ga0f04afc32d43f30b3d20498f7387b868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks a packed version into the specified version.  <a href="#ga0f04afc32d43f30b3d20498f7387b868"></a><br/></td></tr>
<tr class="separator:ga0f04afc32d43f30b3d20498f7387b868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2f714e79a99e457e5fb3bb2e1f7b23f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gae2f714e79a99e457e5fb3bb2e1f7b23f">XVersion_Pack</a> (XVersion *InstancePtr, u16 *PackedVersionPtr)</td></tr>
<tr class="memdesc:gae2f714e79a99e457e5fb3bb2e1f7b23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs a version into the specified packed version.  <a href="#gae2f714e79a99e457e5fb3bb2e1f7b23f"></a><br/></td></tr>
<tr class="separator:gae2f714e79a99e457e5fb3bb2e1f7b23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab85b0654f0b4b643640c57369ecd3bf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gab85b0654f0b4b643640c57369ecd3bf2">XVersion_IsEqual</a> (XVersion *InstancePtr, XVersion *VersionPtr)</td></tr>
<tr class="memdesc:gab85b0654f0b4b643640c57369ecd3bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two versions are equal.  <a href="#gab85b0654f0b4b643640c57369ecd3bf2"></a><br/></td></tr>
<tr class="separator:gab85b0654f0b4b643640c57369ecd3bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20bcd31ada05091e23633264cb63d33c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga20bcd31ada05091e23633264cb63d33c">XVersion_ToString</a> (XVersion *InstancePtr, char *StringPtr)</td></tr>
<tr class="memdesc:ga20bcd31ada05091e23633264cb63d33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a version to a null terminated string.  <a href="#ga20bcd31ada05091e23633264cb63d33c"></a><br/></td></tr>
<tr class="separator:ga20bcd31ada05091e23633264cb63d33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5446415b912932b8a428ca698094d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gacc5446415b912932b8a428ca698094d5">XVersion_FromString</a> (XVersion *InstancePtr, char *StringPtr)</td></tr>
<tr class="memdesc:gacc5446415b912932b8a428ca698094d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a version from a null terminated string.  <a href="#gacc5446415b912932b8a428ca698094d5"></a><br/></td></tr>
<tr class="separator:gacc5446415b912932b8a428ca698094d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a1a40f520ee3c62f829d0e20581503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gab2a1a40f520ee3c62f829d0e20581503">XVersion_Copy</a> (XVersion *InstancePtr, XVersion *VersionPtr)</td></tr>
<tr class="memdesc:gab2a1a40f520ee3c62f829d0e20581503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of a version to another version.  <a href="#gab2a1a40f520ee3c62f829d0e20581503"></a><br/></td></tr>
<tr class="separator:gab2a1a40f520ee3c62f829d0e20581503"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga34f8bacc03ca6dfb9340c96cd449bb1c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga34f8bacc03ca6dfb9340c96cd449bb1c">XAssertStatus</a></td></tr>
<tr class="memdesc:ga34f8bacc03ca6dfb9340c96cd449bb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable allows testing to be done easier with asserts.  <a href="#ga34f8bacc03ca6dfb9340c96cd449bb1c"></a><br/></td></tr>
<tr class="separator:ga34f8bacc03ca6dfb9340c96cd449bb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e19ad3b7f3f7facbe157e082614b83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga70e19ad3b7f3f7facbe157e082614b83">XWaitInAssert</a> = TRUE</td></tr>
<tr class="memdesc:ga70e19ad3b7f3f7facbe157e082614b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable allows the assert functionality to be changed for testing such that it does not wait infinitely.  <a href="#ga70e19ad3b7f3f7facbe157e082614b83"></a><br/></td></tr>
<tr class="separator:ga70e19ad3b7f3f7facbe157e082614b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f8bacc03ca6dfb9340c96cd449bb1c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga34f8bacc03ca6dfb9340c96cd449bb1c">XAssertStatus</a></td></tr>
<tr class="memdesc:ga34f8bacc03ca6dfb9340c96cd449bb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable allows testing to be done easier with asserts.  <a href="#ga34f8bacc03ca6dfb9340c96cd449bb1c"></a><br/></td></tr>
<tr class="separator:ga34f8bacc03ca6dfb9340c96cd449bb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Legacy types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbcf245b9b113bf588540c8909fcb8214"></a>Deprecated legacy types. </p>
</td></tr>
<tr class="memitem:gad12ffdd1f3aefbaab9c3a2e372b53e88"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gad12ffdd1f3aefbaab9c3a2e372b53e88">Xuint8</a></td></tr>
<tr class="memdesc:gad12ffdd1f3aefbaab9c3a2e372b53e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned 8-bit  <a href="#gad12ffdd1f3aefbaab9c3a2e372b53e88"></a><br/></td></tr>
<tr class="separator:gad12ffdd1f3aefbaab9c3a2e372b53e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2faa8fec5a68d8a05c5cb4cda20f0a6"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gaa2faa8fec5a68d8a05c5cb4cda20f0a6">Xint8</a></td></tr>
<tr class="memdesc:gaa2faa8fec5a68d8a05c5cb4cda20f0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed 8-bit  <a href="#gaa2faa8fec5a68d8a05c5cb4cda20f0a6"></a><br/></td></tr>
<tr class="separator:gaa2faa8fec5a68d8a05c5cb4cda20f0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e1c2e36c65f517dcda4ee482eaa749"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gab3e1c2e36c65f517dcda4ee482eaa749">Xuint16</a></td></tr>
<tr class="memdesc:gab3e1c2e36c65f517dcda4ee482eaa749"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned 16-bit  <a href="#gab3e1c2e36c65f517dcda4ee482eaa749"></a><br/></td></tr>
<tr class="separator:gab3e1c2e36c65f517dcda4ee482eaa749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58a139daf1005fea667059c07dca7baf"><td class="memItemLeft" align="right" valign="top">typedef short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga58a139daf1005fea667059c07dca7baf">Xint16</a></td></tr>
<tr class="memdesc:ga58a139daf1005fea667059c07dca7baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed 16-bit  <a href="#ga58a139daf1005fea667059c07dca7baf"></a><br/></td></tr>
<tr class="separator:ga58a139daf1005fea667059c07dca7baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf3b6d075db16e3c6499d3aa39cea86"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga8cf3b6d075db16e3c6499d3aa39cea86">Xuint32</a></td></tr>
<tr class="memdesc:ga8cf3b6d075db16e3c6499d3aa39cea86"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned 32-bit  <a href="#ga8cf3b6d075db16e3c6499d3aa39cea86"></a><br/></td></tr>
<tr class="separator:ga8cf3b6d075db16e3c6499d3aa39cea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf205dab7b2384df48b578ad185cae2a7"><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gaf205dab7b2384df48b578ad185cae2a7">Xint32</a></td></tr>
<tr class="memdesc:gaf205dab7b2384df48b578ad185cae2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed 32-bit  <a href="#gaf205dab7b2384df48b578ad185cae2a7"></a><br/></td></tr>
<tr class="separator:gaf205dab7b2384df48b578ad185cae2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab167b68461f2aa3c5c2312e73a0ba707"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gab167b68461f2aa3c5c2312e73a0ba707">Xfloat32</a></td></tr>
<tr class="memdesc:gab167b68461f2aa3c5c2312e73a0ba707"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit floating point  <a href="#gab167b68461f2aa3c5c2312e73a0ba707"></a><br/></td></tr>
<tr class="separator:gab167b68461f2aa3c5c2312e73a0ba707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152feebbf7fef5a26e0c26660861ab03"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga152feebbf7fef5a26e0c26660861ab03">Xfloat64</a></td></tr>
<tr class="memdesc:ga152feebbf7fef5a26e0c26660861ab03"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit double precision FP  <a href="#ga152feebbf7fef5a26e0c26660861ab03"></a><br/></td></tr>
<tr class="separator:ga152feebbf7fef5a26e0c26660861ab03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b7af47c3b5bda2a5aaa98a2cad22d7"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#gad6b7af47c3b5bda2a5aaa98a2cad22d7">Xboolean</a></td></tr>
<tr class="memdesc:gad6b7af47c3b5bda2a5aaa98a2cad22d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean (XTRUE or XFALSE)  <a href="#gad6b7af47c3b5bda2a5aaa98a2cad22d7"></a><br/></td></tr>
<tr class="separator:gad6b7af47c3b5bda2a5aaa98a2cad22d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
New types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8205beddd6e6d51e911a9dda4952b47e"></a>New simple types. </p>
</td></tr>
<tr class="memitem:gae28a8ca0b6474b90708470e82ed9f931"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae28a8ca0b6474b90708470e82ed9f931"></a>
typedef <a class="el" href="group__common__v1__00__a.html#ga8cf3b6d075db16e3c6499d3aa39cea86">Xuint32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u32</b></td></tr>
<tr class="separator:gae28a8ca0b6474b90708470e82ed9f931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbdfccd62b86ba62ce4b39104a1d419"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6bbdfccd62b86ba62ce4b39104a1d419"></a>
typedef <a class="el" href="group__common__v1__00__a.html#gab3e1c2e36c65f517dcda4ee482eaa749">Xuint16</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u16</b></td></tr>
<tr class="separator:ga6bbdfccd62b86ba62ce4b39104a1d419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9323933281c23292236b0b5f5fcfc7bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9323933281c23292236b0b5f5fcfc7bd"></a>
typedef <a class="el" href="group__common__v1__00__a.html#gad12ffdd1f3aefbaab9c3a2e372b53e88">Xuint8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>u8</b></td></tr>
<tr class="separator:ga9323933281c23292236b0b5f5fcfc7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Memory subtests</h2></td></tr>
<tr class="memitem:ga93cc310a1d400abb7e4658d96c09d568"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__common__v1__00__a.html#ga93cc310a1d400abb7e4658d96c09d568">XUT_ALLMEMTESTS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga93cc310a1d400abb7e4658d96c09d568"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the detailed description of the subtests in the file description.  <a href="#ga93cc310a1d400abb7e4658d96c09d568"></a><br/></td></tr>
<tr class="separator:ga93cc310a1d400abb7e4658d96c09d568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc0d77b47a1a3189b08c2dc308fe9041"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafc0d77b47a1a3189b08c2dc308fe9041"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XUT_INCREMENT</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gafc0d77b47a1a3189b08c2dc308fe9041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a9bbaca7aee2b39e2ae7bebef145c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga76a9bbaca7aee2b39e2ae7bebef145c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XUT_WALKONES</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga76a9bbaca7aee2b39e2ae7bebef145c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e15f0389e9a90b945c0b4cad1973ca8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5e15f0389e9a90b945c0b4cad1973ca8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XUT_WALKZEROS</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga5e15f0389e9a90b945c0b4cad1973ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae727ae724d17b2c5b7e03fc4553ea3ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae727ae724d17b2c5b7e03fc4553ea3ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XUT_INVERSEADDR</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gae727ae724d17b2c5b7e03fc4553ea3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71831986eecc8fe839df3840903fce78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71831986eecc8fe839df3840903fce78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XUT_FIXEDPATTERN</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:ga71831986eecc8fe839df3840903fce78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4c6f4903c367bbc9d6b276d083e931"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd4c6f4903c367bbc9d6b276d083e931"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XUT_MAXTEST</b>&#160;&#160;&#160;XUT_FIXEDPATTERN</td></tr>
<tr class="separator:gadd4c6f4903c367bbc9d6b276d083e931"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga237c4df94339dabd56c08bfa8ef55cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XASSERT_NONVOID</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expression</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                  \</div>
<div class="line">    if (expression)                                \</div>
<div class="line">    {                                              \</div>
<div class="line">        XAssertStatus = XASSERT_NONE;              \</div>
<div class="line">    }                                              \</div>
<div class="line">    else                                           \</div>
<div class="line">    {                                              \</div>
<div class="line">        XAssert(__FILE__, __LINE__);               \</div>
<div class="line">                XAssertStatus = XASSERT_OCCURRED;  \</div>
<div class="line">        return 0;                                  \</div>
<div class="line">    }                                              \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This assert macro is to be used for functions that do return a value. </p>
<p>This in conjunction with the XWaitInAssert boolean can be used to accomodate tests so that asserts which fail allow execution to continue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>is the expression to evaluate. If it evaluates to false, the assert occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 unless the XWaitInAssert variable is true, in which case no return is made and an infinite loop is entered.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__common__v1__00__a.html#ga5c11abd9381dbdec3f55a97b41323ddd">XUtil_MemoryTest16()</a>, <a class="el" href="group__common__v1__00__a.html#gab898ebdd11950907ac66e978d2bd8d92">XUtil_MemoryTest32()</a>, <a class="el" href="group__common__v1__00__a.html#ga777417fa2028d84d0f03ebb3570ea90f">XUtil_MemoryTest8()</a>, <a class="el" href="group__common__v1__00__a.html#gacc5446415b912932b8a428ca698094d5">XVersion_FromString()</a>, and <a class="el" href="group__common__v1__00__a.html#gab85b0654f0b4b643640c57369ecd3bf2">XVersion_IsEqual()</a>.</p>

</div>
</div>
<a class="anchor" id="gabeb9e456a42a06ee1b516bd939dd3750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XASSERT_NONVOID_ALWAYS</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                  \</div>
<div class="line">   XAssert(__FILE__, __LINE__);                    \</div>
<div class="line">           XAssertStatus = XASSERT_OCCURRED;       \</div>
<div class="line">   return 0;                                       \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Always assert. </p>
<p>This assert macro is to be used for functions that do return a value. Use for instances where an assert should always occur.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns void unless the XWaitInAssert variable is true, in which case no return is made and an infinite loop is entered.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1a59ff109b7b674b214f40e07361215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XASSERT_VOID</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expression</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                  \</div>
<div class="line">    if (expression)                                \</div>
<div class="line">    {                                              \</div>
<div class="line">        XAssertStatus = XASSERT_NONE;              \</div>
<div class="line">    }                                              \</div>
<div class="line">    else                                           \</div>
<div class="line">    {                                              \</div>
<div class="line">        XAssert(__FILE__, __LINE__);               \</div>
<div class="line">                XAssertStatus = XASSERT_OCCURRED;  \</div>
<div class="line">        return;                                    \</div>
<div class="line">    }                                              \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This assert macro is to be used for functions that do not return anything (void). </p>
<p>This in conjunction with the XWaitInAssert boolean can be used to accomodate tests so that asserts which fail allow execution to continue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>is the expression to evaluate. If it evaluates to false, the assert occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns void unless the XWaitInAssert variable is true, in which case no return is made and an infinite loop is entered.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>Referenced by <a class="el" href="group__common__v1__00__a.html#gab2a1a40f520ee3c62f829d0e20581503">XVersion_Copy()</a>, and <a class="el" href="group__common__v1__00__a.html#ga20bcd31ada05091e23633264cb63d33c">XVersion_ToString()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f21b82ff570989a66c1addca6fe862a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XASSERT_VOID_ALWAYS</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                  \</div>
<div class="line">   XAssert(__FILE__, __LINE__);                    \</div>
<div class="line">           XAssertStatus = XASSERT_OCCURRED;       \</div>
<div class="line">   return;                                         \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Always assert. </p>
<p>This assert macro is to be used for functions that do not return anything (void). Use for instances where an assert should always occur.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns void unless the XWaitInAssert variable is true, in which case no return is made and an infinite loop is entered.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1e439aeef84a0f2e1f0ad0937d3ccba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCOMPONENT_IS_READY&#160;&#160;&#160;0x11111111</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>component has been initialized </p>

</div>
</div>
<a class="anchor" id="ga8146fba914623632ff0d9edc2acc6a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCOMPONENT_IS_STARTED&#160;&#160;&#160;0x22222222</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>component has been started </p>

</div>
</div>
<a class="anchor" id="ga23d8f4edc8649a0ba9deded0dbb7b05b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_MEM_COPY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DestPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SrcPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;memcpy((void *) DestPtr, (const void *) SrcPtr, (size_t) Bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a non-overlapping block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DestPtr</td><td>Destination address to copy data to.</td></tr>
    <tr><td class="paramname">SrcPtr</td><td>Source address to copy data from.</td></tr>
    <tr><td class="paramname">Bytes</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>XENV_MEM_COPY is deprecated. Use memcpy() instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ga23d8f4edc8649a0ba9deded0dbb7b05b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_MEM_COPY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DestPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SrcPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;memcpy(DestPtr, SrcPtr, Bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a non-overlapping block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DestPtr</td><td>Destination address to copy data to.</td></tr>
    <tr><td class="paramname">SrcPtr</td><td>Source address to copy data from.</td></tr>
    <tr><td class="paramname">Bytes</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga23d8f4edc8649a0ba9deded0dbb7b05b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_MEM_COPY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DestPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SrcPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;memcpy((void *) DestPtr, (const void *) SrcPtr, (size_t) Bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a non-overlapping block of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DestPtr</td><td>Destination address to copy data to.</td></tr>
    <tr><td class="paramname">SrcPtr</td><td>Source address to copy data from.</td></tr>
    <tr><td class="paramname">Bytes</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The use of XENV_MEM_COPY is deprecated. Use memcpy() instead.</dd>
<dd>
This implemention MAY BREAK work if source and target memory area are overlapping. </dd></dl>

</div>
</div>
<a class="anchor" id="gad29b4ad1407af9659a9295b4fab3e64e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_MEM_FILL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DestPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;memset((void *) DestPtr, (int) Data, (size_t) Bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an area of memory with constant data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DestPtr</td><td>Destination address to copy data to.</td></tr>
    <tr><td class="paramname">Data</td><td>Value to set.</td></tr>
    <tr><td class="paramname">Bytes</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>XENV_MEM_FILL is deprecated. Use memset() instead. </dd></dl>

</div>
</div>
<a class="anchor" id="gad29b4ad1407af9659a9295b4fab3e64e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_MEM_FILL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DestPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;memset(DestPtr, Data, Bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an area of memory with constant data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DestPtr</td><td>Destination address to copy data to.</td></tr>
    <tr><td class="paramname">Data</td><td>Value to set.</td></tr>
    <tr><td class="paramname">Bytes</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gad29b4ad1407af9659a9295b4fab3e64e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_MEM_FILL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DestPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;memset((void *) DestPtr, (int) Data, (size_t) Bytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills an area of memory with constant data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DestPtr</td><td>Destination address to copy data to.</td></tr>
    <tr><td class="paramname">Data</td><td>Value to set.</td></tr>
    <tr><td class="paramname">Bytes</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The use of XENV_MEM_FILL is deprecated. Use memset() instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e216393c2fbf374018da12bb110fc88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_DELTA_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp1Ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp2Ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is not yet implemented and always returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Stamp1Ptr</td><td>is the first sampled time stamp. </td></tr>
    <tr><td class="paramname">Stamp2Ptr</td><td>is the second sampled time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None. </p>

</div>
</div>
<a class="anchor" id="ga4e216393c2fbf374018da12bb110fc88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_DELTA_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp1Ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp2Ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is not yet implemented and always returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Stamp1Ptr</td><td>is the first sampled time stamp. </td></tr>
    <tr><td class="paramname">Stamp2Ptr</td><td>is the second sampled time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This macro must be implemented by the user </p>

</div>
</div>
<a class="anchor" id="ga4e216393c2fbf374018da12bb110fc88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_DELTA_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp1Ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp2Ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is not yet implemented and always returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Stamp1Ptr</td><td>is the first sampled time stamp. </td></tr>
    <tr><td class="paramname">Stamp2Ptr</td><td>is the second sampled time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This macro must be implemented by the user. </p>

</div>
</div>
<a class="anchor" id="gaa82c22bd74a502e0cdf081cd2b15f47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_DELTA_US</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp1Ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp2Ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is not yet implemented and always returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Stamp1Ptr</td><td>is the first sampled time stamp. </td></tr>
    <tr><td class="paramname">Stamp2Ptr</td><td>is the second sampled time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa82c22bd74a502e0cdf081cd2b15f47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_DELTA_US</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp1Ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp2Ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is not yet implemented and always returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Stamp1Ptr</td><td>is the first sampled time stamp. </td></tr>
    <tr><td class="paramname">Stamp2Ptr</td><td>is the second sampled time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This macro must be implemented by the user. </p>

</div>
</div>
<a class="anchor" id="gaa82c22bd74a502e0cdf081cd2b15f47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_DELTA_US</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp1Ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Stamp2Ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro is not yet implemented and always returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Stamp1Ptr</td><td>is the first sampled time stamp. </td></tr>
    <tr><td class="paramname">Stamp2Ptr</td><td>is the second sampled time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This macro must be implemented by the user. </p>

</div>
</div>
<a class="anchor" id="ga21fae7ca3043fbd3f73cd6b761afa230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">StampPtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                       \</div>
<div class="line">    vxTimeBaseGet((UINT32*)&amp;(StampPtr)-&gt;TimeBaseUpper,  \</div>
<div class="line">                  (UINT32*)&amp;(StampPtr)-&gt;TimeBaseLower); \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Time is derived from the 64 bit PPC timebase register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StampPtr</td><td>is the storage for the retrieved time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Signature: void <a class="el" href="group__common__v1__00__a.html#ga21fae7ca3043fbd3f73cd6b761afa230" title="Time is derived from the 64 bit PPC timebase register.">XENV_TIME_STAMP_GET(XTIME_STAMP *StampPtr)</a> </p>

</div>
</div>
<a class="anchor" id="ga21fae7ca3043fbd3f73cd6b761afa230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">StampPtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time is derived from the 64 bit PPC timebase register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StampPtr</td><td>is the storage for the retrieved time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Signature: void <a class="el" href="group__common__v1__00__a.html#ga21fae7ca3043fbd3f73cd6b761afa230" title="Time is derived from the 64 bit PPC timebase register.">XENV_TIME_STAMP_GET(XTIME_STAMP *StampPtr)</a> <br/>
<br/>
 This macro must be implemented by the user. </p>

</div>
</div>
<a class="anchor" id="ga21fae7ca3043fbd3f73cd6b761afa230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_TIME_STAMP_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">StampPtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time is derived from the 64 bit PPC timebase register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">StampPtr</td><td>is the storage for the retrieved time stamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Signature: void <a class="el" href="group__common__v1__00__a.html#ga21fae7ca3043fbd3f73cd6b761afa230" title="Time is derived from the 64 bit PPC timebase register.">XENV_TIME_STAMP_GET(XTIME_STAMP *StampPtr)</a> <br/>
<br/>
 This macro must be implemented by the user. </p>

</div>
</div>
<a class="anchor" id="ga45edf2c1128d69e881f9c54d8dcd6a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_USLEEP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">delay</td><td>)</td>
          <td>&#160;&#160;&#160;sysUsDelay(delay)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay the specified number of microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Number of microseconds to delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45edf2c1128d69e881f9c54d8dcd6a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_USLEEP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">delay</td><td>)</td>
          <td>&#160;&#160;&#160;udelay(delay)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay the specified number of microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Number of microseconds to delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>XENV_USLEEP is deprecated. Use udelay() instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45edf2c1128d69e881f9c54d8dcd6a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XENV_USLEEP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">delay</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__common__v1__00__a.html#ga45edf2c1128d69e881f9c54d8dcd6a26" title="XENV_USLEEP(unsigned delay)">XENV_USLEEP(unsigned delay)</a> </p>
<p>Delay the specified number of microseconds. Not implemented without OS support.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Number of microseconds to delay.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ba08d136437c7da95f6825b2e976632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XNULL&#160;&#160;&#160;NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Xilinx NULL, TRUE and FALSE legacy support. </p>
<p>Deprecated. </p>

</div>
</div>
<a class="anchor" id="ga733ac6be9c7e9571dcea62d2ce65522c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUINT64_LSW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x).Lower)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the least significant half of the 64 bit data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the 64 bit word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lower 32 bits of the 64 bit word.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88f27d6c408105d63266828613c6c3e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUINT64_MSW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x).Upper)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the most significant half of the 64 bit data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the 64 bit word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The upper 32 bits of the 64 bit word.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga93cc310a1d400abb7e4658d96c09d568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUT_ALLMEMTESTS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See the detailed description of the subtests in the file description. </p>

<p>Referenced by <a class="el" href="group__common__v1__00__a.html#ga5c11abd9381dbdec3f55a97b41323ddd">XUtil_MemoryTest16()</a>, <a class="el" href="group__common__v1__00__a.html#gab898ebdd11950907ac66e978d2bd8d92">XUtil_MemoryTest32()</a>, and <a class="el" href="group__common__v1__00__a.html#ga777417fa2028d84d0f03ebb3570ea90f">XUtil_MemoryTest8()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5b1b7db368107ff6ebddb3a463dd786b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XAssertCallback)(char *FilenamePtr, int LineNumber)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This data type defines a callback to be invoked when an assert occurs. </p>
<p>The callback is invoked only when asserts are enabled </p>

</div>
</div>
<a class="anchor" id="gad6b7af47c3b5bda2a5aaa98a2cad22d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="group__common__v1__00__a.html#gad6b7af47c3b5bda2a5aaa98a2cad22d7">Xboolean</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>boolean (XTRUE or XFALSE) </p>

</div>
</div>
<a class="anchor" id="gae13dfc6253d3809555cb87f1ac76737a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="struct_x_e_n_v___t_i_m_e___s_t_a_m_p.html">XENV_TIME_STAMP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A structure that contains a time stamp used by other time stamp macros defined below. </p>
<p>This structure is processor dependent. </p>

</div>
</div>
<a class="anchor" id="gae13dfc6253d3809555cb87f1ac76737a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="struct_x_e_n_v___t_i_m_e___s_t_a_m_p.html">XENV_TIME_STAMP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A structure that contains a time stamp used by other time stamp macros defined below. </p>
<p>This structure is processor dependent. </p>

</div>
</div>
<a class="anchor" id="gafac91a7cf7c023c61cd52058caeb4cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XExceptionHandler)(void *InstancePtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This data type defines an exception handler for a processor. </p>
<p>The argument points to the instance of the component </p>

</div>
</div>
<a class="anchor" id="gab167b68461f2aa3c5c2312e73a0ba707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="group__common__v1__00__a.html#gab167b68461f2aa3c5c2312e73a0ba707">Xfloat32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit floating point </p>

</div>
</div>
<a class="anchor" id="ga152feebbf7fef5a26e0c26660861ab03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="group__common__v1__00__a.html#ga152feebbf7fef5a26e0c26660861ab03">Xfloat64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64-bit double precision FP </p>

</div>
</div>
<a class="anchor" id="ga58a139daf1005fea667059c07dca7baf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef short <a class="el" href="group__common__v1__00__a.html#ga58a139daf1005fea667059c07dca7baf">Xint16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 16-bit </p>

</div>
</div>
<a class="anchor" id="gaf205dab7b2384df48b578ad185cae2a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="group__common__v1__00__a.html#gaf205dab7b2384df48b578ad185cae2a7">Xint32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 32-bit </p>

</div>
</div>
<a class="anchor" id="gaa2faa8fec5a68d8a05c5cb4cda20f0a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="group__common__v1__00__a.html#gaa2faa8fec5a68d8a05c5cb4cda20f0a6">Xint8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed 8-bit </p>

</div>
</div>
<a class="anchor" id="gaa5d4da94c76dca492aa80a9966bf1aad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XInterruptHandler)(void *InstancePtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This data type defines an interrupt handler for a device. </p>
<p>The argument points to the instance of the component </p>

</div>
</div>
<a class="anchor" id="gab3e1c2e36c65f517dcda4ee482eaa749"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="group__common__v1__00__a.html#gab3e1c2e36c65f517dcda4ee482eaa749">Xuint16</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 16-bit </p>

</div>
</div>
<a class="anchor" id="ga8cf3b6d075db16e3c6499d3aa39cea86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="group__common__v1__00__a.html#ga8cf3b6d075db16e3c6499d3aa39cea86">Xuint32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 32-bit </p>

</div>
</div>
<a class="anchor" id="gad12ffdd1f3aefbaab9c3a2e372b53e88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="group__common__v1__00__a.html#gad12ffdd1f3aefbaab9c3a2e372b53e88">Xuint8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned 8-bit </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga15bbfbbbf84cb3f772dbbf22f7b07b75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAssert </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>File</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements assert. </p>
<p>Currently, it calls a user-defined callback function if one has been set. Then, it potentially enters an infinite loop depending on the value of the XWaitInAssert variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>is the name of the filename of the source </td></tr>
    <tr><td class="paramname">Line</td><td>is the linenumber within File</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__common__v1__00__a.html#ga70e19ad3b7f3f7facbe157e082614b83">XWaitInAssert</a>.</p>

</div>
</div>
<a class="anchor" id="ga6843e75f679abd8d57f070219aa86fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAssertSetCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common__v1__00__a.html#ga5b1b7db368107ff6ebddb3a463dd786b">XAssertCallback</a>&#160;</td>
          <td class="paramname"><em>Routine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up a callback function to be invoked when an assert occurs. </p>
<p>If there was already a callback installed, then it is replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Routine</td><td>is the callback to be invoked when an assert is taken</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if NDEBUG is set </dd></dl>

</div>
</div>
<a class="anchor" id="gaaecaabeb8ae29619054af3e4a0d6f508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XNullHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>NullParameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Null handler function. </p>
<p>This follows the XInterruptHandler signature for interrupt handlers. It can be used to assign a null handler (a stub) to an interrupt controller vector table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NullParameter</td><td>is an arbitrary void pointer and not used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c11abd9381dbdec3f55a97b41323ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUtil_MemoryTest16 </td>
          <td>(</td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Subtest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a destructive 16-bit wide memory test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Addr</td><td>is a pointer to the region of memory to be tested. </td></tr>
    <tr><td class="paramname">Words</td><td>is the length of the block. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the constant used for the constant pattern test, if 0, 0xDEADBEEF is used. </td></tr>
    <tr><td class="paramname">Subtest</td><td>is the test selected. See <a class="el" href="xutil_8h.html">xutil.h</a> for possible values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<ul>
<li>XST_MEMTEST_FAILED is returned for a failure</li>
<li>XST_SUCCESS is returned for a pass</li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Used for spaces where the address range of the region is smaller than the data width. If the memory range is greater than 2 ** width, the patterns used in XUT_WALKONES and XUT_WALKZEROS will repeat on a boundry of a power of two making it more difficult to detect addressing errors. The XUT_INCREMENT and XUT_INVERSEADDR tests suffer the same problem. Ideally, if large blocks of memory are to be tested, break them up into smaller regions of memory to allow the test patterns used not to repeat over the region tested. </p>

<p>References <a class="el" href="group__common__v1__00__a.html#ga237c4df94339dabd56c08bfa8ef55cff">XASSERT_NONVOID</a>, and <a class="el" href="group__common__v1__00__a.html#ga93cc310a1d400abb7e4658d96c09d568">XUT_ALLMEMTESTS</a>.</p>

</div>
</div>
<a class="anchor" id="gab898ebdd11950907ac66e978d2bd8d92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUtil_MemoryTest32 </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Subtest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a destructive 32-bit wide memory test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Addr</td><td>is a pointer to the region of memory to be tested. </td></tr>
    <tr><td class="paramname">Words</td><td>is the length of the block. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the constant used for the constant pattern test, if 0, 0xDEADBEEF is used. </td></tr>
    <tr><td class="paramname">Subtest</td><td>is the test selected. See <a class="el" href="xutil_8h.html">xutil.h</a> for possible values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<ul>
<li>XST_MEMTEST_FAILED is returned for a failure</li>
<li>XST_SUCCESS is returned for a pass</li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Used for spaces where the address range of the region is smaller than the data width. If the memory range is greater than 2 ** width, the patterns used in XUT_WALKONES and XUT_WALKZEROS will repeat on a boundry of a power of two making it more difficult to detect addressing errors. The XUT_INCREMENT and XUT_INVERSEADDR tests suffer the same problem. Ideally, if large blocks of memory are to be tested, break them up into smaller regions of memory to allow the test patterns used not to repeat over the region tested. </p>

<p>References <a class="el" href="group__common__v1__00__a.html#ga237c4df94339dabd56c08bfa8ef55cff">XASSERT_NONVOID</a>, and <a class="el" href="group__common__v1__00__a.html#ga93cc310a1d400abb7e4658d96c09d568">XUT_ALLMEMTESTS</a>.</p>

</div>
</div>
<a class="anchor" id="ga777417fa2028d84d0f03ebb3570ea90f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUtil_MemoryTest8 </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Subtest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a destructive 8-bit wide memory test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Addr</td><td>is a pointer to the region of memory to be tested. </td></tr>
    <tr><td class="paramname">Words</td><td>is the length of the block. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the constant used for the constant pattern test, if 0, 0xDEADBEEF is used. </td></tr>
    <tr><td class="paramname">Subtest</td><td>is the test selected. See <a class="el" href="xutil_8h.html">xutil.h</a> for possible values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<ul>
<li>XST_MEMTEST_FAILED is returned for a failure</li>
<li>XST_SUCCESS is returned for a pass</li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>Used for spaces where the address range of the region is smaller than the data width. If the memory range is greater than 2 ** width, the patterns used in XUT_WALKONES and XUT_WALKZEROS will repeat on a boundry of a power of two making it more difficult to detect addressing errors. The XUT_INCREMENT and XUT_INVERSEADDR tests suffer the same problem. Ideally, if large blocks of memory are to be tested, break them up into smaller regions of memory to allow the test patterns used not to repeat over the region tested. </p>

<p>References <a class="el" href="group__common__v1__00__a.html#ga237c4df94339dabd56c08bfa8ef55cff">XASSERT_NONVOID</a>, and <a class="el" href="group__common__v1__00__a.html#ga93cc310a1d400abb7e4658d96c09d568">XUT_ALLMEMTESTS</a>.</p>

</div>
</div>
<a class="anchor" id="gab2a1a40f520ee3c62f829d0e20581503"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XVersion_Copy </td>
          <td>(</td>
          <td class="paramtype">XVersion *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XVersion *&#160;</td>
          <td class="paramname"><em>VersionPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the contents of a version to another version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>points to the version which is the source of data for the copy operation. </td></tr>
    <tr><td class="paramname">VersionPtr</td><td>points to another version which is the destination of the copy operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>None.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None. </p>

<p>References <a class="el" href="group__common__v1__00__a.html#gab1a59ff109b7b674b214f40e07361215">XASSERT_VOID</a>.</p>

<p>Referenced by <a class="el" href="group__common__v1__00__a.html#gacc5446415b912932b8a428ca698094d5">XVersion_FromString()</a>, and <a class="el" href="group__common__v1__00__a.html#ga20bcd31ada05091e23633264cb63d33c">XVersion_ToString()</a>.</p>

</div>
</div>
<a class="anchor" id="gacc5446415b912932b8a428ca698094d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XVersion_FromString </td>
          <td>(</td>
          <td class="paramtype">XVersion *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>StringPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a version from a null terminated string. </p>
<p>Since the string may not be a format which is compatible with the version, an error could occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>points to the version which is to be initialized. </td></tr>
    <tr><td class="paramname">StringPtr</td><td>points to a null terminated string which will be converted to a version. The format of the string must match the version string format which is X.YYX where X = 0 - 9, YY = 00 - 99, Z = a - z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>A status, XST_SUCCESS, indicating the conversion was accomplished successfully, or XST_INVALID_VERSION indicating the version string format was not valid.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None. </p>

<p>References <a class="el" href="group__common__v1__00__a.html#ga237c4df94339dabd56c08bfa8ef55cff">XASSERT_NONVOID</a>, and <a class="el" href="group__common__v1__00__a.html#gab2a1a40f520ee3c62f829d0e20581503">XVersion_Copy()</a>.</p>

</div>
</div>
<a class="anchor" id="gab85b0654f0b4b643640c57369ecd3bf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XVersion_IsEqual </td>
          <td>(</td>
          <td class="paramtype">XVersion *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XVersion *&#160;</td>
          <td class="paramname"><em>VersionPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two versions are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>points to the first version to be compared. </td></tr>
    <tr><td class="paramname">VersionPtr</td><td>points to a second version to be compared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>TRUE if the versions are equal, FALSE otherwise.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None. </p>

<p>References <a class="el" href="group__common__v1__00__a.html#ga237c4df94339dabd56c08bfa8ef55cff">XASSERT_NONVOID</a>.</p>

</div>
</div>
<a class="anchor" id="gae2f714e79a99e457e5fb3bb2e1f7b23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XVersion_Pack </td>
          <td>(</td>
          <td class="paramtype">XVersion *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>PackedVersionPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packs a version into the specified packed version. </p>
<p>Versions are packed into the configuration ROM to reduce the amount storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>points to the version to pack. </td></tr>
    <tr><td class="paramname">PackedVersionPtr</td><td>points to the packed version which will receive the new packed version.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>A status, XST_SUCCESS, indicating the packing was accomplished successfully, or an error, XST_INVALID_VERSION, indicating the specified input version was not valid such that the pack did not occur <br/>
<br/>
 The packed version pointed to by PackedVersionPtr is modified with the new packed version if the status indicates success.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>None. </p>

</div>
</div>
<a class="anchor" id="ga20bcd31ada05091e23633264cb63d33c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XVersion_ToString </td>
          <td>(</td>
          <td class="paramtype">XVersion *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>StringPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a version to a null terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>points to the version to convert. </td></tr>
    <tr><td class="paramname">StringPtr</td><td>points to the string which will be the result of the conversion. This does not need to point to a null terminated string as an input, but must point to storage which is an adequate amount to hold the result string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>The null terminated string is inserted at the location pointed to by StringPtr if the status indicates success.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>It is necessary for the caller to have already allocated the storage to contain the string. The amount of memory necessary for the string is specified in the version header file. </p>

<p>References <a class="el" href="group__common__v1__00__a.html#gab1a59ff109b7b674b214f40e07361215">XASSERT_VOID</a>, and <a class="el" href="group__common__v1__00__a.html#gab2a1a40f520ee3c62f829d0e20581503">XVersion_Copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f04afc32d43f30b3d20498f7387b868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XVersion_UnPack </td>
          <td>(</td>
          <td class="paramtype">XVersion *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>PackedVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpacks a packed version into the specified version. </p>
<p>Versions are packed into the configuration ROM to reduce the amount storage. A packed version is a binary format as oppossed to a non-packed version which is implemented as a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>points to the version to unpack the packed version into. </td></tr>
    <tr><td class="paramname">PackedVersion</td><td>contains the packed version to unpack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga34f8bacc03ca6dfb9340c96cd449bb1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XAssertStatus</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable allows testing to be done easier with asserts. </p>
<p>An assert sets this variable such that a driver can evaluate this variable to determine if an assert occurred. </p>

</div>
</div>
<a class="anchor" id="ga34f8bacc03ca6dfb9340c96cd449bb1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XAssertStatus</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable allows testing to be done easier with asserts. </p>
<p>An assert sets this variable such that a driver can evaluate this variable to determine if an assert occurred. </p>

</div>
</div>
<a class="anchor" id="ga70e19ad3b7f3f7facbe157e082614b83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XWaitInAssert = TRUE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable allows the assert functionality to be changed for testing such that it does not wait infinitely. </p>
<p>Use the debugger to disable the waiting during testing of asserts. </p>

<p>Referenced by <a class="el" href="group__common__v1__00__a.html#ga15bbfbbbf84cb3f772dbbf22f7b07b75">XAssert()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
