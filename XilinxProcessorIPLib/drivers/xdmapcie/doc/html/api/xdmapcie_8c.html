<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>xdmapcie: xdmapcie.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">xdmapcie
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xdmapcie_8c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xdmapcie.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>Implements all of functions for <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> IP driver except interrupts and initialization. </p>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who  Date     Changes
</p>
<hr/>
<p>
1.0     tk      01/30/2019      First release
</pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a557a92506060fd460154426bd8c4870c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a557a92506060fd460154426bd8c4870c">XDmaPcie_CfgInitialize</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, <a class="el" href="struct_x_dma_pcie___config.html">XDmaPcie_Config</a> *CfgPtr, UINTPTR EffectiveAddress)</td></tr>
<tr class="memdesc:a557a92506060fd460154426bd8c4870c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance provided by the caller based on the given Config structure.  <a href="#a557a92506060fd460154426bd8c4870c"></a><br/></td></tr>
<tr class="separator:a557a92506060fd460154426bd8c4870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6140581d0eb6e4867a18a996e8e91708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a6140581d0eb6e4867a18a996e8e91708">XDmaPcie_EnumerateFabric</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr)</td></tr>
<tr class="memdesc:a6140581d0eb6e4867a18a996e8e91708"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts PCIe enumeration.  <a href="#a6140581d0eb6e4867a18a996e8e91708"></a><br/></td></tr>
<tr class="separator:a6140581d0eb6e4867a18a996e8e91708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d1050938321b594087912a2272efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#ac61d1050938321b594087912a2272efb">XDmaPcie_GetVsecCapability</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *VersionPtr, u16 *NextCapPtr)</td></tr>
<tr class="memdesc:ac61d1050938321b594087912a2272efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read the VSEC Capability Register.  <a href="#ac61d1050938321b594087912a2272efb"></a><br/></td></tr>
<tr class="separator:ac61d1050938321b594087912a2272efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9acbd19090d9147cdad13913354fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#acf9acbd19090d9147cdad13913354fa6">XDmaPcie_GetVsecHeader</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *RevisionPtr, u16 *LengthPtr)</td></tr>
<tr class="memdesc:acf9acbd19090d9147cdad13913354fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read the VSEC Header Register.  <a href="#acf9acbd19090d9147cdad13913354fa6"></a><br/></td></tr>
<tr class="separator:acf9acbd19090d9147cdad13913354fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83357e666376be50d018b3e0d2d07acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a83357e666376be50d018b3e0d2d07acf">XDmaPcie_GetBridgeInfo</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 *Gen2Ptr, u8 *RootPortPtr, u8 *ECAMSizePtr)</td></tr>
<tr class="memdesc:a83357e666376be50d018b3e0d2d07acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Reads the Bridge info register.  <a href="#a83357e666376be50d018b3e0d2d07acf"></a><br/></td></tr>
<tr class="separator:a83357e666376be50d018b3e0d2d07acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f24eea699cbc956a9705034c5f12607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a5f24eea699cbc956a9705034c5f12607">XDmaPcie_GetRequesterId</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 *BusNumPtr, u8 *DevNumPtr, u8 *FunNumPtr, u8 *PortNumPtr)</td></tr>
<tr class="memdesc:a5f24eea699cbc956a9705034c5f12607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the Bus Location register.  <a href="#a5f24eea699cbc956a9705034c5f12607"></a><br/></td></tr>
<tr class="separator:a5f24eea699cbc956a9705034c5f12607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3533208a920e43d2e9442ca9b02a22a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a3533208a920e43d2e9442ca9b02a22a3">XDmaPcie_GetPhyStatusCtrl</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 *PhyState)</td></tr>
<tr class="memdesc:a3533208a920e43d2e9442ca9b02a22a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read the Phy Status/Control Register.  <a href="#a3533208a920e43d2e9442ca9b02a22a3"></a><br/></td></tr>
<tr class="separator:a3533208a920e43d2e9442ca9b02a22a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baa98cfc13d1f4d209267e80808e3b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a2baa98cfc13d1f4d209267e80808e3b8">XDmaPcie_GetRootPortStatusCtrl</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 *StatusPtr)</td></tr>
<tr class="memdesc:a2baa98cfc13d1f4d209267e80808e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Root Port Status/Control Register.  <a href="#a2baa98cfc13d1f4d209267e80808e3b8"></a><br/></td></tr>
<tr class="separator:a2baa98cfc13d1f4d209267e80808e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f829c82bb17dcc56648246fafa2eaa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a1f829c82bb17dcc56648246fafa2eaa5">XDmaPcie_SetRootPortStatusCtrl</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 StatusData)</td></tr>
<tr class="memdesc:a1f829c82bb17dcc56648246fafa2eaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Value in Root Port Status/Control Register.  <a href="#a1f829c82bb17dcc56648246fafa2eaa5"></a><br/></td></tr>
<tr class="separator:a1f829c82bb17dcc56648246fafa2eaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1641602833f00b16132be700a66e2f93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a1641602833f00b16132be700a66e2f93">XDmaPcie_SetRootPortMSIBase</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, unsigned long long MsiBase)</td></tr>
<tr class="memdesc:a1641602833f00b16132be700a66e2f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write MSI Base Address to Root Port MSI Base Address Register.  <a href="#a1641602833f00b16132be700a66e2f93"></a><br/></td></tr>
<tr class="separator:a1641602833f00b16132be700a66e2f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc77bc991235ea37d13d7bd07032584e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#afc77bc991235ea37d13d7bd07032584e">XDmaPcie_GetRootPortErrFIFOMsg</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u16 *ReqIdPtr, u8 *ErrType, u8 *ErrValid)</td></tr>
<tr class="memdesc:afc77bc991235ea37d13d7bd07032584e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Root Port Error FIFO Message.  <a href="#afc77bc991235ea37d13d7bd07032584e"></a><br/></td></tr>
<tr class="separator:afc77bc991235ea37d13d7bd07032584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae44f206a94bf40daea49281112b46d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a8ae44f206a94bf40daea49281112b46d">XDmaPcie_ClearRootPortErrFIFOMsg</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr)</td></tr>
<tr class="memdesc:a8ae44f206a94bf40daea49281112b46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Root Port Error FIFO Message.  <a href="#a8ae44f206a94bf40daea49281112b46d"></a><br/></td></tr>
<tr class="separator:a8ae44f206a94bf40daea49281112b46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d41c333a761b1c8decb59c19f1ffc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a54d41c333a761b1c8decb59c19f1ffc6">XDmaPcie_GetRootPortIntFIFOReg</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u16 *ReqIdPtr, u16 *MsiAddr, u8 *MsiInt, u8 *IntValid, u16 *MsiMsgData)</td></tr>
<tr class="memdesc:a54d41c333a761b1c8decb59c19f1ffc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Root Port Interrupt FIFO message Register 1 &amp; 2.  <a href="#a54d41c333a761b1c8decb59c19f1ffc6"></a><br/></td></tr>
<tr class="separator:a54d41c333a761b1c8decb59c19f1ffc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9e71d1904e3b6bfca811f5baec640c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a1a9e71d1904e3b6bfca811f5baec640c">XDmaPcie_ClearRootPortIntFIFOReg</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr)</td></tr>
<tr class="memdesc:a1a9e71d1904e3b6bfca811f5baec640c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Root Port FIFO Interrupt message Register 1 &amp; 2.  <a href="#a1a9e71d1904e3b6bfca811f5baec640c"></a><br/></td></tr>
<tr class="separator:a1a9e71d1904e3b6bfca811f5baec640c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9b0cae150260c8ee67c21c3e7cd372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a2c9b0cae150260c8ee67c21c3e7cd372">XDmaPcie_GetLocalBusBar2PcieBar</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 BarNumber, <a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a> *BarAddrPtr)</td></tr>
<tr class="memdesc:a2c9b0cae150260c8ee67c21c3e7cd372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller.  <a href="#a2c9b0cae150260c8ee67c21c3e7cd372"></a><br/></td></tr>
<tr class="separator:a2c9b0cae150260c8ee67c21c3e7cd372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af399300a4c8de88e4545ec848acfbca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#af399300a4c8de88e4545ec848acfbca3">XDmaPcie_SetLocalBusBar2PcieBar</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 BarNumber, <a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a> *BarAddrPtr)</td></tr>
<tr class="memdesc:af399300a4c8de88e4545ec848acfbca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller.  <a href="#af399300a4c8de88e4545ec848acfbca3"></a><br/></td></tr>
<tr class="separator:af399300a4c8de88e4545ec848acfbca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b168437da7bb05a2cdcbc2267df272d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#a0b168437da7bb05a2cdcbc2267df272d">XDmaPcie_ReadLocalConfigSpace</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u16 Offset, u32 *DataPtr)</td></tr>
<tr class="memdesc:a0b168437da7bb05a2cdcbc2267df272d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32-bit value from one of this IP own configuration space.  <a href="#a0b168437da7bb05a2cdcbc2267df272d"></a><br/></td></tr>
<tr class="separator:a0b168437da7bb05a2cdcbc2267df272d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedb6585a8dcbcc40443e7b90932ad6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#aeedb6585a8dcbcc40443e7b90932ad6c">XDmaPcie_WriteLocalConfigSpace</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u16 Offset, u32 Data)</td></tr>
<tr class="memdesc:aeedb6585a8dcbcc40443e7b90932ad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32-bit value to one of this IP own configuration space.  <a href="#aeedb6585a8dcbcc40443e7b90932ad6c"></a><br/></td></tr>
<tr class="separator:aeedb6585a8dcbcc40443e7b90932ad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac6261cddb63084c8ee87518e99edef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#adac6261cddb63084c8ee87518e99edef">XDmaPcie_ReadRemoteConfigSpace</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 *DataPtr)</td></tr>
<tr class="memdesc:adac6261cddb63084c8ee87518e99edef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32-bit value from external PCIe Function's configuration space.  <a href="#adac6261cddb63084c8ee87518e99edef"></a><br/></td></tr>
<tr class="separator:adac6261cddb63084c8ee87518e99edef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47beee6caa44ae3f91979be9cd531bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8c.html#ad47beee6caa44ae3f91979be9cd531bf">XDmaPcie_WriteRemoteConfigSpace</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 Data)</td></tr>
<tr class="memdesc:ad47beee6caa44ae3f91979be9cd531bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32-bit value to external PCIe function's configuration space.  <a href="#ad47beee6caa44ae3f91979be9cd531bf"></a><br/></td></tr>
<tr class="separator:ad47beee6caa44ae3f91979be9cd531bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a557a92506060fd460154426bd8c4870c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDmaPcie_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie___config.html">XDmaPcie_Config</a> *&#160;</td>
          <td class="paramname"><em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance provided by the caller based on the given Config structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on.The memory of the pointer references must be pre-allocated by the caller. </td></tr>
    <tr><td class="paramname">CfgPtr</td><td>is the device configuration structure containing required HW build data. </td></tr>
    <tr><td class="paramname">EffectiveAddress</td><td>is the Physical address of the hardware in a Virtual Memory operating system environment.It is the Base Address in a stand alone environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><pre class="fragment">            - XST_SUCCESS Initialization was successful.
</pre></dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="struct_x_dma_pcie.html#a25bda690bb4c8e6c28b23b63eea79f0f">XDmaPcie::MaxNumOfBuses</a>, <a class="el" href="xdmapcie__hw_8h.html#abcda754d0a61c43d447fadb67aaa7434">XDMAPCIE_BI_ECAM_SIZE_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a4a8456b90f69f3ca2c3a8db12ea24ee8">XDMAPCIE_BI_ECAM_SIZE_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a3608f25f453e0135ff2e2bd6a160533c">XDMAPCIE_BI_OFFSET</a>, <a class="el" href="xdmapcie_8h.html#a086244f1e8866721dbb016893814281a">XDmaPcie_DisableInterrupts()</a>, <a class="el" href="xdmapcie__hw_8h.html#a41b00f72c89e54b044acfcd7bb7dfc86">XDMAPCIE_IM_DISABLE_ALL_MASK</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ae44f206a94bf40daea49281112b46d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ClearRootPortErrFIFOMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Root Port Error FIFO Message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a46d0aae62d5b3314d9eb4ef5830b4ec0">XDMAPCIE_RPEFR_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a1a9e71d1904e3b6bfca811f5baec640c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ClearRootPortIntFIFOReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Root Port FIFO Interrupt message Register 1 &amp; 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex.Clearing any one Interrupt FIFO register clears both registers. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a2d3fa8b6821762a92a973e4b1d341f12">XDMAPCIE_RPIFR1_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a6140581d0eb6e4867a18a996e8e91708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_EnumerateFabric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts PCIe enumeration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> Instance Pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a83357e666376be50d018b3e0d2d07acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetBridgeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Gen2Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>RootPortPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ECAMSizePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Reads the Bridge info register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">Gen2Ptr</td><td>is a pointer to a variable indicating whether underlying PCIe block support PCIe Gen2 Speed. </td></tr>
    <tr><td class="paramname">RootPortPtr</td><td>is a pointer to a variable indication whether underlying PCIe block is root port. </td></tr>
    <tr><td class="paramname">ECAMSizePtr</td><td>is a pointer to a variable where it indicates ECAM size. Value is between 1 to 8. Total address bits dedicated to ECAM is 20 + ECAM size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#abcda754d0a61c43d447fadb67aaa7434">XDMAPCIE_BI_ECAM_SIZE_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a4a8456b90f69f3ca2c3a8db12ea24ee8">XDMAPCIE_BI_ECAM_SIZE_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a2799a39816b787225defc73fb71b174a">XDMAPCIE_BI_GEN2_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a3608f25f453e0135ff2e2bd6a160533c">XDMAPCIE_BI_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a1341b82af3253d651248943c9c106b85">XDMAPCIE_BI_RP_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#ae4893d95f81629e3f530ac3f469865ec">XDMAPCIE_BI_RP_SHIFT</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a2c9b0cae150260c8ee67c21c3e7cd372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetLocalBusBar2PcieBar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>BarNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a> *&#160;</td>
          <td class="paramname"><em>BarAddrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">BarNumber</td><td>is AXI bar number (0 - 5) passed by caller. </td></tr>
    <tr><td class="paramname">BarAddrPtr</td><td>is a pointer to a variable where the driver will . pass back translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#afbfd4139360acfa0164369df56161dd2">XDmaPcie_Config::IncludeBarOffsetReg</a>, <a class="el" href="struct_x_dma_pcie___bar_addr.html#a4e4e0b8f0689604c8984699fc9fa2fce">XDmaPcie_BarAddr::LowerAddr</a>, <a class="el" href="struct_x_dma_pcie___bar_addr.html#aecbed94db7ecb38d5e95ce10a6d1bf39">XDmaPcie_BarAddr::UpperAddr</a>, <a class="el" href="xdmapcie__hw_8h.html#a51aeaa8592563052dfac4d5c7c5ee606">XDMAPCIE_AXIBAR2PCIBAR_0L_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a5c9801387aa82ecd82ef7eeb15224636">XDMAPCIE_AXIBAR2PCIBAR_0U_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a3533208a920e43d2e9442ca9b02a22a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetPhyStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>PhyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read the Phy Status/Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">PhyState</td><td>is a pointer to a variable where the driver will pass back Current physical status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a571a1cd55e8f810fb91fcfebc441ee46">XDMAPCIE_PHYSC_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a5f24eea699cbc956a9705034c5f12607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetRequesterId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>BusNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DevNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>FunNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>PortNumPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the Bus Location register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">BusNumPtr</td><td>is a pointer to a variable where the driver will pass back the bus number of requester ID assigned to IP. </td></tr>
    <tr><td class="paramname">DevNumPtr</td><td>is a pointer to a variable where the driver will pass back the device number of requester ID assigned to IP. </td></tr>
    <tr><td class="paramname">FunNumPtr</td><td>is a pointer to a variable where the driver will pass back the function number of requester ID assigned to IP. </td></tr>
    <tr><td class="paramname">PortNumPtr</td><td>is a pointer to a variable where the driver will pass back the Port number of requester ID assigned to IP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#ac59090cdcbe3d2156f27165a33e21d3c">XDMAPCIE_BL_BUS_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#acc86d34d06e7fd42e5289dbc30aa680e">XDMAPCIE_BL_BUS_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a2b76774fe73eb5ddac64acd04d18a8f2">XDMAPCIE_BL_DEV_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a77a9c17fea6e28f4daa1a40b933d38e0">XDMAPCIE_BL_DEV_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#af5b647370bc05fa2a455f1569f7d5ef7">XDMAPCIE_BL_FUNC_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a31d2fdd979d3087f69bd97eb52b4c499">XDMAPCIE_BL_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#acf6e6d7e43697c4b98bbf6f645f901dd">XDMAPCIE_BL_PORT_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#ac94b2bf9a1b1abfccc5c67b8e2fed743">XDMAPCIE_BL_PORT_SHIFT</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="afc77bc991235ea37d13d7bd07032584e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetRootPortErrFIFOMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>ReqIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ErrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ErrValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Root Port Error FIFO Message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">ReqIdPtr</td><td>is a variable where the driver will pass back the requester Id of error message. </td></tr>
    <tr><td class="paramname">ErrType</td><td>is a variable where the driver will pass back the type of error message </td></tr>
    <tr><td class="paramname">ErrValid</td><td>is a variable where the driver will pass back the status of read operation of error message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, <a class="el" href="xdmapcie__hw_8h.html#abd07ee76293490abe91819f9aef8bc56">XDMAPCIE_RPEFR_ERR_TYPE_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#aef51c54b8bc8f6695dee6c0260e6be08">XDMAPCIE_RPEFR_ERR_TYPE_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a854a4541c2d8ccb05ddf14b86882ebe6">XDMAPCIE_RPEFR_ERR_VALID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#aa0ea8677de2e2270781a5589086d7387">XDMAPCIE_RPEFR_ERR_VALID_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a46d0aae62d5b3314d9eb4ef5830b4ec0">XDMAPCIE_RPEFR_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#ae864fe8e0611b31480e861fb1a48582f">XDMAPCIE_RPEFR_REQ_ID_MASK</a>.</p>

</div>
</div>
<a class="anchor" id="a54d41c333a761b1c8decb59c19f1ffc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDmaPcie_GetRootPortIntFIFOReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>ReqIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>MsiAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>MsiInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>IntValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>MsiMsgData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Root Port Interrupt FIFO message Register 1 &amp; 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">ReqIdPtr</td><td>is a variable where the driver will pass back the requester Id of error message. </td></tr>
    <tr><td class="paramname">MsiAddr</td><td>is a variable where the driver will pass back the MSI address for which interrupt message recieved. </td></tr>
    <tr><td class="paramname">MsiInt</td><td>is a variable where the driver will pass back the type of interrupt message recieved (MSI/INTx). </td></tr>
    <tr><td class="paramname">IntValid</td><td>is a variable where the driver will pass back the status of read operation of interrupt message. </td></tr>
    <tr><td class="paramname">MsiMsgData</td><td>is a variable where the driver will pass back the MSI data recieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MsiMsgData if MSI interrupt is observed or 0 if there is no MSI interrupt.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, <a class="el" href="xdmapcie__hw_8h.html#a2e7d4992c3815b1b8e976cc90baa99e7">XDMAPCIE_RPIFR1_INTR_VALID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#abc20d6f07d915eeeda963f3bc44ce978">XDMAPCIE_RPIFR1_INTR_VALID_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a7313a92a55b01bef8f6d0ee23015bd21">XDMAPCIE_RPIFR1_MSI_ADDR_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#aa13faabf819e0c4fdb157650e1db8ca1">XDMAPCIE_RPIFR1_MSI_ADDR_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a6a5ab88c6292ec6e362f74bd6c9cae4b">XDMAPCIE_RPIFR1_MSIINTR_VALID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#aa39c481cf7526edda33a09cdba1f525e">XDMAPCIE_RPIFR1_MSIINTR_VALID_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a2d3fa8b6821762a92a973e4b1d341f12">XDMAPCIE_RPIFR1_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a4bece0606c363a0cc4778e270fdbb711">XDMAPCIE_RPIFR1_REQ_ID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a2806e420f58fa46b4c36e5c82d401e88">XDMAPCIE_RPIFR2_MSG_DATA_MASK</a>, and <a class="el" href="xdmapcie__hw_8h.html#ad5f6e8d589fe6f5a01e312a8f092799c">XDMAPCIE_RPIFR2_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a2baa98cfc13d1f4d209267e80808e3b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetRootPortStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>StatusPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Root Port Status/Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">StatusPtr</td><td>is a pointer to a variable where the driver will pass back the root port status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#ab68d32651b96f4c8a6cc6c7549509c82">XDMAPCIE_RPSC_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="ac61d1050938321b594087912a2272efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetVsecCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>VsecNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>VsecIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>VersionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>NextCapPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read the VSEC Capability Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">VsecNum</td><td>is a VSEC register number as there are two registers. Possible values are.<ul>
<li>XDMAPCIE_VSEC1 (0)</li>
<li>XDMAPCIE_VSEC2 (1) </li>
</ul>
</td></tr>
    <tr><td class="paramname">VsecIdPtr</td><td>is a pointer to a variable where the driver will pass back the Vendor Specific Enhanced Capability ID. </td></tr>
    <tr><td class="paramname">VersionPtr</td><td>is a pointer to a variable where the driver will . pass back the Version of VSEC. </td></tr>
    <tr><td class="paramname">NextCapPtr</td><td>is a pointer to a variable where the driver will pass back the Next Capability offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, <a class="el" href="xdmapcie__hw_8h.html#a405f9e3195f36f58bd6685bba2231ffb">XDMAPCIE_VSECC_ID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a848f1c9bd9cdd5b2b9100f46b7353edb">XDMAPCIE_VSECC_NEXT_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a9e335708c508110cad0e5c36cacb9eac">XDMAPCIE_VSECC_NEXT_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a16f5d7b6b585ac5ac0fcd5189889c104">XDMAPCIE_VSECC_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a34df2e3887910bf3d736e98a983dcdbf">XDMAPCIE_VSECC_VER_MASK</a>, and <a class="el" href="xdmapcie__hw_8h.html#a019c307ea457a54fe5cffb84f4f807bd">XDMAPCIE_VSECC_VER_SHIFT</a>.</p>

</div>
</div>
<a class="anchor" id="acf9acbd19090d9147cdad13913354fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetVsecHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>VsecNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>VsecIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>RevisionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>LengthPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read the VSEC Header Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">VsecNum</td><td>is a VSEC register number as there are two registers. Possible values are.<ul>
<li>XDMAPCIE_VSEC1 (0)</li>
<li>XDMAPCIE_VSEC2 (1) </li>
</ul>
</td></tr>
    <tr><td class="paramname">VsecIdPtr</td><td>is a pointer to a variable where the driver will pass back the VSEC header structure Id. </td></tr>
    <tr><td class="paramname">RevisionPtr</td><td>is a pointer to a variable where the driver will pass back the Revision of VSEC capability Structure. </td></tr>
    <tr><td class="paramname">LengthPtr</td><td>is a pointer to a variable where the driver will pass . back the length of the VSEC capability structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, <a class="el" href="xdmapcie__hw_8h.html#ad729068100112d67c4a08830e6a12b4d">XDMAPCIE_VSECH_ID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a1471191e3dbfee9c528d5c42a1f6691f">XDMAPCIE_VSECH_LEN_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a324566449eb7d1f827007b13f8c3c127">XDMAPCIE_VSECH_LEN_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#ae6596b5eb3e9c22bc43c90a57ed9945f">XDMAPCIE_VSECH_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a29d0c0b9219248958c08a5a557b01309">XDMAPCIE_VSECH_REV_MASK</a>, and <a class="el" href="xdmapcie__hw_8h.html#a45941794e0251d660ceb5b2ff390155a">XDMAPCIE_VSECH_REV_SHIFT</a>.</p>

</div>
</div>
<a class="anchor" id="a0b168437da7bb05a2cdcbc2267df272d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ReadLocalConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>DataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 32-bit value from one of this IP own configuration space. </p>
<p>Location is identified by its offset from the beginning of the configuration space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">Offset</td><td>from beginning of IP own configuration space. </td></tr>
    <tr><td class="paramname">DataPtr</td><td>is a pointer to a variable where the driver will pass back the value read from the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a1083266540141374178a8efd47a8c838">XDMAPCIE_PCIE_CORE_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="adac6261cddb63084c8ee87518e99edef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ReadRemoteConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>DataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 32-bit value from external PCIe Function's configuration space. </p>
<p>External PCIe function is identified by its Requester ID (Bus#, Device#, Function#). Location is identified by its offset from the begginning of the configuration space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">Bus</td><td>is the external PCIe function's Bus number. </td></tr>
    <tr><td class="paramname">Device</td><td>is the external PCIe function's Device number. </td></tr>
    <tr><td class="paramname">Function</td><td>is the external PCIe function's Function number. </td></tr>
    <tr><td class="paramname">Offset</td><td>from beggininng of PCIe function's configuration space. </td></tr>
    <tr><td class="paramname">DataPtr</td><td>is a pointer to a variable where the driver will pass back the value read from the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. The XDmaPcie_ReadLocalConfigSpace API should be used for reading the local config space. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="struct_x_dma_pcie.html#a25bda690bb4c8e6c28b23b63eea79f0f">XDmaPcie::MaxNumOfBuses</a>, <a class="el" href="xdmapcie_8h.html#aa0a061bd0519f5b946c0abe0d4b6bddd">XDmaPcie_IsEcamBusy</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__caps_8c.html#ac232d6bc0efdff01bf3aff950049cf27">XDmaPcie_GetCapability()</a>, <a class="el" href="xdmapcie__caps_8c.html#ae856a9480f2bbf119a71810e12ac5ff7">XDmaPcie_HasCapability()</a>, and <a class="el" href="xdmapcie__caps_8c.html#a7106f923ba6532a0533e39afdf6728c2">XDmaPcie_PrintAllCapabilites()</a>.</p>

</div>
</div>
<a class="anchor" id="af399300a4c8de88e4545ec848acfbca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_SetLocalBusBar2PcieBar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>BarNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a> *&#160;</td>
          <td class="paramname"><em>BarAddrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data.">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">BarNumber</td><td>is AXI bar number (0 - 5) passed by caller. </td></tr>
    <tr><td class="paramname">BarAddrPtr</td><td>is a pointer to a variable where the driver will pass back translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#afbfd4139360acfa0164369df56161dd2">XDmaPcie_Config::IncludeBarOffsetReg</a>, <a class="el" href="struct_x_dma_pcie___bar_addr.html#a4e4e0b8f0689604c8984699fc9fa2fce">XDmaPcie_BarAddr::LowerAddr</a>, <a class="el" href="struct_x_dma_pcie___bar_addr.html#aecbed94db7ecb38d5e95ce10a6d1bf39">XDmaPcie_BarAddr::UpperAddr</a>, <a class="el" href="xdmapcie__hw_8h.html#a51aeaa8592563052dfac4d5c7c5ee606">XDMAPCIE_AXIBAR2PCIBAR_0L_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a5c9801387aa82ecd82ef7eeb15224636">XDMAPCIE_AXIBAR2PCIBAR_0U_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a1641602833f00b16132be700a66e2f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDmaPcie_SetRootPortMSIBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>MsiBase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write MSI Base Address to Root Port MSI Base Address Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">MsiBase</td><td>is 64 bit base address for MSI.This address should be 4kB aligned always.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if success or XST_FAILURE if failure .</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#ac29f522978bcd22ada72cd32e6d2ad1f">XDMAPCIE_RPMSIB_LOWER_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a39e3da3783cd1ae36538dda9353bd662">XDMAPCIE_RPMSIB_LOWER_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#aa7c2a15bd965cf4c40c6ef0467840f3c">XDMAPCIE_RPMSIB_UPPER_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a2c7a2d9d74f6b92651fe50bddbb5e594">XDMAPCIE_RPMSIB_UPPER_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a1f829c82bb17dcc56648246fafa2eaa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_SetRootPortStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>StatusData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write Value in Root Port Status/Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">StatusData</td><td>is data to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a8e480ce2a44fd9f14991d2421c4db0c7">XDMAPCIE_RPSC_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#ab68d32651b96f4c8a6cc6c7549509c82">XDMAPCIE_RPSC_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="aeedb6585a8dcbcc40443e7b90932ad6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_WriteLocalConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 32-bit value to one of this IP own configuration space. </p>
<p>Location is identified by its offset from the begginning of the configuration space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">Offset</td><td>from beggininng of IP own configuration space. </td></tr>
    <tr><td class="paramname">Data</td><td>to be written to the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a1083266540141374178a8efd47a8c838">XDMAPCIE_PCIE_CORE_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="ad47beee6caa44ae3f91979be9cd531bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_WriteRemoteConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 32-bit value to external PCIe function's configuration space. </p>
<p>External PCIe function is identified by its Requester ID (Bus#, Device#, Function#). Location is identified by its offset from the begginning of the configuration space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">Bus</td><td>is the external PCIe function's Bus number. </td></tr>
    <tr><td class="paramname">Device</td><td>is the external PCIe function's Device number. </td></tr>
    <tr><td class="paramname">Function</td><td>is the external PCIe function's Function number. </td></tr>
    <tr><td class="paramname">Offset</td><td>from beggininng of PCIe function's configuration space. </td></tr>
    <tr><td class="paramname">Data</td><td>to be written to the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. The XDmaPcie_WriteLocalConfigSpace should be used for writing to local config space. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="struct_x_dma_pcie.html#a25bda690bb4c8e6c28b23b63eea79f0f">XDmaPcie::MaxNumOfBuses</a>, <a class="el" href="xdmapcie_8h.html#aa0a061bd0519f5b946c0abe0d4b6bddd">XDmaPcie_IsEcamBusy</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
