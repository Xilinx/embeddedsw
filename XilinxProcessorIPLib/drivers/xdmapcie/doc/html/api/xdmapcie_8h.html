<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>xdmapcie: xdmapcie.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">xdmapcie
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="pages.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('xdmapcie_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xdmapcie.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<div class="textblock"><p>This file contains the software API definition of the Xilinx XDMA PCIe IP (XDma_0). </p>
<p>This driver provides "C" function interface to application/upper layer to access the hardware.</p>
<p><b>Features</b> The driver provides its user with entry points</p>
<ul>
<li>To initialize and configure itself and the hardware</li>
<li>To access PCIe configuration space locally</li>
</ul>
<p><b>Driver Initialization &amp; Configuration</b></p>
<p>The <a class="el" href="struct_x_dma_pcie___config.html" title="This typedef contains IP hardware configuration information. ">XDmaPcie_Config</a> structure is used by the driver to configure itself. This configuration structure is typically created by the tool-chain based on HW build properties.</p>
<p>To support multiple runtime loading and initialization strategies employed by various operating systems, the driver instance can be initialized in the following way:</p>
<ul>
<li>XDmaPcie_LookupConfig(DeviceId) - Use the device identifier to find the static configuration structure defined in xdmapcie_g.c. This is setup by the tools.</li>
<li>XDmaPcie_CfgInitialize(InstancePtr, CfgPtr, EffectiveAddr) - Uses a configuration structure provided by the caller. If running in a system with address translation, the provided virtual memory base address replaces the physical address present in the configuration structure.</li>
</ul>
<p><b>Interrupt Management</b></p>
<p>The <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> driver provides interrupt management functions. It allows the caller to enable/disable each individual interrupt as well as get/clear pending interrupts. Implementation of callback handlers is left to the user.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who  Date     Changes
</p>
<hr/>
<p>
1.0     tk      01/30/2019      First release
</pre> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dma_pcie___config.html">XDmaPcie_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains IP hardware configuration information.  <a href="struct_x_dma_pcie___config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> driver instance data.  <a href="struct_x_dma_pcie.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user is required to use this strucuture when reading or writing translation vector between local bus BARs and XDMA PCIe BARs.  <a href="struct_x_dma_pcie___bar_addr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a11bdbeb0f844db1d203f2b8f6f29ca5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a11bdbeb0f844db1d203f2b8f6f29ca5c">MAX_BARS</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a11bdbeb0f844db1d203f2b8f6f29ca5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">No BAR allocation for Bridge.  <a href="#a11bdbeb0f844db1d203f2b8f6f29ca5c">More...</a><br/></td></tr>
<tr class="separator:a11bdbeb0f844db1d203f2b8f6f29ca5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad74e57979d6bc62e24ddaa31ed11e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#acad74e57979d6bc62e24ddaa31ed11e9">REQ_SIZE</a>&#160;&#160;&#160;(<a class="el" href="xdmapcie_8h.html#a11bdbeb0f844db1d203f2b8f6f29ca5c">MAX_BARS</a> * sizeof(unsigned long))</td></tr>
<tr class="memdesc:acad74e57979d6bc62e24ddaa31ed11e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required size for BAR Alignment.  <a href="#acad74e57979d6bc62e24ddaa31ed11e9">More...</a><br/></td></tr>
<tr class="separator:acad74e57979d6bc62e24ddaa31ed11e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0bb20942845552762a968ec77c293d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a2b0bb20942845552762a968ec77c293d">XDMAPCIE_VSEC1</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:a2b0bb20942845552762a968ec77c293d"><td class="mdescLeft">&#160;</td><td class="mdescRight">First VSEC Register.  <a href="#a2b0bb20942845552762a968ec77c293d">More...</a><br/></td></tr>
<tr class="separator:a2b0bb20942845552762a968ec77c293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc3d3815b4f50f3a1a4a7fe01cc863d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a9fc3d3815b4f50f3a1a4a7fe01cc863d">XDMAPCIE_VSEC2</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:a9fc3d3815b4f50f3a1a4a7fe01cc863d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second VSEC Register.  <a href="#a9fc3d3815b4f50f3a1a4a7fe01cc863d">More...</a><br/></td></tr>
<tr class="separator:a9fc3d3815b4f50f3a1a4a7fe01cc863d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2f08fcc93b4783bec918f9a607fe21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#abb2f08fcc93b4783bec918f9a607fe21">XDmaPcie_IsLinkUp</a>(InstancePtr)</td></tr>
<tr class="memdesc:abb2f08fcc93b4783bec918f9a607fe21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether link is up or not.  <a href="#abb2f08fcc93b4783bec918f9a607fe21">More...</a><br/></td></tr>
<tr class="separator:abb2f08fcc93b4783bec918f9a607fe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a061bd0519f5b946c0abe0d4b6bddd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#aa0a061bd0519f5b946c0abe0d4b6bddd">XDmaPcie_IsEcamBusy</a>(InstancePtr)</td></tr>
<tr class="memdesc:aa0a061bd0519f5b946c0abe0d4b6bddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether ECAM is busy or not.  <a href="#aa0a061bd0519f5b946c0abe0d4b6bddd">More...</a><br/></td></tr>
<tr class="separator:aa0a061bd0519f5b946c0abe0d4b6bddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5554a1ee852247fccc227fb9e3aff8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_dma_pcie___config.html">XDmaPcie_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a5554a1ee852247fccc227fb9e3aff8ac">XDmaPcie_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:a5554a1ee852247fccc227fb9e3aff8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the device configuration based on the unique device ID.  <a href="#a5554a1ee852247fccc227fb9e3aff8ac">More...</a><br/></td></tr>
<tr class="separator:a5554a1ee852247fccc227fb9e3aff8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557a92506060fd460154426bd8c4870c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a557a92506060fd460154426bd8c4870c">XDmaPcie_CfgInitialize</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, <a class="el" href="struct_x_dma_pcie___config.html">XDmaPcie_Config</a> *CfgPtr, UINTPTR EffectiveAddress)</td></tr>
<tr class="memdesc:a557a92506060fd460154426bd8c4870c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance provided by the caller based on the given Config structure.  <a href="#a557a92506060fd460154426bd8c4870c">More...</a><br/></td></tr>
<tr class="separator:a557a92506060fd460154426bd8c4870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d1050938321b594087912a2272efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#ac61d1050938321b594087912a2272efb">XDmaPcie_GetVsecCapability</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *VersionPtr, u16 *NextCapPtr)</td></tr>
<tr class="memdesc:ac61d1050938321b594087912a2272efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read the VSEC Capability Register.  <a href="#ac61d1050938321b594087912a2272efb">More...</a><br/></td></tr>
<tr class="separator:ac61d1050938321b594087912a2272efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9acbd19090d9147cdad13913354fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#acf9acbd19090d9147cdad13913354fa6">XDmaPcie_GetVsecHeader</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *RevisionPtr, u16 *LengthPtr)</td></tr>
<tr class="memdesc:acf9acbd19090d9147cdad13913354fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read the VSEC Header Register.  <a href="#acf9acbd19090d9147cdad13913354fa6">More...</a><br/></td></tr>
<tr class="separator:acf9acbd19090d9147cdad13913354fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83357e666376be50d018b3e0d2d07acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a83357e666376be50d018b3e0d2d07acf">XDmaPcie_GetBridgeInfo</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 *Gen2Ptr, u8 *RootPortPtr, u8 *ECAMSizePtr)</td></tr>
<tr class="memdesc:a83357e666376be50d018b3e0d2d07acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Reads the Bridge info register.  <a href="#a83357e666376be50d018b3e0d2d07acf">More...</a><br/></td></tr>
<tr class="separator:a83357e666376be50d018b3e0d2d07acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f24eea699cbc956a9705034c5f12607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a5f24eea699cbc956a9705034c5f12607">XDmaPcie_GetRequesterId</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 *BusNumPtr, u8 *DevNumPtr, u8 *FunNumPtr, u8 *PortNumPtr)</td></tr>
<tr class="memdesc:a5f24eea699cbc956a9705034c5f12607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the Bus Location register.  <a href="#a5f24eea699cbc956a9705034c5f12607">More...</a><br/></td></tr>
<tr class="separator:a5f24eea699cbc956a9705034c5f12607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3533208a920e43d2e9442ca9b02a22a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a3533208a920e43d2e9442ca9b02a22a3">XDmaPcie_GetPhyStatusCtrl</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 *PhyState)</td></tr>
<tr class="memdesc:a3533208a920e43d2e9442ca9b02a22a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to read the Phy Status/Control Register.  <a href="#a3533208a920e43d2e9442ca9b02a22a3">More...</a><br/></td></tr>
<tr class="separator:a3533208a920e43d2e9442ca9b02a22a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baa98cfc13d1f4d209267e80808e3b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a2baa98cfc13d1f4d209267e80808e3b8">XDmaPcie_GetRootPortStatusCtrl</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 *StatusPtr)</td></tr>
<tr class="memdesc:a2baa98cfc13d1f4d209267e80808e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Root Port Status/Control Register.  <a href="#a2baa98cfc13d1f4d209267e80808e3b8">More...</a><br/></td></tr>
<tr class="separator:a2baa98cfc13d1f4d209267e80808e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f829c82bb17dcc56648246fafa2eaa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a1f829c82bb17dcc56648246fafa2eaa5">XDmaPcie_SetRootPortStatusCtrl</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 StatusData)</td></tr>
<tr class="memdesc:a1f829c82bb17dcc56648246fafa2eaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Value in Root Port Status/Control Register.  <a href="#a1f829c82bb17dcc56648246fafa2eaa5">More...</a><br/></td></tr>
<tr class="separator:a1f829c82bb17dcc56648246fafa2eaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1641602833f00b16132be700a66e2f93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a1641602833f00b16132be700a66e2f93">XDmaPcie_SetRootPortMSIBase</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, unsigned long long MsiBase)</td></tr>
<tr class="memdesc:a1641602833f00b16132be700a66e2f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write MSI Base Address to Root Port MSI Base Address Register.  <a href="#a1641602833f00b16132be700a66e2f93">More...</a><br/></td></tr>
<tr class="separator:a1641602833f00b16132be700a66e2f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc77bc991235ea37d13d7bd07032584e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#afc77bc991235ea37d13d7bd07032584e">XDmaPcie_GetRootPortErrFIFOMsg</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u16 *ReqIdPtr, u8 *ErrType, u8 *ErrValid)</td></tr>
<tr class="memdesc:afc77bc991235ea37d13d7bd07032584e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Root Port Error FIFO Message.  <a href="#afc77bc991235ea37d13d7bd07032584e">More...</a><br/></td></tr>
<tr class="separator:afc77bc991235ea37d13d7bd07032584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae44f206a94bf40daea49281112b46d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a8ae44f206a94bf40daea49281112b46d">XDmaPcie_ClearRootPortErrFIFOMsg</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr)</td></tr>
<tr class="memdesc:a8ae44f206a94bf40daea49281112b46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Root Port Error FIFO Message.  <a href="#a8ae44f206a94bf40daea49281112b46d">More...</a><br/></td></tr>
<tr class="separator:a8ae44f206a94bf40daea49281112b46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d41c333a761b1c8decb59c19f1ffc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a54d41c333a761b1c8decb59c19f1ffc6">XDmaPcie_GetRootPortIntFIFOReg</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u16 *ReqIdPtr, u16 *MsiAddr, u8 *MsiInt, u8 *IntValid, u16 *MsiMsgData)</td></tr>
<tr class="memdesc:a54d41c333a761b1c8decb59c19f1ffc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Root Port Interrupt FIFO message Register 1 &amp; 2.  <a href="#a54d41c333a761b1c8decb59c19f1ffc6">More...</a><br/></td></tr>
<tr class="separator:a54d41c333a761b1c8decb59c19f1ffc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9e71d1904e3b6bfca811f5baec640c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a1a9e71d1904e3b6bfca811f5baec640c">XDmaPcie_ClearRootPortIntFIFOReg</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr)</td></tr>
<tr class="memdesc:a1a9e71d1904e3b6bfca811f5baec640c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Root Port FIFO Interrupt message Register 1 &amp; 2.  <a href="#a1a9e71d1904e3b6bfca811f5baec640c">More...</a><br/></td></tr>
<tr class="separator:a1a9e71d1904e3b6bfca811f5baec640c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9b0cae150260c8ee67c21c3e7cd372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a2c9b0cae150260c8ee67c21c3e7cd372">XDmaPcie_GetLocalBusBar2PcieBar</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 BarNumber, <a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a> *BarAddrPtr)</td></tr>
<tr class="memdesc:a2c9b0cae150260c8ee67c21c3e7cd372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller.  <a href="#a2c9b0cae150260c8ee67c21c3e7cd372">More...</a><br/></td></tr>
<tr class="separator:a2c9b0cae150260c8ee67c21c3e7cd372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af399300a4c8de88e4545ec848acfbca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#af399300a4c8de88e4545ec848acfbca3">XDmaPcie_SetLocalBusBar2PcieBar</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 BarNumber, <a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a> *BarAddrPtr)</td></tr>
<tr class="memdesc:af399300a4c8de88e4545ec848acfbca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller.  <a href="#af399300a4c8de88e4545ec848acfbca3">More...</a><br/></td></tr>
<tr class="separator:af399300a4c8de88e4545ec848acfbca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b168437da7bb05a2cdcbc2267df272d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a0b168437da7bb05a2cdcbc2267df272d">XDmaPcie_ReadLocalConfigSpace</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u16 Offset, u32 *DataPtr)</td></tr>
<tr class="memdesc:a0b168437da7bb05a2cdcbc2267df272d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32-bit value from one of this IP own configuration space.  <a href="#a0b168437da7bb05a2cdcbc2267df272d">More...</a><br/></td></tr>
<tr class="separator:a0b168437da7bb05a2cdcbc2267df272d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedb6585a8dcbcc40443e7b90932ad6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#aeedb6585a8dcbcc40443e7b90932ad6c">XDmaPcie_WriteLocalConfigSpace</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u16 Offset, u32 Data)</td></tr>
<tr class="memdesc:aeedb6585a8dcbcc40443e7b90932ad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32-bit value to one of this IP own configuration space.  <a href="#aeedb6585a8dcbcc40443e7b90932ad6c">More...</a><br/></td></tr>
<tr class="separator:aeedb6585a8dcbcc40443e7b90932ad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac6261cddb63084c8ee87518e99edef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#adac6261cddb63084c8ee87518e99edef">XDmaPcie_ReadRemoteConfigSpace</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 *DataPtr)</td></tr>
<tr class="memdesc:adac6261cddb63084c8ee87518e99edef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32-bit value from external PCIe Function's configuration space.  <a href="#adac6261cddb63084c8ee87518e99edef">More...</a><br/></td></tr>
<tr class="separator:adac6261cddb63084c8ee87518e99edef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47beee6caa44ae3f91979be9cd531bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#ad47beee6caa44ae3f91979be9cd531bf">XDmaPcie_WriteRemoteConfigSpace</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 Data)</td></tr>
<tr class="memdesc:ad47beee6caa44ae3f91979be9cd531bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32-bit value to external PCIe function's configuration space.  <a href="#ad47beee6caa44ae3f91979be9cd531bf">More...</a><br/></td></tr>
<tr class="separator:ad47beee6caa44ae3f91979be9cd531bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50bc19add688d4fe571f7de8c60b0a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#af50bc19add688d4fe571f7de8c60b0a6">XDmaPcie_EnumerateFabric</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *XdmaPciePtr)</td></tr>
<tr class="memdesc:af50bc19add688d4fe571f7de8c60b0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts PCIe enumeration.  <a href="#af50bc19add688d4fe571f7de8c60b0a6">More...</a><br/></td></tr>
<tr class="separator:af50bc19add688d4fe571f7de8c60b0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60093f2ef3dd433de9da51dadc1e46bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a60093f2ef3dd433de9da51dadc1e46bc">XDmaPcie_EnableGlobalInterrupt</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr)</td></tr>
<tr class="memdesc:a60093f2ef3dd433de9da51dadc1e46bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Global Interrupt.  <a href="#a60093f2ef3dd433de9da51dadc1e46bc">More...</a><br/></td></tr>
<tr class="separator:a60093f2ef3dd433de9da51dadc1e46bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3130feda681a6630a2c1d0cb77a2d868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a3130feda681a6630a2c1d0cb77a2d868">XDmaPcie_DisableGlobalInterrupt</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr)</td></tr>
<tr class="memdesc:a3130feda681a6630a2c1d0cb77a2d868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Global Interrupt.  <a href="#a3130feda681a6630a2c1d0cb77a2d868">More...</a><br/></td></tr>
<tr class="separator:a3130feda681a6630a2c1d0cb77a2d868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034dab86e9626ac44e222373d056f693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a034dab86e9626ac44e222373d056f693">XDmaPcie_EnableInterrupts</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 EnableMask)</td></tr>
<tr class="memdesc:a034dab86e9626ac44e222373d056f693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the IP interrupt bits passed into "EnableMask".  <a href="#a034dab86e9626ac44e222373d056f693">More...</a><br/></td></tr>
<tr class="separator:a034dab86e9626ac44e222373d056f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086244f1e8866721dbb016893814281a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a086244f1e8866721dbb016893814281a">XDmaPcie_DisableInterrupts</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 DisableMask)</td></tr>
<tr class="memdesc:a086244f1e8866721dbb016893814281a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the IP interrupt bits passed into "DisableMask".  <a href="#a086244f1e8866721dbb016893814281a">More...</a><br/></td></tr>
<tr class="separator:a086244f1e8866721dbb016893814281a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0db923538acc2ee66a3011f1abf32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a7f0db923538acc2ee66a3011f1abf32c">XDmaPcie_GetEnabledInterrupts</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 *EnabledMaskPtr)</td></tr>
<tr class="memdesc:a7f0db923538acc2ee66a3011f1abf32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently enabled interrupt bits of the IP and pass them back to the caller into "EnabledMask".  <a href="#a7f0db923538acc2ee66a3011f1abf32c">More...</a><br/></td></tr>
<tr class="separator:a7f0db923538acc2ee66a3011f1abf32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcdc92c0afe5f15363ceea6dd2472be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#afbcdc92c0afe5f15363ceea6dd2472be">XDmaPcie_GetPendingInterrupts</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 *PendingMaskPtr)</td></tr>
<tr class="memdesc:afbcdc92c0afe5f15363ceea6dd2472be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently pending interrupt bits of the IP and pass them back to the caller into "PendingMask".  <a href="#afbcdc92c0afe5f15363ceea6dd2472be">More...</a><br/></td></tr>
<tr class="separator:afbcdc92c0afe5f15363ceea6dd2472be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba2488b5b13dfebf7a3df93c300d67e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a1ba2488b5b13dfebf7a3df93c300d67e">XDmaPcie_ClearPendingInterrupts</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u32 ClearMask)</td></tr>
<tr class="memdesc:a1ba2488b5b13dfebf7a3df93c300d67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the currently pending interrupt bits of the IP passed from the caller into "ClearMask".  <a href="#a1ba2488b5b13dfebf7a3df93c300d67e">More...</a><br/></td></tr>
<tr class="separator:a1ba2488b5b13dfebf7a3df93c300d67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae856a9480f2bbf119a71810e12ac5ff7"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#ae856a9480f2bbf119a71810e12ac5ff7">XDmaPcie_HasCapability</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u8 CapId)</td></tr>
<tr class="memdesc:ae856a9480f2bbf119a71810e12ac5ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether capability Id is available or not for the particular Function.  <a href="#ae856a9480f2bbf119a71810e12ac5ff7">More...</a><br/></td></tr>
<tr class="separator:ae856a9480f2bbf119a71810e12ac5ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac232d6bc0efdff01bf3aff950049cf27"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#ac232d6bc0efdff01bf3aff950049cf27">XDmaPcie_GetCapability</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u8 CapId)</td></tr>
<tr class="memdesc:ac232d6bc0efdff01bf3aff950049cf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns offset to the matching capability ID from the Function's Linked list of the capability registers.  <a href="#ac232d6bc0efdff01bf3aff950049cf27">More...</a><br/></td></tr>
<tr class="separator:ac232d6bc0efdff01bf3aff950049cf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7106f923ba6532a0533e39afdf6728c2"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdmapcie_8h.html#a7106f923ba6532a0533e39afdf6728c2">XDmaPcie_PrintAllCapabilites</a> (<a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function)</td></tr>
<tr class="memdesc:a7106f923ba6532a0533e39afdf6728c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints all the available capabilities in the Function.  <a href="#a7106f923ba6532a0533e39afdf6728c2">More...</a><br/></td></tr>
<tr class="separator:a7106f923ba6532a0533e39afdf6728c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a11bdbeb0f844db1d203f2b8f6f29ca5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_BARS&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No BAR allocation for Bridge. </p>

</div>
</div>
<a class="anchor" id="acad74e57979d6bc62e24ddaa31ed11e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REQ_SIZE&#160;&#160;&#160;(<a class="el" href="xdmapcie_8h.html#a11bdbeb0f844db1d203f2b8f6f29ca5c">MAX_BARS</a> * sizeof(unsigned long))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Required size for BAR Alignment. </p>

</div>
</div>
<a class="anchor" id="aa0a061bd0519f5b946c0abe0d4b6bddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDmaPcie_IsEcamBusy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,    \</div>
<div class="line">        <a class="code" href="xdmapcie__hw_8h.html#ac669dec8e84593dc82387d7abb9e27ae">XDMAPCIE_BSC_OFFSET</a>) &amp; <a class="code" href="xdmapcie__hw_8h.html#a0728df5057cc9ea9a5042242192a59cf">XDMAPCIE_BSC_ECAM_BUSY_MASK</a>) ? TRUE : FALSE</div>
<div class="ttc" id="xdmapcie__hw_8h_html_a0728df5057cc9ea9a5042242192a59cf"><div class="ttname"><a href="xdmapcie__hw_8h.html#a0728df5057cc9ea9a5042242192a59cf">XDMAPCIE_BSC_ECAM_BUSY_MASK</a></div><div class="ttdeci">#define XDMAPCIE_BSC_ECAM_BUSY_MASK</div><div class="ttdoc">ECAM Busy Status. </div><div class="ttdef"><b>Definition:</b> xdmapcie_hw.h:511</div></div>
<div class="ttc" id="xdmapcie__hw_8h_html_ac669dec8e84593dc82387d7abb9e27ae"><div class="ttname"><a href="xdmapcie__hw_8h.html#ac669dec8e84593dc82387d7abb9e27ae">XDMAPCIE_BSC_OFFSET</a></div><div class="ttdeci">#define XDMAPCIE_BSC_OFFSET</div><div class="ttdoc">Bridge Status and Control Register. </div><div class="ttdef"><b>Definition:</b> xdmapcie_hw.h:220</div></div>
<div class="ttc" id="xdmapcie__hw_8h_html_a736c70d6aa883f4d252670658e3b95ad"><div class="ttname"><a href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a></div><div class="ttdeci">#define XDmaPcie_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">Macro to read register. </div><div class="ttdef"><b>Definition:</b> xdmapcie_hw.h:972</div></div>
</div><!-- fragment -->
<p>Check whether ECAM is busy or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if ECAM is busy</li>
<li>FALSE if ECAM is idel</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex </dd></dl>

<p>Referenced by <a class="el" href="xdmapcie_8h.html#adac6261cddb63084c8ee87518e99edef">XDmaPcie_ReadRemoteConfigSpace()</a>, and <a class="el" href="xdmapcie_8h.html#ad47beee6caa44ae3f91979be9cd531bf">XDmaPcie_WriteRemoteConfigSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="abb2f08fcc93b4783bec918f9a607fe21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDmaPcie_IsLinkUp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,    \</div>
<div class="line">        <a class="code" href="xdmapcie__hw_8h.html#a571a1cd55e8f810fb91fcfebc441ee46">XDMAPCIE_PHYSC_OFFSET</a>) &amp; <a class="code" href="xdmapcie__hw_8h.html#afc16fa2f0ab33302ebf077134d3b7047">XDMAPCIE_PHYSC_LINK_UP_MASK</a>) ? TRUE : FALSE</div>
<div class="ttc" id="xdmapcie__hw_8h_html_afc16fa2f0ab33302ebf077134d3b7047"><div class="ttname"><a href="xdmapcie__hw_8h.html#afc16fa2f0ab33302ebf077134d3b7047">XDMAPCIE_PHYSC_LINK_UP_MASK</a></div><div class="ttdeci">#define XDMAPCIE_PHYSC_LINK_UP_MASK</div><div class="ttdoc">Link Up Status Mask. </div><div class="ttdef"><b>Definition:</b> xdmapcie_hw.h:662</div></div>
<div class="ttc" id="xdmapcie__hw_8h_html_a571a1cd55e8f810fb91fcfebc441ee46"><div class="ttname"><a href="xdmapcie__hw_8h.html#a571a1cd55e8f810fb91fcfebc441ee46">XDMAPCIE_PHYSC_OFFSET</a></div><div class="ttdeci">#define XDMAPCIE_PHYSC_OFFSET</div><div class="ttdoc">Physical status and Control Register. </div><div class="ttdef"><b>Definition:</b> xdmapcie_hw.h:246</div></div>
<div class="ttc" id="xdmapcie__hw_8h_html_a736c70d6aa883f4d252670658e3b95ad"><div class="ttname"><a href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a></div><div class="ttdeci">#define XDmaPcie_ReadReg(BaseAddress, RegOffset)</div><div class="ttdoc">Macro to read register. </div><div class="ttdef"><b>Definition:</b> xdmapcie_hw.h:972</div></div>
</div><!-- fragment -->
<p>Check whether link is up or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>TRUE if link is up</li>
<li>FALSE if link is down</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b0bb20942845552762a968ec77c293d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDMAPCIE_VSEC1&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First VSEC Register. </p>

</div>
</div>
<a class="anchor" id="a9fc3d3815b4f50f3a1a4a7fe01cc863d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDMAPCIE_VSEC2&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Second VSEC Register. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a557a92506060fd460154426bd8c4870c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDmaPcie_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie___config.html">XDmaPcie_Config</a> *&#160;</td>
          <td class="paramname"><em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINTPTR&#160;</td>
          <td class="paramname"><em>EffectiveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance provided by the caller based on the given Config structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on.The memory of the pointer references must be pre-allocated by the caller. </td></tr>
    <tr><td class="paramname">CfgPtr</td><td>is the device configuration structure containing required HW build data. </td></tr>
    <tr><td class="paramname">EffectiveAddress</td><td>is the Physical address of the hardware in a Virtual Memory operating system environment.It is the Base Address in a stand alone environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><pre class="fragment">            - XST_SUCCESS Initialization was successful.
</pre></dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#a42ba484bddfed2c7c40d2e82cefe2893">XDmaPcie_Config::Ecam</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="struct_x_dma_pcie.html#a25bda690bb4c8e6c28b23b63eea79f0f">XDmaPcie::MaxNumOfBuses</a>, <a class="el" href="struct_x_dma_pcie___config.html#a154ea2174bdb4f7e8b9ef9e11f857c4e">XDmaPcie_Config::NpMemBaseAddr</a>, <a class="el" href="xdmapcie__hw_8h.html#abcda754d0a61c43d447fadb67aaa7434">XDMAPCIE_BI_ECAM_SIZE_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a4a8456b90f69f3ca2c3a8db12ea24ee8">XDMAPCIE_BI_ECAM_SIZE_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a3608f25f453e0135ff2e2bd6a160533c">XDMAPCIE_BI_OFFSET</a>, <a class="el" href="xdmapcie_8h.html#a086244f1e8866721dbb016893814281a">XDmaPcie_DisableInterrupts()</a>, <a class="el" href="xdmapcie__hw_8h.html#a41b00f72c89e54b044acfcd7bb7dfc86">XDMAPCIE_IM_DISABLE_ALL_MASK</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ba2488b5b13dfebf7a3df93c300d67e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ClearPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ClearMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the currently pending interrupt bits of the IP passed from the caller into "ClearMask". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">ClearMask</td><td>is the bit pattern for pending interrupts wanted to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a1a466d7f94958ad960844918169a95ef">XDMAPCIE_ID_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ae44f206a94bf40daea49281112b46d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ClearRootPortErrFIFOMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Root Port Error FIFO Message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a46d0aae62d5b3314d9eb4ef5830b4ec0">XDMAPCIE_RPEFR_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a1a9e71d1904e3b6bfca811f5baec640c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ClearRootPortIntFIFOReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Root Port FIFO Interrupt message Register 1 &amp; 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex.Clearing any one Interrupt FIFO register clears both registers. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a2d3fa8b6821762a92a973e4b1d341f12">XDMAPCIE_RPIFR1_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a3130feda681a6630a2c1d0cb77a2d868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_DisableGlobalInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Global Interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This bit is in the Bridge Status and Control Register. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#ad1ca428956c846fb789bc4c9bb31bc58">XDMAPCIE_BSC_GI_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a46af7762c004cff0605f71238f33039a">XDMAPCIE_BSC_GI_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#ac669dec8e84593dc82387d7abb9e27ae">XDMAPCIE_BSC_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a086244f1e8866721dbb016893814281a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_DisableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DisableMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the IP interrupt bits passed into "DisableMask". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">DisableMask</td><td>is the bit pattern for interrupts wanted to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an interrupt is already disabled before calling this function, it will stay disabled regardless of the value of "DisableMask" passed from the caller. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a241506bc1816800ebc206d77b9d26436">XDMAPCIE_IM_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>, and <a class="el" href="xdmapcie_8h.html#a557a92506060fd460154426bd8c4870c">XDmaPcie_CfgInitialize()</a>.</p>

</div>
</div>
<a class="anchor" id="a60093f2ef3dd433de9da51dadc1e46bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_EnableGlobalInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Global Interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This bit is in the Bridge Status and Control Register. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#ad1ca428956c846fb789bc4c9bb31bc58">XDMAPCIE_BSC_GI_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a46af7762c004cff0605f71238f33039a">XDMAPCIE_BSC_GI_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#ac669dec8e84593dc82387d7abb9e27ae">XDMAPCIE_BSC_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a034dab86e9626ac44e222373d056f693"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_EnableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EnableMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the IP interrupt bits passed into "EnableMask". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">EnableMask</td><td>is the bit pattern for interrupts wanted to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an interrupt is already enabled before calling this function, it will stay enabled regardless of the value of "EnableMask" passed from the caller. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a241506bc1816800ebc206d77b9d26436">XDMAPCIE_IM_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="af50bc19add688d4fe571f7de8c60b0a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_EnumerateFabric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts PCIe enumeration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> Instance Pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a83357e666376be50d018b3e0d2d07acf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetBridgeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Gen2Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>RootPortPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ECAMSizePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Reads the Bridge info register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">Gen2Ptr</td><td>is a pointer to a variable indicating whether underlying PCIe block support PCIe Gen2 Speed. </td></tr>
    <tr><td class="paramname">RootPortPtr</td><td>is a pointer to a variable indication whether underlying PCIe block is root port. </td></tr>
    <tr><td class="paramname">ECAMSizePtr</td><td>is a pointer to a variable where it indicates ECAM size. Value is between 1 to 8. Total address bits dedicated to ECAM is 20 + ECAM size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#abcda754d0a61c43d447fadb67aaa7434">XDMAPCIE_BI_ECAM_SIZE_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a4a8456b90f69f3ca2c3a8db12ea24ee8">XDMAPCIE_BI_ECAM_SIZE_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a2799a39816b787225defc73fb71b174a">XDMAPCIE_BI_GEN2_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a3608f25f453e0135ff2e2bd6a160533c">XDMAPCIE_BI_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a1341b82af3253d651248943c9c106b85">XDMAPCIE_BI_RP_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#ae4893d95f81629e3f530ac3f469865ec">XDMAPCIE_BI_RP_SHIFT</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ac232d6bc0efdff01bf3aff950049cf27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XDmaPcie_GetCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>CapId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns offset to the matching capability ID from the Function's Linked list of the capability registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> Instance Pointer </td></tr>
    <tr><td class="paramname">Bus</td><td>is the number of the Bus </td></tr>
    <tr><td class="paramname">Device</td><td>is the number of the Device </td></tr>
    <tr><td class="paramname">Function</td><td>is number of the Function </td></tr>
    <tr><td class="paramname">cap</td><td>id to get capability pointer offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u64 capability pointer if available 0 if not available. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#a42ba484bddfed2c7c40d2e82cefe2893">XDmaPcie_Config::Ecam</a>, and <a class="el" href="xdmapcie_8c.html#adac6261cddb63084c8ee87518e99edef">XDmaPcie_ReadRemoteConfigSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f0db923538acc2ee66a3011f1abf32c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetEnabledInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>EnabledMaskPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently enabled interrupt bits of the IP and pass them back to the caller into "EnabledMask". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">EnabledMaskPtr</td><td>is a pointer to a variable where the driver will pass back the enabled interrupt bits after reading them from IP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a241506bc1816800ebc206d77b9d26436">XDMAPCIE_IM_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c9b0cae150260c8ee67c21c3e7cd372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetLocalBusBar2PcieBar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>BarNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a> *&#160;</td>
          <td class="paramname"><em>BarAddrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">BarNumber</td><td>is AXI bar number (0 - 5) passed by caller. </td></tr>
    <tr><td class="paramname">BarAddrPtr</td><td>is a pointer to a variable where the driver will . pass back translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___bar_addr.html#a4e4e0b8f0689604c8984699fc9fa2fce">XDmaPcie_BarAddr::LowerAddr</a>, <a class="el" href="struct_x_dma_pcie___bar_addr.html#aecbed94db7ecb38d5e95ce10a6d1bf39">XDmaPcie_BarAddr::UpperAddr</a>, <a class="el" href="xdmapcie__hw_8h.html#a51aeaa8592563052dfac4d5c7c5ee606">XDMAPCIE_AXIBAR2PCIBAR_0L_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a5c9801387aa82ecd82ef7eeb15224636">XDMAPCIE_AXIBAR2PCIBAR_0U_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="afbcdc92c0afe5f15363ceea6dd2472be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>PendingMaskPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently pending interrupt bits of the IP and pass them back to the caller into "PendingMask". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">PendingMaskPtr</td><td>is a pointer to a variable where the driver will pass back the pending interrupt bits after reading them from IP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a1a466d7f94958ad960844918169a95ef">XDMAPCIE_ID_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="a3533208a920e43d2e9442ca9b02a22a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetPhyStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>PhyState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read the Phy Status/Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">PhyState</td><td>is a pointer to a variable where the driver will pass back Current physical status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a571a1cd55e8f810fb91fcfebc441ee46">XDMAPCIE_PHYSC_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="a5f24eea699cbc956a9705034c5f12607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetRequesterId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>BusNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DevNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>FunNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>PortNumPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the Bus Location register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">BusNumPtr</td><td>is a pointer to a variable where the driver will pass back the bus number of requester ID assigned to IP. </td></tr>
    <tr><td class="paramname">DevNumPtr</td><td>is a pointer to a variable where the driver will pass back the device number of requester ID assigned to IP. </td></tr>
    <tr><td class="paramname">FunNumPtr</td><td>is a pointer to a variable where the driver will pass back the function number of requester ID assigned to IP. </td></tr>
    <tr><td class="paramname">PortNumPtr</td><td>is a pointer to a variable where the driver will pass back the Port number of requester ID assigned to IP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#ac59090cdcbe3d2156f27165a33e21d3c">XDMAPCIE_BL_BUS_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#acc86d34d06e7fd42e5289dbc30aa680e">XDMAPCIE_BL_BUS_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a2b76774fe73eb5ddac64acd04d18a8f2">XDMAPCIE_BL_DEV_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a77a9c17fea6e28f4daa1a40b933d38e0">XDMAPCIE_BL_DEV_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#af5b647370bc05fa2a455f1569f7d5ef7">XDMAPCIE_BL_FUNC_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a31d2fdd979d3087f69bd97eb52b4c499">XDMAPCIE_BL_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#acf6e6d7e43697c4b98bbf6f645f901dd">XDMAPCIE_BL_PORT_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#ac94b2bf9a1b1abfccc5c67b8e2fed743">XDMAPCIE_BL_PORT_SHIFT</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="afc77bc991235ea37d13d7bd07032584e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetRootPortErrFIFOMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>ReqIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ErrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ErrValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Root Port Error FIFO Message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">ReqIdPtr</td><td>is a variable where the driver will pass back the requester Id of error message. </td></tr>
    <tr><td class="paramname">ErrType</td><td>is a variable where the driver will pass back the type of error message </td></tr>
    <tr><td class="paramname">ErrValid</td><td>is a variable where the driver will pass back the status of read operation of error message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, <a class="el" href="xdmapcie__hw_8h.html#abd07ee76293490abe91819f9aef8bc56">XDMAPCIE_RPEFR_ERR_TYPE_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#aef51c54b8bc8f6695dee6c0260e6be08">XDMAPCIE_RPEFR_ERR_TYPE_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a854a4541c2d8ccb05ddf14b86882ebe6">XDMAPCIE_RPEFR_ERR_VALID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#aa0ea8677de2e2270781a5589086d7387">XDMAPCIE_RPEFR_ERR_VALID_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a46d0aae62d5b3314d9eb4ef5830b4ec0">XDMAPCIE_RPEFR_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#ae864fe8e0611b31480e861fb1a48582f">XDMAPCIE_RPEFR_REQ_ID_MASK</a>.</p>

</div>
</div>
<a class="anchor" id="a54d41c333a761b1c8decb59c19f1ffc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDmaPcie_GetRootPortIntFIFOReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>ReqIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>MsiAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>MsiInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>IntValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>MsiMsgData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Root Port Interrupt FIFO message Register 1 &amp; 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">ReqIdPtr</td><td>is a variable where the driver will pass back the requester Id of error message. </td></tr>
    <tr><td class="paramname">MsiAddr</td><td>is a variable where the driver will pass back the MSI address for which interrupt message received. </td></tr>
    <tr><td class="paramname">MsiInt</td><td>is a variable where the driver will pass back the type of interrupt message received (MSI/INTx). </td></tr>
    <tr><td class="paramname">IntValid</td><td>is a variable where the driver will pass back the status of read operation of interrupt message. </td></tr>
    <tr><td class="paramname">MsiMsgData</td><td>is a variable where the driver will pass back the MSI data received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MsiMsgData if MSI interrupt is observed or 0 if there is no MSI interrupt.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, <a class="el" href="xdmapcie__hw_8h.html#a2e7d4992c3815b1b8e976cc90baa99e7">XDMAPCIE_RPIFR1_INTR_VALID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#abc20d6f07d915eeeda963f3bc44ce978">XDMAPCIE_RPIFR1_INTR_VALID_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a7313a92a55b01bef8f6d0ee23015bd21">XDMAPCIE_RPIFR1_MSI_ADDR_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#aa13faabf819e0c4fdb157650e1db8ca1">XDMAPCIE_RPIFR1_MSI_ADDR_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a6a5ab88c6292ec6e362f74bd6c9cae4b">XDMAPCIE_RPIFR1_MSIINTR_VALID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#aa39c481cf7526edda33a09cdba1f525e">XDMAPCIE_RPIFR1_MSIINTR_VALID_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a2d3fa8b6821762a92a973e4b1d341f12">XDMAPCIE_RPIFR1_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a4bece0606c363a0cc4778e270fdbb711">XDMAPCIE_RPIFR1_REQ_ID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a2806e420f58fa46b4c36e5c82d401e88">XDMAPCIE_RPIFR2_MSG_DATA_MASK</a>, and <a class="el" href="xdmapcie__hw_8h.html#ad5f6e8d589fe6f5a01e312a8f092799c">XDMAPCIE_RPIFR2_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="a2baa98cfc13d1f4d209267e80808e3b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetRootPortStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>StatusPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Root Port Status/Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">StatusPtr</td><td>is a pointer to a variable where the driver will pass back the root port status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#ab68d32651b96f4c8a6cc6c7549509c82">XDMAPCIE_RPSC_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="ac61d1050938321b594087912a2272efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetVsecCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>VsecNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>VsecIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>VersionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>NextCapPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read the VSEC Capability Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">VsecNum</td><td>is a VSEC register number as there are two registers. Possible values are.<ul>
<li>XDMAPCIE_VSEC1 (0)</li>
<li>XDMAPCIE_VSEC2 (1) </li>
</ul>
</td></tr>
    <tr><td class="paramname">VsecIdPtr</td><td>is a pointer to a variable where the driver will pass back the Vendor Specific Enhanced Capability ID. </td></tr>
    <tr><td class="paramname">VersionPtr</td><td>is a pointer to a variable where the driver will . pass back the Version of VSEC. </td></tr>
    <tr><td class="paramname">NextCapPtr</td><td>is a pointer to a variable where the driver will pass back the Next Capability offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, <a class="el" href="xdmapcie__hw_8h.html#a405f9e3195f36f58bd6685bba2231ffb">XDMAPCIE_VSECC_ID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a848f1c9bd9cdd5b2b9100f46b7353edb">XDMAPCIE_VSECC_NEXT_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a9e335708c508110cad0e5c36cacb9eac">XDMAPCIE_VSECC_NEXT_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#a16f5d7b6b585ac5ac0fcd5189889c104">XDMAPCIE_VSECC_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a34df2e3887910bf3d736e98a983dcdbf">XDMAPCIE_VSECC_VER_MASK</a>, and <a class="el" href="xdmapcie__hw_8h.html#a019c307ea457a54fe5cffb84f4f807bd">XDMAPCIE_VSECC_VER_SHIFT</a>.</p>

</div>
</div>
<a class="anchor" id="acf9acbd19090d9147cdad13913354fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_GetVsecHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>VsecNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>VsecIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>RevisionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&#160;</td>
          <td class="paramname"><em>LengthPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to read the VSEC Header Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">VsecNum</td><td>is a VSEC register number as there are two registers. Possible values are.<ul>
<li>XDMAPCIE_VSEC1 (0)</li>
<li>XDMAPCIE_VSEC2 (1) </li>
</ul>
</td></tr>
    <tr><td class="paramname">VsecIdPtr</td><td>is a pointer to a variable where the driver will pass back the VSEC header structure Id. </td></tr>
    <tr><td class="paramname">RevisionPtr</td><td>is a pointer to a variable where the driver will pass back the Revision of VSEC capability Structure. </td></tr>
    <tr><td class="paramname">LengthPtr</td><td>is a pointer to a variable where the driver will pass . back the length of the VSEC capability structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, <a class="el" href="xdmapcie__hw_8h.html#ad729068100112d67c4a08830e6a12b4d">XDMAPCIE_VSECH_ID_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a1471191e3dbfee9c528d5c42a1f6691f">XDMAPCIE_VSECH_LEN_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a324566449eb7d1f827007b13f8c3c127">XDMAPCIE_VSECH_LEN_SHIFT</a>, <a class="el" href="xdmapcie__hw_8h.html#ae6596b5eb3e9c22bc43c90a57ed9945f">XDMAPCIE_VSECH_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a29d0c0b9219248958c08a5a557b01309">XDMAPCIE_VSECH_REV_MASK</a>, and <a class="el" href="xdmapcie__hw_8h.html#a45941794e0251d660ceb5b2ff390155a">XDMAPCIE_VSECH_REV_SHIFT</a>.</p>

</div>
</div>
<a class="anchor" id="ae856a9480f2bbf119a71810e12ac5ff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XDmaPcie_HasCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>CapId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether capability Id is available or not for the particular Function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> Instance Pointer </td></tr>
    <tr><td class="paramname">Bus</td><td>is the number of the Bus </td></tr>
    <tr><td class="paramname">Device</td><td>is the number of the Device </td></tr>
    <tr><td class="paramname">Function</td><td>is number of the Function </td></tr>
    <tr><td class="paramname">cap</td><td>id to check capability pointer availability</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>u32 0 if capability is not available 1 if capability is available </dd></dl>

<p>References <a class="el" href="xdmapcie_8c.html#adac6261cddb63084c8ee87518e99edef">XDmaPcie_ReadRemoteConfigSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a5554a1ee852247fccc227fb9e3aff8ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_dma_pcie___config.html">XDmaPcie_Config</a>* XDmaPcie_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the device configuration based on the unique device ID. </p>
<p>The table ConfigTable contains the configuration info for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the device identifier to lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> configuration structure pointer if DeviceID is found.</li>
<li>NULL if DeviceID is not found.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="a7106f923ba6532a0533e39afdf6728c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XDmaPcie_PrintAllCapabilites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function prints all the available capabilities in the Function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>pointer to <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> Instance Pointer </td></tr>
    <tr><td class="paramname">Bus</td><td>is the number of the Bus </td></tr>
    <tr><td class="paramname">Device</td><td>is the number of the Device </td></tr>
    <tr><td class="paramname">Function</td><td>is number of the Function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success XST_FAILURE on failure. </dd></dl>

<p>References <a class="el" href="xdmapcie_8c.html#adac6261cddb63084c8ee87518e99edef">XDmaPcie_ReadRemoteConfigSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a0b168437da7bb05a2cdcbc2267df272d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ReadLocalConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>DataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 32-bit value from one of this IP own configuration space. </p>
<p>Location is identified by its offset from the beginning of the configuration space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">Offset</td><td>from beginning of IP own configuration space. </td></tr>
    <tr><td class="paramname">DataPtr</td><td>is a pointer to a variable where the driver will pass back the value read from the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a1083266540141374178a8efd47a8c838">XDMAPCIE_PCIE_CORE_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="adac6261cddb63084c8ee87518e99edef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_ReadRemoteConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>DataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 32-bit value from external PCIe Function's configuration space. </p>
<p>External PCIe function is identified by its Requester ID (Bus#, Device#, Function#). Location is identified by its offset from the beginning of the configuration space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">Bus</td><td>is the external PCIe function's Bus number. </td></tr>
    <tr><td class="paramname">Device</td><td>is the external PCIe function's Device number. </td></tr>
    <tr><td class="paramname">Function</td><td>is the external PCIe function's Function number. </td></tr>
    <tr><td class="paramname">Offset</td><td>from beggininng of PCIe function's configuration space. </td></tr>
    <tr><td class="paramname">DataPtr</td><td>is a pointer to a variable where the driver will pass back the value read from the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. The XDmaPcie_ReadLocalConfigSpace API should be used for reading the local config space. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#a42ba484bddfed2c7c40d2e82cefe2893">XDmaPcie_Config::Ecam</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="struct_x_dma_pcie.html#a25bda690bb4c8e6c28b23b63eea79f0f">XDmaPcie::MaxNumOfBuses</a>, <a class="el" href="xdmapcie__hw_8h.html#acdd10dcc061e19b4fc59bae614d5d623">XDMAPCIE_ATU_LIMIT_ADDR</a>, <a class="el" href="xdmapcie__hw_8h.html#adb19a64b3049aecfb96ecbfaabb0ec4f">XDMAPCIE_ATU_REGION_SIZE</a>, <a class="el" href="xdmapcie__hw_8h.html#ac16ba889496220efc741c8253807c515">XDMAPCIE_CFG_TLP_TYPE0</a>, <a class="el" href="xdmapcie__hw_8h.html#a401d3214b790655f8f2afd71c9ec99f7">XDMAPCIE_CFG_TLP_TYPE1</a>, <a class="el" href="xdmapcie_8h.html#aa0a061bd0519f5b946c0abe0d4b6bddd">XDmaPcie_IsEcamBusy</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#ae8f262322bca4ce8dd8ab88ebda2dedb">XDMAPCIE_REGION_EN</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__caps_8c.html#ac232d6bc0efdff01bf3aff950049cf27">XDmaPcie_GetCapability()</a>, <a class="el" href="xdmapcie__caps_8c.html#ae856a9480f2bbf119a71810e12ac5ff7">XDmaPcie_HasCapability()</a>, and <a class="el" href="xdmapcie__caps_8c.html#a7106f923ba6532a0533e39afdf6728c2">XDmaPcie_PrintAllCapabilites()</a>.</p>

</div>
</div>
<a class="anchor" id="af399300a4c8de88e4545ec848acfbca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_SetLocalBusBar2PcieBar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>BarNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie___bar_addr.html">XDmaPcie_BarAddr</a> *&#160;</td>
          <td class="paramname"><em>BarAddrPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the <a class="el" href="struct_x_dma_pcie.html" title="The XDmaPcie driver instance data. ">XDmaPcie</a> instance to operate on. </td></tr>
    <tr><td class="paramname">BarNumber</td><td>is AXI bar number (0 - 5) passed by caller. </td></tr>
    <tr><td class="paramname">BarAddrPtr</td><td>is a pointer to a variable where the driver will pass back translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___bar_addr.html#a4e4e0b8f0689604c8984699fc9fa2fce">XDmaPcie_BarAddr::LowerAddr</a>, <a class="el" href="struct_x_dma_pcie___bar_addr.html#aecbed94db7ecb38d5e95ce10a6d1bf39">XDmaPcie_BarAddr::UpperAddr</a>, <a class="el" href="xdmapcie__hw_8h.html#a51aeaa8592563052dfac4d5c7c5ee606">XDMAPCIE_AXIBAR2PCIBAR_0L_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#a5c9801387aa82ecd82ef7eeb15224636">XDMAPCIE_AXIBAR2PCIBAR_0U_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a1641602833f00b16132be700a66e2f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDmaPcie_SetRootPortMSIBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>MsiBase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write MSI Base Address to Root Port MSI Base Address Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">MsiBase</td><td>is 64 bit base address for MSI.This address should be 4kB aligned always.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS if success or XST_FAILURE if failure .</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#ac29f522978bcd22ada72cd32e6d2ad1f">XDMAPCIE_RPMSIB_LOWER_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a39e3da3783cd1ae36538dda9353bd662">XDMAPCIE_RPMSIB_LOWER_OFFSET</a>, <a class="el" href="xdmapcie__hw_8h.html#aa7c2a15bd965cf4c40c6ef0467840f3c">XDMAPCIE_RPMSIB_UPPER_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#a2c7a2d9d74f6b92651fe50bddbb5e594">XDMAPCIE_RPMSIB_UPPER_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="a1f829c82bb17dcc56648246fafa2eaa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_SetRootPortStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>StatusData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write Value in Root Port Status/Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">StatusData</td><td>is data to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a8e480ce2a44fd9f14991d2421c4db0c7">XDMAPCIE_RPSC_MASK</a>, <a class="el" href="xdmapcie__hw_8h.html#ab68d32651b96f4c8a6cc6c7549509c82">XDMAPCIE_RPSC_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="aeedb6585a8dcbcc40443e7b90932ad6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_WriteLocalConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 32-bit value to one of this IP own configuration space. </p>
<p>Location is identified by its offset from the beginning of the configuration space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">Offset</td><td>from beggininng of IP own configuration space. </td></tr>
    <tr><td class="paramname">Data</td><td>to be written to the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie___config.html#a11981cd817dda09fa8ffb1e4b6c524bd">XDmaPcie_Config::BaseAddress</a>, <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="xdmapcie__hw_8h.html#a1083266540141374178a8efd47a8c838">XDMAPCIE_PCIE_CORE_OFFSET</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="xdmapcie__rc__enumerate__example_8c.html#aa1e7ab3bea37defba5bf6590492c9b3c">PcieInitRootComplex()</a>.</p>

</div>
</div>
<a class="anchor" id="ad47beee6caa44ae3f91979be9cd531bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDmaPcie_WriteRemoteConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dma_pcie.html">XDmaPcie</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 32-bit value to external PCIe function's configuration space. </p>
<p>External PCIe function is identified by its Requester ID (Bus#, Device#, Function#). Location is identified by its offset from the beginning of the configuration space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td class="paramname">Bus</td><td>is the external PCIe function's Bus number. </td></tr>
    <tr><td class="paramname">Device</td><td>is the external PCIe function's Device number. </td></tr>
    <tr><td class="paramname">Function</td><td>is the external PCIe function's Function number. </td></tr>
    <tr><td class="paramname">Offset</td><td>from beggininng of PCIe function's configuration space. </td></tr>
    <tr><td class="paramname">Data</td><td>to be written to the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when IP is configured as a root complex. The XDmaPcie_WriteLocalConfigSpace should be used for writing to local config space. </dd></dl>

<p>References <a class="el" href="struct_x_dma_pcie.html#af5d05276beffe8f09d05bf237cc3d2f5">XDmaPcie::Config</a>, <a class="el" href="struct_x_dma_pcie___config.html#a42ba484bddfed2c7c40d2e82cefe2893">XDmaPcie_Config::Ecam</a>, <a class="el" href="struct_x_dma_pcie___config.html#ab67ad06680c60071c889da0a04852a96">XDmaPcie_Config::IncludeRootComplex</a>, <a class="el" href="struct_x_dma_pcie.html#ab8f1b6c7f90a5614de5f726f4daef12e">XDmaPcie::IsReady</a>, <a class="el" href="struct_x_dma_pcie.html#a25bda690bb4c8e6c28b23b63eea79f0f">XDmaPcie::MaxNumOfBuses</a>, <a class="el" href="xdmapcie_8h.html#aa0a061bd0519f5b946c0abe0d4b6bddd">XDmaPcie_IsEcamBusy</a>, <a class="el" href="xdmapcie__hw_8h.html#a736c70d6aa883f4d252670658e3b95ad">XDmaPcie_ReadReg</a>, and <a class="el" href="xdmapcie__hw_8h.html#afa180a178e9501f6238f5a5fbbd62a69">XDmaPcie_WriteReg</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
