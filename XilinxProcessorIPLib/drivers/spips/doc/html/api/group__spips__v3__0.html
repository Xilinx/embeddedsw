<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>spips: Spips_v3_0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">spips
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Spips_v3_0</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac782d76352000f7cab838491744a022a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gac782d76352000f7cab838491744a022a">XSpiPs_SetSlaveIdle</a>(InstancePtr,  RegisterValue)</td></tr>
<tr class="separator:gac782d76352000f7cab838491744a022a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f2055cfa93a26da233dff2fa8b0af8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga8f2055cfa93a26da233dff2fa8b0af8b">XSpiPs_GetSlaveIdle</a>(InstancePtr)</td></tr>
<tr class="separator:ga8f2055cfa93a26da233dff2fa8b0af8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5501c2b3144a42ec20d93bcaa4732797"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga5501c2b3144a42ec20d93bcaa4732797">XSpiPs_SetTXWatermark</a>(InstancePtr,  RegisterValue)</td></tr>
<tr class="separator:ga5501c2b3144a42ec20d93bcaa4732797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae768acaf29460ddf625c0842a6546991"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gae768acaf29460ddf625c0842a6546991">XSpiPs_GetTXWatermark</a>(InstancePtr)&#160;&#160;&#160;XSpiPs_In32(((InstancePtr)-&gt;Config.BaseAddress) + <a class="el" href="group__spips__v3__0.html#ga82b0c7855556fbb3d13b1d0fc3f7ae24">XSPIPS_TXWR_OFFSET</a>)</td></tr>
<tr class="separator:gae768acaf29460ddf625c0842a6546991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7789f973a99a1192e89e6df23b8d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gabf7789f973a99a1192e89e6df23b8d84">XSpiPs_SetRXWatermark</a>(InstancePtr,  RegisterValue)</td></tr>
<tr class="separator:gabf7789f973a99a1192e89e6df23b8d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27fb8402703b83365149ff051bb7aee8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga27fb8402703b83365149ff051bb7aee8">XSpiPs_GetRXWatermark</a>(InstancePtr)&#160;&#160;&#160;XSpiPs_In32(((InstancePtr)-&gt;Config.BaseAddress) + <a class="el" href="group__spips__v3__0.html#ga708b416f4994dca83b3d50a464552286">XSPIPS_RXWR_OFFSET</a>)</td></tr>
<tr class="separator:ga27fb8402703b83365149ff051bb7aee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3a41972453b0dfb7ec90f3972ddc74"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga7b3a41972453b0dfb7ec90f3972ddc74">XSpiPs_Enable</a>(InstancePtr)</td></tr>
<tr class="separator:ga7b3a41972453b0dfb7ec90f3972ddc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33752db88677fe0580abb65d6ba70cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gae33752db88677fe0580abb65d6ba70cf">XSpiPs_Disable</a>(InstancePtr)&#160;&#160;&#160;XSpiPs_Out32(((InstancePtr)-&gt;Config.BaseAddress) + <a class="el" href="group__spips__v3__0.html#ga96a2524f86a513015b982462f7a6ffcb">XSPIPS_ER_OFFSET</a>, 0U)</td></tr>
<tr class="separator:gae33752db88677fe0580abb65d6ba70cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4c628392bc69b6295b28d8736d3c14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>(BaseAddress,  RegOffset)&#160;&#160;&#160;XSpiPs_In32((BaseAddress) + (RegOffset))</td></tr>
<tr class="separator:ga3c4c628392bc69b6295b28d8736d3c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16d6923c47520aea34852e4c439bc02a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>(BaseAddress,  RegOffset,  RegisterValue)&#160;&#160;&#160;XSpiPs_Out32((BaseAddress) + (RegOffset), (RegisterValue))</td></tr>
<tr class="separator:ga16d6923c47520aea34852e4c439bc02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaec95e118eb971ab521b5a348a9861783"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gaec95e118eb971ab521b5a348a9861783">XSpiPs_StatusHandler</a>) (void *CallBackRef, u32 StatusEvent, u32 ByteCount)</td></tr>
<tr class="separator:gaec95e118eb971ab521b5a348a9861783"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga66fc6e7b4ec94e279b89cc0eab2debf2"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga66fc6e7b4ec94e279b89cc0eab2debf2">XSpiPs_CfgInitialize</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, <a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr class="separator:ga66fc6e7b4ec94e279b89cc0eab2debf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3abd2456cfa67bc8d24dd255ba7de51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gad3abd2456cfa67bc8d24dd255ba7de51">XSpiPs_Reset</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr class="separator:gad3abd2456cfa67bc8d24dd255ba7de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747939dd62eb9c82ed185611e95211c7"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, u32 ByteCount)</td></tr>
<tr class="separator:ga747939dd62eb9c82ed185611e95211c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94490f99431c92c2a9a54cc41d4abe71"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, u32 ByteCount)</td></tr>
<tr class="separator:ga94490f99431c92c2a9a54cc41d4abe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ef5af2211095df5692567fa4721a8d5"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga1ef5af2211095df5692567fa4721a8d5">XSpiPs_SetSlaveSelect</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 SlaveSel)</td></tr>
<tr class="separator:ga1ef5af2211095df5692567fa4721a8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4efc98fb1e6b9a927146bd3bcab8ea8b"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga4efc98fb1e6b9a927146bd3bcab8ea8b">XSpiPs_GetSlaveSelect</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr class="separator:ga4efc98fb1e6b9a927146bd3bcab8ea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafc99130a16e99abb3d86e682f1de09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gacafc99130a16e99abb3d86e682f1de09">XSpiPs_SetStatusHandler</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, void *CallBackRef, <a class="el" href="group__spips__v3__0.html#gaec95e118eb971ab521b5a348a9861783">XSpiPs_StatusHandler</a> FunctionPtr)</td></tr>
<tr class="separator:gacafc99130a16e99abb3d86e682f1de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57ccd3fab9a25399bdb8bc234fecc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr class="separator:gac57ccd3fab9a25399bdb8bc234fecc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f40732e67f63579b811af115f2c575c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr class="separator:ga1f40732e67f63579b811af115f2c575c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c86f3842f5996d9d7fc874466f4136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga70c86f3842f5996d9d7fc874466f4136">XSpiPs_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="separator:ga70c86f3842f5996d9d7fc874466f4136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa797b9b8184e6f39b0c0038553e48d8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr class="separator:gaaa797b9b8184e6f39b0c0038553e48d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b67fe9b7737a1af8067d6d69e1508b"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gad1b67fe9b7737a1af8067d6d69e1508b">XSpiPs_SetOptions</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u32 Options)</td></tr>
<tr class="separator:gad1b67fe9b7737a1af8067d6d69e1508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842e4cf2fabf1849f451d9592d0b2722"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga842e4cf2fabf1849f451d9592d0b2722">XSpiPs_GetOptions</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr class="separator:ga842e4cf2fabf1849f451d9592d0b2722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8359f8188f7bf36a0688963aff561692"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga8359f8188f7bf36a0688963aff561692">XSpiPs_SetClkPrescaler</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 Prescaler)</td></tr>
<tr class="separator:ga8359f8188f7bf36a0688963aff561692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f7c1eb75848839d7dc4fa81bc273e4"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gab8f7c1eb75848839d7dc4fa81bc273e4">XSpiPs_GetClkPrescaler</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr class="separator:gab8f7c1eb75848839d7dc4fa81bc273e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe7ecd11569d8cf376ebc8f982503c52"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gafe7ecd11569d8cf376ebc8f982503c52">XSpiPs_SetDelays</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 DelayNss, u8 DelayBtwn, u8 DelayAfter, u8 DelayInit)</td></tr>
<tr class="separator:gafe7ecd11569d8cf376ebc8f982503c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga716d3d27606e693e765a2b9d01cce462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 *DelayNss, u8 *DelayBtwn, u8 *DelayAfter, u8 *DelayInit)</td></tr>
<tr class="separator:ga716d3d27606e693e765a2b9d01cce462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab466a4718bbee60293dc226ca043d5b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw</a> (u32 BaseAddress)</td></tr>
<tr class="separator:gab466a4718bbee60293dc226ca043d5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga0aab1b9650381f6e5c64f424ec67844d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_ACTIVE_LOW_OPTION&#160;&#160;&#160;0x00000002U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Active Low Clock option. </p>

</div>
</div>
<a class="anchor" id="ga25ffb7f933bd33275a89e6d1d0d340ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_PHASE_1_OPTION&#160;&#160;&#160;0x00000004U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Clock Phase one option. </p>

</div>
</div>
<a class="anchor" id="ga009c993558540f5018f794996594f34c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_PRESCALE_128&#160;&#160;&#160;0x06U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>PCLK/128 Prescaler. </p>

</div>
</div>
<a class="anchor" id="ga46beb1bbc0f69b94eba21c4e9495c8f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_PRESCALE_16&#160;&#160;&#160;0x03U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>PCLK/16 Prescaler. </p>

</div>
</div>
<a class="anchor" id="ga554021caf9a775e3dceedbc67e8b8dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_PRESCALE_256&#160;&#160;&#160;0x07U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>PCLK/256 Prescaler. </p>

</div>
</div>
<a class="anchor" id="ga17461c15895ead044069b54cb0de879c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_PRESCALE_32&#160;&#160;&#160;0x04U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>PCLK/32 Prescaler. </p>

</div>
</div>
<a class="anchor" id="ga4984355789693743e51841fd3078cd29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_PRESCALE_4&#160;&#160;&#160;0x01U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>PCLK/4 Prescaler. </p>

</div>
</div>
<a class="anchor" id="gac069eaeb884436a488dbf5d8d56b990e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_PRESCALE_64&#160;&#160;&#160;0x05U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>PCLK/64 Prescaler. </p>

</div>
</div>
<a class="anchor" id="ga797ea1218c463e962b5bb3e8c1660519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CLK_PRESCALE_8&#160;&#160;&#160;0x02U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>PCLK/8 Prescaler. </p>

</div>
</div>
<a class="anchor" id="ga4a6535d62a7cad8209d615146f5f050c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_CPHA_MASK&#160;&#160;&#160;0x00000004U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Phase Configuration. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gad1b67fe9b7737a1af8067d6d69e1508b">XSpiPs_SetOptions()</a>.</p>

</div>
</div>
<a class="anchor" id="gad085464580e29731d0eafc1b6eb4bdb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_CPOL_MASK&#160;&#160;&#160;0x00000002U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Polarity Configuration. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gad1b67fe9b7737a1af8067d6d69e1508b">XSpiPs_SetOptions()</a>.</p>

</div>
</div>
<a class="anchor" id="gab767a5fe469912c633373f607a106f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_MANSTRT_MASK&#160;&#160;&#160;0x00010000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Manual Transmission Start. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaff958edcef4502a9c897bd5886fc63cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_MANSTRTEN_MASK&#160;&#160;&#160;0x00008000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Manual Transmission Start Enable. </p>

</div>
</div>
<a class="anchor" id="ga8a86973f92b39e1091cdc8a1ab80dc51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_MODF_GEN_EN_MASK&#160;&#160;&#160;0x00020000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Modefail Generation Enable. </p>

</div>
</div>
<a class="anchor" id="ga134064afeaf8e1a72b0f927d6686794f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_MSTREN_MASK&#160;&#160;&#160;0x00000001U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Master Mode Enable. </p>

</div>
</div>
<a class="anchor" id="gab5bbcb1636123949d0fb41c76d7f77bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_OFFSET&#160;&#160;&#160;0x00U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Configuration. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab8f7c1eb75848839d7dc4fa81bc273e4">XSpiPs_GetClkPrescaler()</a>, <a class="el" href="group__spips__v3__0.html#ga842e4cf2fabf1849f451d9592d0b2722">XSpiPs_GetOptions()</a>, <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, <a class="el" href="group__spips__v3__0.html#gad3abd2456cfa67bc8d24dd255ba7de51">XSpiPs_Reset()</a>, <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>, <a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest()</a>, <a class="el" href="group__spips__v3__0.html#ga8359f8188f7bf36a0688963aff561692">XSpiPs_SetClkPrescaler()</a>, <a class="el" href="group__spips__v3__0.html#gad1b67fe9b7737a1af8067d6d69e1508b">XSpiPs_SetOptions()</a>, <a class="el" href="group__spips__v3__0.html#ga1ef5af2211095df5692567fa4721a8d5">XSpiPs_SetSlaveSelect()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gad2920edca049dac6e9cf45496fa5ea5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_PRESC_MASK&#160;&#160;&#160;0x00000038U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Prescaler Setting. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab8f7c1eb75848839d7dc4fa81bc273e4">XSpiPs_GetClkPrescaler()</a>, and <a class="el" href="group__spips__v3__0.html#ga8359f8188f7bf36a0688963aff561692">XSpiPs_SetClkPrescaler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c36cba75a4a522d258ad5cd668d39da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_PRESC_MAXIMUM&#160;&#160;&#160;0x07U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Prescaler maximum value. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga8359f8188f7bf36a0688963aff561692">XSpiPs_SetClkPrescaler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga89ff9aa9c710a64a2ea00031fa3e38e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_PRESC_SHIFT&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Prescaler shift. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab8f7c1eb75848839d7dc4fa81bc273e4">XSpiPs_GetClkPrescaler()</a>, and <a class="el" href="group__spips__v3__0.html#ga8359f8188f7bf36a0688963aff561692">XSpiPs_SetClkPrescaler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaec8a40193324debd139e5f47fbb2c943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_RESET_STATE&#160;&#160;&#160;0x00020000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Mode Fail Generation Enable. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gad3abd2456cfa67bc8d24dd255ba7de51">XSpiPs_Reset()</a>, <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>, and <a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a2016ac5799028970f07ff16749e135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_SSCTRL_MASK&#160;&#160;&#160;0x00003C00U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Slave Select Decode. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga4efc98fb1e6b9a927146bd3bcab8ea8b">XSpiPs_GetSlaveSelect()</a>, <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>, <a class="el" href="group__spips__v3__0.html#ga1ef5af2211095df5692567fa4721a8d5">XSpiPs_SetSlaveSelect()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf018d47444763ba551c4bded4dcbdda5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_SSCTRL_MAXIMUM&#160;&#160;&#160;0xFU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Slave Select maximum value. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga4efc98fb1e6b9a927146bd3bcab8ea8b">XSpiPs_GetSlaveSelect()</a>, and <a class="el" href="group__spips__v3__0.html#ga1ef5af2211095df5692567fa4721a8d5">XSpiPs_SetSlaveSelect()</a>.</p>

</div>
</div>
<a class="anchor" id="gaca12200356700e8fcd67716aea4aa283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_SSCTRL_SHIFT&#160;&#160;&#160;10U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Slave Select Decode shift. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga4efc98fb1e6b9a927146bd3bcab8ea8b">XSpiPs_GetSlaveSelect()</a>, and <a class="el" href="group__spips__v3__0.html#ga1ef5af2211095df5692567fa4721a8d5">XSpiPs_SetSlaveSelect()</a>.</p>

</div>
</div>
<a class="anchor" id="ga78439588630680bd62e34be7a0674ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_SSDECEN_MASK&#160;&#160;&#160;0x00000200U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Slave Select Decode Enable. </p>

</div>
</div>
<a class="anchor" id="ga639a4d2ccc6f03518062a17c45d9ba0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_CR_SSFORCE_MASK&#160;&#160;&#160;0x00004000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Force Slave Select. </p>

</div>
</div>
<a class="anchor" id="ga33e1010355cd9aca2d607fd41140fdce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DECODE_SSELECT_OPTION&#160;&#160;&#160;0x00000008U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Select 16 slaves Option. </p>

</div>
</div>
<a class="anchor" id="gae33752db88677fe0580abb65d6ba70cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_Disable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;XSpiPs_Out32(((InstancePtr)-&gt;Config.BaseAddress) + <a class="el" href="group__spips__v3__0.html#ga96a2524f86a513015b982462f7a6ffcb">XSPIPS_ER_OFFSET</a>, 0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Disable the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spips__v3__0.html#gae33752db88677fe0580abb65d6ba70cf" title="Disable the device. ">XSpiPs_Disable(u32 *InstancePtr)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort()</a>, <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, and <a class="el" href="group__spips__v3__0.html#gad1b67fe9b7737a1af8067d6d69e1508b">XSpiPs_SetOptions()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a6fad4316227a5337c49e2af28ee8ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DR_AFTER_MASK&#160;&#160;&#160;0x0000FF00U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Delay After Transfers mask. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>.</p>

</div>
</div>
<a class="anchor" id="ga56b1f2b236db35a9be0c75eb8bedb289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DR_AFTER_SHIFT&#160;&#160;&#160;8U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Delay After Transfers shift. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>, and <a class="el" href="group__spips__v3__0.html#gafe7ecd11569d8cf376ebc8f982503c52">XSpiPs_SetDelays()</a>.</p>

</div>
</div>
<a class="anchor" id="gad21ad068d7d43fe94abb40c5d40a1bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DR_BTWN_MASK&#160;&#160;&#160;0x00FF0000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Delay Between Transfers mask. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ff0e7a46a2566b4558a3a5f39819591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DR_BTWN_SHIFT&#160;&#160;&#160;16U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Delay Between Transfers shift. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>, and <a class="el" href="group__spips__v3__0.html#gafe7ecd11569d8cf376ebc8f982503c52">XSpiPs_SetDelays()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c61ee31777ca9fc61bb50dd86d45598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DR_INIT_MASK&#160;&#160;&#160;0x000000FFU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Delay Initially mask. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2cfead0ca3e714dae4cd98538575e723"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DR_NSS_MASK&#160;&#160;&#160;0xFF000000U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Delay for slave select de-assertion between word transfers mask. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d56d5e1023b1e2f11b67d0cfc4dac3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DR_NSS_SHIFT&#160;&#160;&#160;24U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Delay for slave select de-assertion between word transfers shift. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>, and <a class="el" href="group__spips__v3__0.html#gafe7ecd11569d8cf376ebc8f982503c52">XSpiPs_SetDelays()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8f2af4e1987e431a3a4510641c475e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_DR_OFFSET&#160;&#160;&#160;0x18U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Delay Register. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>, and <a class="el" href="group__spips__v3__0.html#gafe7ecd11569d8cf376ebc8f982503c52">XSpiPs_SetDelays()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7b3a41972453b0dfb7ec90f3972ddc74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_Enable</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">XSpiPs_Out32(((InstancePtr)-&gt;Config.BaseAddress) + <a class="code" href="group__spips__v3__0.html#ga96a2524f86a513015b982462f7a6ffcb">XSPIPS_ER_OFFSET</a>, \</div>
<div class="line">                <a class="code" href="group__spips__v3__0.html#gaa31de4b8fd2bc4cd055be77a535f9048">XSPIPS_ER_ENABLE_MASK</a>)</div>
<div class="ttc" id="group__spips__v3__0_html_gaa31de4b8fd2bc4cd055be77a535f9048"><div class="ttname"><a href="group__spips__v3__0.html#gaa31de4b8fd2bc4cd055be77a535f9048">XSPIPS_ER_ENABLE_MASK</a></div><div class="ttdeci">#define XSPIPS_ER_ENABLE_MASK</div><div class="ttdoc">SPI Enable Bit Mask. </div><div class="ttdef"><b>Definition:</b> xspips_hw.h:192</div></div>
<div class="ttc" id="group__spips__v3__0_html_ga96a2524f86a513015b982462f7a6ffcb"><div class="ttname"><a href="group__spips__v3__0.html#ga96a2524f86a513015b982462f7a6ffcb">XSPIPS_ER_OFFSET</a></div><div class="ttdeci">#define XSPIPS_ER_OFFSET</div><div class="ttdoc">Enable/Disable Register. </div><div class="ttdef"><b>Definition:</b> xspips_hw.h:89</div></div>
</div><!-- fragment -->
<p>Enable the device and uninhibit master transactions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spips__v3__0.html#ga7b3a41972453b0dfb7ec90f3972ddc74" title="Enable the device and uninhibit master transactions. ">XSpiPs_Enable(u32 *InstancePtr)</a> </dd></dl>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, <a class="el" href="group__spips__v3__0.html#gad1b67fe9b7737a1af8067d6d69e1508b">XSpiPs_SetOptions()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa31de4b8fd2bc4cd055be77a535f9048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_ER_ENABLE_MASK&#160;&#160;&#160;0x00000001U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>SPI Enable Bit Mask. </p>

</div>
</div>
<a class="anchor" id="ga96a2524f86a513015b982462f7a6ffcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_ER_OFFSET&#160;&#160;&#160;0x14U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Enable/Disable Register. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga57a4f4acf38b7c34eea6033c26f91bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_EVENT_MODE_FAULT&#160;&#160;&#160;1U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Mode fault error. </p>

</div>
</div>
<a class="anchor" id="ga6fd689b3734d076736704ba0ea228502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_EVENT_RECEIVE_OVERRUN&#160;&#160;&#160;4U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Receive data loss because RX FIFO full. </p>

</div>
</div>
<a class="anchor" id="ga001caa2536734fec092dedbd484204e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_EVENT_TRANSFER_DONE&#160;&#160;&#160;2U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Transfer done. </p>

</div>
</div>
<a class="anchor" id="ga2b83686724f80b3ca235108497ffb99e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_EVENT_TRANSMIT_UNDERRUN&#160;&#160;&#160;3U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>TX FIFO empty. </p>

</div>
</div>
<a class="anchor" id="gad82a11ae1f014d578834f1522a8a94ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_FIFO_DEPTH&#160;&#160;&#160;128U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>FIFO depth of Tx and Rx. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0a0da0e20b70ee21a3998117785638e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_FORCE_SSELECT_OPTION&#160;&#160;&#160;0x00000010U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Force Slave Select. </p>

</div>
</div>
<a class="anchor" id="ga27fb8402703b83365149ff051bb7aee8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_GetRXWatermark</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;XSpiPs_In32(((InstancePtr)-&gt;Config.BaseAddress) + <a class="el" href="group__spips__v3__0.html#ga708b416f4994dca83b3d50a464552286">XSPIPS_RXWR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Get the contents of the receive FIFO watermark register. </p>
<p>Use the XSPIPS_RXWR_* constants defined <a class="el" href="xspips__hw_8h.html">xspips_hw.h</a> to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 8-bit value representing the contents of the RXWR register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spips__v3__0.html#ga27fb8402703b83365149ff051bb7aee8" title="Get the contents of the receive FIFO watermark register. ">XSpiPs_GetRXWatermark(u32 *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f2055cfa93a26da233dff2fa8b0af8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_GetSlaveIdle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">XSpiPs_In32(((InstancePtr)-&gt;Config.BaseAddress) +               \</div>
<div class="line">        <a class="code" href="group__spips__v3__0.html#ga4498f0a85ffc367f14d705f37a2dcc11">XSPIPS_SICR_OFFSET</a>)</div>
<div class="ttc" id="group__spips__v3__0_html_ga4498f0a85ffc367f14d705f37a2dcc11"><div class="ttname"><a href="group__spips__v3__0.html#ga4498f0a85ffc367f14d705f37a2dcc11">XSPIPS_SICR_OFFSET</a></div><div class="ttdeci">#define XSPIPS_SICR_OFFSET</div><div class="ttdoc">Slave Idle Count. </div><div class="ttdef"><b>Definition:</b> xspips_hw.h:93</div></div>
</div><!-- fragment -->
<p>Get the contents of the slave idle count register. </p>
<p>Use the XSPIPS_SICR_* constants defined in <a class="el" href="xspips__hw_8h.html">xspips_hw.h</a> to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>8-bit value representing the contents of the SIC register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spips__v3__0.html#ga8f2055cfa93a26da233dff2fa8b0af8b" title="Get the contents of the slave idle count register. ">XSpiPs_GetSlaveIdle(XSpiPs *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae768acaf29460ddf625c0842a6546991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_GetTXWatermark</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td>&#160;&#160;&#160;XSpiPs_In32(((InstancePtr)-&gt;Config.BaseAddress) + <a class="el" href="group__spips__v3__0.html#ga82b0c7855556fbb3d13b1d0fc3f7ae24">XSPIPS_TXWR_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Get the contents of the transmit FIFO watermark register. </p>
<p>Use the XSPIPS_TXWR_* constants defined <a class="el" href="xspips__hw_8h.html">xspips_hw.h</a> to interpret the bit-mask returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>8-bit value representing the contents of the TXWR register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 <a class="el" href="group__spips__v3__0.html#gae768acaf29460ddf625c0842a6546991" title="Get the contents of the transmit FIFO watermark register. ">XSpiPs_GetTXWatermark(u32 *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c019fcf06dccd6efc0026238755e9bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IDR_OFFSET&#160;&#160;&#160;0x0CU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Interrupt Disable. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, and <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="gafe78a9665edf16e3114ff9c54f4b2adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IER_OFFSET&#160;&#160;&#160;0x08U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Interrupt Enable. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga809c89538cb8210bb76e00641226e3ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IMR_OFFSET&#160;&#160;&#160;0x10U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Interrupt Enabled Mask. </p>

</div>
</div>
<a class="anchor" id="gad01d887bc3e3b00c6a25ed26b3f71c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_ISR_RESET_STATE&#160;&#160;&#160;0x04U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Default to tx/rx reg empty. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ecb6f78f0e0f71ac85462071015353d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_DFLT_MASK&#160;&#160;&#160;0x00000027U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Default interrupts mask. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga58051be9e1582d618f4c75be29a32734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_DISABLE_ALL_MASK&#160;&#160;&#160;0x00000043U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Disable all interrupts. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f3e107983ccd2aa609a61691a4acbd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_MODF_MASK&#160;&#160;&#160;0x00000002U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Mode Fault. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort()</a>, <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, and <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9fc7edf6f528d10a32f847f7cb6177cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_RXFULL_MASK&#160;&#160;&#160;0x00000020U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Rx FIFO Full. </p>

</div>
</div>
<a class="anchor" id="ga72359f1b9dc7e5c5f0c5fdb3f6d62fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_RXNEMPTY_MASK&#160;&#160;&#160;0x00000010U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Rx FIFO Not Empty. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort()</a>, and <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga04768ee339e209d5134491b7dc5291f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_RXOVR_MASK&#160;&#160;&#160;0x00000001U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Rx FIFO Overrun. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8553285ef54073a9aa160bbd2035ce2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_TXFULL_MASK&#160;&#160;&#160;0x00000008U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Tx FIFO Full. </p>

</div>
</div>
<a class="anchor" id="gad8525498172f10882b4a7cf59c660577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_TXOW_MASK&#160;&#160;&#160;0x00000004U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Tx FIFO Overwater. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, and <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e7034f3e256ec752fe7cdef9b090ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_TXUF_MASK&#160;&#160;&#160;0x00000040U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Tx FIFO Underflow. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaefc16123501616910c471781dc5a6763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_IXR_WR_TO_CLR_MASK&#160;&#160;&#160;0x00000043U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Interrupts which need write to clear. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e6e32f2a23f47aa9f69c6adccbd2ba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_MANUAL_START_OPTION&#160;&#160;&#160;0x00000020U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Manual Start mode option. </p>

</div>
</div>
<a class="anchor" id="ga1fbe2203de88e79aa3a6c7e70e2f3436"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_MASTER_OPTION&#160;&#160;&#160;0x00000001U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Master mode option. </p>

</div>
</div>
<a class="anchor" id="ga3c4c628392bc69b6295b28d8736d3c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_ReadReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XSpiPs_In32((BaseAddress) + (RegOffset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Read a register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>contains the offset from the 1st register of the device to the target register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value read from the register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: u32 XSpiPs_ReadReg(u32 BaseAddress. int RegOffset) </dd></dl>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort()</a>, <a class="el" href="group__spips__v3__0.html#gab8f7c1eb75848839d7dc4fa81bc273e4">XSpiPs_GetClkPrescaler()</a>, <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>, <a class="el" href="group__spips__v3__0.html#ga842e4cf2fabf1849f451d9592d0b2722">XSpiPs_GetOptions()</a>, <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>, <a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest()</a>, <a class="el" href="group__spips__v3__0.html#ga8359f8188f7bf36a0688963aff561692">XSpiPs_SetClkPrescaler()</a>, <a class="el" href="group__spips__v3__0.html#gad1b67fe9b7737a1af8067d6d69e1508b">XSpiPs_SetOptions()</a>, <a class="el" href="group__spips__v3__0.html#ga1ef5af2211095df5692567fa4721a8d5">XSpiPs_SetSlaveSelect()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga63d53a4c31627791748d8b77d3c24cac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_RXD_OFFSET&#160;&#160;&#160;0x20U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Data Receive Register. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8e6d59478b0789f6ea58abbc85fc1947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_RXWR_MASK&#160;&#160;&#160;0x0000007FU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Receive Watermark Mask. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga708b416f4994dca83b3d50a464552286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_RXWR_OFFSET&#160;&#160;&#160;0x2CU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Receive FIFO Watermark. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="gab806ad4fc5536152742b74aa67f91cc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_RXWR_RESET_VALUE&#160;&#160;&#160;0x00000001U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Receive Watermark register reset value. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf7789f973a99a1192e89e6df23b8d84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_SetRXWatermark</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegisterValue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">XSpiPs_Out32(((InstancePtr)-&gt;Config.BaseAddress) +              \</div>
<div class="line">                <a class="code" href="group__spips__v3__0.html#ga708b416f4994dca83b3d50a464552286">XSPIPS_RXWR_OFFSET</a>, (RegisterValue))</div>
<div class="ttc" id="group__spips__v3__0_html_ga708b416f4994dca83b3d50a464552286"><div class="ttname"><a href="group__spips__v3__0.html#ga708b416f4994dca83b3d50a464552286">XSPIPS_RXWR_OFFSET</a></div><div class="ttdeci">#define XSPIPS_RXWR_OFFSET</div><div class="ttdoc">Receive FIFO Watermark. </div><div class="ttdef"><b>Definition:</b> xspips_hw.h:95</div></div>
</div><!-- fragment -->
<p>Set the contents of the receive FIFO watermark register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">RegisterValue</td><td>is the value to be written, valid values are 1-128.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spips__v3__0.html#gabf7789f973a99a1192e89e6df23b8d84" title="Set the contents of the receive FIFO watermark register. ">XSpiPs_SetRXWatermark(XSpiPs *InstancePtr, u32 RegisterValue)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac782d76352000f7cab838491744a022a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_SetSlaveIdle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegisterValue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">XSpiPs_Out32(((InstancePtr)-&gt;Config.BaseAddress) +      \</div>
<div class="line">                <a class="code" href="group__spips__v3__0.html#ga4498f0a85ffc367f14d705f37a2dcc11">XSPIPS_SICR_OFFSET</a>, (RegisterValue))</div>
<div class="ttc" id="group__spips__v3__0_html_ga4498f0a85ffc367f14d705f37a2dcc11"><div class="ttname"><a href="group__spips__v3__0.html#ga4498f0a85ffc367f14d705f37a2dcc11">XSPIPS_SICR_OFFSET</a></div><div class="ttdeci">#define XSPIPS_SICR_OFFSET</div><div class="ttdoc">Slave Idle Count. </div><div class="ttdef"><b>Definition:</b> xspips_hw.h:93</div></div>
</div><!-- fragment -->
<p>Set the contents of the slave idle count register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">RegisterValue</td><td>is the value to be writen, valid values are 0-255.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spips__v3__0.html#gac782d76352000f7cab838491744a022a" title="Set the contents of the slave idle count register. ">XSpiPs_SetSlaveIdle(XSpiPs *InstancePtr, u32 RegisterValue)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5501c2b3144a42ec20d93bcaa4732797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_SetTXWatermark</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegisterValue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">XSpiPs_Out32(((InstancePtr)-&gt;Config.BaseAddress) +              \</div>
<div class="line">                <a class="code" href="group__spips__v3__0.html#ga82b0c7855556fbb3d13b1d0fc3f7ae24">XSPIPS_TXWR_OFFSET</a>, (RegisterValue))</div>
<div class="ttc" id="group__spips__v3__0_html_ga82b0c7855556fbb3d13b1d0fc3f7ae24"><div class="ttname"><a href="group__spips__v3__0.html#ga82b0c7855556fbb3d13b1d0fc3f7ae24">XSPIPS_TXWR_OFFSET</a></div><div class="ttdeci">#define XSPIPS_TXWR_OFFSET</div><div class="ttdoc">Transmit FIFO Watermark. </div><div class="ttdef"><b>Definition:</b> xspips_hw.h:94</div></div>
</div><!-- fragment -->
<p>Set the contents of the transmit FIFO watermark register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">RegisterValue</td><td>is the value to be written, valid values are 1-128.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void <a class="el" href="group__spips__v3__0.html#ga5501c2b3144a42ec20d93bcaa4732797" title="Set the contents of the transmit FIFO watermark register. ">XSpiPs_SetTXWatermark(XSpiPs *InstancePtr, u32 RegisterValue)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae6d909341b39d857ea6e955e076e9024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_SICR_MASK&#160;&#160;&#160;0x000000FFU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Slave Idle Count Mask. </p>

</div>
</div>
<a class="anchor" id="ga4498f0a85ffc367f14d705f37a2dcc11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_SICR_OFFSET&#160;&#160;&#160;0x24U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Slave Idle Count. </p>

</div>
</div>
<a class="anchor" id="ga29c45b21694c49560b05b5773a976ff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_SR_OFFSET&#160;&#160;&#160;0x04U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Interrupt Status. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort()</a>, <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>, <a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3720b391032e33eb4cdb6b114943abbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_TXD_OFFSET&#160;&#160;&#160;0x1CU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Data Transmit Register. </p>

</div>
</div>
<a class="anchor" id="gac3beb6059f26dbf07ad7f2e8f1b8449c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_TXWR_MASK&#160;&#160;&#160;0x0000007FU</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Transmit Watermark Mask. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga82b0c7855556fbb3d13b1d0fc3f7ae24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_TXWR_OFFSET&#160;&#160;&#160;0x28U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Transmit FIFO Watermark. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a9a7acd83ec76540bc267398ee3bb20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPIPS_TXWR_RESET_VALUE&#160;&#160;&#160;0x00000001U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Transmit Watermark register reset value. </p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>.</p>

</div>
</div>
<a class="anchor" id="ga16d6923c47520aea34852e4c439bc02a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_WriteReg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RegisterValue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;XSpiPs_Out32((BaseAddress) + (RegOffset), (RegisterValue))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8h.html">xspips_hw.h</a>&gt;</code></p>

<p>Write to a register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>contains the base address of the device. </td></tr>
    <tr><td class="paramname">RegOffset</td><td>contains the offset from the 1st register of the device to target register. </td></tr>
    <tr><td class="paramname">RegisterValue</td><td>is the value to be written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-Style signature: void XSpiPs_WriteReg(u32 BaseAddress, int RegOffset, u32 RegisterValue) </dd></dl>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort()</a>, <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, <a class="el" href="group__spips__v3__0.html#ga94490f99431c92c2a9a54cc41d4abe71">XSpiPs_PolledTransfer()</a>, <a class="el" href="group__spips__v3__0.html#gad3abd2456cfa67bc8d24dd255ba7de51">XSpiPs_Reset()</a>, <a class="el" href="group__spips__v3__0.html#gab466a4718bbee60293dc226ca043d5b5">XSpiPs_ResetHw()</a>, <a class="el" href="group__spips__v3__0.html#ga8359f8188f7bf36a0688963aff561692">XSpiPs_SetClkPrescaler()</a>, <a class="el" href="group__spips__v3__0.html#gafe7ecd11569d8cf376ebc8f982503c52">XSpiPs_SetDelays()</a>, <a class="el" href="group__spips__v3__0.html#gad1b67fe9b7737a1af8067d6d69e1508b">XSpiPs_SetOptions()</a>, <a class="el" href="group__spips__v3__0.html#ga1ef5af2211095df5692567fa4721a8d5">XSpiPs_SetSlaveSelect()</a>, and <a class="el" href="group__spips__v3__0.html#ga747939dd62eb9c82ed185611e95211c7">XSpiPs_Transfer()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaec95e118eb971ab521b5a348a9861783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XSpiPs_StatusHandler) (void *CallBackRef, u32 StatusEvent, u32 ByteCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>The handler data type allows the user to define a callback function to handle the asynchronous processing for the SPI device. </p>
<p>The application using this driver is expected to define a handler of this type to support interrupt driven mode. The handler executes in an interrupt context, so only minimal processing should be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is the callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is not important to the driver, so it is a void pointer. </td></tr>
    <tr><td class="paramname">StatusEvent</td><td>holds one or more status events that have occurred. See the <a class="el" href="group__spips__v3__0.html#gacafc99130a16e99abb3d86e682f1de09" title="Sets the status callback function, the status handler, which the driver calls when it encounters cond...">XSpiPs_SetStatusHandler()</a> for details on the status events that can be passed in the callback. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>indicates how many bytes of data were successfully transferred. This may be less than the number of bytes requested if the status event indicates an error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1f40732e67f63579b811af115f2c575c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_Abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>Aborts a transfer in progress by disabling the device and resetting the FIFOs if present. </p>
<p>The byte counts are cleared, the busy flag is cleared, and mode fault is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function does a read/modify/write of the Config register. The user of this function needs to take care of critical sections. </p>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a5b08cdc0b7c5492d46a8e170941ba257">XSpiPs::RemainingBytes</a>, <a class="el" href="struct_x_spi_ps.html#a85a5e324de43e019ef15666bdc0685cd">XSpiPs::RequestedBytes</a>, <a class="el" href="group__spips__v3__0.html#gae33752db88677fe0580abb65d6ba70cf">XSpiPs_Disable</a>, <a class="el" href="group__spips__v3__0.html#ga1f3e107983ccd2aa609a61691a4acbd5">XSPIPS_IXR_MODF_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga72359f1b9dc7e5c5f0c5fdb3f6d62fc4">XSPIPS_IXR_RXNEMPTY_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, <a class="el" href="group__spips__v3__0.html#ga29c45b21694c49560b05b5773a976ff5">XSPIPS_SR_OFFSET</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gac57ccd3fab9a25399bdb8bc234fecc66">XSpiPs_InterruptHandler()</a>, and <a class="el" href="group__spips__v3__0.html#gad3abd2456cfa67bc8d24dd255ba7de51">XSpiPs_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga66fc6e7b4ec94e279b89cc0eab2debf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSpiPs_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EffectiveAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>Initializes a specific <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance such that the driver is ready to use. </p>
<p>The state of the device after initialization is:</p><ul>
<li>Device is disabled</li>
<li>Slave mode</li>
<li>Active high clock polarity</li>
<li>Clock phase 0</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">ConfigPtr</td><td>is a reference to a structure containing information about a specific SPI device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td class="paramname">EffectiveAddr</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use ConfigPtr-&gt;Config.BaseAddress for this device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_DEVICE_IS_STARTED if the device is already started. It must be stopped to re-initialize.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="struct_x_spi_ps.html#a4c8a252eaab49a4fa19fcd688f36fea6">XSpiPs::RecvBufferPtr</a>, <a class="el" href="struct_x_spi_ps.html#a5b08cdc0b7c5492d46a8e170941ba257">XSpiPs::RemainingBytes</a>, <a class="el" href="struct_x_spi_ps.html#a85a5e324de43e019ef15666bdc0685cd">XSpiPs::RequestedBytes</a>, <a class="el" href="struct_x_spi_ps.html#a827b441c0132c3ab87377efb81a027f2">XSpiPs::SendBufferPtr</a>, and <a class="el" href="group__spips__v3__0.html#gad3abd2456cfa67bc8d24dd255ba7de51">XSpiPs_Reset()</a>.</p>

</div>
</div>
<a class="anchor" id="gab8f7c1eb75848839d7dc4fa81bc273e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSpiPs_GetClkPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>This function gets the clock prescaler of an SPI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The prescaler value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gad2920edca049dac6e9cf45496fa5ea5a">XSPIPS_CR_PRESC_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga89ff9aa9c710a64a2ea00031fa3e38e5">XSPIPS_CR_PRESC_SHIFT</a>, and <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga716d3d27606e693e765a2b9d01cce462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_GetDelays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DelayNss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DelayBtwn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DelayAfter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>DelayInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>This function gets the delay settings for an SPI device. </p>
<p>The delay register controls the Delay Between Transfers, Delay After Transfers, and the Delay Initially. The default value is 0x0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">DelayNss</td><td>is a pointer to the delay for which the chip select outputs will be de-asserted between words when CPHA=0. </td></tr>
    <tr><td class="paramname">DelayBtwn</td><td>is a pointer to the Delay Between transfers value. This is a return parameter. </td></tr>
    <tr><td class="paramname">DelayAfter</td><td>is a pointer to the Delay After transfer value. This is a return parameter. </td></tr>
    <tr><td class="paramname">DelayInit</td><td>is a pointer to the Delay Initially value. This is a return parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="group__spips__v3__0.html#ga4a6fad4316227a5337c49e2af28ee8ef">XSPIPS_DR_AFTER_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga56b1f2b236db35a9be0c75eb8bedb289">XSPIPS_DR_AFTER_SHIFT</a>, <a class="el" href="group__spips__v3__0.html#gad21ad068d7d43fe94abb40c5d40a1bd0">XSPIPS_DR_BTWN_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga8ff0e7a46a2566b4558a3a5f39819591">XSPIPS_DR_BTWN_SHIFT</a>, <a class="el" href="group__spips__v3__0.html#ga1c61ee31777ca9fc61bb50dd86d45598">XSPIPS_DR_INIT_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga2cfead0ca3e714dae4cd98538575e723">XSPIPS_DR_NSS_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga2d56d5e1023b1e2f11b67d0cfc4dac3e">XSPIPS_DR_NSS_SHIFT</a>, <a class="el" href="group__spips__v3__0.html#gaf8f2af4e1987e431a3a4510641c475e7">XSPIPS_DR_OFFSET</a>, and <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>.</p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ga842e4cf2fabf1849f451d9592d0b2722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSpiPs_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>This function gets the options for the SPI device. </p>
<p>The options control how the device behaves relative to the SPI bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>Options contains the specified options currently set. This is a bit value where a 1 means the option is on, and a 0 means the option is off. See the bit definitions named XSPIPS_*_OPTIONS in file <a class="el" href="xspips_8h.html">xspips.h</a>.</p>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, and <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga4efc98fb1e6b9a927146bd3bcab8ea8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSpiPs_GetSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>Gets the current slave select setting for the SPI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The slave number selected (starting from 0).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="struct_x_spi_ps.html#a8d79fad73f829520b891e94b6e4536e1">XSpiPs::SlaveSelect</a>, <a class="el" href="group__spips__v3__0.html#ga0a2016ac5799028970f07ff16749e135">XSPIPS_CR_SSCTRL_MASK</a>, <a class="el" href="group__spips__v3__0.html#gaf018d47444763ba551c4bded4dcbdda5">XSPIPS_CR_SSCTRL_MAXIMUM</a>, and <a class="el" href="group__spips__v3__0.html#gaca12200356700e8fcd67716aea4aa283">XSPIPS_CR_SSCTRL_SHIFT</a>.</p>

</div>
</div>
<a class="anchor" id="gac57ccd3fab9a25399bdb8bc234fecc66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>The interrupt handler for SPI interrupts. </p>
<p>This function must be connected by the user to an interrupt controller.</p>
<p>The interrupts that are handled are:</p>
<ul>
<li>Mode Fault Error. This interrupt is generated if this device is selected as a slave when it is configured as a master. The driver aborts any data transfer that is in progress by resetting FIFOs (if present) and resetting its buffer pointers. The upper layer software is informed of the error.</li>
<li>Data Transmit Register (FIFO) Empty. This interrupt is generated when the transmit register or FIFO is empty. The driver uses this interrupt during a transmission to continually send/receive data until the transfer is done.</li>
<li>Data Transmit Register (FIFO) Underflow. This interrupt is generated when the SPI device, when configured as a slave, attempts to read an empty DTR/FIFO. An empty DTR/FIFO usually means that software is not giving the device data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li>
<li>Data Receive Register (FIFO) Overflow. This interrupt is generated when the SPI device attempts to write a received byte to an already full DRR/FIFO. A full DRR/FIFO usually means software is not emptying the data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li>
<li>Slave Mode Fault Error. This interrupt is generated if a slave device is selected as a slave while it is disabled. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The slave select register is being set to deselect the slave when a transfer is complete. This is being done regardless of whether it is a slave or a master since the hardware does not drive the slave select as a slave. </p>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="struct_x_spi_ps.html#a4c8a252eaab49a4fa19fcd688f36fea6">XSpiPs::RecvBufferPtr</a>, <a class="el" href="struct_x_spi_ps.html#a5b08cdc0b7c5492d46a8e170941ba257">XSpiPs::RemainingBytes</a>, <a class="el" href="struct_x_spi_ps.html#a85a5e324de43e019ef15666bdc0685cd">XSpiPs::RequestedBytes</a>, <a class="el" href="struct_x_spi_ps.html#a827b441c0132c3ab87377efb81a027f2">XSpiPs::SendBufferPtr</a>, <a class="el" href="struct_x_spi_ps.html#a012e4128cb1e93e765a8551512d91a77">XSpiPs::StatusRef</a>, <a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort()</a>, <a class="el" href="group__spips__v3__0.html#gab767a5fe469912c633373f607a106f7e">XSPIPS_CR_MANSTRT_MASK</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga0a2016ac5799028970f07ff16749e135">XSPIPS_CR_SSCTRL_MASK</a>, <a class="el" href="group__spips__v3__0.html#gae33752db88677fe0580abb65d6ba70cf">XSpiPs_Disable</a>, <a class="el" href="group__spips__v3__0.html#gad82a11ae1f014d578834f1522a8a94ca">XSPIPS_FIFO_DEPTH</a>, <a class="el" href="group__spips__v3__0.html#ga7c019fcf06dccd6efc0026238755e9bb">XSPIPS_IDR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gafe78a9665edf16e3114ff9c54f4b2adf">XSPIPS_IER_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga8ecb6f78f0e0f71ac85462071015353d">XSPIPS_IXR_DFLT_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga1f3e107983ccd2aa609a61691a4acbd5">XSPIPS_IXR_MODF_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga04768ee339e209d5134491b7dc5291f7">XSPIPS_IXR_RXOVR_MASK</a>, <a class="el" href="group__spips__v3__0.html#gad8525498172f10882b4a7cf59c660577">XSPIPS_IXR_TXOW_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga7e7034f3e256ec752fe7cdef9b090ff6">XSPIPS_IXR_TXUF_MASK</a>, <a class="el" href="group__spips__v3__0.html#gaefc16123501616910c471781dc5a6763">XSPIPS_IXR_WR_TO_CLR_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, <a class="el" href="group__spips__v3__0.html#ga29c45b21694c49560b05b5773a976ff5">XSPIPS_SR_OFFSET</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga70c86f3842f5996d9d7fc874466f4136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a> * XSpiPs_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Looks up the device configuration based on the unique device ID. </p>
<p>A table contains the configuration info for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>contains the ID of the device to look up the configuration for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>A pointer to the configuration found or NULL if the specified device ID was not found. See <a class="el" href="xspips_8h.html">xspips.h</a> for the definition of <a class="el" href="struct_x_spi_ps___config.html" title="This typedef contains configuration information for the device. ">XSpiPs_Config</a>.</p>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94490f99431c92c2a9a54cc41d4abe71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSpiPs_PolledTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>Transfers specified data on the SPI bus in polled mode. </p>
<p>The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: </p><pre>
  XSpiPs_PolledTransfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
      The caller wishes to send and receive, and provides two different
      buffers for send and receive.</pre><pre>  XSpiPs_PolledTransfer(InstancePtr, SendBuf, NULL, ByteCount)
      The caller wishes only to send and does not care about the received
      data. The driver ignores the received data in this case.</pre><pre>  XSpiPs_PolledTransfer(InstancePtr, SendBuf, SendBuf, ByteCount)
      The caller wishes to send and receive, but provides the same buffer
      for doing both. The driver sends the data and overwrites the send
      buffer with received data as it transfers the data.</pre><pre>  XSpiPs_PolledTransfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
      The caller wishes to only receive and does not care about sending
      data.  In this case, the caller must still provide a send buffer, but
      it can be the same as the receive buffer if the caller does not care
      what it sends.  The device must send N bytes of data if it wishes to
      receive N bytes of data.</pre><pre></pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">SendBufPtr</td><td>is a pointer to a buffer of data for sending. This buffer must not be NULL. </td></tr>
    <tr><td class="paramname">RecvBufPtr</td><td>is a pointer to a buffer for received data. This argument can be NULL if do not care about receiving. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the buffers are successfully handed off to the device for transfer.</li>
<li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the SPI bus at the same time. </p>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="struct_x_spi_ps.html#a4c8a252eaab49a4fa19fcd688f36fea6">XSpiPs::RecvBufferPtr</a>, <a class="el" href="struct_x_spi_ps.html#a5b08cdc0b7c5492d46a8e170941ba257">XSpiPs::RemainingBytes</a>, <a class="el" href="struct_x_spi_ps.html#a85a5e324de43e019ef15666bdc0685cd">XSpiPs::RequestedBytes</a>, <a class="el" href="struct_x_spi_ps.html#a827b441c0132c3ab87377efb81a027f2">XSpiPs::SendBufferPtr</a>, <a class="el" href="struct_x_spi_ps.html#a8d79fad73f829520b891e94b6e4536e1">XSpiPs::SlaveSelect</a>, <a class="el" href="group__spips__v3__0.html#gab767a5fe469912c633373f607a106f7e">XSPIPS_CR_MANSTRT_MASK</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga0a2016ac5799028970f07ff16749e135">XSPIPS_CR_SSCTRL_MASK</a>, <a class="el" href="group__spips__v3__0.html#gae33752db88677fe0580abb65d6ba70cf">XSpiPs_Disable</a>, <a class="el" href="group__spips__v3__0.html#ga7b3a41972453b0dfb7ec90f3972ddc74">XSpiPs_Enable</a>, <a class="el" href="group__spips__v3__0.html#gad82a11ae1f014d578834f1522a8a94ca">XSPIPS_FIFO_DEPTH</a>, <a class="el" href="group__spips__v3__0.html#ga1f3e107983ccd2aa609a61691a4acbd5">XSPIPS_IXR_MODF_MASK</a>, <a class="el" href="group__spips__v3__0.html#gad8525498172f10882b4a7cf59c660577">XSPIPS_IXR_TXOW_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, <a class="el" href="group__spips__v3__0.html#ga29c45b21694c49560b05b5773a976ff5">XSPIPS_SR_OFFSET</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gad3abd2456cfa67bc8d24dd255ba7de51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>Resets the SPI device. </p>
<p>Reset must only be called after the driver has been initialized. The configuration of the device after reset is the same as its configuration after initialization. Any data transfer that is in progress is aborted.</p>
<p>The upper layer software is responsible for re-configuring (if necessary) and restarting the SPI device after the reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="group__spips__v3__0.html#ga1f40732e67f63579b811af115f2c575c">XSpiPs_Abort()</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gaec8a40193324debd139e5f47fbb2c943">XSPIPS_CR_RESET_STATE</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#ga66fc6e7b4ec94e279b89cc0eab2debf2">XSpiPs_CfgInitialize()</a>, and <a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="gab466a4718bbee60293dc226ca043d5b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_ResetHw </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__hw_8c.html">xspips_hw.c</a>&gt;</code></p>

<p>Resets the spi module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>is the base address of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gaec8a40193324debd139e5f47fbb2c943">XSPIPS_CR_RESET_STATE</a>, <a class="el" href="group__spips__v3__0.html#ga0a2016ac5799028970f07ff16749e135">XSPIPS_CR_SSCTRL_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga96a2524f86a513015b982462f7a6ffcb">XSPIPS_ER_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga7c019fcf06dccd6efc0026238755e9bb">XSPIPS_IDR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga58051be9e1582d618f4c75be29a32734">XSPIPS_IXR_DISABLE_ALL_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga72359f1b9dc7e5c5f0c5fdb3f6d62fc4">XSPIPS_IXR_RXNEMPTY_MASK</a>, <a class="el" href="group__spips__v3__0.html#gaefc16123501616910c471781dc5a6763">XSPIPS_IXR_WR_TO_CLR_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, <a class="el" href="group__spips__v3__0.html#ga63d53a4c31627791748d8b77d3c24cac">XSPIPS_RXD_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga8e6d59478b0789f6ea58abbc85fc1947">XSPIPS_RXWR_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga708b416f4994dca83b3d50a464552286">XSPIPS_RXWR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gab806ad4fc5536152742b74aa67f91cc7">XSPIPS_RXWR_RESET_VALUE</a>, <a class="el" href="group__spips__v3__0.html#ga29c45b21694c49560b05b5773a976ff5">XSPIPS_SR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gac3beb6059f26dbf07ad7f2e8f1b8449c">XSPIPS_TXWR_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga82b0c7855556fbb3d13b1d0fc3f7ae24">XSPIPS_TXWR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga7a9a7acd83ec76540bc267398ee3bb20">XSPIPS_TXWR_RESET_VALUE</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa797b9b8184e6f39b0c0038553e48d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSpiPs_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>Runs a self-test on the driver/device. </p>
<p>The self-test is destructive in that a reset of the device is performed in order to check the reset values of the registers and to get the device into a known state.</p>
<p>Upon successful return from the self-test, the device is reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful</li>
</ul>
</dd></dl>
<ul>
<li>XST_REGISTER_ERROR indicates a register did not read or write correctly.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gaec8a40193324debd139e5f47fbb2c943">XSPIPS_CR_RESET_STATE</a>, <a class="el" href="group__spips__v3__0.html#ga716d3d27606e693e765a2b9d01cce462">XSpiPs_GetDelays()</a>, <a class="el" href="group__spips__v3__0.html#gad01d887bc3e3b00c6a25ed26b3f71c4a">XSPIPS_ISR_RESET_STATE</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, <a class="el" href="group__spips__v3__0.html#gad3abd2456cfa67bc8d24dd255ba7de51">XSpiPs_Reset()</a>, <a class="el" href="group__spips__v3__0.html#gafe7ecd11569d8cf376ebc8f982503c52">XSpiPs_SetDelays()</a>, and <a class="el" href="group__spips__v3__0.html#ga29c45b21694c49560b05b5773a976ff5">XSPIPS_SR_OFFSET</a>.</p>

</div>
</div>
<a class="anchor" id="ga8359f8188f7bf36a0688963aff561692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSpiPs_SetClkPrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Prescaler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>This function sets the clock prescaler for an SPI device. </p>
<p>The device must be idle rather than busy transferring data before setting these device options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">Prescaler</td><td>is the value that determine how much the clock should be divided by. Use the XSPIPS_CLK_PRESCALE_* constants defined in <a class="el" href="xspips_8h.html">xspips.h</a> for this setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if options are successfully set.</li>
<li>XST_DEVICE_BUSY if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not thread-safe. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gad2920edca049dac6e9cf45496fa5ea5a">XSPIPS_CR_PRESC_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga5c36cba75a4a522d258ad5cd668d39da">XSPIPS_CR_PRESC_MAXIMUM</a>, <a class="el" href="group__spips__v3__0.html#ga89ff9aa9c710a64a2ea00031fa3e38e5">XSPIPS_CR_PRESC_SHIFT</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gafe7ecd11569d8cf376ebc8f982503c52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSpiPs_SetDelays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>DelayNss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>DelayBtwn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>DelayAfter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>DelayInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>This function sets the delay register for the SPI device driver. </p>
<p>The delay register controls the Delay Between Transfers, Delay After Transfers, and the Delay Initially. The default value is 0x0. The range of each delay value is 0-255.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">DelayNss</td><td>is the delay for which the chip select outputs will be de-asserted between words when CPHA=0. </td></tr>
    <tr><td class="paramname">DelayBtwn</td><td>is the delay between one Slave Select being de-activated and the activation of another slave. The delay is the number of master clock periods given by DelayBtwn + 2. </td></tr>
    <tr><td class="paramname">DelayAfter</td><td>define the delay between the last bit of the current byte transfer and the first bit of the next byte transfer. The delay in number of master clock periods is given as: CPHA=0:DelayInit+DelayAfter+3 CPHA=1:DelayAfter+1 </td></tr>
    <tr><td class="paramname">DelayInit</td><td>is the delay between asserting the slave select signal and the first bit transfer. The delay int number of master clock periods is DelayInit+1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if delays are successfully set.</li>
<li>XST_DEVICE_BUSY if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="group__spips__v3__0.html#ga56b1f2b236db35a9be0c75eb8bedb289">XSPIPS_DR_AFTER_SHIFT</a>, <a class="el" href="group__spips__v3__0.html#ga8ff0e7a46a2566b4558a3a5f39819591">XSPIPS_DR_BTWN_SHIFT</a>, <a class="el" href="group__spips__v3__0.html#ga2d56d5e1023b1e2f11b67d0cfc4dac3e">XSPIPS_DR_NSS_SHIFT</a>, <a class="el" href="group__spips__v3__0.html#gaf8f2af4e1987e431a3a4510641c475e7">XSPIPS_DR_OFFSET</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

<p>Referenced by <a class="el" href="group__spips__v3__0.html#gaaa797b9b8184e6f39b0c0038553e48d8">XSpiPs_SelfTest()</a>.</p>

</div>
</div>
<a class="anchor" id="gad1b67fe9b7737a1af8067d6d69e1508b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSpiPs_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8h.html">xspips.h</a>&gt;</code></p>

<p>This function sets the options for the SPI device driver. </p>
<p>The options control how the device behaves relative to the SPI bus. The device must be idle rather than busy transferring data before setting these device options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">Options</td><td>contains the specified options to be set. This is a bit mask where a 1 means to turn the option on, and a 0 means to turn the option off. One or more bit values may be contained in the mask. See the bit definitions named XSPIPS_*_OPTIONS in the file <a class="el" href="xspips_8h.html">xspips.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if options are successfully set.</li>
<li>XST_DEVICE_BUSY if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not thread-safe. </dd></dl>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="group__spips__v3__0.html#ga4a6535d62a7cad8209d615146f5f050c">XSPIPS_CR_CPHA_MASK</a>, <a class="el" href="group__spips__v3__0.html#gad085464580e29731d0eafc1b6eb4bdb0">XSPIPS_CR_CPOL_MASK</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#gae33752db88677fe0580abb65d6ba70cf">XSpiPs_Disable</a>, <a class="el" href="group__spips__v3__0.html#ga7b3a41972453b0dfb7ec90f3972ddc74">XSpiPs_Enable</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ef5af2211095df5692567fa4721a8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSpiPs_SetSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlaveSel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>Selects or deselect the slave with which the master communicates. </p>
<p>This setting affects the SPI_ss_outN signals. The behavior depends on the setting of the CR_SSDECEN bit. If CR_SSDECEN is 0, the SPI_ss_outN bits will be output with a single signal low. If CR_SSDECEN is 1, the SPI_ss_outN bits will reflect the value set.</p>
<p>The user is not allowed to deselect the slave while a transfer is in progress. If no transfer is in progress, the user can select a new slave, which implicitly deselects the current slave. In order to explicitly deselect the current slave, a value of all 1's, 0x0F can be passed in as the argument to the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">SlaveSel</td><td>is the slave number to be selected. Normally, 3 slaves can be selected with values 0-2. In case, 3-8 decode option is set, then upto 8 slaves can be selected. Only one slave can be selected at a time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the slave is selected or deselected successfully.</li>
<li>XST_DEVICE_BUSY if a transfer is in progress, slave cannot be changed.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function only sets the slave which will be selected when a transfer occurs. The slave is not selected when the SPI is idle. The slave select has no affect when the device is configured as a slave. </p>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="struct_x_spi_ps.html#a8d79fad73f829520b891e94b6e4536e1">XSpiPs::SlaveSelect</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga0a2016ac5799028970f07ff16749e135">XSPIPS_CR_SSCTRL_MASK</a>, <a class="el" href="group__spips__v3__0.html#gaf018d47444763ba551c4bded4dcbdda5">XSPIPS_CR_SSCTRL_MAXIMUM</a>, <a class="el" href="group__spips__v3__0.html#gaca12200356700e8fcd67716aea4aa283">XSPIPS_CR_SSCTRL_SHIFT</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

</div>
</div>
<a class="anchor" id="gacafc99130a16e99abb3d86e682f1de09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_SetStatusHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__spips__v3__0.html#gaec95e118eb971ab521b5a348a9861783">XSpiPs_StatusHandler</a>&#160;</td>
          <td class="paramname"><em>FunctionPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to upper layer software. </p>
<p>The handler executes in an interrupt context, so it must minimize the amount of processing performed. One of the following status events is passed to the status handler.</p>
<pre>
XST_SPI_MODE_FAULT		A mode fault error occurred, meaning the device
			is selected as slave while being a master.</pre><pre>XST_SPI_TRANSFER_DONE		The requested data transfer is done</pre><pre>XST_SPI_TRANSMIT_UNDERRUN	As a slave device, the master clocked data
			but there were none available in the transmit
			register/FIFO. This typically means the slave
			application did not issue a transfer request
			fast enough, or the processor/driver could not
			fill the transmit register/FIFO fast enough.</pre><pre>XST_SPI_RECEIVE_OVERRUN	The SPI device lost data. Data was received
			but the receive data register/FIFO was full.</pre><pre>XST_SPI_SLAVE_MODE_FAULT	A slave SPI device was selected as a slave
			while it was disabled. This indicates the
			master is already transferring data (which is
			being dropped until the slave application
			issues a transfer).
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td class="paramname">FunctionPtr</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The handler is called within interrupt context, so it should do its work quickly and queue potentially time-consuming work to a task-level thread. </p>

<p>References <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, and <a class="el" href="struct_x_spi_ps.html#a012e4128cb1e93e765a8551512d91a77">XSpiPs::StatusRef</a>.</p>

</div>
</div>
<a class="anchor" id="ga747939dd62eb9c82ed185611e95211c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 XSpiPs_Transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips_8c.html">xspips.c</a>&gt;</code></p>

<p>Transfers specified data on the SPI bus. </p>
<p>If the SPI device is configured as a master, this function initiates bus communication and sends/receives the data to/from the selected SPI slave. If the SPI device is configured as a slave, this function prepares the buffers to be sent/received when selected by a master. For every byte sent, a byte is received. This function should be used to perform interrupt based transfers.</p>
<p>The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: </p><pre>
  XSpiPs_Transfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
      The caller wishes to send and receive, and provides two different
      buffers for send and receive.</pre><pre>  XSpiPs_Transfer(InstancePtr, SendBuf, NULL, ByteCount)
      The caller wishes only to send and does not care about the received
      data. The driver ignores the received data in this case.</pre><pre>  XSpiPs_Transfer(InstancePtr, SendBuf, SendBuf, ByteCount)
      The caller wishes to send and receive, but provides the same buffer
      for doing both. The driver sends the data and overwrites the send
      buffer with received data as it transfers the data.</pre><pre>  XSpiPs_Transfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
      The caller wishes to only receive and does not care about sending
      data.  In this case, the caller must still provide a send buffer, but
      it can be the same as the receive buffer if the caller does not care
      what it sends.  The device must send N bytes of data if it wishes to
      receive N bytes of data.
</pre><p> Although this function takes entire buffers as arguments, the driver can only transfer a limited number of bytes at a time, limited by the size of the FIFO. A call to this function only starts the transfer, then subsequent transfers of the data is performed by the interrupt service routine until the entire buffer has been transferred. The status callback function is called when the entire buffer has been sent/received.</p>
<p>This function is non-blocking. As a master, the SetSlaveSelect function must be called prior to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html" title="The XSpiPs driver instance data. ">XSpiPs</a> instance. </td></tr>
    <tr><td class="paramname">SendBufPtr</td><td>is a pointer to a buffer of data for sending. This buffer must not be NULL. </td></tr>
    <tr><td class="paramname">RecvBufPtr</td><td>is a pointer to a buffer for received data. This argument can be NULL if do not care about receiving. </td></tr>
    <tr><td class="paramname">ByteCount</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if the buffers are successfully handed off to the device for transfer.</li>
<li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the SPI bus at the same time. </p>

<p>References <a class="el" href="struct_x_spi_ps___config.html#a9b11063c0ae635e0284463e9edf0fdf8">XSpiPs_Config::BaseAddress</a>, <a class="el" href="struct_x_spi_ps.html#a2f23279c800d3c5e2d91622b1fa64aeb">XSpiPs::Config</a>, <a class="el" href="struct_x_spi_ps.html#a27b2c7d9c85bbe889cead27c5c384979">XSpiPs::IsBusy</a>, <a class="el" href="struct_x_spi_ps.html#a2b4bc94dfb1fa4b10dd398b6e2632d05">XSpiPs::IsReady</a>, <a class="el" href="struct_x_spi_ps.html#a4c8a252eaab49a4fa19fcd688f36fea6">XSpiPs::RecvBufferPtr</a>, <a class="el" href="struct_x_spi_ps.html#a5b08cdc0b7c5492d46a8e170941ba257">XSpiPs::RemainingBytes</a>, <a class="el" href="struct_x_spi_ps.html#a85a5e324de43e019ef15666bdc0685cd">XSpiPs::RequestedBytes</a>, <a class="el" href="struct_x_spi_ps.html#a827b441c0132c3ab87377efb81a027f2">XSpiPs::SendBufferPtr</a>, <a class="el" href="struct_x_spi_ps.html#a8d79fad73f829520b891e94b6e4536e1">XSpiPs::SlaveSelect</a>, <a class="el" href="group__spips__v3__0.html#gab767a5fe469912c633373f607a106f7e">XSPIPS_CR_MANSTRT_MASK</a>, <a class="el" href="group__spips__v3__0.html#gab5bbcb1636123949d0fb41c76d7f77bd">XSPIPS_CR_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga0a2016ac5799028970f07ff16749e135">XSPIPS_CR_SSCTRL_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga7b3a41972453b0dfb7ec90f3972ddc74">XSpiPs_Enable</a>, <a class="el" href="group__spips__v3__0.html#gad82a11ae1f014d578834f1522a8a94ca">XSPIPS_FIFO_DEPTH</a>, <a class="el" href="group__spips__v3__0.html#gafe78a9665edf16e3114ff9c54f4b2adf">XSPIPS_IER_OFFSET</a>, <a class="el" href="group__spips__v3__0.html#ga8ecb6f78f0e0f71ac85462071015353d">XSPIPS_IXR_DFLT_MASK</a>, <a class="el" href="group__spips__v3__0.html#gaefc16123501616910c471781dc5a6763">XSPIPS_IXR_WR_TO_CLR_MASK</a>, <a class="el" href="group__spips__v3__0.html#ga3c4c628392bc69b6295b28d8736d3c14">XSpiPs_ReadReg</a>, <a class="el" href="group__spips__v3__0.html#ga29c45b21694c49560b05b5773a976ff5">XSPIPS_SR_OFFSET</a>, and <a class="el" href="group__spips__v3__0.html#ga16d6923c47520aea34852e4c439bc02a">XSpiPs_WriteReg</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga911607d6e9946f277bc01a02c53083ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a> XSpiPs_ConfigTable[XPAR_XSPIPS_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__sinit_8c.html">xspips_sinit.c</a>&gt;</code></p>

<p>This table contains configuration information for each SPI device in the system. </p>

</div>
</div>
<a class="anchor" id="ga911607d6e9946f277bc01a02c53083ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a> XSpiPs_ConfigTable[XPAR_XSPIPS_NUM_INSTANCES]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xspips__g_8c.html">xspips_g.c</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        {</div>
<div class="line">                (u16)XPAR_XSPIPS_0_DEVICE_ID, </div>
<div class="line">                (u32)XPAR_XSPIPS_0_BASEADDR,  </div>
<div class="line">                (u32)XPAR_XSPIPS_0_SPI_CLK_FREQ_HZ</div>
<div class="line">        },</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This table contains configuration information for each SPI device in the system. </p>

</div>
</div>
</div><!-- contents -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
