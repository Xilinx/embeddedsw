<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>axidma: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">axidma
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">axidma Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the driver API for the AXI DMA engine.For a full description of DMA features, please see the hardware spec. This driver supports the following features:</p>
<ul>
<li>Scatter-Gather DMA (SGDMA)</li>
<li>Simple DMA</li>
<li>Interrupts</li>
<li>Programmable interrupt coalescing for SGDMA</li>
<li>APIs to manage Buffer Descriptors (BD) movement to and from the SGDMA engine</li>
</ul>
<p><b>Simple DMA</b></p>
<p>Simple DMA allows the application to define a single transaction between DMA and Device. It has two channels: one from the DMA to Device and the other from Device to DMA. Application has to set the buffer address and length fields to initiate the transfer in respective channel.</p>
<p><b>Transactions</b></p>
<p>The object used to describe a transaction is referred to as a Buffer Descriptor (BD). Buffer descriptors are allocated in the user application. The user application needs to set buffer address, transfer length, and control information for this transfer. The control information includes SOF and EOF. Definition of those masks are in <a class="el" href="xaxidma__hw_8h.html">xaxidma_hw.h</a></p>
<p><b>Scatter-Gather DMA</b></p>
<p>SGDMA allows the application to define a list of transactions in memory which the hardware will process without further application intervention. During this time, the application is free to continue adding more work to keep the Hardware busy.</p>
<p>User can check for the completion of transactions through polling the hardware, or interrupts.</p>
<p>SGDMA processes whole packets. A packet is defined as a series of data bytes that represent a message. SGDMA allows a packet of data to be broken up into one or more transactions. For example, take an Ethernet IP packet which consists of a 14 byte header followed by a 1 or more bytes of payload. With SGDMA, the application may point a BD to the header and another BD to the payload, then transfer them as a single message. This strategy can make a TCP/IP stack more efficient by allowing it to keep packet header and data in different memory regions instead of assembling packets into contiguous blocks of memory.</p>
<p><b>BD Ring Management</b></p>
<p>BD rings are shared by the software and the hardware.</p>
<p>The hardware expects BDs to be setup as a linked list. The DMA hardware walks through the list by following the next pointer field of a completed BD. The hardware stops processing when the just completed BD is the same as the BD specified in the Tail Ptr register in the hardware.</p>
<p>The last BD in the ring is linked to the first BD in the ring.</p>
<p>All BD management are done inside the driver. The user application should not directly modify the BD fields. Modifications to the BD fields should always go through the specific API functions.</p>
<p>Within the ring, the driver maintains four groups of BDs. Each group consists of 0 or more adjacent BDs:</p>
<ul>
<li>Free: The BDs that can be allocated by the application with <a class="el" href="group__axidma__v9__4.html#ga44003cd704b7d4868d1dc00bb433a91f" title="Reserve locations in the BD ring. ">XAxiDma_BdRingAlloc()</a>.</li>
<li>Pre-process: The BDs that have been allocated with <a class="el" href="group__axidma__v9__4.html#ga44003cd704b7d4868d1dc00bb433a91f" title="Reserve locations in the BD ring. ">XAxiDma_BdRingAlloc()</a>. These BDs are under application control. The application modifies these BDs through driver API to prepare them for DMA transactions.</li>
<li>Hardware: The BDs that have been enqueued to hardware with <a class="el" href="group__axidma__v9__4.html#gaac81111b373e373be7dd3989fffffe7b" title="Enqueue a set of BDs to hardware that were previously allocated by XAxiDma_BdRingAlloc(). ">XAxiDma_BdRingToHw()</a>. These BDs are under hardware control and may be in a state of awaiting hardware processing, in process, or processed by hardware. It is considered an error for the application to change BDs while they are in this group. Doing so can cause data corruption and lead to system instability.</li>
<li>Post-process: The BDs that have been processed by hardware and have been extracted from the Hardware group with <a class="el" href="group__axidma__v9__4.html#ga1e5d328b4d4a247d1530fac3efe4c59c" title="Returns a set of BD(s) that have been processed by hardware. ">XAxiDma_BdRingFromHw()</a>. These BDs are under application control. The application can check the transfer status of these BDs. The application use <a class="el" href="group__axidma__v9__4.html#gad2ac76e5a39486896cd484e51d2898c7" title="Frees a set of BDs that had been previously retrieved with XAxiDma_BdRingFromHw(). ">XAxiDma_BdRingFree()</a> to put them into the Free group.</li>
</ul>
<p>BDs are expected to transition in the following way for continuous DMA transfers: </p><pre></pre><pre>        <a class="el" href="group__axidma__v9__4.html#ga44003cd704b7d4868d1dc00bb433a91f" title="Reserve locations in the BD ring. ">XAxiDma_BdRingAlloc()</a>                   <a class="el" href="group__axidma__v9__4.html#gaac81111b373e373be7dd3989fffffe7b" title="Enqueue a set of BDs to hardware that were previously allocated by XAxiDma_BdRingAlloc(). ">XAxiDma_BdRingToHw()</a>
  Free ------------------------&gt; Pre-process ----------------------&gt; Hardware
                                                                     |
   /|\                                                               |
    |   <a class="el" href="group__axidma__v9__4.html#gad2ac76e5a39486896cd484e51d2898c7" title="Frees a set of BDs that had been previously retrieved with XAxiDma_BdRingFromHw(). ">XAxiDma_BdRingFree()</a>                  <a class="el" href="group__axidma__v9__4.html#ga1e5d328b4d4a247d1530fac3efe4c59c" title="Returns a set of BD(s) that have been processed by hardware. ">XAxiDma_BdRingFromHw()</a> |
    +--------------------------- Post-process &lt;----------------------+</pre><pre></pre><p>When a DMA transfer is to be cancelled before enqueuing to hardware, application can return the requested BDs to the Free group using <a class="el" href="group__axidma__v9__4.html#gac58b1ab7a89890142baf67211772d3ce" title="Fully or partially undo an XAxiDma_BdRingAlloc() operation. ">XAxiDma_BdRingUnAlloc()</a>, as shown below: </p><pre></pre><pre>        <a class="el" href="group__axidma__v9__4.html#gac58b1ab7a89890142baf67211772d3ce" title="Fully or partially undo an XAxiDma_BdRingAlloc() operation. ">XAxiDma_BdRingUnAlloc()</a>
  Free &lt;----------------------- Pre-process</pre><pre></pre><p>The API provides functions for BD list traversal:</p><ul>
<li><a class="el" href="group__axidma__v9__4.html#ga4b7e75d1acf86428bd79fcd0d1c13745" title="Return the next BD in the ring. ">XAxiDma_BdRingNext()</a></li>
<li><a class="el" href="group__axidma__v9__4.html#ga86c6d4b9c4f8766634d46a3078eadc8a" title="Return the previous BD in the ring. ">XAxiDma_BdRingPrev()</a></li>
</ul>
<p>These functions should be used with care as they do not understand where one group ends and another begins.</p>
<p><b>SGDMA Descriptor Ring Creation</b></p>
<p>BD ring is created using <a class="el" href="group__axidma__v9__4.html#ga5c6d6f492642dd355478c3a853556d6b" title="Using a memory segment allocated by the caller, This fundtion creates and setup the BD ring...">XAxiDma_BdRingCreate()</a>. The memory for the BD ring is allocated by the application, and it has to be contiguous. Physical address is required to setup the BD ring.</p>
<p>The applicaiton can use <a class="el" href="group__axidma__v9__4.html#ga6899085c400b8f453381b305ac5521d9" title="Use this macro at initialization time to determine how many bytes of memory are required to contain a...">XAxiDma_BdRingMemCalc()</a> to find out the amount of memory needed for a certain number of BDs. <a class="el" href="group__axidma__v9__4.html#ga5c87fcb74fe669b5998e53d0a4b35127" title="Use this macro at initialization time to determine how many BDs will fit within the given memory cons...">XAxiDma_BdRingCntCalc()</a> can be used to find out how many BDs can be allocated for certain amount of memory.</p>
<p>A helper function, <a class="el" href="group__axidma__v9__4.html#gad044df5bd676a71226411ba7f78ef20b" title="Clone the given BD into every BD in the ring. ">XAxiDma_BdRingClone()</a>, can speed up the BD ring setup if the BDs have same types of controls, for example, SOF and EOF. After using the <a class="el" href="group__axidma__v9__4.html#gad044df5bd676a71226411ba7f78ef20b" title="Clone the given BD into every BD in the ring. ">XAxiDma_BdRingClone()</a>, the application only needs to setup the buffer address and transfer length. Note that certain BDs in one packet, for example, the first BD and the last BD, may need to setup special control information.</p>
<p><b>Descriptor Ring State Machine</b></p>
<p>There are two states of the BD ring:</p>
<ul>
<li>HALTED (H), where hardware is not running</li>
<li>NOT HALTED (NH), where hardware is running</li>
</ul>
<p>The following diagram shows the state transition for the DMA engine:</p>
<pre>
  _____ <a class="el" href="group__axidma__v9__4.html#ga7b38bc9220c391823219937580bd816f" title="Start a DMA channel and Allow DMA transactions to commence on a given channel if descriptors are read...">XAxiDma_StartBdRingHw()</a>, or <a class="el" href="group__axidma__v9__4.html#gaafd18a1df185c30b4745c147e3295ac3" title="Start a DMA channel, updates current descriptors and Allow DMA transactions to commence on a given ch...">XAxiDma_BdRingStart()</a>,   ______
  |   |               or <a class="el" href="group__axidma__v9__5.html#ga847cd9a0255fcb444bce58b945de8574" title="Resume DMA transactions on both channels. ">XAxiDma_Resume()</a>                    |    |
  | H |-----------------------------------------------------&gt;| NH |
  |   |&lt;-----------------------------------------------------|    |
  -----   <a class="el" href="group__axidma__v9__5.html#gadb572b623215a7df62b1e0468e3bd68c" title="Pause DMA transactions on both channels. ">XAxiDma_Pause()</a> or <a class="el" href="group__axidma__v9__5.html#ga5b7d1248ef065915fd8c9e8d5e00640f" title="Reset both TX and RX channels of a DMA engine. ">XAxiDma_Reset()</a>                 ------
</pre><p><b>Interrupt Coalescing</b></p>
<p>SGDMA provides control over the frequency of interrupts through interrupt coalescing. The DMA engine provides two ways to tune the interrupt coalescing:</p>
<ul>
<li>The packet threshold counter. Interrupt will fire once the programmable number of packets have been processed by the engine.</li>
<li>The packet delay timer counter. Interrupt will fire once the programmable amount of time has passed after processing the last packet, and no new packets to process. Note that the interrupt will only fire if at least one packet has been processed.</li>
</ul>
<p><b> Interrupt </b></p>
<p>Interrupts are handled by the user application. Each DMA channel has its own interrupt ID. The driver provides APIs to enable/disable interrupt, and tune the interrupt frequency regarding to packet processing frequency.</p>
<p><b> Software Initialization </b></p>
<p>To use the Simple mode DMA engine for transfers, the following setup is required:</p>
<ul>
<li>DMA Initialization using <a class="el" href="group__axidma__v9__5.html#ga8026e76c90d891d21c9c355ff776cb77" title="This function initializes a DMA engine. ">XAxiDma_CfgInitialize()</a> function. This step initializes a driver instance for the given DMA engine and resets the engine.</li>
<li>Enable interrupts if chosen to use interrupt mode. The application is responsible for setting up the interrupt system, which includes providing and connecting interrupt handlers and call back functions, before enabling the interrupts.</li>
<li>Set the buffer address and length field in respective channels to start the DMA transfer</li>
</ul>
<p>To use the SG mode DMA engine for transfers, the following setup are required:</p>
<ul>
<li>DMA Initialization using <a class="el" href="group__axidma__v9__5.html#ga8026e76c90d891d21c9c355ff776cb77" title="This function initializes a DMA engine. ">XAxiDma_CfgInitialize()</a> function. This step initializes a driver instance for the given DMA engine and resets the engine.</li>
<li>BD Ring creation. A BD ring is needed per DMA channel and can be built by calling <a class="el" href="group__axidma__v9__4.html#ga5c6d6f492642dd355478c3a853556d6b" title="Using a memory segment allocated by the caller, This fundtion creates and setup the BD ring...">XAxiDma_BdRingCreate()</a>.</li>
<li>Enable interrupts if chose to use interrupt mode. The application is responsible for setting up the interrupt system, which includes providing and connecting interrupt handlers and call back functions, before enabling the interrupts.</li>
<li>Start a DMA transfer: Call <a class="el" href="group__axidma__v9__4.html#gaafd18a1df185c30b4745c147e3295ac3" title="Start a DMA channel, updates current descriptors and Allow DMA transactions to commence on a given ch...">XAxiDma_BdRingStart()</a> to start a transfer for the first time or after a reset, and <a class="el" href="group__axidma__v9__4.html#gaac81111b373e373be7dd3989fffffe7b" title="Enqueue a set of BDs to hardware that were previously allocated by XAxiDma_BdRingAlloc(). ">XAxiDma_BdRingToHw()</a> if the channel is already started. Calling <a class="el" href="group__axidma__v9__4.html#gaac81111b373e373be7dd3989fffffe7b" title="Enqueue a set of BDs to hardware that were previously allocated by XAxiDma_BdRingAlloc(). ">XAxiDma_BdRingToHw()</a> when a DMA channel is not running will not put the BDs to the hardware, and the BDs will be processed later when the DMA channel is started through <a class="el" href="group__axidma__v9__4.html#gaafd18a1df185c30b4745c147e3295ac3" title="Start a DMA channel, updates current descriptors and Allow DMA transactions to commence on a given ch...">XAxiDma_BdRingStart()</a>.</li>
</ul>
<p><b> How to start DMA transactions </b></p>
<p>The user application uses <a class="el" href="group__axidma__v9__4.html#gaac81111b373e373be7dd3989fffffe7b" title="Enqueue a set of BDs to hardware that were previously allocated by XAxiDma_BdRingAlloc(). ">XAxiDma_BdRingToHw()</a> to submit BDs to the hardware to start DMA transfers.</p>
<p>For both channels, if the DMA engine is currently stopped (using <a class="el" href="group__axidma__v9__5.html#gadb572b623215a7df62b1e0468e3bd68c" title="Pause DMA transactions on both channels. ">XAxiDma_Pause()</a>), the newly added BDs will be accepted but not processed until the DMA engine is started, using <a class="el" href="group__axidma__v9__4.html#gaafd18a1df185c30b4745c147e3295ac3" title="Start a DMA channel, updates current descriptors and Allow DMA transactions to commence on a given ch...">XAxiDma_BdRingStart()</a>, or resumed, using <a class="el" href="group__axidma__v9__5.html#ga847cd9a0255fcb444bce58b945de8574" title="Resume DMA transactions on both channels. ">XAxiDma_Resume()</a>.</p>
<p><b> Software Post-Processing on completed DMA transactions </b></p>
<p>If the interrupt system has been set up and the interrupts are enabled, a DMA channels notifies the software about the completion of a transfer through interrupts. Otherwise, the user application can poll for completions of the BDs, using <a class="el" href="group__axidma__v9__4.html#ga1e5d328b4d4a247d1530fac3efe4c59c" title="Returns a set of BD(s) that have been processed by hardware. ">XAxiDma_BdRingFromHw()</a> or <a class="el" href="group__axidma__v9__4.html#ga844fc6b60315598387d17c8148a891e4" title="Check whether a BD has completed in hardware. ">XAxiDma_BdHwCompleted()</a>.</p>
<ul>
<li>Once BDs are finished by a channel, the application first needs to fetch them from the channel using <a class="el" href="group__axidma__v9__4.html#ga1e5d328b4d4a247d1530fac3efe4c59c" title="Returns a set of BD(s) that have been processed by hardware. ">XAxiDma_BdRingFromHw()</a>.</li>
<li>On the TX side, the application now could free the data buffers attached to those BDs as the data in the buffers has been transmitted.</li>
<li>On the RX side, the application now could use the received data in the buffers attached to those BDs.</li>
<li>For both channels, completed BDs need to be put back to the Free group using <a class="el" href="group__axidma__v9__4.html#gad2ac76e5a39486896cd484e51d2898c7" title="Frees a set of BDs that had been previously retrieved with XAxiDma_BdRingFromHw(). ">XAxiDma_BdRingFree()</a>, so they can be used for future transactions.</li>
<li>On the RX side, it is the application's responsibility to have BDs ready to receive data at any time. Otherwise, the RX channel refuses to accept any data if it has no RX BDs.</li>
</ul>
<p><b> Examples </b></p>
<p>We provide five examples to show how to use the driver API:</p><ul>
<li>One for SG interrupt mode (<a class="el" href="xaxidma__example__sg__intr_8c.html" title="This file demonstrates how to use the xaxidma driver on the Xilinx AXI DMA core (AXIDMA) to transfer ...">xaxidma_example_sg_intr.c</a>), multiple BD/packets transfer</li>
<li>One for SG polling mode (<a class="el" href="xaxidma__example__sg__poll_8c.html" title="This file demonstrates how to use the xaxidma driver on the Xilinx AXI DMA core (AXIDMA) to transfer ...">xaxidma_example_sg_poll.c</a>), single BD transfer.</li>
<li>One for SG polling mode (xaxidma_poll_multi_pkts.c), multiple BD/packets transfer</li>
<li>One for simple polling mode (<a class="el" href="xaxidma__example__simple__poll_8c.html" title="This file demonstrates how to use the xaxidma driver on the Xilinx AXI DMA core (AXIDMA) to transfer ...">xaxidma_example_simple_poll.c</a>)</li>
<li>One for simple Interrupt mode (<a class="el" href="xaxidma__example__simple__intr_8c.html" title="This file demonstrates how to use the xaxidma driver on the Xilinx AXI DMA core (AXIDMA) to transfer ...">xaxidma_example_simple_intr.c</a>)</li>
</ul>
<p><b> Address Translation </b></p>
<p>All buffer addresses and BD addresses for the hardware are physical addresses. The user application is responsible to provide physical buffer address for the BD upon BD ring creation. The user application accesses BD through its virtual addess. The driver maintains the address translation between the physical and virtual address for BDs.</p>
<p><b> Cache Coherency </b></p>
<p>This driver expects all application buffers attached to BDs to be in cache coherent memory. If cache is used in the system, buffers for transmit MUST be flushed from the cache before passing the associated BD to this driver. Buffers for receive MUST be invalidated before accessing the data.</p>
<p><b> Alignment </b></p>
<p>For BDs:</p>
<p>Minimum alignment is defined by the constant XAXIDMA_BD_MINIMUM_ALIGNMENT. This is the smallest alignment allowed by both hardware and software for them to properly work.</p>
<p>If the descriptor ring is to be placed in cached memory, alignment also MUST be at least the processor's cache-line size. Otherwise, system instability occurs. For alignment larger than the cache line size, multiple cache line size alignment is required.</p>
<p>Aside from the initial creation of the descriptor ring (see <a class="el" href="group__axidma__v9__4.html#ga5c6d6f492642dd355478c3a853556d6b" title="Using a memory segment allocated by the caller, This fundtion creates and setup the BD ring...">XAxiDma_BdRingCreate()</a>), there are no other run-time checks for proper alignment of BDs.</p>
<p>For application data buffers:</p>
<p>Application data buffers may reside on any alignment if DRE is built into the hardware. Otherwise, application data buffer must be word-aligned. The word is defined by XPAR_AXIDMA_0_M_AXIS_MM2S_TDATA_WIDTH for transmit and XPAR_AXIDMA_0_S_AXIS_S2MM_TDATA_WIDTH for receive.</p>
<p>For scatter gather transfers that have more than one BDs in the chain of BDs, Each BD transfer length must be multiple of word too. Otherwise, internal error happens in the hardware.</p>
<p><b> Error Handling </b></p>
<p>The DMA engine will halt on all error conditions. It requires the software to do a reset before it can start process new transfer requests.</p>
<p><b> Restart After Stopping </b></p>
<p>After the DMA engine has been stopped (through reset or reset after an error) the software keeps track of the current BD pointer when reset happens, and processing of BDs can be resumed through <a class="el" href="group__axidma__v9__4.html#gaafd18a1df185c30b4745c147e3295ac3" title="Start a DMA channel, updates current descriptors and Allow DMA transactions to commence on a given ch...">XAxiDma_BdRingStart()</a>.</p>
<p><b> Limitations </b></p>
<p>This driver does not have any mechanisms for mutual exclusion. It is up to the application to provide this protection.</p>
<p><b> Hardware Defaults &amp; Exclusive Use </b></p>
<p>After the initialization or reset, the DMA engine is in the following default mode:</p><ul>
<li>All interrupts are disabled.</li>
<li>Interrupt coalescing counter is 1.</li>
<li>The DMA engine is not running (halted). Each DMA channel is started separately, using <a class="el" href="group__axidma__v9__4.html#ga7b38bc9220c391823219937580bd816f" title="Start a DMA channel and Allow DMA transactions to commence on a given channel if descriptors are read...">XAxiDma_StartBdRingHw()</a> if no BDs are setup for transfer yet, or <a class="el" href="group__axidma__v9__4.html#gaafd18a1df185c30b4745c147e3295ac3" title="Start a DMA channel, updates current descriptors and Allow DMA transactions to commence on a given ch...">XAxiDma_BdRingStart()</a> otherwise.</li>
</ul>
<p>The driver has exclusive use of the registers and BDs. All accesses to the registers and BDs should go through the driver interface.</p>
<p><b> Debug Print </b></p>
<p>To see the debug print for the driver, please put "-DDEBUG" as the extra compiler flags in software platform settings. Also comment out the line in xdebug.h: "#undef DEBUG".</p>
<p><b>Changes From v1.00a</b></p>
<p>. We have changes return type for <a class="el" href="group__axidma__v9__4.html#gac1a9cb01ba6cd686ee08245f5e08cb22" title="Set the BD&#39;s buffer address. ">XAxiDma_BdSetBufAddr()</a> from void to int . We added <a class="el" href="group__axidma__v9__5.html#gacd79fe1f2642f5cf8423e483b6f54e6e" title="Look up the hardware configuration for a device instance. ">XAxiDma_LookupConfig()</a> so that user does not need to look for the hardware settings anymore.</p>
<pre>
MODIFICATION HISTORY:</pre><pre>Ver   Who  Date     Changes
<hr/>

1.00a jz   05/18/10 First release
2.00a jz   08/10/10 Second release, added in <a class="el" href="xaxidma__g_8c.html">xaxidma_g.c</a>, <a class="el" href="xaxidma__sinit_8c.html">xaxidma_sinit.c</a>,
                    updated tcl file, added <a class="el" href="xaxidma__porting__guide_8h.html">xaxidma_porting_guide.h</a>
3.00a jz   11/22/10 Support IP core parameters change
4.00a rkv  02/22/11 Added support for simple DMA mode
              New API added for simple DMA mode are<ul>
<li>XAxiDma_Busy</li>
<li>XAxiDma_SimpleTransfer
              New Macros added for simple DMA mode are<ul>
<li>XAxiDma_HasSg</li>
<li>XAxiDma_IntrEnable</li>
<li>XAxiDma_IntrGetEnabled</li>
<li>XAxiDma_IntrDisable</li>
<li>XAxiDma_IntrGetIrq</li>
<li>XAxiDma_IntrAckIrq
5.00a srt  08/25/11  Added support for memory barrier and modified
                Cache Macros to have a common API for Microblaze
                and Zynq.
6.00a srt  01/24/12 Added support for Multi-Channel DMA mode.</li>
</ul>
</li>
</ul>
</pre><pre>Changed APIs:
                * <a class="el" href="group__axidma__v9__5.html#ga6373ac3baa5365607f6727f4e2ece7a5" title="Get Receive (Rx) Ring ptr. ">XAxiDma_GetRxRing(InstancePtr, RingIndex)</a>
                * XAxiDma_Start(XAxiDma * InstancePtr, int RingIndex)
                * XAxiDma_Started(XAxiDma * InstancePtr, int RingIndex)
                * XAxiDma_Pause(XAxiDma * InstancePtr, int RingIndex)
                * XAxiDma_Resume(XAxiDma * InstancePtr, int RingIndex)
                * XAxiDma_SimpleTransfer(<a class="el" href="struct_x_axi_dma.html" title="The XAxiDma driver instance data. ">XAxiDma</a> <em>InstancePtr,
                                        u32 BuffAddr, u32 Length,
                                        int Direction, int RingIndex)
                * XAxiDma_StartBdRingHw(<a class="el" href="struct_x_axi_dma___bd_ring.html" title="Container structure for descriptor storage control. ">XAxiDma_BdRing</a> * RingPtr,
                                int RingIndex)
                * XAxiDma_BdRingStart(<a class="el" href="struct_x_axi_dma___bd_ring.html" title="Container structure for descriptor storage control. ">XAxiDma_BdRing</a> * RingPtr,
                                         int RingIndex)
                * XAxiDma_BdRingToHw(<a class="el" href="struct_x_axi_dma___bd_ring.html" title="Container structure for descriptor storage control. ">XAxiDma_BdRing</a> * RingPtr,
                        int NumBd, XAxiDma_Bd * BdSetPtr, int RingIndex)
                * XAxiDma_BdRingDumpRegs(<a class="el" href="struct_x_axi_dma___bd_ring.html" title="Container structure for descriptor storage control. ">XAxiDma_BdRing</a> * RingPtr,
                                         int RingIndex)
                * XAxiDma_BdRingSnapShotCurrBd(<a class="el" href="struct_x_axi_dma___bd_ring.html" title="Container structure for descriptor storage control. ">XAxiDma_BdRing</a> * RingPtr,
                                         int RingIndex)
                * XAxiDma_BdSetLength(XAxiDma_Bd *BdPtr,
                                u32 LenBytes, u32 LengthMask)
                * <a class="el" href="group__axidma__v9__4.html#gaae88a4ef129d6100fd087f7693186d80" title="Get the actual transfer length of a BD. ">XAxiDma_BdGetActualLength(BdPtr, LengthMask)</a>
                * <a class="el" href="group__axidma__v9__4.html#gadaf226acada2c1d857d29205ce4c2a58" title="Retrieve the length field value from the given BD. ">XAxiDma_BdGetLength(BdPtr, LengthMask)</a><ul>
<li>New APIs
                * XAxiDma_SelectKeyHole(<a class="el" href="struct_x_axi_dma.html" title="The XAxiDma driver instance data. ">XAxiDma</a> *InstancePtr,
                                        int Direction, int Select)
                * XAxiDma_UpdateBdRingCDesc(<a class="el" href="struct_x_axi_dma___bd_ring.html" title="Container structure for descriptor storage control. ">XAxiDma_BdRing</a> * RingPtr,
                                        int RingIndex)
7.00a srt  06/18/12  All the APIs changed in v6_00_a are reverted back for
               backward compatibility.<ul>
<li>New API:
                  <a class="el" href="group__axidma__v9__5.html#gaf03e87b58cf2f9800e6260fda3745631" title="Get Receive (Rx) Ring ptr of a Index. ">XAxiDma_GetRxIndexRing(InstancePtr, RingIndex)</a>
7.01a srt  10/26/12  - Fixed issue with driver as it fails with IP version
                 &lt; 6.00a as the parameter C_NUM__CHANNELS is not
                 applicable.</li>
</ul>
</li>
<li>Changed the logic of MCDMA BD fields Set APIs, to
                 clear the field first and then set it.
7.02a srt  01/23/13  Replaced *_TDATA_WIDTH parameters to *_DATA_WIDTH
               (CR 691867)
               Updated DDR base address for IPI designs (CR 703656).
8.0   adk  19/12/13  Updated as per the New Tcl API's
      srt  01/29/14  Added support for Micro DMA Mode and cyclic mode of
               operations.</li>
</ul>
</em></pre><pre><em>New APIs:
                * XAxiDma_SelectCyclicMode(<a class="el" href="struct_x_axi_dma.html" title="The XAxiDma driver instance data. ">XAxiDma</a> <em>InstancePtr,
                                        int Direction, int Select)
                        * XAxiDma_BdSetBufAddrMicroMode(XAxiDma_Bd</em>, u32)
8.1   adk  20/01/15  Added support for peripheral test. Created the self
               test example to include it on peripheral test's(CR#823144).
8.1   adk  29/01/15  Added the sefltest api (XAxiDma_Selftest) to the driver source files
                      (<a class="el" href="xaxidma__selftest_8c.html">xaxidma_selftest.c</a>) and called this from the selftest example
9.0     adk  27/07/15  Added support for 64-bit Addressing.
9.0   adk  19/08/15  Fixed CR#873125 DMA SG Mode example tests are failing on
               HW in 2015.3.
9.1   sk   11/10/15 Used UINTPTR instead of u32 for Baseaddress CR# 867425.
9.3   adk  26/07/16 Reduce the size of the buffer descriptor to 64 bytes.
      ms   01/23/17 Modified xil_printf statement in main function for all
           examples to ensure that "Successfully ran" and "Failed" strings
           are available in all examples. This is a fix for CR-965028.
      ms   03/17/17 Added readme.txt file in examples folder for doxygen
                    generation.
      ms   04/05/17 Modified Comment lines in functions to recognize
                    it as documentation block and added tabspace at return
                    statements in functions of axidma examples for proper
                    documentation while generating doxygen.
                    Modified readme file in examples folder.
9.4  adk   25/07/17 Added example for cyclic dma mode CR#974218.
     adk   08/08/17 Fixed CR#980607 Can't select individual AXI DMA code examples.
              Fixed compilation warning in the driver
9.5  adk   17/10/17 Fixed CR#987026 mulit packet example fails on A53.
             26/10/17 Fixed CR#987214 Fix race condition in the <a class="el" href="group__axidma__v9__5.html#ga5b7d1248ef065915fd8c9e8d5e00640f" title="Reset both TX and RX channels of a DMA engine. ">XAxiDma_Reset()</a>.
     rsp   11/01/17 Fixed CR#988210 Add interface to do config lookup based
                    on base address.

</em></pre></div></div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
