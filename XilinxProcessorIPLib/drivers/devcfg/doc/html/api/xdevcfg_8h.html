<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver devcfg v3_1: xdevcfg.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xdevcfg.h File Reference</h1><code>#include &quot;<a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a>&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dcfg.html">XDcfg</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#ab38a126fb94358d812a4b7b92a25d0f3">XDCFG_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a3ba07086d0dbdaef2fb617005ab125a6">XDCFG_NON_SECURE_PCAP_WRITE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#abc61481d4d62cabf1c6aaf98b3e80efe">XDCFG_SECURE_PCAP_WRITE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#ad1fa1d0ade51e2aa11fc802d1ecf5cd9">XDCFG_PCAP_READBACK</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#ae3a8ffa7a266e1d027e5e7c3a0d80f7f">XDCFG_CONCURRENT_SECURE_READ_WRITE</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a51a80c5fcaf3d9965ffb18ca9a59207e">XDCFG_CONCURRENT_NONSEC_READ_WRITE</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a2ed83e25f13a262faf75dfd55bae3522">XDcfg_Unlock</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a24929684d9a57ee5943c5379ba21114b">XDcfg_GetPsVersion</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a49f0c43c6fdeb7eff99095fffc5c18e9">XDcfg_ReadMultiBootConfig</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a16c0f3e337e8ebeb09d71c8b717a9018">XDcfg_SelectIcapInterface</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a7a3a846dfaf3161443364bca917f7c34">XDcfg_SelectPcapInterface</a>(InstancePtr)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a98b91ecac0510dc4f55961e285f425ef">XDcfg_IntrHandler</a> )(void *CallBackRef, u32 Status)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a33bfeb1455b8553f55d614ec46a52670">XDcfg_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a2c24756b9d6f8e81b620d27a86379e15">XDcfg_SelfTest</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#afcaaa8ac67cf7316c54d1cba36e83e08">XDcfg_CfgInitialize</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, <a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> *ConfigPtr, u32 EffectiveAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#abb2094cb7d36f83c4c150a3b18e8aad0">XDcfg_EnablePCAP</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a7f73a84f734f2e1996a029d8e5934b9c">XDcfg_DisablePCAP</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#acc8c10b5cc877595c1ade09e1a589296">XDcfg_SetControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#aeb69ef133b53618e896a4776b9e8f337">XDcfg_ClearControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a81a254369eea778c17c212cc95056c26">XDcfg_GetControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a1e0516cd9cdc5066e98e3c3c195c1d3c">XDcfg_SetLockRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#ad3df072e27abfff9beb69cb09567a8c1">XDcfg_GetLockRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a89e1eef15fcfe06cd0e8d8dd7e804ad1">XDcfg_SetConfigRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a3b46b8db6ea49d8c066fefe0d137b2c9">XDcfg_GetConfigRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#ae7a3e8052f73c370990b77dae5751a36">XDcfg_SetStatusRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#aaacacd5169ad7a79f09d08858f58dc8e">XDcfg_GetStatusRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a332a5c7c856e8f6637cafaa3ec69eaca">XDcfg_SetRomShadowRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a5573651d2f14ff760e36d551a49fa919">XDcfg_GetSoftwareIdRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a2739b6bce23b6e02a9076c0eba8664d4">XDcfg_SetMiscControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#aee0dfc6838f33d700fc4b8a5549b0473">XDcfg_GetMiscControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#ab3412c2881ffaa15fd3615770a4225a7">XDcfg_IsDmaBusy</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#afda6d24be18657370c15e1e893a0ab05">XDcfg_InitiateDma</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 SourcePtr, u32 DestPtr, u32 SrcWordLength, u32 DestWordLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a5a7a69cfe6e10770f82089bdd277955d">XDcfg_Transfer</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, void *SourcePtr, u32 SrcWordLength, void *DestPtr, u32 DestWordLength, u32 TransferType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#ab9c70f073e4522d6085c0059bc385aa9">XDcfg_IntrEnable</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#ab7606b370c10d68d61402bed68955a80">XDcfg_IntrDisable</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a879fec56ba0f64d3b2128f11e2b022f0">XDcfg_IntrGetEnabled</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a9ed5382e8c80a2277816a4db98a1ec6f">XDcfg_IntrGetStatus</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#afff047d176ced3a255248219c1278e3b">XDcfg_IntrClear</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#a3cb50f996ae2577642b7d1b91c33105f">XDcfg_InterruptHandler</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8h.html#aed08df4afb0dd9c343bf994b4c18e926">XDcfg_SetHandler</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a51a80c5fcaf3d9965ffb18ca9a59207e"></a><!-- doxytag: member="xdevcfg.h::XDCFG_CONCURRENT_NONSEC_READ_WRITE" ref="a51a80c5fcaf3d9965ffb18ca9a59207e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDCFG_CONCURRENT_NONSEC_READ_WRITE&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3a8ffa7a266e1d027e5e7c3a0d80f7f"></a><!-- doxytag: member="xdevcfg.h::XDCFG_CONCURRENT_SECURE_READ_WRITE" ref="ae3a8ffa7a266e1d027e5e7c3a0d80f7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDCFG_CONCURRENT_SECURE_READ_WRITE&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a24929684d9a57ee5943c5379ba21114b"></a><!-- doxytag: member="xdevcfg.h::XDcfg_GetPsVersion" ref="a24929684d9a57ee5943c5379ba21114b" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_GetPsVersion</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xdevcfg__hw_8h.html#a77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddr,                 \
                        <a class="code" href="xdevcfg__hw_8h.html#a80ad10863ac12916d347046e8263f5b2">XDCFG_MCTRL_OFFSET</a>)) &amp;                          \
                        <a class="code" href="xdevcfg__hw_8h.html#ade09d0c3fb076a8e0849d9a6acddef46">XDCFG_MCTRL_PCAP_PS_VERSION_MASK</a>) &gt;&gt;            \
                        <a class="code" href="xdevcfg__hw_8h.html#a2578e62e3b1e6e9783f523779c6d8323">XDCFG_MCTRL_PCAP_PS_VERSION_SHIFT</a>
</pre></div><p>Get the version number of the PS from the Miscellaneous Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Version of the PS.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xdevcfg_8h.html#a24929684d9a57ee5943c5379ba21114b">XDcfg_GetPsVersion(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab38a126fb94358d812a4b7b92a25d0f3"></a><!-- doxytag: member="xdevcfg.h::XDCFG_H" ref="ab38a126fb94358d812a4b7b92a25d0f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDCFG_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ba07086d0dbdaef2fb617005ab125a6"></a><!-- doxytag: member="xdevcfg.h::XDCFG_NON_SECURE_PCAP_WRITE" ref="a3ba07086d0dbdaef2fb617005ab125a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDCFG_NON_SECURE_PCAP_WRITE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad1fa1d0ade51e2aa11fc802d1ecf5cd9"></a><!-- doxytag: member="xdevcfg.h::XDCFG_PCAP_READBACK" ref="ad1fa1d0ade51e2aa11fc802d1ecf5cd9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDCFG_PCAP_READBACK&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a49f0c43c6fdeb7eff99095fffc5c18e9"></a><!-- doxytag: member="xdevcfg.h::XDcfg_ReadMultiBootConfig" ref="a49f0c43c6fdeb7eff99095fffc5c18e9" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_ReadMultiBootConfig</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xdevcfg__hw_8h.html#a77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddr +          \
                        <a class="code" href="xdevcfg__hw_8h.html#afe5bf5a7eb6a4d2e8d5a7a9cc8f60d59">XDCFG_MULTIBOOT_ADDR_OFFSET</a>)
</pre></div><p>Read the multiboot config register value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xdevcfg_8h.html#a49f0c43c6fdeb7eff99095fffc5c18e9">XDcfg_ReadMultiBootConfig(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc61481d4d62cabf1c6aaf98b3e80efe"></a><!-- doxytag: member="xdevcfg.h::XDCFG_SECURE_PCAP_WRITE" ref="abc61481d4d62cabf1c6aaf98b3e80efe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDCFG_SECURE_PCAP_WRITE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a16c0f3e337e8ebeb09d71c8b717a9018"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SelectIcapInterface" ref="a16c0f3e337e8ebeb09d71c8b717a9018" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_SelectIcapInterface</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xdevcfg__hw_8h.html#a8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddr, <a class="code" href="xdevcfg__hw_8h.html#a31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>,   \
        ((<a class="code" href="xdevcfg__hw_8h.html#a77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddr, <a class="code" href="xdevcfg__hw_8h.html#a31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>)) \
        &amp; ( ~<a class="code" href="xdevcfg__hw_8h.html#aac84a7176f99dc0e1d66a53673053228">XDCFG_CTRL_PCAP_PR_MASK</a>)))
</pre></div><p>Selects ICAP interface for reconfiguration after the initial configuration of the PL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xdevcfg_8h.html#a16c0f3e337e8ebeb09d71c8b717a9018">XDcfg_SelectIcapInterface(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a3a846dfaf3161443364bca917f7c34"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SelectPcapInterface" ref="a7a3a846dfaf3161443364bca917f7c34" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_SelectPcapInterface</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xdevcfg__hw_8h.html#a8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddr, <a class="code" href="xdevcfg__hw_8h.html#a31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>,    \
        ((<a class="code" href="xdevcfg__hw_8h.html#a77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddr, <a class="code" href="xdevcfg__hw_8h.html#a31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>))  \
        | <a class="code" href="xdevcfg__hw_8h.html#aac84a7176f99dc0e1d66a53673053228">XDCFG_CTRL_PCAP_PR_MASK</a>))
</pre></div><p>Selects PCAP interface for reconfiguration after the initial configuration of the PL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xdevcfg_8h.html#a7a3a846dfaf3161443364bca917f7c34">XDcfg_SelectPcapInterface(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ed83e25f13a262faf75dfd55bae3522"></a><!-- doxytag: member="xdevcfg.h::XDcfg_Unlock" ref="a2ed83e25f13a262faf75dfd55bae3522" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_Unlock</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xdevcfg__hw_8h.html#a8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddr,                  \
        <a class="code" href="xdevcfg__hw_8h.html#a7dfcf6697edba5f229b22fc33d614363">XDCFG_UNLOCK_OFFSET</a>, <a class="code" href="xdevcfg__hw_8h.html#a2830ab27372d4841a56ae22b06aa1f9a">XDCFG_UNLOCK_DATA</a>)
</pre></div><p>Unlock the Device Config Interface block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xdevcfg_8h.html#a2ed83e25f13a262faf75dfd55bae3522">XDcfg_Unlock(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a98b91ecac0510dc4f55961e285f425ef"></a><!-- doxytag: member="xdevcfg.h::XDcfg_IntrHandler" ref="a98b91ecac0510dc4f55961e285f425ef" args=")(void *CallBackRef, u32 Status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xdevcfg_8h.html#a98b91ecac0510dc4f55961e285f425ef">XDcfg_IntrHandler</a>)(void *CallBackRef, u32 Status)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The handler data type allows the user to define a callback function to respond to interrupt events in the system. This function is executed in interrupt context, so amount of processing should be minimized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver component, so it is a void pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Status</em>&nbsp;</td><td>is the Interrupt status of the <a class="el" href="struct_x_dcfg.html">XDcfg</a> device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="afcaaa8ac67cf7316c54d1cba36e83e08"></a><!-- doxytag: member="xdevcfg.h::XDcfg_CfgInitialize" ref="afcaaa8ac67cf7316c54d1cba36e83e08" args="(XDcfg *InstancePtr, XDcfg_Config *ConfigPtr, u32 EffectiveAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDcfg_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the Device Config Interface driver. This function must be called before other functions of the driver are called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is the config structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the base address for the device. It could be a virtual address if address translation is supported in the system, otherwise it is the physical address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful.</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The very first APB access to the Device Configuration Interface block needs to be a write to the UNLOCK register with the value of 0x757BDF0D. This step is to be done once after reset, any other APB access has to come after this. The APB access is considered illegal if the step is not done or if it is done incorrectly. Furthermore, if any of efuse_sec_cfg[5:0] is high, the following additional actions would be carried out. In other words, if all bits are low, the following steps are not done. 1. AES is disabled 2. All APB writes disabled 3. SoC debug fully enabled </dd></dl>

</div>
</div>
<a class="anchor" id="aeb69ef133b53618e896a4776b9e8f337"></a><!-- doxytag: member="xdevcfg.h::XDcfg_ClearControlRegister" ref="aeb69ef133b53618e896a4776b9e8f337" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_ClearControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function Clears the specified bit positions of the Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 32 bit value which holds the bit positions to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f73a84f734f2e1996a029d8e5934b9c"></a><!-- doxytag: member="xdevcfg.h::XDcfg_DisablePCAP" ref="a7f73a84f734f2e1996a029d8e5934b9c" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_DisablePCAP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The functions disables the PCAP interface by clearing the PCAP mode bit in the control register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="abb2094cb7d36f83c4c150a3b18e8aad0"></a><!-- doxytag: member="xdevcfg.h::XDcfg_EnablePCAP" ref="abb2094cb7d36f83c4c150a3b18e8aad0" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_EnablePCAP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The functions enables the PCAP interface by setting the PCAP mode bit in the control register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Enable FPGA programming from PCAP interface. Enabling this bit disables all the external interfaces from programming of FPGA except for ICAP. The user needs to ensure that the FPGA is programmed through either PCAP or ICAP. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b46b8db6ea49d8c066fefe0d137b2c9"></a><!-- doxytag: member="xdevcfg.h::XDcfg_GetConfigRegister" ref="a3b46b8db6ea49d8c066fefe0d137b2c9" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetConfigRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Configuration Register with the given value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Config Register. Use the XDCFG_CFG_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a81a254369eea778c17c212cc95056c26"></a><!-- doxytag: member="xdevcfg.h::XDcfg_GetControlRegister" ref="a81a254369eea778c17c212cc95056c26" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Control Register. Use the XDCFG_CTRL_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3df072e27abfff9beb69cb09567a8c1"></a><!-- doxytag: member="xdevcfg.h::XDcfg_GetLockRegister" ref="ad3df072e27abfff9beb69cb09567a8c1" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetLockRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Lock Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Lock Register. Use the XDCFG_CR_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aee0dfc6838f33d700fc4b8a5549b0473"></a><!-- doxytag: member="xdevcfg.h::XDcfg_GetMiscControlRegister" ref="aee0dfc6838f33d700fc4b8a5549b0473" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetMiscControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Miscellaneous Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>32 Bit boot software ID.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This register is locked for write once the system enters usermode. Hence API to reading the register only is provided. </dd></dl>

</div>
</div>
<a class="anchor" id="a5573651d2f14ff760e36d551a49fa919"></a><!-- doxytag: member="xdevcfg.h::XDcfg_GetSoftwareIdRegister" ref="a5573651d2f14ff760e36d551a49fa919" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetSoftwareIdRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Software ID Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>32 Bit boot software ID.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This register is locked for write once the system enters usermode. Hence API for reading the register only is provided. </dd></dl>

</div>
</div>
<a class="anchor" id="aaacacd5169ad7a79f09d08858f58dc8e"></a><!-- doxytag: member="xdevcfg.h::XDcfg_GetStatusRegister" ref="aaacacd5169ad7a79f09d08858f58dc8e" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetStatusRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Status Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Status Register. Use the XDCFG_STATUS_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="afda6d24be18657370c15e1e893a0ab05"></a><!-- doxytag: member="xdevcfg.h::XDcfg_InitiateDma" ref="afda6d24be18657370c15e1e893a0ab05" args="(XDcfg *InstancePtr, u32 SourcePtr, u32 DestPtr, u32 SrcWordLength, u32 DestWordLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_InitiateDma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SourcePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SrcWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DestWordLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates the DMA transfer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SourcePtr</em>&nbsp;</td><td>contains a pointer to the source memory where the data is to be transferred from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcWordLength</em>&nbsp;</td><td>is the number of words (32 bit) to be transferred for the source transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>contains a pointer to the destination memory where the data is to be transferred to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestWordLength</em>&nbsp;</td><td>is the number of words (32 bit) to be transferred for the Destination transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the caller function to ensure that correct values are passed to this function.</dd></dl>
<p>The 2 LSBs of the SourcePtr (Source)/ DestPtr (Destination) address when equal to 2’b01 indicates the last DMA command of an overall transfer. </p>

</div>
</div>
<a class="anchor" id="a3cb50f996ae2577642b7d1b91c33105f"></a><!-- doxytag: member="xdevcfg.h::XDcfg_InterruptHandler" ref="a3cb50f996ae2577642b7d1b91c33105f" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The interrupt handler for the Device Config Interface.</p>
<p>Events are signaled to upper layer for proper handling.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="afff047d176ced3a255248219c1278e3b"></a><!-- doxytag: member="xdevcfg.h::XDcfg_IntrClear" ref="afff047d176ced3a255248219c1278e3b" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_IntrClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clears the specified interrupts in the Interrupt Status Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be cleared. Bit positions of 1 will be cleared. Bit positions of 0 will not change the previous interrupt status. This mask is formed by OR'ing XDCFG_INT_* bits which are defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7606b370c10d68d61402bed68955a80"></a><!-- doxytag: member="xdevcfg.h::XDcfg_IntrDisable" ref="ab7606b370c10d68d61402bed68955a80" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the specified interrupts in the device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XDCFG_INT_* bits defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9c70f073e4522d6085c0059bc385aa9"></a><!-- doxytag: member="xdevcfg.h::XDcfg_IntrEnable" ref="ab9c70f073e4522d6085c0059bc385aa9" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the specified interrupts in the device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XDCFG_INT_* bits defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a879fec56ba0f64d3b2128f11e2b022f0"></a><!-- doxytag: member="xdevcfg.h::XDcfg_IntrGetEnabled" ref="a879fec56ba0f64d3b2128f11e2b022f0" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_IntrGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the enabled interrupts read from the Interrupt Mask Register. Use the XDCFG_INT_* constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the IMR.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ed5382e8c80a2277816a4db98a1ec6f"></a><!-- doxytag: member="xdevcfg.h::XDcfg_IntrGetStatus" ref="a9ed5382e8c80a2277816a4db98a1ec6f" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_IntrGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the interrupt status read from Interrupt Status Register. Use the XDCFG_INT_* constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Interrupt Status register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3412c2881ffaa15fd3615770a4225a7"></a><!-- doxytag: member="xdevcfg.h::XDcfg_IsDmaBusy" ref="ab3412c2881ffaa15fd3615770a4225a7" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_IsDmaBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function checks if DMA command queue is full.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS is the DMA is busy XST_FAILURE if the DMA is idle</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The DMA queue has a depth of two. </dd></dl>

</div>
</div>
<a class="anchor" id="a33bfeb1455b8553f55d614ec46a52670"></a><!-- doxytag: member="xdevcfg.h::XDcfg_LookupConfig" ref="a33bfeb1455b8553f55d614ec46a52670" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a>* XDcfg_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lookup the device configuration based on the unique device ID. The table contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c24756b9d6f8e81b620d27a86379e15"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SelfTest" ref="a2c24756b9d6f8e81b620d27a86379e15" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDcfg_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Run a self-test on the Device Configuration Interface. This test does a control register write and reads back the same value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if self-test was successful.</li>
<li>XST_FAILURE if fails.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a89e1eef15fcfe06cd0e8d8dd7e804ad1"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SetConfigRegister" ref="a89e1eef15fcfe06cd0e8d8dd7e804ad1" args="(XDcfg *InstancePtr, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetConfigRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the Configuration Register with the given value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="acc8c10b5cc877595c1ade09e1a589296"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SetControlRegister" ref="acc8c10b5cc877595c1ade09e1a589296" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 32 bit mask data to be written to the Register. The mask definitions are defined in the <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aed08df4afb0dd9c343bf994b4c18e926"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SetHandler" ref="aed08df4afb0dd9c343bf994b4c18e926" args="(XDcfg *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler that will be called when an event (interrupt) occurs that needs application's attention.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e0516cd9cdc5066e98e3c3c195c1d3c"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SetLockRegister" ref="a1e0516cd9cdc5066e98e3c3c195c1d3c" args="(XDcfg *InstancePtr, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetLockRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the Lock Register. These bits can only be set to a 1. They will be cleared after a Power On Reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a2739b6bce23b6e02a9076c0eba8664d4"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SetMiscControlRegister" ref="a2739b6bce23b6e02a9076c0eba8664d4" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetMiscControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the bit mask for the feature in Miscellaneous Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the feature to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a332a5c7c856e8f6637cafaa3ec69eaca"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SetRomShadowRegister" ref="a332a5c7c856e8f6637cafaa3ec69eaca" args="(XDcfg *InstancePtr, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetRomShadowRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the ROM Shadow Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This register is can only be written and is used to control the RAM shadow of 32 bit 4K page ROM pages in user mode </dd></dl>

</div>
</div>
<a class="anchor" id="ae7a3e8052f73c370990b77dae5751a36"></a><!-- doxytag: member="xdevcfg.h::XDcfg_SetStatusRegister" ref="ae7a3e8052f73c370990b77dae5751a36" args="(XDcfg *InstancePtr, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetStatusRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the Status Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a7a69cfe6e10770f82089bdd277955d"></a><!-- doxytag: member="xdevcfg.h::XDcfg_Transfer" ref="a5a7a69cfe6e10770f82089bdd277955d" args="(XDcfg *InstancePtr, void *SourcePtr, u32 SrcWordLength, void *DestPtr, u32 DestWordLength, u32 TransferType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_Transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>SourcePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SrcWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DestWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>TransferType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function starts the DMA transfer. This function only starts the operation and returns before the operation may be completed. If the interrupt is enabled, an interrupt will be generated when the operation is completed, otherwise it is necessary to poll the Status register to determine when it is completed. It is the responsibility of the caller to determine when the operation is completed by handling the generated interrupt or polling the Status Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SourcePtr</em>&nbsp;</td><td>contains a pointer to the source memory where the data is to be transferred from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcWordLength</em>&nbsp;</td><td>is the number of words (32 bit) to be transferred for the source transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>contains a pointer to the destination memory where the data is to be transferred to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestWordLength</em>&nbsp;</td><td>is the number of words (32 bit) to be transferred for the Destination transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TransferType</em>&nbsp;</td><td>contains the type of PCAP transfer being requested. The definitions can be found in the <a class="el" href="xdevcfg_8h.html">xdevcfg.h</a> file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS.if DMA transfer initiated successfully</li>
<li>XST_DEVICE_BUSY if DMA is busy</li>
<li>XST_INVALID_PARAM if invalid Source / Destination address is sent or an invalid Source / Destination length is sent</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the caller to ensure that the cache is flushed and invalidated both before the DMA operation is started and after the DMA operation completes if the memory pointed to is cached. The caller must also ensure that the pointers contain physical address rather than a virtual address if address translation is being used.</dd></dl>
<p>The 2 LSBs of the SourcePtr (Source)/ DestPtr (Destination) address when equal to 2’b01 indicates the last DMA command of an overall transfer. </p>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
