<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>devcfg: Devcfg_v3_5</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">devcfg
   </div>
   <div id="projectbrief">Xilinx SDK Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__devcfg__v3__5.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Devcfg_v3_5</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains configuration information for the device.  <a href="struct_x_dcfg___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dcfg.html">XDcfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> driver instance data.  <a href="struct_x_dcfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2ed83e25f13a262faf75dfd55bae3522"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga2ed83e25f13a262faf75dfd55bae3522">XDcfg_Unlock</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga2ed83e25f13a262faf75dfd55bae3522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the Device Config Interface block.  <a href="#ga2ed83e25f13a262faf75dfd55bae3522">More...</a><br /></td></tr>
<tr class="separator:ga2ed83e25f13a262faf75dfd55bae3522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24929684d9a57ee5943c5379ba21114b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga24929684d9a57ee5943c5379ba21114b">XDcfg_GetPsVersion</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga24929684d9a57ee5943c5379ba21114b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version number of the PS from the Miscellaneous Control Register.  <a href="#ga24929684d9a57ee5943c5379ba21114b">More...</a><br /></td></tr>
<tr class="separator:ga24929684d9a57ee5943c5379ba21114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f0c43c6fdeb7eff99095fffc5c18e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga49f0c43c6fdeb7eff99095fffc5c18e9">XDcfg_ReadMultiBootConfig</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga49f0c43c6fdeb7eff99095fffc5c18e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the multiboot config register value.  <a href="#ga49f0c43c6fdeb7eff99095fffc5c18e9">More...</a><br /></td></tr>
<tr class="separator:ga49f0c43c6fdeb7eff99095fffc5c18e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c0f3e337e8ebeb09d71c8b717a9018"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga16c0f3e337e8ebeb09d71c8b717a9018">XDcfg_SelectIcapInterface</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga16c0f3e337e8ebeb09d71c8b717a9018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects ICAP interface for reconfiguration after the initial configuration of the PL.  <a href="#ga16c0f3e337e8ebeb09d71c8b717a9018">More...</a><br /></td></tr>
<tr class="separator:ga16c0f3e337e8ebeb09d71c8b717a9018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3a846dfaf3161443364bca917f7c34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga7a3a846dfaf3161443364bca917f7c34">XDcfg_SelectPcapInterface</a>(InstancePtr)</td></tr>
<tr class="memdesc:ga7a3a846dfaf3161443364bca917f7c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects PCAP interface for reconfiguration after the initial configuration of the PL.  <a href="#ga7a3a846dfaf3161443364bca917f7c34">More...</a><br /></td></tr>
<tr class="separator:ga7a3a846dfaf3161443364bca917f7c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacaa24b2920f1bc5b56662062f2c380e0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gacaa24b2920f1bc5b56662062f2c380e0">XDcfg_IntrHandler</a>) (void *CallBackRef, u32 Status)</td></tr>
<tr class="memdesc:gacaa24b2920f1bc5b56662062f2c380e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handler data type allows the user to define a callback function to respond to interrupt events in the system.  <a href="#gacaa24b2920f1bc5b56662062f2c380e0">More...</a><br /></td></tr>
<tr class="separator:gacaa24b2920f1bc5b56662062f2c380e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafcaaa8ac67cf7316c54d1cba36e83e08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gafcaaa8ac67cf7316c54d1cba36e83e08">XDcfg_CfgInitialize</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, <a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> *ConfigPtr, u32 EffectiveAddress)</td></tr>
<tr class="memdesc:gafcaaa8ac67cf7316c54d1cba36e83e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Device Config Interface driver.  <a href="#gafcaaa8ac67cf7316c54d1cba36e83e08">More...</a><br /></td></tr>
<tr class="separator:gafcaaa8ac67cf7316c54d1cba36e83e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2094cb7d36f83c4c150a3b18e8aad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gabb2094cb7d36f83c4c150a3b18e8aad0">XDcfg_EnablePCAP</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:gabb2094cb7d36f83c4c150a3b18e8aad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions enables the PCAP interface by setting the PCAP mode bit in the control register.  <a href="#gabb2094cb7d36f83c4c150a3b18e8aad0">More...</a><br /></td></tr>
<tr class="separator:gabb2094cb7d36f83c4c150a3b18e8aad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f73a84f734f2e1996a029d8e5934b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga7f73a84f734f2e1996a029d8e5934b9c">XDcfg_DisablePCAP</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga7f73a84f734f2e1996a029d8e5934b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions disables the PCAP interface by clearing the PCAP mode bit in the control register.  <a href="#ga7f73a84f734f2e1996a029d8e5934b9c">More...</a><br /></td></tr>
<tr class="separator:ga7f73a84f734f2e1996a029d8e5934b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc8c10b5cc877595c1ade09e1a589296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gacc8c10b5cc877595c1ade09e1a589296">XDcfg_SetControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:gacc8c10b5cc877595c1ade09e1a589296"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the contents of the Control Register.  <a href="#gacc8c10b5cc877595c1ade09e1a589296">More...</a><br /></td></tr>
<tr class="separator:gacc8c10b5cc877595c1ade09e1a589296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb69ef133b53618e896a4776b9e8f337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gaeb69ef133b53618e896a4776b9e8f337">XDcfg_ClearControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:gaeb69ef133b53618e896a4776b9e8f337"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function Clears the specified bit positions of the Control Register.  <a href="#gaeb69ef133b53618e896a4776b9e8f337">More...</a><br /></td></tr>
<tr class="separator:gaeb69ef133b53618e896a4776b9e8f337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81a254369eea778c17c212cc95056c26"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga81a254369eea778c17c212cc95056c26">XDcfg_GetControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga81a254369eea778c17c212cc95056c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads the contents of the Control Register.  <a href="#ga81a254369eea778c17c212cc95056c26">More...</a><br /></td></tr>
<tr class="separator:ga81a254369eea778c17c212cc95056c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e0516cd9cdc5066e98e3c3c195c1d3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga1e0516cd9cdc5066e98e3c3c195c1d3c">XDcfg_SetLockRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:ga1e0516cd9cdc5066e98e3c3c195c1d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the contents of the Lock Register.  <a href="#ga1e0516cd9cdc5066e98e3c3c195c1d3c">More...</a><br /></td></tr>
<tr class="separator:ga1e0516cd9cdc5066e98e3c3c195c1d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3df072e27abfff9beb69cb09567a8c1"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gad3df072e27abfff9beb69cb09567a8c1">XDcfg_GetLockRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:gad3df072e27abfff9beb69cb09567a8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads the contents of the Lock Register.  <a href="#gad3df072e27abfff9beb69cb09567a8c1">More...</a><br /></td></tr>
<tr class="separator:gad3df072e27abfff9beb69cb09567a8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e1eef15fcfe06cd0e8d8dd7e804ad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga89e1eef15fcfe06cd0e8d8dd7e804ad1">XDcfg_SetConfigRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:ga89e1eef15fcfe06cd0e8d8dd7e804ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the contents of the Configuration Register with the given value.  <a href="#ga89e1eef15fcfe06cd0e8d8dd7e804ad1">More...</a><br /></td></tr>
<tr class="separator:ga89e1eef15fcfe06cd0e8d8dd7e804ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b46b8db6ea49d8c066fefe0d137b2c9"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga3b46b8db6ea49d8c066fefe0d137b2c9">XDcfg_GetConfigRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga3b46b8db6ea49d8c066fefe0d137b2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads the contents of the Configuration Register with the given value.  <a href="#ga3b46b8db6ea49d8c066fefe0d137b2c9">More...</a><br /></td></tr>
<tr class="separator:ga3b46b8db6ea49d8c066fefe0d137b2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a3e8052f73c370990b77dae5751a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gae7a3e8052f73c370990b77dae5751a36">XDcfg_SetStatusRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:gae7a3e8052f73c370990b77dae5751a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the contents of the Status Register.  <a href="#gae7a3e8052f73c370990b77dae5751a36">More...</a><br /></td></tr>
<tr class="separator:gae7a3e8052f73c370990b77dae5751a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacacd5169ad7a79f09d08858f58dc8e"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gaaacacd5169ad7a79f09d08858f58dc8e">XDcfg_GetStatusRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaaacacd5169ad7a79f09d08858f58dc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads the contents of the Status Register.  <a href="#gaaacacd5169ad7a79f09d08858f58dc8e">More...</a><br /></td></tr>
<tr class="separator:gaaacacd5169ad7a79f09d08858f58dc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga332a5c7c856e8f6637cafaa3ec69eaca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga332a5c7c856e8f6637cafaa3ec69eaca">XDcfg_SetRomShadowRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr class="memdesc:ga332a5c7c856e8f6637cafaa3ec69eaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the contents of the ROM Shadow Control Register.  <a href="#ga332a5c7c856e8f6637cafaa3ec69eaca">More...</a><br /></td></tr>
<tr class="separator:ga332a5c7c856e8f6637cafaa3ec69eaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5573651d2f14ff760e36d551a49fa919"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga5573651d2f14ff760e36d551a49fa919">XDcfg_GetSoftwareIdRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga5573651d2f14ff760e36d551a49fa919"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads the contents of the Software ID Register.  <a href="#ga5573651d2f14ff760e36d551a49fa919">More...</a><br /></td></tr>
<tr class="separator:ga5573651d2f14ff760e36d551a49fa919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2739b6bce23b6e02a9076c0eba8664d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga2739b6bce23b6e02a9076c0eba8664d4">XDcfg_SetMiscControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:ga2739b6bce23b6e02a9076c0eba8664d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the bit mask for the feature in Miscellaneous Control Register.  <a href="#ga2739b6bce23b6e02a9076c0eba8664d4">More...</a><br /></td></tr>
<tr class="separator:ga2739b6bce23b6e02a9076c0eba8664d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0dfc6838f33d700fc4b8a5549b0473"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gaee0dfc6838f33d700fc4b8a5549b0473">XDcfg_GetMiscControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:gaee0dfc6838f33d700fc4b8a5549b0473"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads the contents of the Miscellaneous Control Register.  <a href="#gaee0dfc6838f33d700fc4b8a5549b0473">More...</a><br /></td></tr>
<tr class="separator:gaee0dfc6838f33d700fc4b8a5549b0473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3412c2881ffaa15fd3615770a4225a7"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gab3412c2881ffaa15fd3615770a4225a7">XDcfg_IsDmaBusy</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:gab3412c2881ffaa15fd3615770a4225a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if DMA command queue is full.  <a href="#gab3412c2881ffaa15fd3615770a4225a7">More...</a><br /></td></tr>
<tr class="separator:gab3412c2881ffaa15fd3615770a4225a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda6d24be18657370c15e1e893a0ab05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gafda6d24be18657370c15e1e893a0ab05">XDcfg_InitiateDma</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 SourcePtr, u32 DestPtr, u32 SrcWordLength, u32 DestWordLength)</td></tr>
<tr class="memdesc:gafda6d24be18657370c15e1e893a0ab05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initiates the DMA transfer.  <a href="#gafda6d24be18657370c15e1e893a0ab05">More...</a><br /></td></tr>
<tr class="separator:gafda6d24be18657370c15e1e893a0ab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7a69cfe6e10770f82089bdd277955d"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga5a7a69cfe6e10770f82089bdd277955d">XDcfg_Transfer</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, void *SourcePtr, u32 SrcWordLength, void *DestPtr, u32 DestWordLength, u32 TransferType)</td></tr>
<tr class="memdesc:ga5a7a69cfe6e10770f82089bdd277955d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts the DMA transfer.  <a href="#ga5a7a69cfe6e10770f82089bdd277955d">More...</a><br /></td></tr>
<tr class="separator:ga5a7a69cfe6e10770f82089bdd277955d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7512afadad93e25630048943fd72d41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gab7512afadad93e25630048943fd72d41">XDcfg_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr class="memdesc:gab7512afadad93e25630048943fd72d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the device configuration based on the unique device ID.  <a href="#gab7512afadad93e25630048943fd72d41">More...</a><br /></td></tr>
<tr class="separator:gab7512afadad93e25630048943fd72d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c24756b9d6f8e81b620d27a86379e15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga2c24756b9d6f8e81b620d27a86379e15">XDcfg_SelfTest</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga2c24756b9d6f8e81b620d27a86379e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a self-test on the Device Configuration Interface.  <a href="#ga2c24756b9d6f8e81b620d27a86379e15">More...</a><br /></td></tr>
<tr class="separator:ga2c24756b9d6f8e81b620d27a86379e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c70f073e4522d6085c0059bc385aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gab9c70f073e4522d6085c0059bc385aa9">XDcfg_IntrEnable</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:gab9c70f073e4522d6085c0059bc385aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the specified interrupts in the device.  <a href="#gab9c70f073e4522d6085c0059bc385aa9">More...</a><br /></td></tr>
<tr class="separator:gab9c70f073e4522d6085c0059bc385aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7606b370c10d68d61402bed68955a80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gab7606b370c10d68d61402bed68955a80">XDcfg_IntrDisable</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:gab7606b370c10d68d61402bed68955a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the specified interrupts in the device.  <a href="#gab7606b370c10d68d61402bed68955a80">More...</a><br /></td></tr>
<tr class="separator:gab7606b370c10d68d61402bed68955a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879fec56ba0f64d3b2128f11e2b022f0"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga879fec56ba0f64d3b2128f11e2b022f0">XDcfg_IntrGetEnabled</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga879fec56ba0f64d3b2128f11e2b022f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the enabled interrupts read from the Interrupt Mask Register.  <a href="#ga879fec56ba0f64d3b2128f11e2b022f0">More...</a><br /></td></tr>
<tr class="separator:ga879fec56ba0f64d3b2128f11e2b022f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed5382e8c80a2277816a4db98a1ec6f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga9ed5382e8c80a2277816a4db98a1ec6f">XDcfg_IntrGetStatus</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga9ed5382e8c80a2277816a4db98a1ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the interrupt status read from Interrupt Status Register.  <a href="#ga9ed5382e8c80a2277816a4db98a1ec6f">More...</a><br /></td></tr>
<tr class="separator:ga9ed5382e8c80a2277816a4db98a1ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff047d176ced3a255248219c1278e3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gafff047d176ced3a255248219c1278e3b">XDcfg_IntrClear</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr class="memdesc:gafff047d176ced3a255248219c1278e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the specified interrupts in the Interrupt Status Register.  <a href="#gafff047d176ced3a255248219c1278e3b">More...</a><br /></td></tr>
<tr class="separator:gafff047d176ced3a255248219c1278e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb50f996ae2577642b7d1b91c33105f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga3cb50f996ae2577642b7d1b91c33105f">XDcfg_InterruptHandler</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr class="memdesc:ga3cb50f996ae2577642b7d1b91c33105f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interrupt handler for the Device Config Interface.  <a href="#ga3cb50f996ae2577642b7d1b91c33105f">More...</a><br /></td></tr>
<tr class="separator:ga3cb50f996ae2577642b7d1b91c33105f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed08df4afb0dd9c343bf994b4c18e926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#gaed08df4afb0dd9c343bf994b4c18e926">XDcfg_SetHandler</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr class="memdesc:gaed08df4afb0dd9c343bf994b4c18e926"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handler that will be called when an event (interrupt) occurs that needs application's attention.  <a href="#gaed08df4afb0dd9c343bf994b4c18e926">More...</a><br /></td></tr>
<tr class="separator:gaed08df4afb0dd9c343bf994b4c18e926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995fb32dbac8a7899c9be66a8bf7d3d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga995fb32dbac8a7899c9be66a8bf7d3d1">XDcfg_ResetHw</a> (u32 BaseAddr)</td></tr>
<tr class="memdesc:ga995fb32dbac8a7899c9be66a8bf7d3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function perform the reset sequence to the given devcfg interface by configuring the appropriate control bits in the devcfg specifc registers the devcfg reset squence involves the following steps Disable all the interuupts Clear the status Update relevant config registers with reset values Disbale the looopback mode and pcap rate enable.  <a href="#ga995fb32dbac8a7899c9be66a8bf7d3d1">More...</a><br /></td></tr>
<tr class="separator:ga995fb32dbac8a7899c9be66a8bf7d3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga77946de6f18b07bd6c24fdd084ab5395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devcfg__v3__5.html#ga77946de6f18b07bd6c24fdd084ab5395">XDcfg_ConfigTable</a> [1]</td></tr>
<tr class="memdesc:ga77946de6f18b07bd6c24fdd084ab5395"><td class="mdescLeft">&#160;</td><td class="mdescRight">This table contains configuration information for each Device Config Interface instance in the system.  <a href="#ga77946de6f18b07bd6c24fdd084ab5395">More...</a><br /></td></tr>
<tr class="separator:ga77946de6f18b07bd6c24fdd084ab5395"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga24929684d9a57ee5943c5379ba21114b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24929684d9a57ee5943c5379ba21114b">&#9670;&nbsp;</a></span>XDcfg_GetPsVersion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_GetPsVersion</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddr,                 \</div><div class="line">                        <a class="code" href="group__devcfg__v3__3.html#ga80ad10863ac12916d347046e8263f5b2">XDCFG_MCTRL_OFFSET</a>)) &amp;                          \</div><div class="line">                        <a class="code" href="group__devcfg__v3__3.html#gade09d0c3fb076a8e0849d9a6acddef46">XDCFG_MCTRL_PCAP_PS_VERSION_MASK</a>) &gt;&gt;            \</div><div class="line">                        XDCFG_MCTRL_PCAP_PS_VERSION_SHIFT</div><div class="ttc" id="group__devcfg__v3__3_html_gade09d0c3fb076a8e0849d9a6acddef46"><div class="ttname"><a href="group__devcfg__v3__3.html#gade09d0c3fb076a8e0849d9a6acddef46">XDCFG_MCTRL_PCAP_PS_VERSION_MASK</a></div><div class="ttdeci">#define XDCFG_MCTRL_PCAP_PS_VERSION_MASK</div><div class="ttdoc">PS Version Mask. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:412</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga77561dc2e9ea13137f50a8193b8fbcd3"><div class="ttname"><a href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a></div><div class="ttdeci">#define XDcfg_ReadReg(BaseAddr, RegOffset)</div><div class="ttdoc">Read the given register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:456</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga80ad10863ac12916d347046e8263f5b2"><div class="ttname"><a href="group__devcfg__v3__3.html#ga80ad10863ac12916d347046e8263f5b2">XDCFG_MCTRL_OFFSET</a></div><div class="ttdeci">#define XDCFG_MCTRL_OFFSET</div><div class="ttdoc">Miscellaneous Control Reg. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:91</div></div>
</div><!-- fragment -->
<p>Get the version number of the PS from the Miscellaneous Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Version of the PS.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__devcfg__v3__5.html#ga24929684d9a57ee5943c5379ba21114b" title="Get the version number of the PS from the Miscellaneous Control Register. ">XDcfg_GetPsVersion(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<a id="ga49f0c43c6fdeb7eff99095fffc5c18e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49f0c43c6fdeb7eff99095fffc5c18e9">&#9670;&nbsp;</a></span>XDcfg_ReadMultiBootConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_ReadMultiBootConfig</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddr,           \</div><div class="line">                        <a class="code" href="group__devcfg__v3__3.html#gafe5bf5a7eb6a4d2e8d5a7a9cc8f60d59">XDCFG_MULTIBOOT_ADDR_OFFSET</a>)</div><div class="ttc" id="group__devcfg__v3__3_html_gafe5bf5a7eb6a4d2e8d5a7a9cc8f60d59"><div class="ttname"><a href="group__devcfg__v3__3.html#gafe5bf5a7eb6a4d2e8d5a7a9cc8f60d59">XDCFG_MULTIBOOT_ADDR_OFFSET</a></div><div class="ttdeci">#define XDCFG_MULTIBOOT_ADDR_OFFSET</div><div class="ttdoc">Multi BootAddress Pointer. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:88</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga77561dc2e9ea13137f50a8193b8fbcd3"><div class="ttname"><a href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a></div><div class="ttdeci">#define XDcfg_ReadReg(BaseAddr, RegOffset)</div><div class="ttdoc">Read the given register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:456</div></div>
</div><!-- fragment -->
<p>Read the multiboot config register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: u32 <a class="el" href="group__devcfg__v3__5.html#ga49f0c43c6fdeb7eff99095fffc5c18e9" title="Read the multiboot config register value. ">XDcfg_ReadMultiBootConfig(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<a id="ga16c0f3e337e8ebeb09d71c8b717a9018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c0f3e337e8ebeb09d71c8b717a9018">&#9670;&nbsp;</a></span>XDcfg_SelectIcapInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_SelectIcapInterface</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddr, <a class="code" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>,   \</div><div class="line">        ((<a class="code" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddr, <a class="code" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>)) \</div><div class="line">        &amp; ( ~<a class="code" href="group__devcfg__v3__3.html#gaac84a7176f99dc0e1d66a53673053228">XDCFG_CTRL_PCAP_PR_MASK</a>)))</div><div class="ttc" id="group__devcfg__v3__3_html_ga31ebfed655e59d8ee204b253e04ee024"><div class="ttname"><a href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a></div><div class="ttdeci">#define XDCFG_CTRL_OFFSET</div><div class="ttdoc">Control Register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:77</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga77561dc2e9ea13137f50a8193b8fbcd3"><div class="ttname"><a href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a></div><div class="ttdeci">#define XDcfg_ReadReg(BaseAddr, RegOffset)</div><div class="ttdoc">Read the given register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:456</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga8ae617fbb2b3e148a8b2489e90fbdea3"><div class="ttname"><a href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a></div><div class="ttdeci">#define XDcfg_WriteReg(BaseAddr, RegOffset, Data)</div><div class="ttdoc">Write to the given register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:474</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_gaac84a7176f99dc0e1d66a53673053228"><div class="ttname"><a href="group__devcfg__v3__3.html#gaac84a7176f99dc0e1d66a53673053228">XDCFG_CTRL_PCAP_PR_MASK</a></div><div class="ttdeci">#define XDCFG_CTRL_PCAP_PR_MASK</div><div class="ttdoc">Enable PCAP for PR. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:110</div></div>
</div><!-- fragment -->
<p>Selects ICAP interface for reconfiguration after the initial configuration of the PL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__devcfg__v3__5.html#ga16c0f3e337e8ebeb09d71c8b717a9018" title="Selects ICAP interface for reconfiguration after the initial configuration of the PL...">XDcfg_SelectIcapInterface(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<a id="ga7a3a846dfaf3161443364bca917f7c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a3a846dfaf3161443364bca917f7c34">&#9670;&nbsp;</a></span>XDcfg_SelectPcapInterface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_SelectPcapInterface</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddr, <a class="code" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>,    \</div><div class="line">        ((<a class="code" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddr, <a class="code" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>))  \</div><div class="line">        | <a class="code" href="group__devcfg__v3__3.html#gaac84a7176f99dc0e1d66a53673053228">XDCFG_CTRL_PCAP_PR_MASK</a>))</div><div class="ttc" id="group__devcfg__v3__3_html_ga31ebfed655e59d8ee204b253e04ee024"><div class="ttname"><a href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a></div><div class="ttdeci">#define XDCFG_CTRL_OFFSET</div><div class="ttdoc">Control Register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:77</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga77561dc2e9ea13137f50a8193b8fbcd3"><div class="ttname"><a href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a></div><div class="ttdeci">#define XDcfg_ReadReg(BaseAddr, RegOffset)</div><div class="ttdoc">Read the given register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:456</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga8ae617fbb2b3e148a8b2489e90fbdea3"><div class="ttname"><a href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a></div><div class="ttdeci">#define XDcfg_WriteReg(BaseAddr, RegOffset, Data)</div><div class="ttdoc">Write to the given register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:474</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_gaac84a7176f99dc0e1d66a53673053228"><div class="ttname"><a href="group__devcfg__v3__3.html#gaac84a7176f99dc0e1d66a53673053228">XDCFG_CTRL_PCAP_PR_MASK</a></div><div class="ttdeci">#define XDCFG_CTRL_PCAP_PR_MASK</div><div class="ttdoc">Enable PCAP for PR. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:110</div></div>
</div><!-- fragment -->
<p>Selects PCAP interface for reconfiguration after the initial configuration of the PL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__devcfg__v3__5.html#ga7a3a846dfaf3161443364bca917f7c34" title="Selects PCAP interface for reconfiguration after the initial configuration of the PL...">XDcfg_SelectPcapInterface(XDcfg* InstancePtr)</a> </dd></dl>

</div>
</div>
<a id="ga2ed83e25f13a262faf75dfd55bae3522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed83e25f13a262faf75dfd55bae3522">&#9670;&nbsp;</a></span>XDcfg_Unlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDcfg_Unlock</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InstancePtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddr,                  \</div><div class="line">        <a class="code" href="group__devcfg__v3__3.html#ga7dfcf6697edba5f229b22fc33d614363">XDCFG_UNLOCK_OFFSET</a>, <a class="code" href="group__devcfg__v3__3.html#ga2830ab27372d4841a56ae22b06aa1f9a">XDCFG_UNLOCK_DATA</a>)</div><div class="ttc" id="group__devcfg__v3__3_html_ga2830ab27372d4841a56ae22b06aa1f9a"><div class="ttname"><a href="group__devcfg__v3__3.html#ga2830ab27372d4841a56ae22b06aa1f9a">XDCFG_UNLOCK_DATA</a></div><div class="ttdeci">#define XDCFG_UNLOCK_DATA</div><div class="ttdoc">First APB access data. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:430</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga7dfcf6697edba5f229b22fc33d614363"><div class="ttname"><a href="group__devcfg__v3__3.html#ga7dfcf6697edba5f229b22fc33d614363">XDCFG_UNLOCK_OFFSET</a></div><div class="ttdeci">#define XDCFG_UNLOCK_OFFSET</div><div class="ttdoc">Unlock Register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:90</div></div>
<div class="ttc" id="group__devcfg__v3__3_html_ga8ae617fbb2b3e148a8b2489e90fbdea3"><div class="ttname"><a href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a></div><div class="ttdeci">#define XDcfg_WriteReg(BaseAddr, RegOffset, Data)</div><div class="ttdoc">Write to the given register. </div><div class="ttdef"><b>Definition:</b> xdevcfg_hw.h:474</div></div>
</div><!-- fragment -->
<p>Unlock the Device Config Interface block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the instance of <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C-style signature: void <a class="el" href="group__devcfg__v3__5.html#ga2ed83e25f13a262faf75dfd55bae3522" title="Unlock the Device Config Interface block. ">XDcfg_Unlock(XDcfg* InstancePtr)</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__devcfg__v3__5.html#gafcaaa8ac67cf7316c54d1cba36e83e08">XDcfg_CfgInitialize()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gacaa24b2920f1bc5b56662062f2c380e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaa24b2920f1bc5b56662062f2c380e0">&#9670;&nbsp;</a></span>XDcfg_IntrHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XDcfg_IntrHandler) (void *CallBackRef, u32 Status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>The handler data type allows the user to define a callback function to respond to interrupt events in the system. </p>
<p>This function is executed in interrupt context, so amount of processing should be minimized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>is the callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver component, so it is a void pointer. </td></tr>
    <tr><td class="paramname">Status</td><td>is the Interrupt status of the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafcaaa8ac67cf7316c54d1cba36e83e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcaaa8ac67cf7316c54d1cba36e83e08">&#9670;&nbsp;</a></span>XDcfg_CfgInitialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDcfg_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> *&#160;</td>
          <td class="paramname"><em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EffectiveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>Initialize the Device Config Interface driver. </p>
<p>This function must be called before other functions of the driver are called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">ConfigPtr</td><td>is the config structure. </td></tr>
    <tr><td class="paramname">EffectiveAddress</td><td>is the base address for the device. It could be a virtual address if address translation is supported in the system, otherwise it is the physical address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if initialization was successful.</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The very first APB access to the Device Configuration Interface block needs to be a write to the UNLOCK register with the value of 0x757BDF0D. This step is to be done once after reset, any other APB access has to come after this. The APB access is considered illegal if the step is not done or if it is done incorrectly. Furthermore, if any of efuse_sec_cfg[5:0] is high, the following additional actions would be carried out. In other words, if all bits are low, the following steps are not done.<ol type="1">
<li>AES is disabled</li>
<li>All APB writes disabled</li>
<li>SoC debug fully enabled </li>
</ol>
</dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg___config.html#aed08774c7a83a68bf1af0188a80bb62f">XDcfg_Config::DeviceId</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="struct_x_dcfg.html#a8c0b292203540ec4fa43ef3a8b633bbd">XDcfg::IsStarted</a>, and <a class="el" href="group__devcfg__v3__5.html#ga2ed83e25f13a262faf75dfd55bae3522">XDcfg_Unlock</a>.</p>

<p class="reference">Referenced by <a class="el" href="xdevcfg__selftest__example_8c.html#aee3ce00335c2f2e886f475d5e11aaf72">DcfgSelfTestExample()</a>, <a class="el" href="xdevcfg__interrupt__example_8c.html#a2a07952c85939f2590c00f736e075bd1">XDcfgInterruptExample()</a>, and <a class="el" href="xdevcfg__reg__readback__example_8c.html#ae521229b81ef92bbf76223679d5ae55e">XDcfgRegReadExample()</a>.</p>

</div>
</div>
<a id="gaeb69ef133b53618e896a4776b9e8f337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb69ef133b53618e896a4776b9e8f337">&#9670;&nbsp;</a></span>XDcfg_ClearControlRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_ClearControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function Clears the specified bit positions of the Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 32 bit value which holds the bit positions to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="ga7f73a84f734f2e1996a029d8e5934b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f73a84f734f2e1996a029d8e5934b9c">&#9670;&nbsp;</a></span>XDcfg_DisablePCAP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_DisablePCAP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The functions disables the PCAP interface by clearing the PCAP mode bit in the control register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#gade98fb162f4954144b33a71eb81a25e3">XDCFG_CTRL_PCAP_MODE_MASK</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="gabb2094cb7d36f83c4c150a3b18e8aad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb2094cb7d36f83c4c150a3b18e8aad0">&#9670;&nbsp;</a></span>XDcfg_EnablePCAP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_EnablePCAP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The functions enables the PCAP interface by setting the PCAP mode bit in the control register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Enable FPGA programming from PCAP interface. Enabling this bit disables all the external interfaces from programming of FPGA except for ICAP. The user needs to ensure that the FPGA is programmed through either PCAP or ICAP. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#gade98fb162f4954144b33a71eb81a25e3">XDCFG_CTRL_PCAP_MODE_MASK</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="ga3b46b8db6ea49d8c066fefe0d137b2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b46b8db6ea49d8c066fefe0d137b2c9">&#9670;&nbsp;</a></span>XDcfg_GetConfigRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetConfigRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function reads the contents of the Configuration Register with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the Config Register. Use the XDCFG_CFG_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga3fafe11b95af8da04f385c9313a6958b">XDCFG_CFG_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>.</p>

</div>
</div>
<a id="ga81a254369eea778c17c212cc95056c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81a254369eea778c17c212cc95056c26">&#9670;&nbsp;</a></span>XDcfg_GetControlRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function reads the contents of the Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the Control Register. Use the XDCFG_CTRL_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__devcfg__v3__5.html#ga2c24756b9d6f8e81b620d27a86379e15">XDcfg_SelfTest()</a>.</p>

</div>
</div>
<a id="gad3df072e27abfff9beb69cb09567a8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3df072e27abfff9beb69cb09567a8c1">&#9670;&nbsp;</a></span>XDcfg_GetLockRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetLockRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function reads the contents of the Lock Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the Lock Register. Use the XDCFG_CR_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#gad126a845b17979d640cd2dd00eab29f9">XDCFG_LOCK_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>.</p>

</div>
</div>
<a id="gaee0dfc6838f33d700fc4b8a5549b0473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee0dfc6838f33d700fc4b8a5549b0473">&#9670;&nbsp;</a></span>XDcfg_GetMiscControlRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetMiscControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function reads the contents of the Miscellaneous Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32 Bit boot software ID.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This register is locked for write once the system enters usermode. Hence API to reading the register only is provided. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga80ad10863ac12916d347046e8263f5b2">XDCFG_MCTRL_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>.</p>

</div>
</div>
<a id="ga5573651d2f14ff760e36d551a49fa919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5573651d2f14ff760e36d551a49fa919">&#9670;&nbsp;</a></span>XDcfg_GetSoftwareIdRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetSoftwareIdRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function reads the contents of the Software ID Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32 Bit boot software ID.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This register is locked for write once the system enters usermode. Hence API for reading the register only is provided. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, and <a class="el" href="group__devcfg__v3__3.html#gad56285ef89202c084bad1724cc3f8df1">XDCFG_SW_ID_OFFSET</a>.</p>

</div>
</div>
<a id="gaaacacd5169ad7a79f09d08858f58dc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaacacd5169ad7a79f09d08858f58dc8e">&#9670;&nbsp;</a></span>XDcfg_GetStatusRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetStatusRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function reads the contents of the Status Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the Status Register. Use the XDCFG_STATUS_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, and <a class="el" href="group__devcfg__v3__3.html#ga6646b7874a5c9cc7bcdba6072bb4ff72">XDCFG_STATUS_OFFSET</a>.</p>

</div>
</div>
<a id="gafda6d24be18657370c15e1e893a0ab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda6d24be18657370c15e1e893a0ab05">&#9670;&nbsp;</a></span>XDcfg_InitiateDma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_InitiateDma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SourcePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SrcWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DestWordLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>This function initiates the DMA transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">SourcePtr</td><td>contains a pointer to the source memory where the data is to be transferred from. </td></tr>
    <tr><td class="paramname">SrcWordLength</td><td>is the number of words (32 bit) to be transferred for the source transfer. </td></tr>
    <tr><td class="paramname">DestPtr</td><td>contains a pointer to the destination memory where the data is to be transferred to. </td></tr>
    <tr><td class="paramname">DestWordLength</td><td>is the number of words (32 bit) to be transferred for the Destination transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is the responsibility of the caller function to ensure that correct values are passed to this function. <pre class="fragment">    The 2 LSBs of the SourcePtr (Source)/ DestPtr (Destination)
</pre> address when equal to 2b01 indicates the last DMA command of an overall transfer. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="group__devcfg__v3__3.html#ga24e1d08d2aa66c6fe2a8be9086ef9a41">XDCFG_DMA_DEST_ADDR_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#gaffc13cbb412f77e54b0ecf2f25e205ee">XDCFG_DMA_DEST_LEN_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#ga18c6f2aab3a27da352296a1324ed73b4">XDCFG_DMA_SRC_ADDR_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#gaaf9fa64a65762a428ba36bd38a80ab80">XDCFG_DMA_SRC_LEN_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="ga3cb50f996ae2577642b7d1b91c33105f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb50f996ae2577642b7d1b91c33105f">&#9670;&nbsp;</a></span>XDcfg_InterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>The interrupt handler for the Device Config Interface. </p>
<p>Events are signaled to upper layer for proper handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga5abc2123bae0a1d3512d41be98ca477c">XDCFG_INT_STS_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="gafff047d176ced3a255248219c1278e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafff047d176ced3a255248219c1278e3b">&#9670;&nbsp;</a></span>XDcfg_IntrClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_IntrClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>This function clears the specified interrupts in the Interrupt Status Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the bit-mask of the interrupts to be cleared. Bit positions of 1 will be cleared. Bit positions of 0 will not change the previous interrupt status. This mask is formed by OR'ing XDCFG_INT_* bits which are defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga5abc2123bae0a1d3512d41be98ca477c">XDCFG_INT_STS_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="xdevcfg__reg__readback__example_8c.html#af9cf92cccf467028f2ac04b532a100c0">XDcfg_GetConfigReg()</a>.</p>

</div>
</div>
<a id="gab7606b370c10d68d61402bed68955a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7606b370c10d68d61402bed68955a80">&#9670;&nbsp;</a></span>XDcfg_IntrDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>This function disables the specified interrupts in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the bit-mask of the interrupts to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XDCFG_INT_* bits defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga15552ab3878c35ec94749ebed5247fe5">XDCFG_INT_MASK_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>.</p>

</div>
</div>
<a id="gab9c70f073e4522d6085c0059bc385aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c70f073e4522d6085c0059bc385aa9">&#9670;&nbsp;</a></span>XDcfg_IntrEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>This function enables the specified interrupts in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the bit-mask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XDCFG_INT_* bits defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga15552ab3878c35ec94749ebed5247fe5">XDCFG_INT_MASK_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>.</p>

</div>
</div>
<a id="ga879fec56ba0f64d3b2128f11e2b022f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879fec56ba0f64d3b2128f11e2b022f0">&#9670;&nbsp;</a></span>XDcfg_IntrGetEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_IntrGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>This function returns the enabled interrupts read from the Interrupt Mask Register. </p>
<p>Use the XDCFG_INT_* constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the IMR.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga15552ab3878c35ec94749ebed5247fe5">XDCFG_INT_MASK_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>.</p>

</div>
</div>
<a id="ga9ed5382e8c80a2277816a4db98a1ec6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed5382e8c80a2277816a4db98a1ec6f">&#9670;&nbsp;</a></span>XDcfg_IntrGetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_IntrGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>This function returns the interrupt status read from Interrupt Status Register. </p>
<p>Use the XDCFG_INT_* constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit value representing the contents of the Interrupt Status register.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga5abc2123bae0a1d3512d41be98ca477c">XDCFG_INT_STS_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>.</p>

</div>
</div>
<a id="gab3412c2881ffaa15fd3615770a4225a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3412c2881ffaa15fd3615770a4225a7">&#9670;&nbsp;</a></span>XDcfg_IsDmaBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_IsDmaBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>This function checks if DMA command queue is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS is the DMA is busy XST_FAILURE if the DMA is idle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The DMA queue has a depth of two. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, <a class="el" href="group__devcfg__v3__3.html#ga48a0c155d061c98656101cb19a87f0a0">XDCFG_STATUS_DMA_CMD_Q_F_MASK</a>, and <a class="el" href="group__devcfg__v3__3.html#ga6646b7874a5c9cc7bcdba6072bb4ff72">XDCFG_STATUS_OFFSET</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__devcfg__v3__5.html#ga5a7a69cfe6e10770f82089bdd277955d">XDcfg_Transfer()</a>.</p>

</div>
</div>
<a id="gab7512afadad93e25630048943fd72d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7512afadad93e25630048943fd72d41">&#9670;&nbsp;</a></span>XDcfg_LookupConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> * XDcfg_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>Lookup the device configuration based on the unique device ID. </p>
<p>The table contains the configuration info for each device in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="group__devcfg__v3__5.html#ga77946de6f18b07bd6c24fdd084ab5395">XDcfg_ConfigTable</a>.</p>

<p class="reference">Referenced by <a class="el" href="xdevcfg__selftest__example_8c.html#aee3ce00335c2f2e886f475d5e11aaf72">DcfgSelfTestExample()</a>, <a class="el" href="xdevcfg__interrupt__example_8c.html#a2a07952c85939f2590c00f736e075bd1">XDcfgInterruptExample()</a>, and <a class="el" href="xdevcfg__reg__readback__example_8c.html#ae521229b81ef92bbf76223679d5ae55e">XDcfgRegReadExample()</a>.</p>

</div>
</div>
<a id="ga995fb32dbac8a7899c9be66a8bf7d3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga995fb32dbac8a7899c9be66a8bf7d3d1">&#9670;&nbsp;</a></span>XDcfg_ResetHw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_ResetHw </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BaseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg__hw_8c.html">xdevcfg_hw.c</a>&gt;</code></p>

<p>This function perform the reset sequence to the given devcfg interface by configuring the appropriate control bits in the devcfg specifc registers the devcfg reset squence involves the following steps Disable all the interuupts Clear the status Update relevant config registers with reset values Disbale the looopback mode and pcap rate enable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseAddress</td><td>of the interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will not modify the slcr registers that are relavant for devcfg controller </dd></dl>

<p class="reference">References <a class="el" href="group__devcfg__v3__3.html#ga15552ab3878c35ec94749ebed5247fe5">XDCFG_INT_MASK_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="ga2c24756b9d6f8e81b620d27a86379e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c24756b9d6f8e81b620d27a86379e15">&#9670;&nbsp;</a></span>XDcfg_SelfTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDcfg_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>Run a self-test on the Device Configuration Interface. </p>
<p>This test does a control register write and reads back the same value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if self-test was successful.</li>
<li>XST_FAILURE if fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#gaee65740fa83e66131a1b706844bbc368">XDCFG_CTRL_NIDEN_MASK</a>, <a class="el" href="group__devcfg__v3__5.html#ga81a254369eea778c17c212cc95056c26">XDcfg_GetControlRegister()</a>, and <a class="el" href="group__devcfg__v3__5.html#gacc8c10b5cc877595c1ade09e1a589296">XDcfg_SetControlRegister()</a>.</p>

<p class="reference">Referenced by <a class="el" href="xdevcfg__selftest__example_8c.html#aee3ce00335c2f2e886f475d5e11aaf72">DcfgSelfTestExample()</a>, <a class="el" href="xdevcfg__interrupt__example_8c.html#a2a07952c85939f2590c00f736e075bd1">XDcfgInterruptExample()</a>, and <a class="el" href="xdevcfg__reg__readback__example_8c.html#ae521229b81ef92bbf76223679d5ae55e">XDcfgRegReadExample()</a>.</p>

</div>
</div>
<a id="ga89e1eef15fcfe06cd0e8d8dd7e804ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89e1eef15fcfe06cd0e8d8dd7e804ad1">&#9670;&nbsp;</a></span>XDcfg_SetConfigRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetConfigRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function sets the contents of the Configuration Register with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Data</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga3fafe11b95af8da04f385c9313a6958b">XDCFG_CFG_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="gacc8c10b5cc877595c1ade09e1a589296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc8c10b5cc877595c1ade09e1a589296">&#9670;&nbsp;</a></span>XDcfg_SetControlRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function sets the contents of the Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the 32 bit mask data to be written to the Register. The mask definitions are defined in the <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga31ebfed655e59d8ee204b253e04ee024">XDCFG_CTRL_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__devcfg__v3__5.html#ga2c24756b9d6f8e81b620d27a86379e15">XDcfg_SelfTest()</a>.</p>

</div>
</div>
<a id="gaed08df4afb0dd9c343bf994b4c18e926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed08df4afb0dd9c343bf994b4c18e926">&#9670;&nbsp;</a></span>XDcfg_SetHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&gt;</code></p>

<p>This function sets the handler that will be called when an event (interrupt) occurs that needs application's attention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance </td></tr>
    <tr><td class="paramname">CallBackFunc</td><td>is the address of the callback function. </td></tr>
    <tr><td class="paramname">CallBackRef</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>.</p>

</div>
</div>
<a id="ga1e0516cd9cdc5066e98e3c3c195c1d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e0516cd9cdc5066e98e3c3c195c1d3c">&#9670;&nbsp;</a></span>XDcfg_SetLockRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetLockRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function sets the contents of the Lock Register. </p>
<p>These bits can only be set to a 1. They will be cleared after a Power On Reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Data</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#gad126a845b17979d640cd2dd00eab29f9">XDCFG_LOCK_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="ga2739b6bce23b6e02a9076c0eba8664d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2739b6bce23b6e02a9076c0eba8664d4">&#9670;&nbsp;</a></span>XDcfg_SetMiscControlRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetMiscControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function sets the bit mask for the feature in Miscellaneous Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Mask</td><td>is the bit-mask of the feature to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga80ad10863ac12916d347046e8263f5b2">XDCFG_MCTRL_OFFSET</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="ga332a5c7c856e8f6637cafaa3ec69eaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga332a5c7c856e8f6637cafaa3ec69eaca">&#9670;&nbsp;</a></span>XDcfg_SetRomShadowRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetRomShadowRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function sets the contents of the ROM Shadow Control Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Data</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This register is can only be written and is used to control the RAM shadow of 32 bit 4K page ROM pages in user mode </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga895856e5cf4578a328a12bb0f0287826">XDCFG_ROM_SHADOW_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="gae7a3e8052f73c370990b77dae5751a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a3e8052f73c370990b77dae5751a36">&#9670;&nbsp;</a></span>XDcfg_SetStatusRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetStatusRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>The function sets the contents of the Status Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">Data</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__3.html#ga6646b7874a5c9cc7bcdba6072bb4ff72">XDCFG_STATUS_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga8ae617fbb2b3e148a8b2489e90fbdea3">XDcfg_WriteReg</a>.</p>

</div>
</div>
<a id="ga5a7a69cfe6e10770f82089bdd277955d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a7a69cfe6e10770f82089bdd277955d">&#9670;&nbsp;</a></span>XDcfg_Transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_Transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>SourcePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SrcWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DestWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>TransferType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg_8c.html">xdevcfg.c</a>&gt;</code></p>

<p>This function starts the DMA transfer. </p>
<p>This function only starts the operation and returns before the operation may be completed. If the interrupt is enabled, an interrupt will be generated when the operation is completed, otherwise it is necessary to poll the Status register to determine when it is completed. It is the responsibility of the caller to determine when the operation is completed by handling the generated interrupt or polling the Status Register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html" title="The XDcfg driver instance data. ">XDcfg</a> instance. </td></tr>
    <tr><td class="paramname">SourcePtr</td><td>contains a pointer to the source memory where the data is to be transferred from. </td></tr>
    <tr><td class="paramname">SrcWordLength</td><td>is the number of words (32 bit) to be transferred for the source transfer. </td></tr>
    <tr><td class="paramname">DestPtr</td><td>contains a pointer to the destination memory where the data is to be transferred to. </td></tr>
    <tr><td class="paramname">DestWordLength</td><td>is the number of words (32 bit) to be transferred for the Destination transfer. </td></tr>
    <tr><td class="paramname">TransferType</td><td>contains the type of PCAP transfer being requested. The definitions can be found in the <a class="el" href="xdevcfg_8h.html">xdevcfg.h</a> file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS.if DMA transfer initiated successfully</li>
<li>XST_DEVICE_BUSY if DMA is busy</li>
<li>XST_INVALID_PARAM if invalid Source / Destination address is sent or an invalid Source / Destination length is sent</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is the responsibility of the caller to ensure that the cache is flushed and invalidated both before the DMA operation is started and after the DMA operation completes if the memory pointed to is cached. The caller must also ensure that the pointers contain physical address rather than a virtual address if address translation is being used. <pre class="fragment">    The 2 LSBs of the SourcePtr (Source)/ DestPtr (Destination)
</pre> address when equal to 2b01 indicates the last DMA command of an overall transfer. </dd></dl>

<p class="reference">References <a class="el" href="struct_x_dcfg___config.html#a97b0e40ed1632649e15eedea77e84a82">XDcfg_Config::BaseAddr</a>, <a class="el" href="struct_x_dcfg.html#aa781f458f64d74c8147d10f09683301e">XDcfg::Config</a>, <a class="el" href="struct_x_dcfg.html#acd5816f6958bdbe2081d586d2b613f27">XDcfg::IsReady</a>, <a class="el" href="group__devcfg__v3__5.html#gab3412c2881ffaa15fd3615770a4225a7">XDcfg_IsDmaBusy()</a>, <a class="el" href="group__devcfg__v3__3.html#ga77561dc2e9ea13137f50a8193b8fbcd3">XDcfg_ReadReg</a>, <a class="el" href="group__devcfg__v3__3.html#ga6646b7874a5c9cc7bcdba6072bb4ff72">XDCFG_STATUS_OFFSET</a>, and <a class="el" href="group__devcfg__v3__3.html#ga2adb521e9dab8223c16f2ebbfccc830f">XDCFG_STATUS_PCFG_INIT_MASK</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga77946de6f18b07bd6c24fdd084ab5395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77946de6f18b07bd6c24fdd084ab5395">&#9670;&nbsp;</a></span>XDcfg_ConfigTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> XDcfg_ConfigTable[1]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="xdevcfg__g_8c.html">xdevcfg_g.c</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        {</div><div class="line">                XPAR_XDCFG_0_DEVICE_ID,</div><div class="line">                XPAR_XDCFG_0_BASEADDR,</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment -->
<p>This table contains configuration information for each Device Config Interface instance in the system. </p>

<p class="reference">Referenced by <a class="el" href="group__devcfg__v3__5.html#gab7512afadad93e25630048943fd72d41">XDcfg_LookupConfig()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
