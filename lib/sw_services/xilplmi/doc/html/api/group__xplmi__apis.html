<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>xilplmi: XilPlmi Versal APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">xilplmi
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__xplmi__apis.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">XilPlmi Versal APIs</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa731fb15670d4c6b00900c5fddf18b3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaa731fb15670d4c6b00900c5fddf18b3a">XPLMI_PROC_PSM_SEND_API_ID</a>&#160;&#160;&#160;(0x8U)</td></tr>
<tr class="memdesc:gaa731fb15670d4c6b00900c5fddf18b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">API Id.  <a href="#gaa731fb15670d4c6b00900c5fddf18b3a">More...</a><br/></td></tr>
<tr class="separator:gaa731fb15670d4c6b00900c5fddf18b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f9e530d9fd0ac8bc438f8fa8d2d7e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga72f9e530d9fd0ac8bc438f8fa8d2d7e3">XPLMI_PROC_PSM_SEND_API_ID_IDX</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga72f9e530d9fd0ac8bc438f8fa8d2d7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">API Id index.  <a href="#ga72f9e530d9fd0ac8bc438f8fa8d2d7e3">More...</a><br/></td></tr>
<tr class="separator:ga72f9e530d9fd0ac8bc438f8fa8d2d7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada65453fe2429adeabe5ddf19142645f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gada65453fe2429adeabe5ddf19142645f">XPLMI_PROC_PSM_SEND_START_ADDR_IDX</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gada65453fe2429adeabe5ddf19142645f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start address index.  <a href="#gada65453fe2429adeabe5ddf19142645f">More...</a><br/></td></tr>
<tr class="separator:gada65453fe2429adeabe5ddf19142645f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67561068c4094fb86f2f4cbcb3551c7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga67561068c4094fb86f2f4cbcb3551c7c">XPLMI_PROC_PSM_SEND_END_ADDR_IDX</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:ga67561068c4094fb86f2f4cbcb3551c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">End address index.  <a href="#ga67561068c4094fb86f2f4cbcb3551c7c">More...</a><br/></td></tr>
<tr class="separator:ga67561068c4094fb86f2f4cbcb3551c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2fad7d1424c4a8333cfdfeeb800adc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga4d2fad7d1424c4a8333cfdfeeb800adc">XPLMI_PROC_PAYLOAD_ARG_CNT</a>&#160;&#160;&#160;(8U)</td></tr>
<tr class="memdesc:ga4d2fad7d1424c4a8333cfdfeeb800adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Payload argument count.  <a href="#ga4d2fad7d1424c4a8333cfdfeeb800adc">More...</a><br/></td></tr>
<tr class="separator:ga4d2fad7d1424c4a8333cfdfeeb800adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76c9c65d8ab797fcf9c07586372ab57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gae76c9c65d8ab797fcf9c07586372ab57">XPLMI_PLM_GENERIC_PLMUPDATE</a>&#160;&#160;&#160;(0x20U)</td></tr>
<tr class="memdesc:gae76c9c65d8ab797fcf9c07586372ab57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic PLM update.  <a href="#gae76c9c65d8ab797fcf9c07586372ab57">More...</a><br/></td></tr>
<tr class="separator:gae76c9c65d8ab797fcf9c07586372ab57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b72aa9057242becf536b55903c7741"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga83b72aa9057242becf536b55903c7741">IPI_MAX_TIMEOUT</a>&#160;&#160;&#160;(~0U)</td></tr>
<tr class="memdesc:ga83b72aa9057242becf536b55903c7741"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPI Max timeout.  <a href="#ga83b72aa9057242becf536b55903c7741">More...</a><br/></td></tr>
<tr class="separator:ga83b72aa9057242becf536b55903c7741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98c00816801677a601071bf085c85df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaf98c00816801677a601071bf085c85df">XPLMI_SCATTER_WRITE_PAYLOAD_LEN</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:gaf98c00816801677a601071bf085c85df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter write payload length.  <a href="#gaf98c00816801677a601071bf085c85df">More...</a><br/></td></tr>
<tr class="separator:gaf98c00816801677a601071bf085c85df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397480c245b3cdca2b2d6e99ff197cee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga397480c245b3cdca2b2d6e99ff197cee">XPLMI_SCATTER_WRITE2_PAYLOAD_LEN</a>&#160;&#160;&#160;(3U)</td></tr>
<tr class="memdesc:ga397480c245b3cdca2b2d6e99ff197cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter write2 payload length.  <a href="#ga397480c245b3cdca2b2d6e99ff197cee">More...</a><br/></td></tr>
<tr class="separator:ga397480c245b3cdca2b2d6e99ff197cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219705f95bebd92b02253f067b573f88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga219705f95bebd92b02253f067b573f88">XPLMI_FIPS_WRITE_KATMASK_PAYLOAD_LEN</a>&#160;&#160;&#160;(7U)</td></tr>
<tr class="memdesc:ga219705f95bebd92b02253f067b573f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIPS write KAT mask payload length.  <a href="#ga219705f95bebd92b02253f067b573f88">More...</a><br/></td></tr>
<tr class="separator:ga219705f95bebd92b02253f067b573f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga16dfbc95a9bdf0502840e261b8865652"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga16dfbc95a9bdf0502840e261b8865652">XPlmi_DmaTransfer</a> (u64 Dest, u64 Src, u32 Len, u32 Flags)</td></tr>
<tr class="memdesc:ga16dfbc95a9bdf0502840e261b8865652"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides functionality for DMA write.  <a href="#ga16dfbc95a9bdf0502840e261b8865652">More...</a><br/></td></tr>
<tr class="separator:ga16dfbc95a9bdf0502840e261b8865652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d211f8f98008e3fb03a2516376e4c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga82d211f8f98008e3fb03a2516376e4c7">XPlmi_CheckIpiAccess</a> (u32 CmdId, u32 IpiReqType)</td></tr>
<tr class="memdesc:ga82d211f8f98008e3fb03a2516376e4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the IPI command is accessible or not.  <a href="#ga82d211f8f98008e3fb03a2516376e4c7">More...</a><br/></td></tr>
<tr class="separator:ga82d211f8f98008e3fb03a2516376e4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9043da48baf45f46f01c4b0086cd2f14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga9043da48baf45f46f01c4b0086cd2f14">XPlmi_ValidateCmd</a> (u32 ModuleId, u32 ApiId)</td></tr>
<tr class="memdesc:ga9043da48baf45f46f01c4b0086cd2f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the Cmd passed is supported via IPI mechanism or not.  <a href="#ga9043da48baf45f46f01c4b0086cd2f14">More...</a><br/></td></tr>
<tr class="separator:ga9043da48baf45f46f01c4b0086cd2f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ddc1de78adaa52322685bd933f588e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga8ddc1de78adaa52322685bd933f588e7">XPlmi_InPlacePlmUpdate</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:ga8ddc1de78adaa52322685bd933f588e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides In Place PLM Update support.  <a href="#ga8ddc1de78adaa52322685bd933f588e7">More...</a><br/></td></tr>
<tr class="separator:ga8ddc1de78adaa52322685bd933f588e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8878d25485f7e85643a90933ed37e67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaf8878d25485f7e85643a90933ed37e67">XPlmi_PsmSequence</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:gaf8878d25485f7e85643a90933ed37e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to transfer all psm_sequence commands to PSM RAM regions which are then processed by PSM immediately.  <a href="#gaf8878d25485f7e85643a90933ed37e67">More...</a><br/></td></tr>
<tr class="separator:gaf8878d25485f7e85643a90933ed37e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8aea8817f7523f8e19f5b8f2712234"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga2c8aea8817f7523f8e19f5b8f2712234">XPlmi_ScatterWrite</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:ga2c8aea8817f7523f8e19f5b8f2712234"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will write single 32 bit value to multiple addresses which are specified in the payload.  <a href="#ga2c8aea8817f7523f8e19f5b8f2712234">More...</a><br/></td></tr>
<tr class="separator:ga2c8aea8817f7523f8e19f5b8f2712234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1cdb534edb8282728567c27ed02bc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga1e1cdb534edb8282728567c27ed02bc1">XPlmi_ScatterWrite2</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:ga1e1cdb534edb8282728567c27ed02bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will write 2 32-bit values to multiple addresses which are specified by the payload.  <a href="#ga1e1cdb534edb8282728567c27ed02bc1">More...</a><br/></td></tr>
<tr class="separator:ga1e1cdb534edb8282728567c27ed02bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30cbe0eeabc180d930a709179f8a2801"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga30cbe0eeabc180d930a709179f8a2801">XPlmi_SetFipsKatMask</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:ga30cbe0eeabc180d930a709179f8a2801"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will store the KAT mask set by the user so that PLM can monitor the RTCA and compare it with KAT masks before going into FIPS operational state.  <a href="#ga30cbe0eeabc180d930a709179f8a2801">More...</a><br/></td></tr>
<tr class="separator:ga30cbe0eeabc180d930a709179f8a2801"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0c73dba6f2d5451ba20a3c0f2f49d6ab"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga0c73dba6f2d5451ba20a3c0f2f49d6ab">XPlmi_SsitEvents_t::EventOrigin</a></td></tr>
<tr class="memdesc:ga0c73dba6f2d5451ba20a3c0f2f49d6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event orgin.  <a href="#ga0c73dba6f2d5451ba20a3c0f2f49d6ab">More...</a><br/></td></tr>
<tr class="separator:ga0c73dba6f2d5451ba20a3c0f2f49d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6edba9664412089e967ac22af1c7d79b"><td class="memItemLeft" align="right" valign="top">XPlmi_EventHandler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga6edba9664412089e967ac22af1c7d79b">XPlmi_SsitEvents_t::EventHandler</a></td></tr>
<tr class="memdesc:ga6edba9664412089e967ac22af1c7d79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler.  <a href="#ga6edba9664412089e967ac22af1c7d79b">More...</a><br/></td></tr>
<tr class="separator:ga6edba9664412089e967ac22af1c7d79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80bc1243f0687c76d2c09130d5e4cd6"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaa80bc1243f0687c76d2c09130d5e4cd6">XPlmi_SsitEventStruct_t::SlrIndex</a></td></tr>
<tr class="memdesc:gaa80bc1243f0687c76d2c09130d5e4cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slr index.  <a href="#gaa80bc1243f0687c76d2c09130d5e4cd6">More...</a><br/></td></tr>
<tr class="separator:gaa80bc1243f0687c76d2c09130d5e4cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a99bb8c59d5e636fe29d75e6d252a9"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gad7a99bb8c59d5e636fe29d75e6d252a9">XPlmi_SsitEventStruct_t::IsIntrEnabled</a></td></tr>
<tr class="memdesc:gad7a99bb8c59d5e636fe29d75e6d252a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interruput enable status check.  <a href="#gad7a99bb8c59d5e636fe29d75e6d252a9">More...</a><br/></td></tr>
<tr class="separator:gad7a99bb8c59d5e636fe29d75e6d252a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf81f6416476f36f307c68bf1cc7a4b"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga1bf81f6416476f36f307c68bf1cc7a4b">XPlmi_SsitEventStruct_t::SlavesMask</a></td></tr>
<tr class="memdesc:ga1bf81f6416476f36f307c68bf1cc7a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slaves mask.  <a href="#ga1bf81f6416476f36f307c68bf1cc7a4b">More...</a><br/></td></tr>
<tr class="separator:ga1bf81f6416476f36f307c68bf1cc7a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254ed570fd434f05f81b810349f1d592"><td class="memItemLeft" align="right" valign="top">XPlmi_SsitEvents_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga254ed570fd434f05f81b810349f1d592">XPlmi_SsitEventStruct_t::Events</a> [XPLMI_SSIT_MAX_EVENTS]</td></tr>
<tr class="memdesc:ga254ed570fd434f05f81b810349f1d592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of SSIT maximum events.  <a href="#ga254ed570fd434f05f81b810349f1d592">More...</a><br/></td></tr>
<tr class="separator:ga254ed570fd434f05f81b810349f1d592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17a730be6cee9cabcbf2686d6463d543"><td class="memItemLeft" align="right" valign="top">XPlmi_TaskNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga17a730be6cee9cabcbf2686d6463d543">XPlmi_SsitEventStruct_t::Task1</a></td></tr>
<tr class="memdesc:ga17a730be6cee9cabcbf2686d6463d543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task1 pointer to the TaskNode structure.  <a href="#ga17a730be6cee9cabcbf2686d6463d543">More...</a><br/></td></tr>
<tr class="separator:ga17a730be6cee9cabcbf2686d6463d543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cfb7bb11e85c2ee58482fcd8f68f6"><td class="memItemLeft" align="right" valign="top">XPlmi_TaskNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga914cfb7bb11e85c2ee58482fcd8f68f6">XPlmi_SsitEventStruct_t::Task2</a></td></tr>
<tr class="memdesc:ga914cfb7bb11e85c2ee58482fcd8f68f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task2 pointer to the TaskNode structure.  <a href="#ga914cfb7bb11e85c2ee58482fcd8f68f6">More...</a><br/></td></tr>
<tr class="separator:ga914cfb7bb11e85c2ee58482fcd8f68f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e911f5d96e634fa2094792c130bf9a"><td class="memItemLeft" align="right" valign="top">XPlmi_TaskNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gac7e911f5d96e634fa2094792c130bf9a">XPlmi_SsitEventStruct_t::Task3</a></td></tr>
<tr class="memdesc:gac7e911f5d96e634fa2094792c130bf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task3 pointer to the TaskNode structure.  <a href="#gac7e911f5d96e634fa2094792c130bf9a">More...</a><br/></td></tr>
<tr class="separator:gac7e911f5d96e634fa2094792c130bf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64129a720ca64e4f1cf1ed9279cce00f"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga64129a720ca64e4f1cf1ed9279cce00f">XPlmi_SsitEventVectorTable_t::Events32</a> [XPLMI_SSIT_MAX_EVENT32_INDEX]</td></tr>
<tr class="memdesc:ga64129a720ca64e4f1cf1ed9279cce00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of SSIT maximum events 32.  <a href="#ga64129a720ca64e4f1cf1ed9279cce00f">More...</a><br/></td></tr>
<tr class="separator:ga64129a720ca64e4f1cf1ed9279cce00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48d925ddd447c3e5b00eab9f221429b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaf48d925ddd447c3e5b00eab9f221429b">XPlmi_EventLogging</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:gaf48d925ddd447c3e5b00eab9f221429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides Event Logging command execution.  <a href="#gaf48d925ddd447c3e5b00eab9f221429b">More...</a><br/></td></tr>
<tr class="separator:gaf48d925ddd447c3e5b00eab9f221429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79ea148da2b84189d2d8d01c4592f59c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga79ea148da2b84189d2d8d01c4592f59c">XPlmi_MoveProc</a> (u8 ProcIndex, XPlmi_ProcList *ProcList)</td></tr>
<tr class="memdesc:ga79ea148da2b84189d2d8d01c4592f59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides functionality to move procs when proc command is received for existing ProcId.  <a href="#ga79ea148da2b84189d2d8d01c4592f59c">More...</a><br/></td></tr>
<tr class="separator:ga79ea148da2b84189d2d8d01c4592f59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a3680a8c996865c6e87c4a44669973"><td class="memItemLeft" align="right" valign="top">XPlmi_ProcList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaf5a3680a8c996865c6e87c4a44669973">XPlmi_GetProcList</a> (u8 ProcListType)</td></tr>
<tr class="memdesc:gaf5a3680a8c996865c6e87c4a44669973"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function defines ProcList and returns the address of the same.  <a href="#gaf5a3680a8c996865c6e87c4a44669973">More...</a><br/></td></tr>
<tr class="separator:gaf5a3680a8c996865c6e87c4a44669973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697a0b26b0197bbcca5e075f4cd1f765"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga697a0b26b0197bbcca5e075f4cd1f765">XPlmi_SetProcList</a> (u32 Address, u16 Size)</td></tr>
<tr class="memdesc:ga697a0b26b0197bbcca5e075f4cd1f765"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets PSM ProcList address to given Address and Size.  <a href="#ga697a0b26b0197bbcca5e075f4cd1f765">More...</a><br/></td></tr>
<tr class="separator:ga697a0b26b0197bbcca5e075f4cd1f765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga053bc9806bfc10856b7617c75da2a864"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga053bc9806bfc10856b7617c75da2a864">XPlmi_ExecuteProc</a> (u32 ProcId)</td></tr>
<tr class="memdesc:ga053bc9806bfc10856b7617c75da2a864"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides functionality to execute given ProcId when request to execute a particular ProcId.  <a href="#ga053bc9806bfc10856b7617c75da2a864">More...</a><br/></td></tr>
<tr class="separator:ga053bc9806bfc10856b7617c75da2a864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0060d3f27c5c714f99941cd06d0142d0"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga0060d3f27c5c714f99941cd06d0142d0">XPlmi_GetSlrIndex</a> (void)</td></tr>
<tr class="memdesc:ga0060d3f27c5c714f99941cd06d0142d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the local SLR index.  <a href="#ga0060d3f27c5c714f99941cd06d0142d0">More...</a><br/></td></tr>
<tr class="separator:ga0060d3f27c5c714f99941cd06d0142d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873411286b21b899a8a6782b9b0a6b1b"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga873411286b21b899a8a6782b9b0a6b1b">XPlmi_GetSlavesSlrMask</a> (void)</td></tr>
<tr class="memdesc:ga873411286b21b899a8a6782b9b0a6b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the combined mask of all slave SLRs.  <a href="#ga873411286b21b899a8a6782b9b0a6b1b">More...</a><br/></td></tr>
<tr class="separator:ga873411286b21b899a8a6782b9b0a6b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ceffb7348ed1c37af238f02df63905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaf7ceffb7348ed1c37af238f02df63905">XPlmi_SsitRegisterEvent</a> (u32 EventIndex, XPlmi_EventHandler_t Handler, u8 EventOrigin)</td></tr>
<tr class="memdesc:gaf7ceffb7348ed1c37af238f02df63905"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to register any event between Master and Slave SLRs.  <a href="#gaf7ceffb7348ed1c37af238f02df63905">More...</a><br/></td></tr>
<tr class="separator:gaf7ceffb7348ed1c37af238f02df63905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07fd84a364236b869b74f56a55a1f1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gae07fd84a364236b869b74f56a55a1f1e">XPlmi_SsitWriteEventBufferAndTriggerMsgEvent</a> (u8 SlrIndex, u32 *ReqBuf, u32 ReqBufSize)</td></tr>
<tr class="memdesc:gae07fd84a364236b869b74f56a55a1f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to write the event buffer data and trigger the Message Event.  <a href="#gae07fd84a364236b869b74f56a55a1f1e">More...</a><br/></td></tr>
<tr class="separator:gae07fd84a364236b869b74f56a55a1f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef6b32fe8a4519644b90ca780397e4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga5ef6b32fe8a4519644b90ca780397e4a">XPlmi_SsitReadEventBuffer</a> (u32 *ReqBuf, u32 ReqBufSize)</td></tr>
<tr class="memdesc:ga5ef6b32fe8a4519644b90ca780397e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the event buffer of Master SLR in Slave SLRs where the message event is received.  <a href="#ga5ef6b32fe8a4519644b90ca780397e4a">More...</a><br/></td></tr>
<tr class="separator:ga5ef6b32fe8a4519644b90ca780397e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d1464d41ef967f174542299449cad8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gae5d1464d41ef967f174542299449cad8">XPlmi_SsitTriggerEvent</a> (u8 SlrIndex, u32 EventIndex)</td></tr>
<tr class="memdesc:gae5d1464d41ef967f174542299449cad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to trigger the given event to the given SLR.  <a href="#gae5d1464d41ef967f174542299449cad8">More...</a><br/></td></tr>
<tr class="separator:gae5d1464d41ef967f174542299449cad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510deac0c8054dc5352bcd297e48dac3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga510deac0c8054dc5352bcd297e48dac3">XPlmi_SsitWaitForEvent</a> (u8 SlrIndex, u32 EventIndex, u32 TimeOut)</td></tr>
<tr class="memdesc:ga510deac0c8054dc5352bcd297e48dac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to wait for the event to be acknowledged by the given SLR after triggering.  <a href="#ga510deac0c8054dc5352bcd297e48dac3">More...</a><br/></td></tr>
<tr class="separator:ga510deac0c8054dc5352bcd297e48dac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacadf5fc2d6cee12eac80dfec967c2c3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gacadf5fc2d6cee12eac80dfec967c2c3f">XPlmi_SsitReadResponse</a> (u8 SlrIndex, u32 *RespBuf, u32 RespBufSize)</td></tr>
<tr class="memdesc:gacadf5fc2d6cee12eac80dfec967c2c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the response (if applicable) in Master SLR once the event is acknowledged by Slave SLR.  <a href="#gacadf5fc2d6cee12eac80dfec967c2c3f">More...</a><br/></td></tr>
<tr class="separator:gacadf5fc2d6cee12eac80dfec967c2c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2475d6e57ee465119b1bb88bd17c0588"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga2475d6e57ee465119b1bb88bd17c0588">XPlmi_SsitWriteResponseAndAckMsgEvent</a> (u32 *RespBuf, u32 RespBufSize)</td></tr>
<tr class="memdesc:ga2475d6e57ee465119b1bb88bd17c0588"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to write the response (if applicable) in Slave SLR once the event is handled and acknowledge the message event.  <a href="#ga2475d6e57ee465119b1bb88bd17c0588">More...</a><br/></td></tr>
<tr class="separator:ga2475d6e57ee465119b1bb88bd17c0588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e27e5bd43606860f63a38572f4821bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga3e27e5bd43606860f63a38572f4821bf">XPlmi_SsitAcknowledgeEvent</a> (u8 SlrIndex, u32 EventIndex)</td></tr>
<tr class="memdesc:ga3e27e5bd43606860f63a38572f4821bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to acknowledge the event after handling.  <a href="#ga3e27e5bd43606860f63a38572f4821bf">More...</a><br/></td></tr>
<tr class="separator:ga3e27e5bd43606860f63a38572f4821bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e76ea091646d92e7a0482e67602b86f"><td class="memItemLeft" align="right" valign="top">u64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga2e76ea091646d92e7a0482e67602b86f">XPlmi_SsitGetSlrAddr</a> (u32 Address, u8 SlrIndex)</td></tr>
<tr class="memdesc:ga2e76ea091646d92e7a0482e67602b86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the global SLR address for the given local address.  <a href="#ga2e76ea091646d92e7a0482e67602b86f">More...</a><br/></td></tr>
<tr class="separator:ga2e76ea091646d92e7a0482e67602b86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7eb4ca501aab712353daf78cfb4863"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gafd7eb4ca501aab712353daf78cfb4863">XPlmi_SsitSendMsgEventAndGetResp</a> (u8 SlrIndex, u32 *ReqBuf, u32 ReqBufSize, u32 *RespBuf, u32 RespBufSize, u32 WaitForEventCompletion)</td></tr>
<tr class="memdesc:gafd7eb4ca501aab712353daf78cfb4863"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sends a message event with given request buffer to a slave SLR, waits for event completion, reads the response from the slave SLR and returns it to the caller.  <a href="#gafd7eb4ca501aab712353daf78cfb4863">More...</a><br/></td></tr>
<tr class="separator:gafd7eb4ca501aab712353daf78cfb4863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09694a4b8467a90ed7afdda529d5f721"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga09694a4b8467a90ed7afdda529d5f721">XPlmi_SendIpiCmdToSlaveSlr</a> (u32 *Payload, u32 *RespBuf)</td></tr>
<tr class="memdesc:ga09694a4b8467a90ed7afdda529d5f721"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles invalid commands.  <a href="#ga09694a4b8467a90ed7afdda529d5f721">More...</a><br/></td></tr>
<tr class="separator:ga09694a4b8467a90ed7afdda529d5f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24bb1ce85073deed1339422ee5d915f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaf24bb1ce85073deed1339422ee5d915f">XPlmi_SsitSyncMaster</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:gaf24bb1ce85073deed1339422ee5d915f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides SSIT Sync Master command execution.  <a href="#gaf24bb1ce85073deed1339422ee5d915f">More...</a><br/></td></tr>
<tr class="separator:gaf24bb1ce85073deed1339422ee5d915f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d0e16deb820f98b18689dc9966f3ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gad6d0e16deb820f98b18689dc9966f3ff">XPlmi_SsitSyncSlaves</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:gad6d0e16deb820f98b18689dc9966f3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides SSIT Sync Slaves command execution.  <a href="#gad6d0e16deb820f98b18689dc9966f3ff">More...</a><br/></td></tr>
<tr class="separator:gad6d0e16deb820f98b18689dc9966f3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb88dc15cd3354f65b346c3e92c2d88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga5cb88dc15cd3354f65b346c3e92c2d88">XPlmi_SsitWaitSlaves</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:ga5cb88dc15cd3354f65b346c3e92c2d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides SSIT Wait Slaves command execution.  <a href="#ga5cb88dc15cd3354f65b346c3e92c2d88">More...</a><br/></td></tr>
<tr class="separator:ga5cb88dc15cd3354f65b346c3e92c2d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa33ba3dc66267cc831a88255d9a1409"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaaa33ba3dc66267cc831a88255d9a1409">XPLMI_SSIT_SINGLE_EAM_EVENT_ERR_ID</a>&#160;&#160;&#160;(XIL_NODETYPE_EVENT_ERROR_PMC_ERR1)</td></tr>
<tr class="memdesc:gaaa33ba3dc66267cc831a88255d9a1409"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSIT Single EAM Event Macros.  <a href="#gaaa33ba3dc66267cc831a88255d9a1409">More...</a><br/></td></tr>
<tr class="separator:gaaa33ba3dc66267cc831a88255d9a1409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37f68542fdb6d4c42b74ab8862be551"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaf37f68542fdb6d4c42b74ab8862be551">XPlmi_EnableWdt</a> (u32 NodeId, u32 Periodicity)</td></tr>
<tr class="memdesc:gaf37f68542fdb6d4c42b74ab8862be551"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the WDT and sets NodeId and periodicity.  <a href="#gaf37f68542fdb6d4c42b74ab8862be551">More...</a><br/></td></tr>
<tr class="separator:gaf37f68542fdb6d4c42b74ab8862be551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d8d2bbe4d87840df7d3b40d42355af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#ga55d8d2bbe4d87840df7d3b40d42355af">XPlmi_KickWdt</a> (u32 NodeId)</td></tr>
<tr class="memdesc:ga55d8d2bbe4d87840df7d3b40d42355af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to kick the WDT.  <a href="#ga55d8d2bbe4d87840df7d3b40d42355af">More...</a><br/></td></tr>
<tr class="separator:ga55d8d2bbe4d87840df7d3b40d42355af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4eadfbcae0dd8a8d8872640a32744b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gac4eadfbcae0dd8a8d8872640a32744b4">XPlmi_RestoreWdt</a> (void)</td></tr>
<tr class="memdesc:gac4eadfbcae0dd8a8d8872640a32744b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to restore wdt after the In-Place PLM Update.  <a href="#gac4eadfbcae0dd8a8d8872640a32744b4">More...</a><br/></td></tr>
<tr class="separator:gac4eadfbcae0dd8a8d8872640a32744b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa331a666f6dbd1e7a908327e3898a11d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaa331a666f6dbd1e7a908327e3898a11d">XPlmi_StopWdt</a> (u32 NodeId)</td></tr>
<tr class="memdesc:gaa331a666f6dbd1e7a908327e3898a11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops PMC WDT.  <a href="#gaa331a666f6dbd1e7a908327e3898a11d">More...</a><br/></td></tr>
<tr class="separator:gaa331a666f6dbd1e7a908327e3898a11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80acce34d3a6858f42b05b8a52df7bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xplmi__apis.html#gaa80acce34d3a6858f42b05b8a52df7bd">XPlmi_DefaultSWdtConfig</a> (void)</td></tr>
<tr class="memdesc:gaa80acce34d3a6858f42b05b8a52df7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the default WDT configuration if the wdt is not enabled and ROM SWDT usage bit is enabled in EFUSE.  <a href="#gaa80acce34d3a6858f42b05b8a52df7bd">More...</a><br/></td></tr>
<tr class="separator:gaa80acce34d3a6858f42b05b8a52df7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga83b72aa9057242becf536b55903c7741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPI_MAX_TIMEOUT&#160;&#160;&#160;(~0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPI Max timeout. </p>

</div>
</div>
<a class="anchor" id="ga219705f95bebd92b02253f067b573f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_FIPS_WRITE_KATMASK_PAYLOAD_LEN&#160;&#160;&#160;(7U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FIPS write KAT mask payload length. </p>

<p>Referenced by <a class="el" href="group__xplmi__apis.html#ga30cbe0eeabc180d930a709179f8a2801">XPlmi_SetFipsKatMask()</a>.</p>

</div>
</div>
<a class="anchor" id="gae76c9c65d8ab797fcf9c07586372ab57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_PLM_GENERIC_PLMUPDATE&#160;&#160;&#160;(0x20U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic PLM update. </p>

<p>Referenced by <a class="el" href="group__xplmi__apis.html#ga9043da48baf45f46f01c4b0086cd2f14">XPlmi_ValidateCmd()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d2fad7d1424c4a8333cfdfeeb800adc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_PROC_PAYLOAD_ARG_CNT&#160;&#160;&#160;(8U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Payload argument count. </p>

</div>
</div>
<a class="anchor" id="gaa731fb15670d4c6b00900c5fddf18b3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_PROC_PSM_SEND_API_ID&#160;&#160;&#160;(0x8U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API Id. </p>

</div>
</div>
<a class="anchor" id="ga72f9e530d9fd0ac8bc438f8fa8d2d7e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_PROC_PSM_SEND_API_ID_IDX&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API Id index. </p>

</div>
</div>
<a class="anchor" id="ga67561068c4094fb86f2f4cbcb3551c7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_PROC_PSM_SEND_END_ADDR_IDX&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End address index. </p>

</div>
</div>
<a class="anchor" id="gada65453fe2429adeabe5ddf19142645f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_PROC_PSM_SEND_START_ADDR_IDX&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start address index. </p>

</div>
</div>
<a class="anchor" id="ga397480c245b3cdca2b2d6e99ff197cee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_SCATTER_WRITE2_PAYLOAD_LEN&#160;&#160;&#160;(3U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatter write2 payload length. </p>

<p>Referenced by <a class="el" href="group__xplmi__apis.html#ga1e1cdb534edb8282728567c27ed02bc1">XPlmi_ScatterWrite2()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf98c00816801677a601071bf085c85df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_SCATTER_WRITE_PAYLOAD_LEN&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatter write payload length. </p>

<p>Referenced by <a class="el" href="group__xplmi__apis.html#ga2c8aea8817f7523f8e19f5b8f2712234">XPlmi_ScatterWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaa33ba3dc66267cc831a88255d9a1409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_SSIT_SINGLE_EAM_EVENT_ERR_ID&#160;&#160;&#160;(XIL_NODETYPE_EVENT_ERROR_PMC_ERR1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SSIT Single EAM Event Macros. </p>
<p>Enable SSIT Single EAM Event forwarding from Slave SLRs to Master SLR for this specific error interrupt</p>
<ul>
<li>XPLMI_SSIT_SINGLE_EAM_EVENT_ERR_ID is the Error NodeId</li>
<li>XPLMI_SSIT_SINGLE_EAM_EVENT_ERR_MASK is the Error Event Mask</li>
<li>XPLMI_SSIT_SINGLE_EAM_EVENT_ERR_TRIG is the trigger register address</li>
</ul>
<p>On Master SLR, this interrupt will trigger the same error in the local EAM </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga82d211f8f98008e3fb03a2516376e4c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_CheckIpiAccess </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>CmdId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>IpiReqType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the IPI command is accessible or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CmdId</td><td>is the Command ID </td></tr>
    <tr><td class="paramname">IpiReqType</td><td>is the IPI command request type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and XST_FAILURE on failure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CmdId</td><td>is the Command ID </td></tr>
    <tr><td class="paramname">IpiReqType</td><td>is the IPI command request type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success</li>
<li>XST_FAILURE on failure </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xplmi_8h.html#adf6711e85d6a9449675252cf416e470d">XPLMI_CMD_SECURE</a>.</p>

</div>
</div>
<a class="anchor" id="gaa80acce34d3a6858f42b05b8a52df7bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_DefaultSWdtConfig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the default WDT configuration if the wdt is not enabled and ROM SWDT usage bit is enabled in EFUSE. </p>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and error code on failure </dd></dl>

<p>References <a class="el" href="group__xplmi__apis.html#gaf37f68542fdb6d4c42b74ab8862be551">XPlmi_EnableWdt()</a>, <a class="el" href="xplmi__proc_8c.html#a174c4697a5d6684da653761b5fcdc0c6">XPlmi_GetPmcIroFreq()</a>, and <a class="el" href="net_2xplmi__wdt_8c.html#af2177ed5392b42fa1a4bc937a90abbb9">XPLMI_PM_DEV_PMC_WDT</a>.</p>

</div>
</div>
<a class="anchor" id="ga16dfbc95a9bdf0502840e261b8865652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_DmaTransfer </td>
          <td>(</td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides functionality for DMA write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is the destination address </td></tr>
    <tr><td class="paramname">Src</td><td>is the source address </td></tr>
    <tr><td class="paramname">Len</td><td>is the number of words to be transferred </td></tr>
    <tr><td class="paramname">Flags</td><td>is the DMA transfer related flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XPLMI_ERR_UNALIGNED_DMA_XFER if unaligned DMA transfer fails. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xplmi__dma_8c.html#a1b0be0d5fccf58e120aa3d786fd0ddb3">XPlmi_DmaXfr()</a>, and <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a2869c5a80b4a2b931415afe2583ebab2">XPLMI_ERR_UNALIGNED_DMA_XFER</a>.</p>

<p>Referenced by <a class="el" href="group__xplmi__apis.html#ga79ea148da2b84189d2d8d01c4592f59c">XPlmi_MoveProc()</a>, and <a class="el" href="group__xplmi__apis.html#gaf8878d25485f7e85643a90933ed37e67">XPlmi_PsmSequence()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf37f68542fdb6d4c42b74ab8862be551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_EnableWdt </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>NodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Periodicity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the WDT and sets NodeId and periodicity. </p>
<pre class="fragment">            It also verifies the parameters.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NodeId</td><td>NodeId is the MIO node to be used by PLM for toggling. </td></tr>
    <tr><td class="paramname">Periodicity</td><td>at which MIO value should be toggled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if success.</li>
<li>XPLMI_ERR_WDT_PERIODICITY on invalid Periodicity.</li>
<li>XPLMI_ERR_WDT_LPD_NOT_INITIALIZED if LPD is not initialized.</li>
<li>XPLMI_ERR_WDT_NODE_ID on invalid node ID.</li>
</ul>
</dd></dl>
<pre class="fragment">            It also verifies the parameters.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NodeId</td><td>NodeId is the MIO node to be used by PLM for toggling. </td></tr>
    <tr><td class="paramname">Periodicity</td><td>at which MIO value should be toggled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if success.</li>
<li>XPLMI_ERR_WDT_PERIODICITY on invalid Periodicity.</li>
<li>XPLMI_ERR_PMC_WDT_NOT_ENABLED if PMC WDT is tried use and it is not enabled in design.</li>
<li>XPLMI_ERR_PMC_WDT_DRV_INIT if PMC WDT driver initialization fails.</li>
<li>XPLMI_ERR_WDT_LPD_NOT_INITIALIZED if LPD is not initialized.</li>
<li>XPLMI_ERR_WDT_NODE_ID on invalid node ID. </li>
</ul>
</dd></dl>
<ul>
<li>Check for Valid Node ID</li>
</ul>
<p>Check for Valid Node ID </p>

<p>References <a class="el" href="xplmi_8h.html#a2da9f028be145a4f17852a4d3eb7898f">LPD_WDT_INITIALIZED</a>, <a class="el" href="net_2xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a9bd588b46199bb9db79c7ea4b330b40d">XPLMI_ERR_PMC_WDT_DRV_INIT</a>, <a class="el" href="net_2xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3abc3d4e69232b3912c6cb0f2be0e9922b">XPLMI_ERR_PMC_WDT_NOT_ENABLED</a>, <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a7639e8ca8278bee32b86c32e3eb0701d">XPLMI_ERR_WDT_LPD_NOT_INITIALIZED</a>, <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a85adec0c1a68eac5059e7a636db81edc">XPLMI_ERR_WDT_NODE_ID</a>, <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3aa930119634e74a1b7da35a5126eafaaf">XPLMI_ERR_WDT_PERIODICITY</a>, <a class="el" href="net_2xplmi__wdt_8c.html#a4fe46ba3dac6e3b6193ce517e61c55bd">XPLMI_MIO_NUM_PER_BANK</a>, <a class="el" href="net_2xplmi__wdt_8c.html#af2177ed5392b42fa1a4bc937a90abbb9">XPLMI_PM_DEV_PMC_WDT</a>, <a class="el" href="net_2xplmi__wdt_8c.html#a4362c318cfc21cb8bd9954d3544698e5">XPLMI_PM_STMIC_LMIO_0</a>, <a class="el" href="net_2xplmi__wdt_8c.html#ad3b2c3a348035801e77d0fcc4f5251ff">XPLMI_PM_STMIC_LMIO_25</a>, <a class="el" href="net_2xplmi__wdt_8c.html#af57d921006ec568207d4a173e061a85e">XPLMI_PM_STMIC_PMIO_0</a>, <a class="el" href="net_2xplmi__wdt_8c.html#a1b99c20342284aa02741921212f3fb4f">XPLMI_PM_STMIC_PMIO_51</a>, <a class="el" href="xplmi_8c.html#a4eb444b49ce4a70d9cda587bddafada9">XPlmi_SetLpdInitialized()</a>, <a class="el" href="net_2xplmi__wdt_8c.html#a78c579f1af43fffa792adef2f246e098">XPLMI_SPP_WDT_PERIODICITY_MIN</a>, <a class="el" href="net_2xplmi__wdt_8c.html#a5d8cbcc3b768b671d9d962e23b290c79">XPLMI_WDT_PERIODICITY_MAX</a>, and <a class="el" href="net_2xplmi__wdt_8c.html#a93dca420dde8557945784982956d7547">XPLMI_WDT_PERIODICITY_MIN</a>.</p>

<p>Referenced by <a class="el" href="group__xplmi__apis.html#gaa80acce34d3a6858f42b05b8a52df7bd">XPlmi_DefaultSWdtConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf48d925ddd447c3e5b00eab9f221429b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_EventLogging </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides Event Logging command execution. </p>
<pre class="fragment">    Command payload parameters are
    Sub command
    1 - Configure print log level
            Arg1 - Log Level
    2 - Configure Debug Log buffer memory
            Arg1 - High Address
            Arg2 - Low Address
            Arg3 - Length
    3 - Retrieve Debug Log buffer
            Arg1 - High Address
            Arg2 - Low Address
    4 - Retrieve Debug Log buffer information
    5 - Configure Trace Log buffer memory
            Arg1 - High Address
            Arg2 - Low Address
            Arg3 - Length
    6 - Retrieve Trace Log buffer
            Arg1 - High Address
            Arg2 - Low Address
    7 - Retrieve Trace Log buffer information
    8 - Configure Uart
            Arg1 - Uart Select
            Arg2 - Uart Enable
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XPLMI_ERR_INVALID_LOG_LEVEL on invalid log level.</li>
<li>XST_INVALID_PARAM on invalid logging command. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xplmi__debug_8c.html#a51cdb30d3f7194a797cbe30886428a9b">XPlmi_ConfigUart()</a>, <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a7466fdb1702f55644534e57cd36d8be4">XPLMI_ERR_INVALID_LOG_LEVEL</a>, and <a class="el" href="xplmi__plat_8c.html#a7b1237961b575e4f2942d8f749c09f5c">XPlmi_GetTraceLogInst()</a>.</p>

</div>
</div>
<a class="anchor" id="ga053bc9806bfc10856b7617c75da2a864"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_ExecuteProc </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ProcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides functionality to execute given ProcId when request to execute a particular ProcId. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ProcId</td><td>is ProcId to be executed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XPLMI_ERR_PROC_LPD_NOT_INITIALIZED if LPD failed to initialize.</li>
<li>XPLMI_PROCID_NOT_VALID on invalid Proc ID. </li>
</ul>
</dd></dl>
<ul>
<li>If the ProcId has MSB set, then its in PMC RAM memory.</li>
<li>If LPD is not initialized or Proc memory is not available, do not execute the proc and return an error.</li>
<li>Execute proc if the received ProcId is valid.</li>
<li>Pass the Proc CDO to CDO parser.</li>
<li>Fill ProcCdo structure with Proc related parameters.</li>
<li>Execute Proc. </li>
</ul>

<p>References <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a37417435e36928413a5b8a5b4fafe9b7">XPLMI_ERR_PROC_LPD_NOT_INITIALIZED</a>, <a class="el" href="group__xplmi__apis.html#gaf5a3680a8c996865c6e87c4a44669973">XPlmi_GetProcList()</a>, <a class="el" href="xplmi__dma_8c.html#aeb1672e944604b6ba1345fd59858961a">XPlmi_MemSetBytes()</a>, <a class="el" href="xplmi__cdo_8c.html#aaa4e2fe96baa321cd17c045bffb049b5">XPlmi_ProcessCdo()</a>, and <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3af9f8038c2a9f87bbf60dc1cce5a7e853">XPLMI_PROCID_NOT_VALID</a>.</p>

<p>Referenced by <a class="el" href="xplmi__err_8h.html#a713bdac07b25c74467015744419d1f2b">XPlmi_HandleLinkDownError()</a>, and <a class="el" href="net_2xplmi__err_8h.html#abbe778fcdba9267e9a02ece17cd6eb28">XPlmi_HandleLinkUpEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5a3680a8c996865c6e87c4a44669973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XPlmi_ProcList* XPlmi_GetProcList </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>ProcListType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function defines ProcList and returns the address of the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ProcListType</td><td>is the proc list type if it is stored in PMC or PSM RAM</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ProcList is the address of ProcList structure </dd></dl>
<ul>
<li>Create static ProcList structure and initialize with zero during initial call.</li>
<li>Initialize first ProcData address of the PmcProcList to the PMC RAM reserved address and ProcMemSize with the Max Size allocated</li>
</ul>

<p>Referenced by <a class="el" href="group__xplmi__apis.html#ga053bc9806bfc10856b7617c75da2a864">XPlmi_ExecuteProc()</a>, <a class="el" href="group__xplmi__apis.html#gaf8878d25485f7e85643a90933ed37e67">XPlmi_PsmSequence()</a>, and <a class="el" href="group__xplmi__apis.html#ga697a0b26b0197bbcca5e075f4cd1f765">XPlmi_SetProcList()</a>.</p>

</div>
</div>
<a class="anchor" id="ga873411286b21b899a8a6782b9b0a6b1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XPlmi_GetSlavesSlrMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the combined mask of all slave SLRs. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns combined mask of all slave SLRs </dd></dl>

</div>
</div>
<a class="anchor" id="ga0060d3f27c5c714f99941cd06d0142d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XPlmi_GetSlrIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the local SLR index. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns Local SLR index </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ddc1de78adaa52322685bd933f588e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_InPlacePlmUpdate </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides In Place PLM Update support. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure Command payload parameters are<ul>
<li>High Addr</li>
<li>Low Addr</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xplmi__update_8c.html#aaadab5133cb40cbaa1113c26036ca0e3">XPlmi_PlmUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga55d8d2bbe4d87840df7d3b40d42355af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XPlmi_KickWdt </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>NodeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to kick the WDT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NodeId</td><td>is the Node ID of external WDT or internal PMC WDT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga79ea148da2b84189d2d8d01c4592f59c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_MoveProc </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>ProcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XPlmi_ProcList *&#160;</td>
          <td class="paramname"><em>ProcList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides functionality to move procs when proc command is received for existing ProcId. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ProcIndex</td><td>is the index of ProcId to be moved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure </li>
</ul>
</dd></dl>
<ul>
<li>If only one proc is available and if a new proc command is received with same ID, it can directly be overwritten.</li>
<li>If proc command is received for existing ProcId, move all procs behind this to front</li>
<li>Call XPlmi_DmaTransfer with flags DMA0 and INCR</li>
<li>Update ProcList with moved data </li>
</ul>

<p>References <a class="el" href="group__xplmi__apis.html#ga16dfbc95a9bdf0502840e261b8865652">XPlmi_DmaTransfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8878d25485f7e85643a90933ed37e67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_PsmSequence </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to transfer all psm_sequence commands to PSM RAM regions which are then processed by PSM immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is a pointer to command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if success.</li>
<li>XPLMI_ERR_PROC_LPD_NOT_INITIALIZED if failed to initialize LPD.</li>
<li>XPLMI_UNSUPPORTED_PROC_LENGTH if received proc does not fit in the proc memory. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__xplmi__apis.html#ga16dfbc95a9bdf0502840e261b8865652">XPlmi_DmaTransfer()</a>, <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a37417435e36928413a5b8a5b4fafe9b7">XPLMI_ERR_PROC_LPD_NOT_INITIALIZED</a>, <a class="el" href="group__xplmi__apis.html#gaf5a3680a8c996865c6e87c4a44669973">XPlmi_GetProcList()</a>, <a class="el" href="net_2xplmi__plat_8h.html#ae424b112a6de4a0b30aea99b25fd4345">XPLMI_PSM_SEQUENCE_CMD_ID</a>, and <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a72b8fb7d68dc34c5f2e6e4616f21a51e">XPLMI_UNSUPPORTED_PROC_LENGTH</a>.</p>

</div>
</div>
<a class="anchor" id="gac4eadfbcae0dd8a8d8872640a32744b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XPlmi_RestoreWdt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to restore wdt after the In-Place PLM Update. </p>

<p>Referenced by <a class="el" href="net_2xplmi__plat_8c.html#a4d05007b07e69ed4471ee801451b3141">XPlmi_PreInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c8aea8817f7523f8e19f5b8f2712234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_ScatterWrite </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will write single 32 bit value to multiple addresses which are specified in the payload. </p>
<pre class="fragment">            Command payload parameters are
            - Value
            - Address[N]: array of N addresses
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if success.</li>
<li>XPLMI_ERR_INVALID_PAYLOAD_LEN on invalid payload length. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a93ab94741c638b0862654ee27fe1e7b1">XPLMI_ERR_INVALID_PAYLOAD_LEN</a>, <a class="el" href="xplmi__debug_8c.html#a2b28c3907e83a63bf43adaa1f5a545e9">XPlmi_Print()</a>, and <a class="el" href="group__xplmi__apis.html#gaf98c00816801677a601071bf085c85df">XPLMI_SCATTER_WRITE_PAYLOAD_LEN</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e1cdb534edb8282728567c27ed02bc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_ScatterWrite2 </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will write 2 32-bit values to multiple addresses which are specified by the payload. </p>
<pre class="fragment">            Command payload parameters are
            - Value1
                    - Value2
            - Address[N]: array of N addresses
            where Address[i] = Value1 and Address[i] + 4 = Value2
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if success.</li>
<li>XPLMI_ERR_INVALID_PAYLOAD_LEN on invalid payload length. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a93ab94741c638b0862654ee27fe1e7b1">XPLMI_ERR_INVALID_PAYLOAD_LEN</a>, <a class="el" href="xplmi__debug_8c.html#a2b28c3907e83a63bf43adaa1f5a545e9">XPlmi_Print()</a>, and <a class="el" href="group__xplmi__apis.html#ga397480c245b3cdca2b2d6e99ff197cee">XPLMI_SCATTER_WRITE2_PAYLOAD_LEN</a>.</p>

</div>
</div>
<a class="anchor" id="ga09694a4b8467a90ed7afdda529d5f721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SendIpiCmdToSlaveSlr </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>Payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>RespBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles invalid commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Payload</td><td>holds the inputs of the slaves </td></tr>
    <tr><td class="paramname">RespBuf</td><td>Stores the response of the slaves</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XPLMI_ERR_CMD_APIID on unregistered command ID.</li>
<li>XPLMI_SSIT_INTR_NOT_ENABLED if interrupts are not enabled. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a60d83e4808e366a70f784c43c35da87b">XPLMI_ERR_CMD_APIID</a>, <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a4591a2e587480c03265730ac90a2f21f">XPLMI_SSIT_INTR_NOT_ENABLED</a>, <a class="el" href="xplmi__plat_8h.html#af7150452d8d587d941948d7aa96b42b6">XPLMI_SSIT_MONOLITIC</a>, and <a class="el" href="group__xplmi__apis.html#gafd7eb4ca501aab712353daf78cfb4863">XPlmi_SsitSendMsgEventAndGetResp()</a>.</p>

</div>
</div>
<a class="anchor" id="ga30cbe0eeabc180d930a709179f8a2801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SetFipsKatMask </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will store the KAT mask set by the user so that PLM can monitor the RTCA and compare it with KAT masks before going into FIPS operational state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if success.</li>
<li>XPLMI_ERR_INVALID_PAYLOAD_LEN on invalid payload length. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="net_2xplmi__plat_8c.html#a45c3c8d152ab4449a53105b5ddfef2f8">XPlmi_CheckAndUpdateFipsState()</a>, <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3a93ab94741c638b0862654ee27fe1e7b1">XPLMI_ERR_INVALID_PAYLOAD_LEN</a>, <a class="el" href="group__xplmi__apis.html#ga219705f95bebd92b02253f067b573f88">XPLMI_FIPS_WRITE_KATMASK_PAYLOAD_LEN</a>, <a class="el" href="net_2xplmi__plat_8c.html#adbfe941b26a0c7c29dad3cde1672b3ca">XPlmi_GetFipsKatMaskInstance()</a>, <a class="el" href="net_2xplmi__plat_8h.html#a5f0e868170b5439cca330a084da91a6e">XPLMI_HNIC_CPM5N_PCIDE_KAT_MASK</a>, <a class="el" href="xplmi__plat_8h.html#a014e46fa04f789c7a66bd1916bae6d87">XPLMI_KAT_MASK</a>, <a class="el" href="net_2xplmi__plat_8h.html#ad39e256ff690c0be572158a3c877aee8">XPLMI_PKI_KAT_MASK</a>, <a class="el" href="xplmi__debug_8c.html#a2b28c3907e83a63bf43adaa1f5a545e9">XPlmi_Print()</a>, and <a class="el" href="xplmi__plat_8h.html#a0dcbd77f0bc65ccf175514d2684adea4">XPLMI_ROM_KAT_MASK</a>.</p>

</div>
</div>
<a class="anchor" id="ga697a0b26b0197bbcca5e075f4cd1f765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SetProcList </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets PSM ProcList address to given Address and Size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Address</td><td>is the address of Proc reserved memory for PSM ProcList </td></tr>
    <tr><td class="paramname">Size</td><td>is the size of Proc reserved memory for PSM ProcList in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure</li>
<li>XPLMI_ERR_PROC_INVALID_ADDRESS_RANGE if provided proc address is invalid. </li>
</ul>
</dd></dl>
<ul>
<li>Validate the allocated memory address range. Otherwise return an error.</li>
<li>Initialize first ProcData address of PSM ProcList to the given Address and ProcMemSize with the given Size</li>
</ul>

<p>References <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3af3c29ffbdc05b1f66066f1fa38f2a5d3">XPLMI_ERR_PROC_INVALID_ADDRESS_RANGE</a>, <a class="el" href="group__xplmi__apis.html#gaf5a3680a8c996865c6e87c4a44669973">XPlmi_GetProcList()</a>, and <a class="el" href="xplmi__plat_8c.html#a25824586eac02fce773e27974c0ab87d">XPlmi_VerifyAddrRange()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e27e5bd43606860f63a38572f4821bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitAcknowledgeEvent </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EventIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to acknowledge the event after handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SlrIndex</td><td>is index of the SLR for which the event was triggered </td></tr>
    <tr><td class="paramname">EventIndex</td><td>is the event to acknowledge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2e76ea091646d92e7a0482e67602b86f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XPlmi_SsitGetSlrAddr </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlrIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the global SLR address for the given local address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Address</td><td>is the local address for which the global SLR address need to be calculated </td></tr>
    <tr><td class="paramname">SlrIndex</td><td>is the index of the SLR for which the address need to be calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns 0x0 for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5ef6b32fe8a4519644b90ca780397e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitReadEventBuffer </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>ReqBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ReqBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the event buffer of Master SLR in Slave SLRs where the message event is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ReqBuf</td><td>is the buffer to which the event buffer data to be written </td></tr>
    <tr><td class="paramname">ReqBufSize</td><td>is the size of the ReqBuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gacadf5fc2d6cee12eac80dfec967c2c3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitReadResponse </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>RespBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>RespBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the response (if applicable) in Master SLR once the event is acknowledged by Slave SLR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SlrIndex</td><td>is the SLR index from the response need to be read </td></tr>
    <tr><td class="paramname">RespBuf</td><td>is the Response Buffer to where the response to be written </td></tr>
    <tr><td class="paramname">RespBufSize</td><td>is the size of the response buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf7ceffb7348ed1c37af238f02df63905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitRegisterEvent </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EventIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XPlmi_EventHandler_t&#160;</td>
          <td class="paramname"><em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>EventOrigin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to register any event between Master and Slave SLRs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EventIndex</td><td>is the Index of the event to be registered </td></tr>
    <tr><td class="paramname">Handler</td><td>is the handler to be executed when this Event occurs </td></tr>
    <tr><td class="paramname">EventOrigin</td><td>is the SLR origin which can trigger the event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gafd7eb4ca501aab712353daf78cfb4863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitSendMsgEventAndGetResp </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>ReqBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ReqBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>RespBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>RespBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>WaitForEventCompletion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sends a message event with given request buffer to a slave SLR, waits for event completion, reads the response from the slave SLR and returns it to the caller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SlrIndex</td><td>is the SLR index from which the response need to be read </td></tr>
    <tr><td class="paramname">ReqBuf</td><td>is the buffer to which the event buffer data to be written </td></tr>
    <tr><td class="paramname">ReqBufSize</td><td>is the size of the ReqBuf </td></tr>
    <tr><td class="paramname">RespBuf</td><td>is the Response Buffer to where the response to be written </td></tr>
    <tr><td class="paramname">RespBufSize</td><td>is the size of the response buffer </td></tr>
    <tr><td class="paramname">WaitForEventCompletion</td><td>is the maximum time to wait before the requested message event is handled by a slave SLR [in microseconds]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

<p>Referenced by <a class="el" href="group__xplmi__apis.html#ga09694a4b8467a90ed7afdda529d5f721">XPlmi_SendIpiCmdToSlaveSlr()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf24bb1ce85073deed1339422ee5d915f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitSyncMaster </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides SSIT Sync Master command execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the Status of SSIT Sync Master command </dd></dl>
<ul>
<li>Initiate synchronization to PLM running on master SLR</li>
<li>Wait for Master SLR to reach synchronization point</li>
<li>Complete synchronization from slave</li>
<li>Clear existing status to know the actual status from Master SLR </li>
</ul>

<p>References <a class="el" href="xplmi__plat_8h.html#a87db74c2941db56d04925ceea68ad5b5">XPLMI_SSIT_SYNC_MASTER_CMD_ID</a>, and <a class="el" href="xplmi__util_8c.html#aa6f19eeebb4a42d17f8e2f62b01b0080">XPlmi_UtilRMW()</a>.</p>

</div>
</div>
<a class="anchor" id="gad6d0e16deb820f98b18689dc9966f3ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitSyncSlaves </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides SSIT Sync Slaves command execution. </p>
<pre class="fragment">            Command payload parameters are
                    * Slaves Mask
                    * Timeout
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns the Status of SSIT Sync Slaves command</li>
<li>XPLMI_ERR_SSIT_SLAVE_SYNC if master timedout on slave sync. </li>
</ul>
</dd></dl>
<ul>
<li>Wait until all Slaves initiate synchronization point.</li>
<li>Acknowledge synchronization.</li>
<li>Clear existing status to know the actual status from Slave SLRs.</li>
<li>If the timeout is exceeded, return an error code.</li>
<li>De-assert synchronization acknowledgement from master. </li>
</ul>

<p>References <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3abab859474788188c34e50ac8b707d27f">XPLMI_ERR_SSIT_SLAVE_SYNC</a>, <a class="el" href="xplmi__wdt_8c.html#aa4a47c5570d5ee0c85d80d71d4b66b28">XPlmi_SetPlmLiveStatus()</a>, and <a class="el" href="xplmi__plat_8h.html#ae8fb58230b573f14f434ce48e7957300">XPLMI_SSIT_SYNC_SLAVES_CMD_ID</a>.</p>

</div>
</div>
<a class="anchor" id="gae5d1464d41ef967f174542299449cad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitTriggerEvent </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EventIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to trigger the given event to the given SLR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SlrIndex</td><td>is the index of the SLR to which the event to be triggered </td></tr>
    <tr><td class="paramname">EventIndex</td><td>is the Index of the event to be triggered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga510deac0c8054dc5352bcd297e48dac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitWaitForEvent </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>EventIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>TimeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to wait for the event to be acknowledged by the given SLR after triggering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SlrIndex</td><td>is the SLR index where the event is triggered </td></tr>
    <tr><td class="paramname">EventIndex</td><td>is the Index of the event triggered </td></tr>
    <tr><td class="paramname">TimeOut</td><td>is the timeout in us to wait for the acknowledgment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5cb88dc15cd3354f65b346c3e92c2d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitWaitSlaves </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides SSIT Wait Slaves command execution. </p>
<pre class="fragment">                     Command payload parameters are
                    * Slaves Mask
                    * Timeout
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns the Status of SSIT Wait Slaves command</li>
<li>XPLMI_ERR_SSIT_SLAVE_SYNC if master timedout on slave sync. </li>
</ul>
</dd></dl>
<ul>
<li>Clear any existing SSIT errors in PMC_ERR1_STATUS register.</li>
<li>Wait until all Slaves initiate synchronization point.</li>
<li>If the timeout is exceeded, return an error code. </li>
</ul>

<p>References <a class="el" href="xplmi__status_8h.html#a2e39b3b0824b1911dafde398ea02b6d3abab859474788188c34e50ac8b707d27f">XPLMI_ERR_SSIT_SLAVE_SYNC</a>, <a class="el" href="xplmi__wdt_8c.html#aa4a47c5570d5ee0c85d80d71d4b66b28">XPlmi_SetPlmLiveStatus()</a>, and <a class="el" href="xplmi__plat_8h.html#a708063660b8e1d38b4ccf40af1ba21fc">XPLMI_SSIT_WAIT_SLAVES_CMD_ID</a>.</p>

</div>
</div>
<a class="anchor" id="gae07fd84a364236b869b74f56a55a1f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitWriteEventBufferAndTriggerMsgEvent </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlrIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>ReqBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ReqBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to write the event buffer data and trigger the Message Event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SlrIndex</td><td>is the index of the SLR to which the event buffer need to be written </td></tr>
    <tr><td class="paramname">ReqBuf</td><td>is the buffer from where the event buffer data to be written to Slave SLRs event buffer </td></tr>
    <tr><td class="paramname">ReqBufSize</td><td>is the size of the ReqBuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2475d6e57ee465119b1bb88bd17c0588"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_SsitWriteResponseAndAckMsgEvent </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>RespBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>RespBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to write the response (if applicable) in Slave SLR once the event is handled and acknowledge the message event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RespBuf</td><td>is the Response Buffer data to be written </td></tr>
    <tr><td class="paramname">RespBufSize</td><td>is the size of the response buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns XST_SUCCESS for non-SSIT designs </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa331a666f6dbd1e7a908327e3898a11d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XPlmi_StopWdt </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>NodeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops PMC WDT. </p>
<p>Used during In-Place PLM update.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NodeId</td><td>is the Node ID of external WDT or internal PMC WDT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga9043da48baf45f46f01c4b0086cd2f14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XPlmi_ValidateCmd </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ModuleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ApiId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the Cmd passed is supported via IPI mechanism or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ModuleId</td><td>is the module ID </td></tr>
    <tr><td class="paramname">ApiId</td><td>is the API ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and XST_FAILURE on failure</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ModuleId</td><td>is the module ID </td></tr>
    <tr><td class="paramname">ApiId</td><td>is the API ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success</li>
<li>XST_FAILURE on failure </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__xplmi__apis.html#gae76c9c65d8ab797fcf9c07586372ab57">XPLMI_PLM_GENERIC_PLMUPDATE</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga6edba9664412089e967ac22af1c7d79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XPlmi_EventHandler_t XPlmi_SsitEvents_t::EventHandler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event handler. </p>

</div>
</div>
<a class="anchor" id="ga0c73dba6f2d5451ba20a3c0f2f49d6ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XPlmi_SsitEvents_t::EventOrigin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event orgin. </p>

</div>
</div>
<a class="anchor" id="ga254ed570fd434f05f81b810349f1d592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XPlmi_SsitEvents_t XPlmi_SsitEventStruct_t::Events[XPLMI_SSIT_MAX_EVENTS]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of SSIT maximum events. </p>

</div>
</div>
<a class="anchor" id="ga64129a720ca64e4f1cf1ed9279cce00f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XPlmi_SsitEventVectorTable_t::Events32[XPLMI_SSIT_MAX_EVENT32_INDEX]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of SSIT maximum events 32. </p>

</div>
</div>
<a class="anchor" id="gad7a99bb8c59d5e636fe29d75e6d252a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XPlmi_SsitEventStruct_t::IsIntrEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interruput enable status check. </p>

</div>
</div>
<a class="anchor" id="ga1bf81f6416476f36f307c68bf1cc7a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XPlmi_SsitEventStruct_t::SlavesMask</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slaves mask. </p>

</div>
</div>
<a class="anchor" id="gaa80bc1243f0687c76d2c09130d5e4cd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XPlmi_SsitEventStruct_t::SlrIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slr index. </p>

</div>
</div>
<a class="anchor" id="ga17a730be6cee9cabcbf2686d6463d543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XPlmi_TaskNode* XPlmi_SsitEventStruct_t::Task1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task1 pointer to the TaskNode structure. </p>

</div>
</div>
<a class="anchor" id="ga914cfb7bb11e85c2ee58482fcd8f68f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XPlmi_TaskNode* XPlmi_SsitEventStruct_t::Task2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task2 pointer to the TaskNode structure. </p>

</div>
</div>
<a class="anchor" id="gac7e911f5d96e634fa2094792c130bf9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XPlmi_TaskNode* XPlmi_SsitEventStruct_t::Task3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task3 pointer to the TaskNode structure. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
