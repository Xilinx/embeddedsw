<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>xilloader: XilLoader Server APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">xilloader
   </div>
   <div id="projectbrief">Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__xloader__server__apis.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">XilLoader Server APIs</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1e7b2ae49b2f41294ba3e4c7403df20b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga1e7b2ae49b2f41294ba3e4c7403df20b">XLOADER_IMAGE_INFO_TBL_MAX_NUM</a></td></tr>
<tr class="memdesc:ga1e7b2ae49b2f41294ba3e4c7403df20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of image info tables in the available buffer.  <a href="#ga1e7b2ae49b2f41294ba3e4c7403df20b">More...</a><br/></td></tr>
<tr class="separator:ga1e7b2ae49b2f41294ba3e4c7403df20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb9479f179f61feb1b1368cbe99e562"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaaeb9479f179f61feb1b1368cbe99e562">XLOADER_PCR_MEASUREMENT_INDEX_MASK</a>&#160;&#160;&#160;(0xFFFF0000U)</td></tr>
<tr class="memdesc:gaaeb9479f179f61feb1b1368cbe99e562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for PCR Measurement index.  <a href="#gaaeb9479f179f61feb1b1368cbe99e562">More...</a><br/></td></tr>
<tr class="separator:gaaeb9479f179f61feb1b1368cbe99e562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e43af745222cb78f6a71853c891183"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gab5e43af745222cb78f6a71853c891183">XLOADER_RSA_PSS_MSB_PADDING_MASK</a>&#160;&#160;&#160;(u8)(0x80U)</td></tr>
<tr class="memdesc:gab5e43af745222cb78f6a71853c891183"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA PSS MSB padding mask.  <a href="#gab5e43af745222cb78f6a71853c891183">More...</a><br/></td></tr>
<tr class="separator:gab5e43af745222cb78f6a71853c891183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ac029ac7965b392e6bb0097876fd94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga98ac029ac7965b392e6bb0097876fd94">XLOADER_RSA_EM_MSB_INDEX</a>&#160;&#160;&#160;(0x0U)</td></tr>
<tr class="memdesc:ga98ac029ac7965b392e6bb0097876fd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSA EM MSB Index.  <a href="#ga98ac029ac7965b392e6bb0097876fd94">More...</a><br/></td></tr>
<tr class="separator:ga98ac029ac7965b392e6bb0097876fd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad372ad8e543134647457ddfd18128ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaad372ad8e543134647457ddfd18128ab">XLOADER_PUF_SHUT_GLB_VAR_FLTR_EN_SHIFT</a>&#160;&#160;&#160;(31U)</td></tr>
<tr class="memdesc:gaad372ad8e543134647457ddfd18128ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift for Global Variation Filter in PUF shutter value.  <a href="#gaad372ad8e543134647457ddfd18128ab">More...</a><br/></td></tr>
<tr class="separator:gaad372ad8e543134647457ddfd18128ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37451d47afb1549cfd45ae1c5947d579"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga37451d47afb1549cfd45ae1c5947d579">XLOADER_AES_RESET_VAL</a>&#160;&#160;&#160;(0x1U)</td></tr>
<tr class="memdesc:ga37451d47afb1549cfd45ae1c5947d579"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES Reset value.  <a href="#ga37451d47afb1549cfd45ae1c5947d579">More...</a><br/></td></tr>
<tr class="separator:ga37451d47afb1549cfd45ae1c5947d579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d874ef5d60f3bba3fe7e580e2335b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga05d874ef5d60f3bba3fe7e580e2335b4">XLOADER_AES_RESET_REG</a>&#160;&#160;&#160;(0xF11E0010U)</td></tr>
<tr class="memdesc:ga05d874ef5d60f3bba3fe7e580e2335b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">AES Reset register address.  <a href="#ga05d874ef5d60f3bba3fe7e580e2335b4">More...</a><br/></td></tr>
<tr class="separator:ga05d874ef5d60f3bba3fe7e580e2335b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c9cd6721e418777842ed226fedcb2c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga8c9cd6721e418777842ed226fedcb2c8">XLOADER_ECDSA_RSA_RESET_REG</a>&#160;&#160;&#160;(0xF1200040U)</td></tr>
<tr class="memdesc:ga8c9cd6721e418777842ed226fedcb2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDSA RSA Reset register address.  <a href="#ga8c9cd6721e418777842ed226fedcb2c8">More...</a><br/></td></tr>
<tr class="separator:ga8c9cd6721e418777842ed226fedcb2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8095884006d0bdec587bc2e15157bf33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga8095884006d0bdec587bc2e15157bf33">XLOADER_ECDSA_RSA_RESET_VAL</a>&#160;&#160;&#160;(0x1U)</td></tr>
<tr class="memdesc:ga8095884006d0bdec587bc2e15157bf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDSA RSA Reset value.  <a href="#ga8095884006d0bdec587bc2e15157bf33">More...</a><br/></td></tr>
<tr class="separator:ga8095884006d0bdec587bc2e15157bf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga670aed828759635178d1bac15da2fd91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga670aed828759635178d1bac15da2fd91">XLOADER_GET_PRTN_HASH_INDEX</a>(PdiPtr)</td></tr>
<tr class="memdesc:ga670aed828759635178d1bac15da2fd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partition hash index depending on full/partial PDI.  <a href="#ga670aed828759635178d1bac15da2fd91">More...</a><br/></td></tr>
<tr class="separator:ga670aed828759635178d1bac15da2fd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf062051d3fb77de1a64d1c59099d39de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaf062051d3fb77de1a64d1c59099d39de">CFRAME_BCAST_REG_TESTMODE_OFFSET</a>&#160;&#160;&#160;(0x120U)</td></tr>
<tr class="memdesc:gaf062051d3fb77de1a64d1c59099d39de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test mode offset.  <a href="#gaf062051d3fb77de1a64d1c59099d39de">More...</a><br/></td></tr>
<tr class="separator:gaf062051d3fb77de1a64d1c59099d39de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cb237f68a9fc494cb17b1e4c78a71e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4cb237f68a9fc494cb17b1e4c78a71e1">CFRAME_BCAST_REG_TESTMODE_CRAM_SELF_CHECK_MASK</a>&#160;&#160;&#160;(0x100U)</td></tr>
<tr class="memdesc:ga4cb237f68a9fc494cb17b1e4c78a71e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRAM self check mask.  <a href="#ga4cb237f68a9fc494cb17b1e4c78a71e1">More...</a><br/></td></tr>
<tr class="separator:ga4cb237f68a9fc494cb17b1e4c78a71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad043b6b35eb2a61501ee7d2b7d2dac35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gad043b6b35eb2a61501ee7d2b7d2dac35">CFRAME_BCAST_REG_FAR_OFFSET</a>&#160;&#160;&#160;(0x10U)</td></tr>
<tr class="memdesc:gad043b6b35eb2a61501ee7d2b7d2dac35"><td class="mdescLeft">&#160;</td><td class="mdescRight">CFrame address register offset.  <a href="#gad043b6b35eb2a61501ee7d2b7d2dac35">More...</a><br/></td></tr>
<tr class="separator:gad043b6b35eb2a61501ee7d2b7d2dac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecec768f7aa5f3c9bdbb23ca2f79af31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaecec768f7aa5f3c9bdbb23ca2f79af31">CFRAME_BCAST_REG_FAR_BLOCKTYPE_SHIFT</a>&#160;&#160;&#160;(20U)</td></tr>
<tr class="memdesc:gaecec768f7aa5f3c9bdbb23ca2f79af31"><td class="mdescLeft">&#160;</td><td class="mdescRight">CFrame address register block type shift.  <a href="#gaecec768f7aa5f3c9bdbb23ca2f79af31">More...</a><br/></td></tr>
<tr class="separator:gaecec768f7aa5f3c9bdbb23ca2f79af31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e70988fc31bef75378289d76c871ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga17e70988fc31bef75378289d76c871ac">CFRAME_MAX_BLOCK_TYPE_COUNT</a>&#160;&#160;&#160;(0x3U)</td></tr>
<tr class="memdesc:ga17e70988fc31bef75378289d76c871ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">CFrame maximum block type count.  <a href="#ga17e70988fc31bef75378289d76c871ac">More...</a><br/></td></tr>
<tr class="separator:ga17e70988fc31bef75378289d76c871ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae2a99f34bb1f1b102eaaac9ee1dd21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4ae2a99f34bb1f1b102eaaac9ee1dd21">XPLMI_ZERO</a>&#160;&#160;&#160;(0x0U)</td></tr>
<tr class="memdesc:ga4ae2a99f34bb1f1b102eaaac9ee1dd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero.  <a href="#ga4ae2a99f34bb1f1b102eaaac9ee1dd21">More...</a><br/></td></tr>
<tr class="separator:ga4ae2a99f34bb1f1b102eaaac9ee1dd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad74c706747e37822e8d9a5524cc341ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gad74c706747e37822e8d9a5524cc341ea">CFRAME_CRC_POLL_TIMEOUT</a>&#160;&#160;&#160;(0xFFFFU)</td></tr>
<tr class="memdesc:gad74c706747e37822e8d9a5524cc341ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC poll time out.  <a href="#gad74c706747e37822e8d9a5524cc341ea">More...</a><br/></td></tr>
<tr class="separator:gad74c706747e37822e8d9a5524cc341ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8baed59f0b542201eae4c147aad4e686"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga8baed59f0b542201eae4c147aad4e686">XLOADER_CFRAME_DATACLEAR_CHECK_CMD_ID</a>&#160;&#160;&#160;(0xCU)</td></tr>
<tr class="memdesc:ga8baed59f0b542201eae4c147aad4e686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data clear check command Id.  <a href="#ga8baed59f0b542201eae4c147aad4e686">More...</a><br/></td></tr>
<tr class="separator:ga8baed59f0b542201eae4c147aad4e686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891205248039898c45e6ba5b3cce1d60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga891205248039898c45e6ba5b3cce1d60">PMC_GLOBAL_PMC_ERR2_STATUS_CFI_SHIFT</a>&#160;&#160;&#160;(16U)</td></tr>
<tr class="memdesc:ga891205248039898c45e6ba5b3cce1d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">CFI Non-Correctable Error shift.  <a href="#ga891205248039898c45e6ba5b3cce1d60">More...</a><br/></td></tr>
<tr class="separator:ga891205248039898c45e6ba5b3cce1d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ffba6e00178b279c6c2e8f162408cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga08ffba6e00178b279c6c2e8f162408cb">XLOADER_SBI_DELAY_IN_MICROSEC</a>&#160;&#160;&#160;(5000U)</td></tr>
<tr class="memdesc:ga08ffba6e00178b279c6c2e8f162408cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicates SBI delay in micro second.  <a href="#ga08ffba6e00178b279c6c2e8f162408cb">More...</a><br/></td></tr>
<tr class="separator:ga08ffba6e00178b279c6c2e8f162408cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90289e1764cf2d23465bfe018e6b5f84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga90289e1764cf2d23465bfe018e6b5f84">XLOADER_LOG_LEVEL_MASK</a>&#160;&#160;&#160;(0xF0U)</td></tr>
<tr class="memdesc:ga90289e1764cf2d23465bfe018e6b5f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicates Log level mask.  <a href="#ga90289e1764cf2d23465bfe018e6b5f84">More...</a><br/></td></tr>
<tr class="separator:ga90289e1764cf2d23465bfe018e6b5f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2649fc63e039d0ea257ceb1706063594"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga2649fc63e039d0ea257ceb1706063594">XLOADER_SUCCESS_NOT_PRTN_OWNER</a>&#160;&#160;&#160;(0x100U)</td></tr>
<tr class="memdesc:ga2649fc63e039d0ea257ceb1706063594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that PLM is not the partition owner.  <a href="#ga2649fc63e039d0ea257ceb1706063594">More...</a><br/></td></tr>
<tr class="separator:ga2649fc63e039d0ea257ceb1706063594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eba70b7be10245a53f4834b514bcb7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4eba70b7be10245a53f4834b514bcb7e">XLOADER_BOOT_COPY_OPTIMIZATION_ENABLED</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga4eba70b7be10245a53f4834b514bcb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates Boot Device Copy Optimization is Enabled.  <a href="#ga4eba70b7be10245a53f4834b514bcb7e">More...</a><br/></td></tr>
<tr class="separator:ga4eba70b7be10245a53f4834b514bcb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ad484f4b4344573008a1fa138ad597"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gae1ad484f4b4344573008a1fa138ad597">XLOADER_SHA3_RESET_REG</a>&#160;&#160;&#160;(0xF1210004U)</td></tr>
<tr class="memdesc:gae1ad484f4b4344573008a1fa138ad597"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA3 Reset register address.  <a href="#gae1ad484f4b4344573008a1fa138ad597">More...</a><br/></td></tr>
<tr class="separator:gae1ad484f4b4344573008a1fa138ad597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a802ef19167e4a011890ac7bf61f7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga18a802ef19167e4a011890ac7bf61f7d">XLOADER_SHA3_RESET_VAL</a>&#160;&#160;&#160;(0x1U)</td></tr>
<tr class="memdesc:ga18a802ef19167e4a011890ac7bf61f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA3 Reset value.  <a href="#ga18a802ef19167e4a011890ac7bf61f7d">More...</a><br/></td></tr>
<tr class="separator:ga18a802ef19167e4a011890ac7bf61f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb8da78a452c3524858aa626b6a91797"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gafb8da78a452c3524858aa626b6a91797">XLOADER_TCM_0</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gafb8da78a452c3524858aa626b6a91797"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCM 0.  <a href="#gafb8da78a452c3524858aa626b6a91797">More...</a><br/></td></tr>
<tr class="separator:gafb8da78a452c3524858aa626b6a91797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7aac7aa870f5c4290d6ad101dbfe39d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gac7aac7aa870f5c4290d6ad101dbfe39d">XLOADER_TCM_1</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gac7aac7aa870f5c4290d6ad101dbfe39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCM 1.  <a href="#gac7aac7aa870f5c4290d6ad101dbfe39d">More...</a><br/></td></tr>
<tr class="separator:gac7aac7aa870f5c4290d6ad101dbfe39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc35282335ca2e17f74dd302d034667"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gabdc35282335ca2e17f74dd302d034667">XLOADER_RPU_GLBL_CNTL</a>&#160;&#160;&#160;(0xFF9A0000U)</td></tr>
<tr class="memdesc:gabdc35282335ca2e17f74dd302d034667"><td class="mdescLeft">&#160;</td><td class="mdescRight">RPU global control.  <a href="#gabdc35282335ca2e17f74dd302d034667">More...</a><br/></td></tr>
<tr class="separator:gabdc35282335ca2e17f74dd302d034667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690701a566a217bfc9daf80efdaa1602"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga690701a566a217bfc9daf80efdaa1602">XLOADER_TCMCOMB_MASK</a>&#160;&#160;&#160;(0x40U)</td></tr>
<tr class="memdesc:ga690701a566a217bfc9daf80efdaa1602"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCM combine mask.  <a href="#ga690701a566a217bfc9daf80efdaa1602">More...</a><br/></td></tr>
<tr class="separator:ga690701a566a217bfc9daf80efdaa1602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad403a72b35f69de5a924f73a3508d354"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gad403a72b35f69de5a924f73a3508d354">XLOADER_TCMCOMB_SHIFT</a>&#160;&#160;&#160;(6U)</td></tr>
<tr class="memdesc:gad403a72b35f69de5a924f73a3508d354"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCM combine shift.  <a href="#gad403a72b35f69de5a924f73a3508d354">More...</a><br/></td></tr>
<tr class="separator:gad403a72b35f69de5a924f73a3508d354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c00225c89279d31e9ee223214a95e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga01c00225c89279d31e9ee223214a95e4">PLM_VP1802_POR_SETTLE_TIME</a>&#160;&#160;&#160;(25000U)</td></tr>
<tr class="memdesc:ga01c00225c89279d31e9ee223214a95e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicates POR settle time for VP1802.  <a href="#ga01c00225c89279d31e9ee223214a95e4">More...</a><br/></td></tr>
<tr class="separator:ga01c00225c89279d31e9ee223214a95e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b029f8eb41a438e0a2851c15a0055a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4b029f8eb41a438e0a2851c15a0055a0">XLOADER_IMAGE_INFO_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga4b029f8eb41a438e0a2851c15a0055a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image version information.  <a href="#ga4b029f8eb41a438e0a2851c15a0055a0">More...</a><br/></td></tr>
<tr class="separator:ga4b029f8eb41a438e0a2851c15a0055a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b010e88b328a818eb02d24852674e8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga9b010e88b328a818eb02d24852674e8e">XLOADER_IMAGE_INFO_LCVERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga9b010e88b328a818eb02d24852674e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image lowest compatible version information.  <a href="#ga9b010e88b328a818eb02d24852674e8e">More...</a><br/></td></tr>
<tr class="separator:ga9b010e88b328a818eb02d24852674e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4fbb00ecf27e811f1e6282caa21c70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaab4fbb00ecf27e811f1e6282caa21c70">XLOADER_PDI_LIST_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gaab4fbb00ecf27e811f1e6282caa21c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">PDI version list.  <a href="#gaab4fbb00ecf27e811f1e6282caa21c70">More...</a><br/></td></tr>
<tr class="separator:gaab4fbb00ecf27e811f1e6282caa21c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc78ce7d57074b011bd80837a7b133a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gacc78ce7d57074b011bd80837a7b133a8">XLOADER_PDI_LIST_LCVERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gacc78ce7d57074b011bd80837a7b133a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PDI lowest compatible version list.  <a href="#gacc78ce7d57074b011bd80837a7b133a8">More...</a><br/></td></tr>
<tr class="separator:gacc78ce7d57074b011bd80837a7b133a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb0c6d91d6ea175ab641751e8cb2d56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga3cb0c6d91d6ea175ab641751e8cb2d56">XLOADER_ATF_HANDOFF_PARAMS_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga3cb0c6d91d6ea175ab641751e8cb2d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATF handoff parameters version.  <a href="#ga3cb0c6d91d6ea175ab641751e8cb2d56">More...</a><br/></td></tr>
<tr class="separator:ga3cb0c6d91d6ea175ab641751e8cb2d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656ec0b30e14c020dbc723daa4275842"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga656ec0b30e14c020dbc723daa4275842">XLOADER_ATF_HANDOFF_PARAMS_LCVERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga656ec0b30e14c020dbc723daa4275842"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATF handoff parameters lowest compatible version.  <a href="#ga656ec0b30e14c020dbc723daa4275842">More...</a><br/></td></tr>
<tr class="separator:ga656ec0b30e14c020dbc723daa4275842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4902a96e0396c283f07058cc576228f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4902a96e0396c283f07058cc576228f9">XLOADER_BOOTPDI_INFO_PARAMS_VERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:ga4902a96e0396c283f07058cc576228f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">BootPDI info version.  <a href="#ga4902a96e0396c283f07058cc576228f9">More...</a><br/></td></tr>
<tr class="separator:ga4902a96e0396c283f07058cc576228f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9435ad99e3e9b2e04e3438dc2db2c3c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga9435ad99e3e9b2e04e3438dc2db2c3c2">XLOADER_BOOTPDI_INFO_PARAMS_LCVERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:ga9435ad99e3e9b2e04e3438dc2db2c3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">BootPDI info lowest compatible version.  <a href="#ga9435ad99e3e9b2e04e3438dc2db2c3c2">More...</a><br/></td></tr>
<tr class="separator:ga9435ad99e3e9b2e04e3438dc2db2c3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga280195c8872446ce29567b7a5dff7486"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga280195c8872446ce29567b7a5dff7486">XLOADER_CMD_GET_DDR_DEVICE_ID</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga280195c8872446ce29567b7a5dff7486"><td class="mdescLeft">&#160;</td><td class="mdescRight">DDR device id.  <a href="#ga280195c8872446ce29567b7a5dff7486">More...</a><br/></td></tr>
<tr class="separator:ga280195c8872446ce29567b7a5dff7486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab68989608ddaae8e60e757fe4261c06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaab68989608ddaae8e60e757fe4261c06">XLOADER_DDR_CRYPTO_MAIN_OFFSET</a>&#160;&#160;&#160;(0X40000U)</td></tr>
<tr class="memdesc:gaab68989608ddaae8e60e757fe4261c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">DDR crypto block offset from ub.  <a href="#gaab68989608ddaae8e60e757fe4261c06">More...</a><br/></td></tr>
<tr class="separator:gaab68989608ddaae8e60e757fe4261c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f25e90d333d2cb81e08b8b0889a9d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga08f25e90d333d2cb81e08b8b0889a9d6">XLOADER_DDR_PERF_MON_CNT0_OFFSET</a>&#160;&#160;&#160;(0X868U)</td></tr>
<tr class="memdesc:ga08f25e90d333d2cb81e08b8b0889a9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter 0 offset.  <a href="#ga08f25e90d333d2cb81e08b8b0889a9d6">More...</a><br/></td></tr>
<tr class="separator:ga08f25e90d333d2cb81e08b8b0889a9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c71f1b4c75ad9161caecb08ef0400a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga98c71f1b4c75ad9161caecb08ef0400a">XLOADER_DDR_PERF_MON_CNT1_OFFSET</a>&#160;&#160;&#160;(0X86CU)</td></tr>
<tr class="memdesc:ga98c71f1b4c75ad9161caecb08ef0400a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter 1 offset.  <a href="#ga98c71f1b4c75ad9161caecb08ef0400a">More...</a><br/></td></tr>
<tr class="separator:ga98c71f1b4c75ad9161caecb08ef0400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee2c86cf56654f376ad72d8132a08d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gadee2c86cf56654f376ad72d8132a08d8">XLOADER_DDR_PERF_MON_CNT2_OFFSET</a>&#160;&#160;&#160;(0X870U)</td></tr>
<tr class="memdesc:gadee2c86cf56654f376ad72d8132a08d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter 2 offset.  <a href="#gadee2c86cf56654f376ad72d8132a08d8">More...</a><br/></td></tr>
<tr class="separator:gadee2c86cf56654f376ad72d8132a08d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ee459f51efdeb7666d9e790e539d36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga66ee459f51efdeb7666d9e790e539d36">XLOADER_DDR_PERF_MON_CNT3_OFFSET</a>&#160;&#160;&#160;(0X874U)</td></tr>
<tr class="memdesc:ga66ee459f51efdeb7666d9e790e539d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter 3 offset.  <a href="#ga66ee459f51efdeb7666d9e790e539d36">More...</a><br/></td></tr>
<tr class="separator:ga66ee459f51efdeb7666d9e790e539d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cce691e196dc2b9637fa0d443517afa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga6cce691e196dc2b9637fa0d443517afa">XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_INDEX</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga6cce691e196dc2b9637fa0d443517afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index in the Payload of ConfigureJtagState command where JTAG state flag is present.  <a href="#ga6cce691e196dc2b9637fa0d443517afa">More...</a><br/></td></tr>
<tr class="separator:ga6cce691e196dc2b9637fa0d443517afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57693974e707c6a48cd7fbabc088e59e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga57693974e707c6a48cd7fbabc088e59e">XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_MASK</a>&#160;&#160;&#160;(0x03U)</td></tr>
<tr class="memdesc:ga57693974e707c6a48cd7fbabc088e59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for JTAG state flag.  <a href="#ga57693974e707c6a48cd7fbabc088e59e">More...</a><br/></td></tr>
<tr class="separator:ga57693974e707c6a48cd7fbabc088e59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d1e34b4e890bfeefe1628bfd7b23bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga52d1e34b4e890bfeefe1628bfd7b23bc">XLOADER_CONFIG_JTAG_STATE_FLAG_ENABLE</a>&#160;&#160;&#160;(0x03U)</td></tr>
<tr class="memdesc:ga52d1e34b4e890bfeefe1628bfd7b23bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of JTAG state flag if enabled.  <a href="#ga52d1e34b4e890bfeefe1628bfd7b23bc">More...</a><br/></td></tr>
<tr class="separator:ga52d1e34b4e890bfeefe1628bfd7b23bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5144bf150041ae57d72cde9f8ee700"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gafd5144bf150041ae57d72cde9f8ee700">XLOADER_CONFIG_JTAG_STATE_FLAG_DISABLE</a>&#160;&#160;&#160;(0x00U)</td></tr>
<tr class="memdesc:gafd5144bf150041ae57d72cde9f8ee700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of JTAG state flag if disabled.  <a href="#gafd5144bf150041ae57d72cde9f8ee700">More...</a><br/></td></tr>
<tr class="separator:gafd5144bf150041ae57d72cde9f8ee700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047cb86e4b5bd655438c68ad0979377e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga047cb86e4b5bd655438c68ad0979377e">XLOADER_EFUSE_OBFUS_KEY</a>&#160;&#160;&#160;(0xA5C3C5A7U)</td></tr>
<tr class="memdesc:ga047cb86e4b5bd655438c68ad0979377e"><td class="mdescLeft">&#160;</td><td class="mdescRight">eFuse obfuscated key  <a href="#ga047cb86e4b5bd655438c68ad0979377e">More...</a><br/></td></tr>
<tr class="separator:ga047cb86e4b5bd655438c68ad0979377e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539d826d2600671de8f64468dce86cb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga539d826d2600671de8f64468dce86cb9">XLOADER_BBRAM_OBFUS_KEY</a>&#160;&#160;&#160;(0x3A5C3C57U)</td></tr>
<tr class="memdesc:ga539d826d2600671de8f64468dce86cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">BBRAM obfuscated key.  <a href="#ga539d826d2600671de8f64468dce86cb9">More...</a><br/></td></tr>
<tr class="separator:ga539d826d2600671de8f64468dce86cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91eeacdb8e0914b1e96182c942d6f95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gad91eeacdb8e0914b1e96182c942d6f95">XLOADER_BH_OBFUS_KEY</a>&#160;&#160;&#160;(0xA35C7CA5U)</td></tr>
<tr class="memdesc:gad91eeacdb8e0914b1e96182c942d6f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot header obfuscated key.  <a href="#gad91eeacdb8e0914b1e96182c942d6f95">More...</a><br/></td></tr>
<tr class="separator:gad91eeacdb8e0914b1e96182c942d6f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b029f8eb41a438e0a2851c15a0055a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4b029f8eb41a438e0a2851c15a0055a0">XLOADER_IMAGE_INFO_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga4b029f8eb41a438e0a2851c15a0055a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image version information.  <a href="#ga4b029f8eb41a438e0a2851c15a0055a0">More...</a><br/></td></tr>
<tr class="separator:ga4b029f8eb41a438e0a2851c15a0055a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b010e88b328a818eb02d24852674e8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga9b010e88b328a818eb02d24852674e8e">XLOADER_IMAGE_INFO_LCVERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga9b010e88b328a818eb02d24852674e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image lowest compatible version information.  <a href="#ga9b010e88b328a818eb02d24852674e8e">More...</a><br/></td></tr>
<tr class="separator:ga9b010e88b328a818eb02d24852674e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4fbb00ecf27e811f1e6282caa21c70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaab4fbb00ecf27e811f1e6282caa21c70">XLOADER_PDI_LIST_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gaab4fbb00ecf27e811f1e6282caa21c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">PDI version list.  <a href="#gaab4fbb00ecf27e811f1e6282caa21c70">More...</a><br/></td></tr>
<tr class="separator:gaab4fbb00ecf27e811f1e6282caa21c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc78ce7d57074b011bd80837a7b133a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gacc78ce7d57074b011bd80837a7b133a8">XLOADER_PDI_LIST_LCVERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gacc78ce7d57074b011bd80837a7b133a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PDI lowest compatible version list.  <a href="#gacc78ce7d57074b011bd80837a7b133a8">More...</a><br/></td></tr>
<tr class="separator:gacc78ce7d57074b011bd80837a7b133a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb0c6d91d6ea175ab641751e8cb2d56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga3cb0c6d91d6ea175ab641751e8cb2d56">XLOADER_ATF_HANDOFF_PARAMS_VERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga3cb0c6d91d6ea175ab641751e8cb2d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATF handoff parameters version.  <a href="#ga3cb0c6d91d6ea175ab641751e8cb2d56">More...</a><br/></td></tr>
<tr class="separator:ga3cb0c6d91d6ea175ab641751e8cb2d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656ec0b30e14c020dbc723daa4275842"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga656ec0b30e14c020dbc723daa4275842">XLOADER_ATF_HANDOFF_PARAMS_LCVERSION</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga656ec0b30e14c020dbc723daa4275842"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATF handoff parameters lowest compatible version.  <a href="#ga656ec0b30e14c020dbc723daa4275842">More...</a><br/></td></tr>
<tr class="separator:ga656ec0b30e14c020dbc723daa4275842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4902a96e0396c283f07058cc576228f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4902a96e0396c283f07058cc576228f9">XLOADER_BOOTPDI_INFO_PARAMS_VERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:ga4902a96e0396c283f07058cc576228f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">BootPDI info version.  <a href="#ga4902a96e0396c283f07058cc576228f9">More...</a><br/></td></tr>
<tr class="separator:ga4902a96e0396c283f07058cc576228f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9435ad99e3e9b2e04e3438dc2db2c3c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga9435ad99e3e9b2e04e3438dc2db2c3c2">XLOADER_BOOTPDI_INFO_PARAMS_LCVERSION</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:ga9435ad99e3e9b2e04e3438dc2db2c3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">BootPDI info lowest compatible version.  <a href="#ga9435ad99e3e9b2e04e3438dc2db2c3c2">More...</a><br/></td></tr>
<tr class="separator:ga9435ad99e3e9b2e04e3438dc2db2c3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga280195c8872446ce29567b7a5dff7486"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga280195c8872446ce29567b7a5dff7486">XLOADER_CMD_GET_DDR_DEVICE_ID</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga280195c8872446ce29567b7a5dff7486"><td class="mdescLeft">&#160;</td><td class="mdescRight">DDR device id.  <a href="#ga280195c8872446ce29567b7a5dff7486">More...</a><br/></td></tr>
<tr class="separator:ga280195c8872446ce29567b7a5dff7486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab68989608ddaae8e60e757fe4261c06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaab68989608ddaae8e60e757fe4261c06">XLOADER_DDR_CRYPTO_MAIN_OFFSET</a>&#160;&#160;&#160;(0X40000U)</td></tr>
<tr class="memdesc:gaab68989608ddaae8e60e757fe4261c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">DDR crypto block offset from ub.  <a href="#gaab68989608ddaae8e60e757fe4261c06">More...</a><br/></td></tr>
<tr class="separator:gaab68989608ddaae8e60e757fe4261c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f25e90d333d2cb81e08b8b0889a9d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga08f25e90d333d2cb81e08b8b0889a9d6">XLOADER_DDR_PERF_MON_CNT0_OFFSET</a>&#160;&#160;&#160;(0X868U)</td></tr>
<tr class="memdesc:ga08f25e90d333d2cb81e08b8b0889a9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter 0 offset.  <a href="#ga08f25e90d333d2cb81e08b8b0889a9d6">More...</a><br/></td></tr>
<tr class="separator:ga08f25e90d333d2cb81e08b8b0889a9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c71f1b4c75ad9161caecb08ef0400a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga98c71f1b4c75ad9161caecb08ef0400a">XLOADER_DDR_PERF_MON_CNT1_OFFSET</a>&#160;&#160;&#160;(0X86CU)</td></tr>
<tr class="memdesc:ga98c71f1b4c75ad9161caecb08ef0400a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter 1 offset.  <a href="#ga98c71f1b4c75ad9161caecb08ef0400a">More...</a><br/></td></tr>
<tr class="separator:ga98c71f1b4c75ad9161caecb08ef0400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee2c86cf56654f376ad72d8132a08d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gadee2c86cf56654f376ad72d8132a08d8">XLOADER_DDR_PERF_MON_CNT2_OFFSET</a>&#160;&#160;&#160;(0X870U)</td></tr>
<tr class="memdesc:gadee2c86cf56654f376ad72d8132a08d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter 2 offset.  <a href="#gadee2c86cf56654f376ad72d8132a08d8">More...</a><br/></td></tr>
<tr class="separator:gadee2c86cf56654f376ad72d8132a08d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ee459f51efdeb7666d9e790e539d36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga66ee459f51efdeb7666d9e790e539d36">XLOADER_DDR_PERF_MON_CNT3_OFFSET</a>&#160;&#160;&#160;(0X874U)</td></tr>
<tr class="memdesc:ga66ee459f51efdeb7666d9e790e539d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter 3 offset.  <a href="#ga66ee459f51efdeb7666d9e790e539d36">More...</a><br/></td></tr>
<tr class="separator:ga66ee459f51efdeb7666d9e790e539d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cce691e196dc2b9637fa0d443517afa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga6cce691e196dc2b9637fa0d443517afa">XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_INDEX</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga6cce691e196dc2b9637fa0d443517afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index in the Payload of ConfigureJtagState command where JTAG state flag is present.  <a href="#ga6cce691e196dc2b9637fa0d443517afa">More...</a><br/></td></tr>
<tr class="separator:ga6cce691e196dc2b9637fa0d443517afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57693974e707c6a48cd7fbabc088e59e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga57693974e707c6a48cd7fbabc088e59e">XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_MASK</a>&#160;&#160;&#160;(0x03U)</td></tr>
<tr class="memdesc:ga57693974e707c6a48cd7fbabc088e59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for JTAG state flag.  <a href="#ga57693974e707c6a48cd7fbabc088e59e">More...</a><br/></td></tr>
<tr class="separator:ga57693974e707c6a48cd7fbabc088e59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d1e34b4e890bfeefe1628bfd7b23bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga52d1e34b4e890bfeefe1628bfd7b23bc">XLOADER_CONFIG_JTAG_STATE_FLAG_ENABLE</a>&#160;&#160;&#160;(0x03U)</td></tr>
<tr class="memdesc:ga52d1e34b4e890bfeefe1628bfd7b23bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of JTAG state flag if enabled.  <a href="#ga52d1e34b4e890bfeefe1628bfd7b23bc">More...</a><br/></td></tr>
<tr class="separator:ga52d1e34b4e890bfeefe1628bfd7b23bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5144bf150041ae57d72cde9f8ee700"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gafd5144bf150041ae57d72cde9f8ee700">XLOADER_CONFIG_JTAG_STATE_FLAG_DISABLE</a>&#160;&#160;&#160;(0x00U)</td></tr>
<tr class="memdesc:gafd5144bf150041ae57d72cde9f8ee700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of JTAG state flag if disabled.  <a href="#gafd5144bf150041ae57d72cde9f8ee700">More...</a><br/></td></tr>
<tr class="separator:gafd5144bf150041ae57d72cde9f8ee700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951c28272c57cf2ddd983dc451e090f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga951c28272c57cf2ddd983dc451e090f1">XLOADER_EFUSE_ROM_RSVD_OFFSET</a>&#160;&#160;&#160;(0xF1250090U)</td></tr>
<tr class="memdesc:ga951c28272c57cf2ddd983dc451e090f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROM Reserved eFuse cache offset.  <a href="#ga951c28272c57cf2ddd983dc451e090f1">More...</a><br/></td></tr>
<tr class="separator:ga951c28272c57cf2ddd983dc451e090f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa836e407e0fa958e23c0a392f4eb5d22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaa836e407e0fa958e23c0a392f4eb5d22">XLOADER_EFUSE_ROM_RSVD_AUTH_KEYS_TO_HASH_MASK</a>&#160;&#160;&#160;(0x00000200U)</td></tr>
<tr class="memdesc:gaa836e407e0fa958e23c0a392f4eb5d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUTH_KEYS_TO_HASH eFuse bit mask.  <a href="#gaa836e407e0fa958e23c0a392f4eb5d22">More...</a><br/></td></tr>
<tr class="separator:gaa836e407e0fa958e23c0a392f4eb5d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046afb20e36313e56a14baee4f7af1cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga046afb20e36313e56a14baee4f7af1cd">XLOADER_EFUSE_ROM_RSVD_AUTH_KEYS_TO_HASH_SHIFT</a>&#160;&#160;&#160;(9U)</td></tr>
<tr class="memdesc:ga046afb20e36313e56a14baee4f7af1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">AUTH_KEYS_TO_HASH eFuse bit shift.  <a href="#ga046afb20e36313e56a14baee4f7af1cd">More...</a><br/></td></tr>
<tr class="separator:ga046afb20e36313e56a14baee4f7af1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047cb86e4b5bd655438c68ad0979377e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga047cb86e4b5bd655438c68ad0979377e">XLOADER_EFUSE_OBFUS_KEY</a>&#160;&#160;&#160;(0xA5C3C5A7U)</td></tr>
<tr class="memdesc:ga047cb86e4b5bd655438c68ad0979377e"><td class="mdescLeft">&#160;</td><td class="mdescRight">eFuse obfuscated key  <a href="#ga047cb86e4b5bd655438c68ad0979377e">More...</a><br/></td></tr>
<tr class="separator:ga047cb86e4b5bd655438c68ad0979377e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539d826d2600671de8f64468dce86cb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga539d826d2600671de8f64468dce86cb9">XLOADER_BBRAM_OBFUS_KEY</a>&#160;&#160;&#160;(0x3A5C3C57U)</td></tr>
<tr class="memdesc:ga539d826d2600671de8f64468dce86cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">BBRAM obfuscated key.  <a href="#ga539d826d2600671de8f64468dce86cb9">More...</a><br/></td></tr>
<tr class="separator:ga539d826d2600671de8f64468dce86cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91eeacdb8e0914b1e96182c942d6f95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gad91eeacdb8e0914b1e96182c942d6f95">XLOADER_BH_OBFUS_KEY</a>&#160;&#160;&#160;(0xA35C7CA5U)</td></tr>
<tr class="memdesc:gad91eeacdb8e0914b1e96182c942d6f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot header obfuscated key.  <a href="#gad91eeacdb8e0914b1e96182c942d6f95">More...</a><br/></td></tr>
<tr class="separator:gad91eeacdb8e0914b1e96182c942d6f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5aef75ed3205f50c75189b7c46099856"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga5aef75ed3205f50c75189b7c46099856">XLoader_SecureAuthInit</a> (XLoader_SecureParams *SecurePtr, const XilPdi_PrtnHdr *PrtnHdr)</td></tr>
<tr class="memdesc:ga5aef75ed3205f50c75189b7c46099856"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes authentication parameters of XLoader_SecureParams's instance.  <a href="#ga5aef75ed3205f50c75189b7c46099856">More...</a><br/></td></tr>
<tr class="separator:ga5aef75ed3205f50c75189b7c46099856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df696fd17dec50576f817a1cd1f7105"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga9df696fd17dec50576f817a1cd1f7105">XLoader_SecureEncInit</a> (XLoader_SecureParams *SecurePtr, const XilPdi_PrtnHdr *PrtnHdr)</td></tr>
<tr class="memdesc:ga9df696fd17dec50576f817a1cd1f7105"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes encryption parameters of XLoader_SecureParams's instance.  <a href="#ga9df696fd17dec50576f817a1cd1f7105">More...</a><br/></td></tr>
<tr class="separator:ga9df696fd17dec50576f817a1cd1f7105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d852b900fa863fa8719bba0e2699423"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga7d852b900fa863fa8719bba0e2699423">XLoader_SecureValidations</a> (const XLoader_SecureParams *SecurePtr)</td></tr>
<tr class="memdesc:ga7d852b900fa863fa8719bba0e2699423"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if authentication/encryption is compulsory.  <a href="#ga7d852b900fa863fa8719bba0e2699423">More...</a><br/></td></tr>
<tr class="separator:ga7d852b900fa863fa8719bba0e2699423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b3b88f124856db12efa0ce4d6c81d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gac4b3b88f124856db12efa0ce4d6c81d0">XLoader_ReadAndVerifySecureHdrs</a> (XLoader_SecureParams *SecurePtr, XilPdi_MetaHdr *MetaHdr)</td></tr>
<tr class="memdesc:gac4b3b88f124856db12efa0ce4d6c81d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function authenticates and/or decrypts the image headers and partition headers and copies the contents to the corresponding structures.  <a href="#gac4b3b88f124856db12efa0ce4d6c81d0">More...</a><br/></td></tr>
<tr class="separator:gac4b3b88f124856db12efa0ce4d6c81d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be961c2f80c31d661adab83f62ba790"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga6be961c2f80c31d661adab83f62ba790">XLoader_IsPpkValid</a> (<a class="el" href="xloader__auth__enc_8h.html#a85aba33b166080b4874c0f5657589b3e">XLoader_PpkSel</a> PpkSelect, const u8 *PpkHash)</td></tr>
<tr class="memdesc:ga6be961c2f80c31d661adab83f62ba790"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads PPK invalid bits.  <a href="#ga6be961c2f80c31d661adab83f62ba790">More...</a><br/></td></tr>
<tr class="separator:ga6be961c2f80c31d661adab83f62ba790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1549a54ac384c080bcc344843debcf5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga1549a54ac384c080bcc344843debcf5e">XLoader_RsaPssSignVerify</a> (XPmcDma *PmcDmaInstPtr, u8 *MsgHash, XSecure_Rsa *RsaInstPtr, u8 *Signature, u32 KeySize)</td></tr>
<tr class="memdesc:ga1549a54ac384c080bcc344843debcf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function encrypts the RSA signature provided and performs required PSS operations to extract salt and calculates M prime hash and compares with hash obtained from EM.  <a href="#ga1549a54ac384c080bcc344843debcf5e">More...</a><br/></td></tr>
<tr class="separator:ga1549a54ac384c080bcc344843debcf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434f49bc94a9078a86451ac5bde637cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga434f49bc94a9078a86451ac5bde637cc">XLoader_AddAuthJtagToScheduler</a> (void)</td></tr>
<tr class="memdesc:ga434f49bc94a9078a86451ac5bde637cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds periodic checks of the status of Auth JTAG interrupt status to the scheduler.  <a href="#ga434f49bc94a9078a86451ac5bde637cc">More...</a><br/></td></tr>
<tr class="separator:ga434f49bc94a9078a86451ac5bde637cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab0ef6b838c9f3d87f5f6566065938a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga5ab0ef6b838c9f3d87f5f6566065938a">XLoader_CheckAuthJtagIntStatus</a> (void *Arg)</td></tr>
<tr class="memdesc:ga5ab0ef6b838c9f3d87f5f6566065938a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks the status of Auth JTAG interrupt status and it disables the Jtag as per the timeout set by user.  <a href="#ga5ab0ef6b838c9f3d87f5f6566065938a">More...</a><br/></td></tr>
<tr class="separator:ga5ab0ef6b838c9f3d87f5f6566065938a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203aa0ade1430a8a53e7974c0e4eba3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga203aa0ade1430a8a53e7974c0e4eba3c">XLoader_EnableJtag</a> (volatile u32 CfgState)</td></tr>
<tr class="memdesc:ga203aa0ade1430a8a53e7974c0e4eba3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the Jtag.  <a href="#ga203aa0ade1430a8a53e7974c0e4eba3c">More...</a><br/></td></tr>
<tr class="separator:ga203aa0ade1430a8a53e7974c0e4eba3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c758fcaf8c676a9d7fa9de03e6b535"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga53c758fcaf8c676a9d7fa9de03e6b535">XLoader_DisableJtag</a> (void)</td></tr>
<tr class="memdesc:ga53c758fcaf8c676a9d7fa9de03e6b535"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the Jtag.  <a href="#ga53c758fcaf8c676a9d7fa9de03e6b535">More...</a><br/></td></tr>
<tr class="separator:ga53c758fcaf8c676a9d7fa9de03e6b535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f293db863b881993077e17fc892007"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga22f293db863b881993077e17fc892007">XLoader_AuthEncClear</a> (void)</td></tr>
<tr class="memdesc:ga22f293db863b881993077e17fc892007"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to clear secure critical data related to authentication and encryption in case of exceptions.  <a href="#ga22f293db863b881993077e17fc892007">More...</a><br/></td></tr>
<tr class="separator:ga22f293db863b881993077e17fc892007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a415ea9b49abb198cae9ba6f9eb0b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga43a415ea9b49abb198cae9ba6f9eb0b5">XLoader_ClearKatOnPPDI</a> (XilPdi *PdiPtr, u32 PlmKatMask)</td></tr>
<tr class="memdesc:ga43a415ea9b49abb198cae9ba6f9eb0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the KAT status.  <a href="#ga43a415ea9b49abb198cae9ba6f9eb0b5">More...</a><br/></td></tr>
<tr class="separator:ga43a415ea9b49abb198cae9ba6f9eb0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399279fd63d1bed34a886c24c414ee48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga399279fd63d1bed34a886c24c414ee48">XLoader_ClearAesKey</a> (u32 *DecKeySrc)</td></tr>
<tr class="memdesc:ga399279fd63d1bed34a886c24c414ee48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the AES keys when RedKeyClear is set in PMC RAM.  <a href="#ga399279fd63d1bed34a886c24c414ee48">More...</a><br/></td></tr>
<tr class="separator:ga399279fd63d1bed34a886c24c414ee48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa912487046c04b1c90ca418a19ac3e0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaa912487046c04b1c90ca418a19ac3e0d">XLoader_ProcessAuthEncPrtn</a> (XLoader_SecureParams *SecurePtr, u64 DestAddr, u32 BlockSize, u8 Last)</td></tr>
<tr class="memdesc:gaa912487046c04b1c90ca418a19ac3e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs authentication and decryption of the partition.  <a href="#gaa912487046c04b1c90ca418a19ac3e0d">More...</a><br/></td></tr>
<tr class="separator:gaa912487046c04b1c90ca418a19ac3e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb572c209348e5ec41f2e15c92de9c36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gacb572c209348e5ec41f2e15c92de9c36">XLoader_CheckSecureState</a> (u32 RegVal, u32 Var, u32 ExpectedValue)</td></tr>
<tr class="memdesc:gacb572c209348e5ec41f2e15c92de9c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the secure state of boot matches the expected value or not.  <a href="#gacb572c209348e5ec41f2e15c92de9c36">More...</a><br/></td></tr>
<tr class="separator:gacb572c209348e5ec41f2e15c92de9c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677a618842a76cb8ee935fd0e5bd18fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga677a618842a76cb8ee935fd0e5bd18fa">XLoader_ImgHdrTblAuth</a> (XLoader_SecureParams *SecurePtr)</td></tr>
<tr class="memdesc:ga677a618842a76cb8ee935fd0e5bd18fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function authenticates the image header table.  <a href="#ga677a618842a76cb8ee935fd0e5bd18fa">More...</a><br/></td></tr>
<tr class="separator:ga677a618842a76cb8ee935fd0e5bd18fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112597ce43d11195a3d8924eb435254f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga112597ce43d11195a3d8924eb435254f">XLoader_DataAuth</a> (XLoader_SecureParams *SecurePtr, u8 *Hash, u8 *Signature)</td></tr>
<tr class="memdesc:ga112597ce43d11195a3d8924eb435254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function authenticates the data with SPK.  <a href="#ga112597ce43d11195a3d8924eb435254f">More...</a><br/></td></tr>
<tr class="separator:ga112597ce43d11195a3d8924eb435254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953be1ba88ede7dedb1f86081b14f221"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga953be1ba88ede7dedb1f86081b14f221">XLoader_CframeInit</a> (void)</td></tr>
<tr class="memdesc:ga953be1ba88ede7dedb1f86081b14f221"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the Cframe driver.  <a href="#ga953be1ba88ede7dedb1f86081b14f221">More...</a><br/></td></tr>
<tr class="separator:ga953be1ba88ede7dedb1f86081b14f221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389dc49f070aafe94e78fd1009de7038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga389dc49f070aafe94e78fd1009de7038">XLoader_CframeErrorHandler</a> (u32 ImageId)</td></tr>
<tr class="memdesc:ga389dc49f070aafe94e78fd1009de7038"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to check the CFU ISR and PMC_ERR1 and PMC_ERR2 status registers to check for any errors in PL and call corresponding error recovery functions if needed.  <a href="#ga389dc49f070aafe94e78fd1009de7038">More...</a><br/></td></tr>
<tr class="separator:ga389dc49f070aafe94e78fd1009de7038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac94a1020e3745f6791480bf86040a759"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:gac94a1020e3745f6791480bf86040a759"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to check if the Cframe data is cleared or not using CRC method.  <a href="#gac94a1020e3745f6791480bf86040a759">More...</a><br/></td></tr>
<tr class="separator:gac94a1020e3745f6791480bf86040a759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8ea42231382fe5a5a155bd327b15ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaed8ea42231382fe5a5a155bd327b15ff">XLoader_CfiSelectiveRead</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:gaed8ea42231382fe5a5a155bd327b15ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides CFI SELECTIVE READ command execution.  <a href="#gaed8ea42231382fe5a5a155bd327b15ff">More...</a><br/></td></tr>
<tr class="separator:gaed8ea42231382fe5a5a155bd327b15ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df79c2616e31ed2a2060900a4222464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga9df79c2616e31ed2a2060900a4222464">XLoader_DdrInit</a> (u32 DeviceFlags)</td></tr>
<tr class="memdesc:ga9df79c2616e31ed2a2060900a4222464"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to initialize for DDR init.  <a href="#ga9df79c2616e31ed2a2060900a4222464">More...</a><br/></td></tr>
<tr class="separator:ga9df79c2616e31ed2a2060900a4222464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03c18623c76cf0e2f5effddd4b15415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaa03c18623c76cf0e2f5effddd4b15415">XLoader_DdrCopy</a> (u64 SrcAddr, u64 DestAddr, u32 Length, u32 FlagsVal)</td></tr>
<tr class="memdesc:gaa03c18623c76cf0e2f5effddd4b15415"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to copy the data from DDR to destination address.  <a href="#gaa03c18623c76cf0e2f5effddd4b15415">More...</a><br/></td></tr>
<tr class="separator:gaa03c18623c76cf0e2f5effddd4b15415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a4c313af5a0caa20fa13c561ba0f04a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga7a4c313af5a0caa20fa13c561ba0f04a">XLoader_DdrRelease</a> (void)</td></tr>
<tr class="memdesc:ga7a4c313af5a0caa20fa13c561ba0f04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases control of DDR.  <a href="#ga7a4c313af5a0caa20fa13c561ba0f04a">More...</a><br/></td></tr>
<tr class="separator:ga7a4c313af5a0caa20fa13c561ba0f04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb74ee2f2a0e0dcce9bfdae7750bbc14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gacb74ee2f2a0e0dcce9bfdae7750bbc14">XLoader_LoadImagePrtns</a> (XilPdi *PdiPtr)</td></tr>
<tr class="memdesc:gacb74ee2f2a0e0dcce9bfdae7750bbc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the partition.  <a href="#gacb74ee2f2a0e0dcce9bfdae7750bbc14">More...</a><br/></td></tr>
<tr class="separator:gacb74ee2f2a0e0dcce9bfdae7750bbc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629ebb0c55462b5cde87f7e91037b8c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga629ebb0c55462b5cde87f7e91037b8c0">XLoader_PrtnCopy</a> (const XilPdi *PdiPtr, const XLoader_DeviceCopy *DeviceCopy, void *SecureParamsPtr)</td></tr>
<tr class="memdesc:ga629ebb0c55462b5cde87f7e91037b8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies partition data to respective target memories.  <a href="#ga629ebb0c55462b5cde87f7e91037b8c0">More...</a><br/></td></tr>
<tr class="separator:ga629ebb0c55462b5cde87f7e91037b8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9410756c2dbe4b6bd6cdfce81a5bd7fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga9410756c2dbe4b6bd6cdfce81a5bd7fa">XLoader_SecureInit</a> (XLoader_SecureParams *SecurePtr, XilPdi *PdiPtr, u32 PrtnNum)</td></tr>
<tr class="memdesc:ga9410756c2dbe4b6bd6cdfce81a5bd7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes XLoader_SecureParams's instance.  <a href="#ga9410756c2dbe4b6bd6cdfce81a5bd7fa">More...</a><br/></td></tr>
<tr class="separator:ga9410756c2dbe4b6bd6cdfce81a5bd7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04bdca8398a9278a9c382ef66ad42ed9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga04bdca8398a9278a9c382ef66ad42ed9">XLoader_SecureCopy</a> (XLoader_SecureParams *SecurePtr, u64 DestAddr, u32 Size)</td></tr>
<tr class="memdesc:ga04bdca8398a9278a9c382ef66ad42ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads secure non-cdo partitions.  <a href="#ga04bdca8398a9278a9c382ef66ad42ed9">More...</a><br/></td></tr>
<tr class="separator:ga04bdca8398a9278a9c382ef66ad42ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9171035e129091fbaddbc27756381f76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga9171035e129091fbaddbc27756381f76">XLoader_SecureClear</a> (void)</td></tr>
<tr class="memdesc:ga9171035e129091fbaddbc27756381f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to clear secure critical data in case of exceptions.  <a href="#ga9171035e129091fbaddbc27756381f76">More...</a><br/></td></tr>
<tr class="separator:ga9171035e129091fbaddbc27756381f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fdae4e3fe98e871dd93c7cb31ce387"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga88fdae4e3fe98e871dd93c7cb31ce387">XLoader_VerifyHashNUpdateNext</a> (XLoader_SecureParams *SecurePtr, u64 DataAddr, u32 Size, u8 Last)</td></tr>
<tr class="memdesc:ga88fdae4e3fe98e871dd93c7cb31ce387"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates hash and compares with expected hash.  <a href="#ga88fdae4e3fe98e871dd93c7cb31ce387">More...</a><br/></td></tr>
<tr class="separator:ga88fdae4e3fe98e871dd93c7cb31ce387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5054d79a7dcc052ae83d997f183c8779"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga5054d79a7dcc052ae83d997f183c8779">XLoader_SecureChunkCopy</a> (XLoader_SecureParams *SecurePtr, u64 SrcAddr, u8 Last, u32 BlockSize, u32 TotalSize)</td></tr>
<tr class="memdesc:ga5054d79a7dcc052ae83d997f183c8779"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the data from SrcAddr to chunk memory during processing of secure partitions.  <a href="#ga5054d79a7dcc052ae83d997f183c8779">More...</a><br/></td></tr>
<tr class="separator:ga5054d79a7dcc052ae83d997f183c8779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5d053bbf2e5283aac4b2a1e860b44d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4e5d053bbf2e5283aac4b2a1e860b44d">XLoader_CheckNonZeroPpk</a> (void)</td></tr>
<tr class="memdesc:ga4e5d053bbf2e5283aac4b2a1e860b44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if PPK is programmed.  <a href="#ga4e5d053bbf2e5283aac4b2a1e860b44d">More...</a><br/></td></tr>
<tr class="separator:ga4e5d053bbf2e5283aac4b2a1e860b44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e99458db1239a8f1bcb70eee9025232"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga3e99458db1239a8f1bcb70eee9025232">XLoader_GetAHWRoT</a> (const u32 *AHWRoTPtr)</td></tr>
<tr class="memdesc:ga3e99458db1239a8f1bcb70eee9025232"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the state of authenticated boot.  <a href="#ga3e99458db1239a8f1bcb70eee9025232">More...</a><br/></td></tr>
<tr class="separator:ga3e99458db1239a8f1bcb70eee9025232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d4a7f2cecd7b051a5418ad7586cac3"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga27d4a7f2cecd7b051a5418ad7586cac3">XLoader_GetSHWRoT</a> (const u32 *SHWRoTPtr)</td></tr>
<tr class="memdesc:ga27d4a7f2cecd7b051a5418ad7586cac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the state of encrypted boot.  <a href="#ga27d4a7f2cecd7b051a5418ad7586cac3">More...</a><br/></td></tr>
<tr class="separator:ga27d4a7f2cecd7b051a5418ad7586cac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade5fc1ce6a279c921672d5692df5cf56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gade5fc1ce6a279c921672d5692df5cf56">XLoader_SetSecureState</a> (void)</td></tr>
<tr class="memdesc:gade5fc1ce6a279c921672d5692df5cf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the value of PPK efuse bits, DEC only efuse bits and fields in bootheader and accordingly sets the Secure State of boot.  <a href="#gade5fc1ce6a279c921672d5692df5cf56">More...</a><br/></td></tr>
<tr class="separator:gade5fc1ce6a279c921672d5692df5cf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31df7acaead3af0dfa1735979d3cee12"><td class="memItemLeft" align="right" valign="top">XLoader_SecureTempParams *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga31df7acaead3af0dfa1735979d3cee12">XLoader_GetTempParams</a> (void)</td></tr>
<tr class="memdesc:ga31df7acaead3af0dfa1735979d3cee12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the pointer to XLoader_SecureTempParams.  <a href="#ga31df7acaead3af0dfa1735979d3cee12">More...</a><br/></td></tr>
<tr class="separator:ga31df7acaead3af0dfa1735979d3cee12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8bc92d0322ebe706e0642274395c092"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gac8bc92d0322ebe706e0642274395c092">XLoader_GetKekSrc</a> (void)</td></tr>
<tr class="memdesc:gac8bc92d0322ebe706e0642274395c092"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates KEK red key availability status from boot header.  <a href="#gac8bc92d0322ebe706e0642274395c092">More...</a><br/></td></tr>
<tr class="separator:gac8bc92d0322ebe706e0642274395c092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67aad6fd596b7f1b30b91ae303531984"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga67aad6fd596b7f1b30b91ae303531984">XLoader_AesObfusKeySelect</a> (u32 PdiKeySrc, u32 DecKeyMask, void *KeySrcPtr)</td></tr>
<tr class="memdesc:ga67aad6fd596b7f1b30b91ae303531984"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides Obfuscated Aes Key source.  <a href="#ga67aad6fd596b7f1b30b91ae303531984">More...</a><br/></td></tr>
<tr class="separator:ga67aad6fd596b7f1b30b91ae303531984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa62422fdc9b21c619499f950bc07bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga7aa62422fdc9b21c619499f950bc07bf">XLoader_RsaKat</a> (XPmcDma *PmcDmaPtr)</td></tr>
<tr class="memdesc:ga7aa62422fdc9b21c619499f950bc07bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function runs the KAT for RSA.  <a href="#ga7aa62422fdc9b21c619499f950bc07bf">More...</a><br/></td></tr>
<tr class="separator:ga7aa62422fdc9b21c619499f950bc07bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12304b3fe7be1b2e0831cda984875428"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga12304b3fe7be1b2e0831cda984875428">XLoader_MaskGenFunc</a> (XSecure_Sha3 *Sha3InstancePtr, u8 *Out, u32 OutLen, u8 *Input)</td></tr>
<tr class="memdesc:ga12304b3fe7be1b2e0831cda984875428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask generation function with SHA3.  <a href="#ga12304b3fe7be1b2e0831cda984875428">More...</a><br/></td></tr>
<tr class="separator:ga12304b3fe7be1b2e0831cda984875428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257b3dbbc96ac1826e77aca54f99693c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga257b3dbbc96ac1826e77aca54f99693c">XLoader_IsAdditionalPpkValid</a> (const u8 *PpkHash)</td></tr>
<tr class="memdesc:ga257b3dbbc96ac1826e77aca54f99693c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function verifies whether the additional PPK is valid.  <a href="#ga257b3dbbc96ac1826e77aca54f99693c">More...</a><br/></td></tr>
<tr class="separator:ga257b3dbbc96ac1826e77aca54f99693c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f284fd6c101bd12f2c987bad6d3fead"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga1f284fd6c101bd12f2c987bad6d3fead">XLoader_AdditionalPpkSelect</a> (<a class="el" href="xloader__auth__enc_8h.html#a85aba33b166080b4874c0f5657589b3e">XLoader_PpkSel</a> PpkSelect, u32 *InvalidMask, u32 *PpkOffset)</td></tr>
<tr class="memdesc:ga1f284fd6c101bd12f2c987bad6d3fead"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks for the additional PPK select and returns the PPK invalid mask and PPK efuse cache start offset if PPK is valid.  <a href="#ga1f284fd6c101bd12f2c987bad6d3fead">More...</a><br/></td></tr>
<tr class="separator:ga1f284fd6c101bd12f2c987bad6d3fead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab971c3f4e75170b57d1f5fdcd51cc092"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gab971c3f4e75170b57d1f5fdcd51cc092">XLoader_CheckSecureStateAuth</a> (volatile u32 *AHWRoT)</td></tr>
<tr class="memdesc:gab971c3f4e75170b57d1f5fdcd51cc092"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks Secure State for Authentication.  <a href="#gab971c3f4e75170b57d1f5fdcd51cc092">More...</a><br/></td></tr>
<tr class="separator:gab971c3f4e75170b57d1f5fdcd51cc092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a50858612ed6ece8fff88a67b9f30ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga5a50858612ed6ece8fff88a67b9f30ec">XLoader_MbPmcI2cHandshake</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:ga5a50858612ed6ece8fff88a67b9f30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parse the handshake command request coming from MB and calls the function for handshake process.  <a href="#ga5a50858612ed6ece8fff88a67b9f30ec">More...</a><br/></td></tr>
<tr class="separator:ga5a50858612ed6ece8fff88a67b9f30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331850d019d28f888cfa3499be80529d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga331850d019d28f888cfa3499be80529d">XLoader_AddDeviceStateChangeToScheduler</a> (void)</td></tr>
<tr class="memdesc:ga331850d019d28f888cfa3499be80529d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds periodic checks of the device status change during secure boot.  <a href="#ga331850d019d28f888cfa3499be80529d">More...</a><br/></td></tr>
<tr class="separator:ga331850d019d28f888cfa3499be80529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53a30d478b54d5ef349ca169085eb7b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga53a30d478b54d5ef349ca169085eb7b8">XLoader_CheckDeviceStateChange</a> (void *Arg)</td></tr>
<tr class="memdesc:ga53a30d478b54d5ef349ca169085eb7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks the JTAG device state change.  <a href="#ga53a30d478b54d5ef349ca169085eb7b8">More...</a><br/></td></tr>
<tr class="separator:ga53a30d478b54d5ef349ca169085eb7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab224d645e2c390ff06c8aec01babcae0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gab224d645e2c390ff06c8aec01babcae0">XLoader_MaskGenFunc</a> (XSecure_Sha *ShaInstancePtr, u8 *Out, u32 OutLen, u8 *Input)</td></tr>
<tr class="memdesc:gab224d645e2c390ff06c8aec01babcae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask generation function with SHA3.  <a href="#gab224d645e2c390ff06c8aec01babcae0">More...</a><br/></td></tr>
<tr class="separator:gab224d645e2c390ff06c8aec01babcae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647a935c43dcde43b8f4c308764fbd6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga647a935c43dcde43b8f4c308764fbd6d">XLoader_UpdateCfgLimitCount</a> (u32 UpdateFlag)</td></tr>
<tr class="memdesc:ga647a935c43dcde43b8f4c308764fbd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the configuration limiter count if Configuration limiter feature is enabled in case of secure boot.  <a href="#ga647a935c43dcde43b8f4c308764fbd6d">More...</a><br/></td></tr>
<tr class="separator:ga647a935c43dcde43b8f4c308764fbd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1cdd4fc9cc85230700e3650a3ed49ee2"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga1cdd4fc9cc85230700e3650a3ed49ee2">XLoader_AuthJtagStatus::JtagTimeOut</a></td></tr>
<tr class="memdesc:ga1cdd4fc9cc85230700e3650a3ed49ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout value set by user.  <a href="#ga1cdd4fc9cc85230700e3650a3ed49ee2">More...</a><br/></td></tr>
<tr class="separator:ga1cdd4fc9cc85230700e3650a3ed49ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369516f479da2d39dde2e936226ab71e"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga369516f479da2d39dde2e936226ab71e">XLoader_AuthJtagStatus::JtagTimerEnabled</a></td></tr>
<tr class="memdesc:ga369516f479da2d39dde2e936226ab71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable JTAG timer.  <a href="#ga369516f479da2d39dde2e936226ab71e">More...</a><br/></td></tr>
<tr class="separator:ga369516f479da2d39dde2e936226ab71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6102b4e4351f8aad6295633297a003a2"><td class="memItemLeft" align="right" valign="top">volatile u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga6102b4e4351f8aad6295633297a003a2">XLoader_AuthJtagStatus::AuthFailCounter</a></td></tr>
<tr class="memdesc:ga6102b4e4351f8aad6295633297a003a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for failed attempts to authenticate JTAG.  <a href="#ga6102b4e4351f8aad6295633297a003a2">More...</a><br/></td></tr>
<tr class="separator:ga6102b4e4351f8aad6295633297a003a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33cc0865fab2d4910de17341df9ee27a"><td class="memItemLeft" align="right" valign="top">volatile u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga33cc0865fab2d4910de17341df9ee27a">XLoader_AuthJtagStatus::AuthFailCounterTmp</a></td></tr>
<tr class="memdesc:ga33cc0865fab2d4910de17341df9ee27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For temporal redundancy.  <a href="#ga33cc0865fab2d4910de17341df9ee27a">More...</a><br/></td></tr>
<tr class="separator:ga33cc0865fab2d4910de17341df9ee27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb10f2e97fecfb15aae4fed081b02502"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gacb10f2e97fecfb15aae4fed081b02502">XLoader_Init</a> (void)</td></tr>
<tr class="memdesc:gacb10f2e97fecfb15aae4fed081b02502"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the loader instance and registers loader commands with PLM.  <a href="#gacb10f2e97fecfb15aae4fed081b02502">More...</a><br/></td></tr>
<tr class="separator:gacb10f2e97fecfb15aae4fed081b02502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc121bcc59feb4ece3c40802d81987b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaadc121bcc59feb4ece3c40802d81987b">XLoader_PdiInit</a> (XilPdi *PdiPtr, <a class="el" href="xloader_8h.html#a1b158ce0f453a76bb3cf394a719e1828">PdiSrc_t</a> PdiSource, u64 PdiAddr)</td></tr>
<tr class="memdesc:gaadc121bcc59feb4ece3c40802d81987b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the PDI instance with required details and read the meta header.  <a href="#gaadc121bcc59feb4ece3c40802d81987b">More...</a><br/></td></tr>
<tr class="separator:gaadc121bcc59feb4ece3c40802d81987b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8493673eccf135010606bf9449bc5ee4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga8493673eccf135010606bf9449bc5ee4">XLoader_LoadPdi</a> (XilPdi *PdiPtr, <a class="el" href="xloader_8h.html#a1b158ce0f453a76bb3cf394a719e1828">PdiSrc_t</a> PdiSrc, u64 PdiAddr)</td></tr>
<tr class="memdesc:ga8493673eccf135010606bf9449bc5ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides loading PDI.  <a href="#ga8493673eccf135010606bf9449bc5ee4">More...</a><br/></td></tr>
<tr class="separator:ga8493673eccf135010606bf9449bc5ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1174525d720931317820d083d51efdd7"><td class="memItemLeft" align="right" valign="top">XLoader_ImageInfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga1174525d720931317820d083d51efdd7">XLoader_GetImageInfoEntry</a> (u32 ImgID)</td></tr>
<tr class="memdesc:ga1174525d720931317820d083d51efdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the ImageInfoEntry by checking if an entry exists for that particular ImgId in the ImgInfoTbl.  <a href="#ga1174525d720931317820d083d51efdd7">More...</a><br/></td></tr>
<tr class="separator:ga1174525d720931317820d083d51efdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga304b923a96834575c1fee9eed2ffb870"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga304b923a96834575c1fee9eed2ffb870">XLoader_LoadImageInfoTbl</a> (u64 DestAddr, u32 MaxSize, u32 *NumEntries)</td></tr>
<tr class="memdesc:ga304b923a96834575c1fee9eed2ffb870"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads the ImageInfo table to the given memory address.  <a href="#ga304b923a96834575c1fee9eed2ffb870">More...</a><br/></td></tr>
<tr class="separator:ga304b923a96834575c1fee9eed2ffb870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443aaeef586ee9cefe8509092d99ca17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga443aaeef586ee9cefe8509092d99ca17">XLoader_LoadImage</a> (XilPdi *PdiPtr)</td></tr>
<tr class="memdesc:ga443aaeef586ee9cefe8509092d99ca17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used load a image in PDI.  <a href="#ga443aaeef586ee9cefe8509092d99ca17">More...</a><br/></td></tr>
<tr class="separator:ga443aaeef586ee9cefe8509092d99ca17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbbecc3b2545a3e076d421f086715e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga3dbbecc3b2545a3e076d421f086715e6">XLoader_RestartImage</a> (u32 ImageId, u32 *FuncID)</td></tr>
<tr class="memdesc:ga3dbbecc3b2545a3e076d421f086715e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to restart the image in PDI.  <a href="#ga3dbbecc3b2545a3e076d421f086715e6">More...</a><br/></td></tr>
<tr class="separator:ga3dbbecc3b2545a3e076d421f086715e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168d5df4c9c896833846a6fcc9693451"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga168d5df4c9c896833846a6fcc9693451">XLoader_IdCodeCheck</a> (const XilPdi_ImgHdrTbl *ImgHdrTbl)</td></tr>
<tr class="memdesc:ga168d5df4c9c896833846a6fcc9693451"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the checks of IDCODE and EXTENDED IDCODE.  <a href="#ga168d5df4c9c896833846a6fcc9693451">More...</a><br/></td></tr>
<tr class="separator:ga168d5df4c9c896833846a6fcc9693451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa91a58dad6f9d08c018cbf914f7202c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gafa91a58dad6f9d08c018cbf914f7202c">XLoader_ReadImageStoreCfg</a> (void)</td></tr>
<tr class="memdesc:gafa91a58dad6f9d08c018cbf914f7202c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the Image Store DDR Memory Addr.  <a href="#gafa91a58dad6f9d08c018cbf914f7202c">More...</a><br/></td></tr>
<tr class="separator:gafa91a58dad6f9d08c018cbf914f7202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8122f50322351d61e03c5dd33cf6f635"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga8122f50322351d61e03c5dd33cf6f635">XLoader_IsPdiAddrLookup</a> (u32 PdiId, u64 *PdiAddr)</td></tr>
<tr class="memdesc:ga8122f50322351d61e03c5dd33cf6f635"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read the Address based-on PDI Id from Image Store.  <a href="#ga8122f50322351d61e03c5dd33cf6f635">More...</a><br/></td></tr>
<tr class="separator:ga8122f50322351d61e03c5dd33cf6f635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be2984f0912856671c01e2132da604d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga7be2984f0912856671c01e2132da604d">Xloader_SaveBootPdiInfo</a> (XilPdi *BootPdiPtr)</td></tr>
<tr class="memdesc:ga7be2984f0912856671c01e2132da604d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to save the BootPDI info.  <a href="#ga7be2984f0912856671c01e2132da604d">More...</a><br/></td></tr>
<tr class="separator:ga7be2984f0912856671c01e2132da604d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60991670bc1598b674f3f81d3982caf"><td class="memItemLeft" align="right" valign="top">XilPdi *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaf60991670bc1598b674f3f81d3982caf">XLoader_GetPdiInstance</a> (void)</td></tr>
<tr class="memdesc:gaf60991670bc1598b674f3f81d3982caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides PdiInstance pointer.  <a href="#gaf60991670bc1598b674f3f81d3982caf">More...</a><br/></td></tr>
<tr class="separator:gaf60991670bc1598b674f3f81d3982caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00abb3a6ba0436f171b8a00656d93057"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga00abb3a6ba0436f171b8a00656d93057">XLoader_InitPdiInstanceForExtractMHAndOptData</a> (XPlmi_Cmd *Cmd, XilPdi *PdiPtr, u64 SrcAddr, u64 DestAddr, u32 DestSize)</td></tr>
<tr class="memdesc:ga00abb3a6ba0436f171b8a00656d93057"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes PDI Instance pointer for extracting Metaheader and OptionalData.  <a href="#ga00abb3a6ba0436f171b8a00656d93057">More...</a><br/></td></tr>
<tr class="separator:ga00abb3a6ba0436f171b8a00656d93057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a471be6e3406b3fe9d851c16619847"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga11a471be6e3406b3fe9d851c16619847">XLoader_ClearATFHandoffParams</a> (XilPdi *PdiPtr)</td></tr>
<tr class="memdesc:ga11a471be6e3406b3fe9d851c16619847"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears ATF Handoff parameters in case of multi-partitions in APU subsystem.  <a href="#ga11a471be6e3406b3fe9d851c16619847">More...</a><br/></td></tr>
<tr class="separator:ga11a471be6e3406b3fe9d851c16619847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea4300bb5e4bd5116c3d2bf72902824"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga3ea4300bb5e4bd5116c3d2bf72902824">XLoader_GetImageAndPrtnInfo</a> (XilPdi *PdiPtr, u32 ImageId)</td></tr>
<tr class="memdesc:ga3ea4300bb5e4bd5116c3d2bf72902824"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides Image number and partition number of a given ImgID in the PDI instance.  <a href="#ga3ea4300bb5e4bd5116c3d2bf72902824">More...</a><br/></td></tr>
<tr class="separator:ga3ea4300bb5e4bd5116c3d2bf72902824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee855df9e0b6924472583ce2ed0edf9"><td class="memItemLeft" align="right" valign="top">XLoader_ImageInfoTbl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga8ee855df9e0b6924472583ce2ed0edf9">XLoader_GetImageInfoTbl</a> (void)</td></tr>
<tr class="memdesc:ga8ee855df9e0b6924472583ce2ed0edf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides ImageInfoTbl pointer.  <a href="#ga8ee855df9e0b6924472583ce2ed0edf9">More...</a><br/></td></tr>
<tr class="separator:ga8ee855df9e0b6924472583ce2ed0edf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4719cd0b80cb8626bbd934db116429"><td class="memItemLeft" align="right" valign="top">XLoader_ImageStore *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga3c4719cd0b80cb8626bbd934db116429">XLoader_GetPdiList</a> (void)</td></tr>
<tr class="memdesc:ga3c4719cd0b80cb8626bbd934db116429"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides pointer to PdiList.  <a href="#ga3c4719cd0b80cb8626bbd934db116429">More...</a><br/></td></tr>
<tr class="separator:ga3c4719cd0b80cb8626bbd934db116429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66559b884d7cf9ebdeb4850cc1b32a30"><td class="memItemLeft" align="right" valign="top">XilPdi_ATFHandoffParams *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga66559b884d7cf9ebdeb4850cc1b32a30">XLoader_GetATFHandoffParamsAddr</a> (void)</td></tr>
<tr class="memdesc:ga66559b884d7cf9ebdeb4850cc1b32a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the ATFHandoffParams structure address to the caller.  <a href="#ga66559b884d7cf9ebdeb4850cc1b32a30">More...</a><br/></td></tr>
<tr class="separator:ga66559b884d7cf9ebdeb4850cc1b32a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c3b5e104f9dadbef8b3c59d683bd332"><td class="memItemLeft" align="right" valign="top">XilBootPdiInfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga6c3b5e104f9dadbef8b3c59d683bd332">XLoader_GetBootPdiInfo</a> (void)</td></tr>
<tr class="memdesc:ga6c3b5e104f9dadbef8b3c59d683bd332"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides pointer to BootPDI Info.  <a href="#ga6c3b5e104f9dadbef8b3c59d683bd332">More...</a><br/></td></tr>
<tr class="separator:ga6c3b5e104f9dadbef8b3c59d683bd332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdd3f08598453e93f5b6ce59411c1824"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gabdd3f08598453e93f5b6ce59411c1824">XLoader_StartImage</a> (XilPdi *PdiPtr)</td></tr>
<tr class="memdesc:gabdd3f08598453e93f5b6ce59411c1824"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to start the subsystems in the PDI.  <a href="#gabdd3f08598453e93f5b6ce59411c1824">More...</a><br/></td></tr>
<tr class="separator:gabdd3f08598453e93f5b6ce59411c1824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b1966d6afb00e55785154bac01c8228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga0b1966d6afb00e55785154bac01c8228">XLoader_SetATFHandoffParameters</a> (const XilPdi_PrtnHdr *PrtnHdr)</td></tr>
<tr class="memdesc:ga0b1966d6afb00e55785154bac01c8228"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the handoff parameters to the ARM Trusted Firmware(ATF).  <a href="#ga0b1966d6afb00e55785154bac01c8228">More...</a><br/></td></tr>
<tr class="separator:ga0b1966d6afb00e55785154bac01c8228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c6d50618fcc0ebd51c6790069b5c5cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga3c6d50618fcc0ebd51c6790069b5c5cd">XLoader_SetJtagTapToReset</a> (void)</td></tr>
<tr class="memdesc:ga3c6d50618fcc0ebd51c6790069b5c5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to run MJTAG solution workaround in which JTAG Tap state will be set to reset.  <a href="#ga3c6d50618fcc0ebd51c6790069b5c5cd">More...</a><br/></td></tr>
<tr class="separator:ga3c6d50618fcc0ebd51c6790069b5c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf53860991287c550d874547a0ca021bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaf53860991287c550d874547a0ca021bb">XLoader_GetSDPdiSrcNAddr</a> (u32 SecBootMode, XilPdi *PdiPtr, u32 *PdiSrc, u64 *PdiAddr)</td></tr>
<tr class="memdesc:gaf53860991287c550d874547a0ca021bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get PdiSrc and PdiAddr for Secondary SD boot modes.  <a href="#gaf53860991287c550d874547a0ca021bb">More...</a><br/></td></tr>
<tr class="separator:gaf53860991287c550d874547a0ca021bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee480ef9152cd51e9aabb49fd0515fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf</a> (XilPdi *PdiPtr, const XilPdi_PrtnHdr *PrtnHdr, XLoader_PrtnParams *PrtnParams, XLoader_SecureParams *SecureParams)</td></tr>
<tr class="memdesc:ga4ee480ef9152cd51e9aabb49fd0515fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the elf partitions to specified destinations.  <a href="#ga4ee480ef9152cd51e9aabb49fd0515fd">More...</a><br/></td></tr>
<tr class="separator:ga4ee480ef9152cd51e9aabb49fd0515fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafe5cd1245a7aaf54eb6c3d1a1146578"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gaafe5cd1245a7aaf54eb6c3d1a1146578">XLoader_UpdateHandoffParam</a> (XilPdi *PdiPtr)</td></tr>
<tr class="memdesc:gaafe5cd1245a7aaf54eb6c3d1a1146578"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to update the handoff parameters.  <a href="#gaafe5cd1245a7aaf54eb6c3d1a1146578">More...</a><br/></td></tr>
<tr class="separator:gaafe5cd1245a7aaf54eb6c3d1a1146578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98700d17bfbbf3cf29e418a784745169"><td class="memItemLeft" align="right" valign="top">u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga98700d17bfbbf3cf29e418a784745169">XLoader_SkipMJtagWorkAround</a> (XilPdi *PdiPtr)</td></tr>
<tr class="memdesc:ga98700d17bfbbf3cf29e418a784745169"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if MJTAG workaround partition needs to be skipped.  <a href="#ga98700d17bfbbf3cf29e418a784745169">More...</a><br/></td></tr>
<tr class="separator:ga98700d17bfbbf3cf29e418a784745169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e1b8db2c77863361f3d8802cff6d8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga99e1b8db2c77863361f3d8802cff6d8b">XLoader_ProcessDeferredError</a> (void)</td></tr>
<tr class="memdesc:ga99e1b8db2c77863361f3d8802cff6d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if MJTAG workaround is required.  <a href="#ga99e1b8db2c77863361f3d8802cff6d8b">More...</a><br/></td></tr>
<tr class="separator:ga99e1b8db2c77863361f3d8802cff6d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95eeb47f59afe0b42f06502ee0bd39f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga95eeb47f59afe0b42f06502ee0bd39f9">XLoader_PerformInternalPOR</a> (void)</td></tr>
<tr class="memdesc:ga95eeb47f59afe0b42f06502ee0bd39f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check conditions and perform internal POR for VP1802 and VP1502 device if required.  <a href="#ga95eeb47f59afe0b42f06502ee0bd39f9">More...</a><br/></td></tr>
<tr class="separator:ga95eeb47f59afe0b42f06502ee0bd39f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a9ce1c4ab7abdcba0759e1165c8e57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga56a9ce1c4ab7abdcba0759e1165c8e57">Xloader_SsitEoPdiSync</a> (XilPdi *PdiPtr)</td></tr>
<tr class="memdesc:ga56a9ce1c4ab7abdcba0759e1165c8e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will sync the PDI load status with master if End of PDI SYNC bit is enabled in IHT.  <a href="#ga56a9ce1c4ab7abdcba0759e1165c8e57">More...</a><br/></td></tr>
<tr class="separator:ga56a9ce1c4ab7abdcba0759e1165c8e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga256f3577575dfc0f2b9de5df039a2f2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga256f3577575dfc0f2b9de5df039a2f2d">XLoader_ReadDdrCryptoPerfCounters</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:ga256f3577575dfc0f2b9de5df039a2f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads DDR crypto performance counters of given DDR device id.  <a href="#ga256f3577575dfc0f2b9de5df039a2f2d">More...</a><br/></td></tr>
<tr class="separator:ga256f3577575dfc0f2b9de5df039a2f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36eeb66375a1d833608e9869ac5e8c25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga36eeb66375a1d833608e9869ac5e8c25">XLoader_UpdateHandler</a> (XPlmi_ModuleOp Op)</td></tr>
<tr class="memdesc:ga36eeb66375a1d833608e9869ac5e8c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides update handler for xilloader.  <a href="#ga36eeb66375a1d833608e9869ac5e8c25">More...</a><br/></td></tr>
<tr class="separator:ga36eeb66375a1d833608e9869ac5e8c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7318d4d7ae39a9e258676bbb949341d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga7318d4d7ae39a9e258676bbb949341d0">XLoader_PlatInit</a> (void)</td></tr>
<tr class="memdesc:ga7318d4d7ae39a9e258676bbb949341d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the loader with platform specific initializations.  <a href="#ga7318d4d7ae39a9e258676bbb949341d0">More...</a><br/></td></tr>
<tr class="separator:ga7318d4d7ae39a9e258676bbb949341d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610d38218f6d60c5d6ad9880efa6ad35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga610d38218f6d60c5d6ad9880efa6ad35">XLoader_HdrMeasurement</a> (XilPdi *PdiPtr)</td></tr>
<tr class="memdesc:ga610d38218f6d60c5d6ad9880efa6ad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function measures the PDI's meta header data by calculating the hash using SHA3.  <a href="#ga610d38218f6d60c5d6ad9880efa6ad35">More...</a><br/></td></tr>
<tr class="separator:ga610d38218f6d60c5d6ad9880efa6ad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdd06a059cd7970791f71533c47b8d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gafbdd06a059cd7970791f71533c47b8d6">XLoader_DataMeasurement</a> (XLoader_ImageMeasureInfo *ImageInfo)</td></tr>
<tr class="memdesc:gafbdd06a059cd7970791f71533c47b8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function measures the data by calculating SHA3 hash.  <a href="#gafbdd06a059cd7970791f71533c47b8d6">More...</a><br/></td></tr>
<tr class="separator:gafbdd06a059cd7970791f71533c47b8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac253b7c53e277edd095f79563590c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga5ac253b7c53e277edd095f79563590c4">XLoader_SecureConfigMeasurement</a> (XLoader_SecureParams *SecurePtr, u32 PcrInfo, u32 *DigestIndex, u32 OverWrite)</td></tr>
<tr class="memdesc:ga5ac253b7c53e277edd095f79563590c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function measures the Secure Configuration that is SPK, SPK ID and Encryption Revoke ID and extends to the specified PCR.  <a href="#ga5ac253b7c53e277edd095f79563590c4">More...</a><br/></td></tr>
<tr class="separator:ga5ac253b7c53e277edd095f79563590c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63654b2e9bd794bd9dedfeadd404b109"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga63654b2e9bd794bd9dedfeadd404b109">XLoader_ConfigureJtagState</a> (XPlmi_Cmd *Cmd)</td></tr>
<tr class="memdesc:ga63654b2e9bd794bd9dedfeadd404b109"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables or disable Jtag Access Command payload parameters are.  <a href="#ga63654b2e9bd794bd9dedfeadd404b109">More...</a><br/></td></tr>
<tr class="separator:ga63654b2e9bd794bd9dedfeadd404b109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3082e333a47e4fea07fba25bba8582e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#gad3082e333a47e4fea07fba25bba8582e">XLoader_LoadLpdAndPsmElf</a> ()</td></tr>
<tr class="memdesc:gad3082e333a47e4fea07fba25bba8582e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will load the LPD and PSM ELF file from DDR.  <a href="#gad3082e333a47e4fea07fba25bba8582e">More...</a><br/></td></tr>
<tr class="separator:gad3082e333a47e4fea07fba25bba8582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830f47f91bd5f3b12b41a8e80108017d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xloader__server__apis.html#ga830f47f91bd5f3b12b41a8e80108017d">XLoader_CheckAndUpdateSecureState</a> (void)</td></tr>
<tr class="memdesc:ga830f47f91bd5f3b12b41a8e80108017d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks and updates the secure state configuration.  <a href="#ga830f47f91bd5f3b12b41a8e80108017d">More...</a><br/></td></tr>
<tr class="separator:ga830f47f91bd5f3b12b41a8e80108017d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaecec768f7aa5f3c9bdbb23ca2f79af31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFRAME_BCAST_REG_FAR_BLOCKTYPE_SHIFT&#160;&#160;&#160;(20U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CFrame address register block type shift. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="gad043b6b35eb2a61501ee7d2b7d2dac35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFRAME_BCAST_REG_FAR_OFFSET&#160;&#160;&#160;(0x10U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CFrame address register offset. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4cb237f68a9fc494cb17b1e4c78a71e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFRAME_BCAST_REG_TESTMODE_CRAM_SELF_CHECK_MASK&#160;&#160;&#160;(0x100U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRAM self check mask. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf062051d3fb77de1a64d1c59099d39de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFRAME_BCAST_REG_TESTMODE_OFFSET&#160;&#160;&#160;(0x120U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test mode offset. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="gad74c706747e37822e8d9a5524cc341ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFRAME_CRC_POLL_TIMEOUT&#160;&#160;&#160;(0xFFFFU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRC poll time out. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ga17e70988fc31bef75378289d76c871ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFRAME_MAX_BLOCK_TYPE_COUNT&#160;&#160;&#160;(0x3U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CFrame maximum block type count. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ga01c00225c89279d31e9ee223214a95e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLM_VP1802_POR_SETTLE_TIME&#160;&#160;&#160;(25000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag indicates POR settle time for VP1802. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga95eeb47f59afe0b42f06502ee0bd39f9">XLoader_PerformInternalPOR()</a>.</p>

</div>
</div>
<a class="anchor" id="ga891205248039898c45e6ba5b3cce1d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PMC_GLOBAL_PMC_ERR2_STATUS_CFI_SHIFT&#160;&#160;&#160;(16U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CFI Non-Correctable Error shift. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga389dc49f070aafe94e78fd1009de7038">XLoader_CframeErrorHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga05d874ef5d60f3bba3fe7e580e2335b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_AES_RESET_REG&#160;&#160;&#160;(0xF11E0010U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AES Reset register address. </p>

</div>
</div>
<a class="anchor" id="ga37451d47afb1549cfd45ae1c5947d579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_AES_RESET_VAL&#160;&#160;&#160;(0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AES Reset value. </p>

</div>
</div>
<a class="anchor" id="ga656ec0b30e14c020dbc723daa4275842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_ATF_HANDOFF_PARAMS_LCVERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATF handoff parameters lowest compatible version. </p>

</div>
</div>
<a class="anchor" id="ga656ec0b30e14c020dbc723daa4275842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_ATF_HANDOFF_PARAMS_LCVERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATF handoff parameters lowest compatible version. </p>

</div>
</div>
<a class="anchor" id="ga3cb0c6d91d6ea175ab641751e8cb2d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_ATF_HANDOFF_PARAMS_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATF handoff parameters version. </p>

</div>
</div>
<a class="anchor" id="ga3cb0c6d91d6ea175ab641751e8cb2d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_ATF_HANDOFF_PARAMS_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATF handoff parameters version. </p>

</div>
</div>
<a class="anchor" id="ga539d826d2600671de8f64468dce86cb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BBRAM_OBFUS_KEY&#160;&#160;&#160;(0x3A5C3C57U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BBRAM obfuscated key. </p>

</div>
</div>
<a class="anchor" id="ga539d826d2600671de8f64468dce86cb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BBRAM_OBFUS_KEY&#160;&#160;&#160;(0x3A5C3C57U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BBRAM obfuscated key. </p>

</div>
</div>
<a class="anchor" id="gad91eeacdb8e0914b1e96182c942d6f95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BH_OBFUS_KEY&#160;&#160;&#160;(0xA35C7CA5U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot header obfuscated key. </p>

</div>
</div>
<a class="anchor" id="gad91eeacdb8e0914b1e96182c942d6f95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BH_OBFUS_KEY&#160;&#160;&#160;(0xA35C7CA5U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot header obfuscated key. </p>

</div>
</div>
<a class="anchor" id="ga4eba70b7be10245a53f4834b514bcb7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BOOT_COPY_OPTIMIZATION_ENABLED&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates Boot Device Copy Optimization is Enabled. </p>

</div>
</div>
<a class="anchor" id="ga9435ad99e3e9b2e04e3438dc2db2c3c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BOOTPDI_INFO_PARAMS_LCVERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BootPDI info lowest compatible version. </p>

</div>
</div>
<a class="anchor" id="ga9435ad99e3e9b2e04e3438dc2db2c3c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BOOTPDI_INFO_PARAMS_LCVERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BootPDI info lowest compatible version. </p>

</div>
</div>
<a class="anchor" id="ga4902a96e0396c283f07058cc576228f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BOOTPDI_INFO_PARAMS_VERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BootPDI info version. </p>

</div>
</div>
<a class="anchor" id="ga4902a96e0396c283f07058cc576228f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_BOOTPDI_INFO_PARAMS_VERSION&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BootPDI info version. </p>

</div>
</div>
<a class="anchor" id="ga8baed59f0b542201eae4c147aad4e686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CFRAME_DATACLEAR_CHECK_CMD_ID&#160;&#160;&#160;(0xCU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data clear check command Id. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6cce691e196dc2b9637fa0d443517afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_INDEX&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index in the Payload of ConfigureJtagState command where JTAG state flag is present. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga63654b2e9bd794bd9dedfeadd404b109">XLoader_ConfigureJtagState()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6cce691e196dc2b9637fa0d443517afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_INDEX&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index in the Payload of ConfigureJtagState command where JTAG state flag is present. </p>

</div>
</div>
<a class="anchor" id="ga57693974e707c6a48cd7fbabc088e59e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_MASK&#160;&#160;&#160;(0x03U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for JTAG state flag. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga63654b2e9bd794bd9dedfeadd404b109">XLoader_ConfigureJtagState()</a>.</p>

</div>
</div>
<a class="anchor" id="ga57693974e707c6a48cd7fbabc088e59e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_MASK&#160;&#160;&#160;(0x03U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for JTAG state flag. </p>

</div>
</div>
<a class="anchor" id="ga280195c8872446ce29567b7a5dff7486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CMD_GET_DDR_DEVICE_ID&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DDR device id. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga256f3577575dfc0f2b9de5df039a2f2d">XLoader_ReadDdrCryptoPerfCounters()</a>.</p>

</div>
</div>
<a class="anchor" id="ga280195c8872446ce29567b7a5dff7486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CMD_GET_DDR_DEVICE_ID&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DDR device id. </p>

</div>
</div>
<a class="anchor" id="gafd5144bf150041ae57d72cde9f8ee700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CONFIG_JTAG_STATE_FLAG_DISABLE&#160;&#160;&#160;(0x00U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of JTAG state flag if disabled. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga63654b2e9bd794bd9dedfeadd404b109">XLoader_ConfigureJtagState()</a>.</p>

</div>
</div>
<a class="anchor" id="gafd5144bf150041ae57d72cde9f8ee700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CONFIG_JTAG_STATE_FLAG_DISABLE&#160;&#160;&#160;(0x00U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of JTAG state flag if disabled. </p>

</div>
</div>
<a class="anchor" id="ga52d1e34b4e890bfeefe1628bfd7b23bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CONFIG_JTAG_STATE_FLAG_ENABLE&#160;&#160;&#160;(0x03U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of JTAG state flag if enabled. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga63654b2e9bd794bd9dedfeadd404b109">XLoader_ConfigureJtagState()</a>.</p>

</div>
</div>
<a class="anchor" id="ga52d1e34b4e890bfeefe1628bfd7b23bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_CONFIG_JTAG_STATE_FLAG_ENABLE&#160;&#160;&#160;(0x03U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of JTAG state flag if enabled. </p>

</div>
</div>
<a class="anchor" id="gaab68989608ddaae8e60e757fe4261c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_CRYPTO_MAIN_OFFSET&#160;&#160;&#160;(0X40000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DDR crypto block offset from ub. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga256f3577575dfc0f2b9de5df039a2f2d">XLoader_ReadDdrCryptoPerfCounters()</a>.</p>

</div>
</div>
<a class="anchor" id="gaab68989608ddaae8e60e757fe4261c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_CRYPTO_MAIN_OFFSET&#160;&#160;&#160;(0X40000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DDR crypto block offset from ub. </p>

</div>
</div>
<a class="anchor" id="ga08f25e90d333d2cb81e08b8b0889a9d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_PERF_MON_CNT0_OFFSET&#160;&#160;&#160;(0X868U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter 0 offset. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga256f3577575dfc0f2b9de5df039a2f2d">XLoader_ReadDdrCryptoPerfCounters()</a>.</p>

</div>
</div>
<a class="anchor" id="ga08f25e90d333d2cb81e08b8b0889a9d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_PERF_MON_CNT0_OFFSET&#160;&#160;&#160;(0X868U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter 0 offset. </p>

</div>
</div>
<a class="anchor" id="ga98c71f1b4c75ad9161caecb08ef0400a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_PERF_MON_CNT1_OFFSET&#160;&#160;&#160;(0X86CU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter 1 offset. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga256f3577575dfc0f2b9de5df039a2f2d">XLoader_ReadDdrCryptoPerfCounters()</a>.</p>

</div>
</div>
<a class="anchor" id="ga98c71f1b4c75ad9161caecb08ef0400a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_PERF_MON_CNT1_OFFSET&#160;&#160;&#160;(0X86CU)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter 1 offset. </p>

</div>
</div>
<a class="anchor" id="gadee2c86cf56654f376ad72d8132a08d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_PERF_MON_CNT2_OFFSET&#160;&#160;&#160;(0X870U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter 2 offset. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga256f3577575dfc0f2b9de5df039a2f2d">XLoader_ReadDdrCryptoPerfCounters()</a>.</p>

</div>
</div>
<a class="anchor" id="gadee2c86cf56654f376ad72d8132a08d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_PERF_MON_CNT2_OFFSET&#160;&#160;&#160;(0X870U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter 2 offset. </p>

</div>
</div>
<a class="anchor" id="ga66ee459f51efdeb7666d9e790e539d36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_PERF_MON_CNT3_OFFSET&#160;&#160;&#160;(0X874U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter 3 offset. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga256f3577575dfc0f2b9de5df039a2f2d">XLoader_ReadDdrCryptoPerfCounters()</a>.</p>

</div>
</div>
<a class="anchor" id="ga66ee459f51efdeb7666d9e790e539d36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_DDR_PERF_MON_CNT3_OFFSET&#160;&#160;&#160;(0X874U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter 3 offset. </p>

</div>
</div>
<a class="anchor" id="ga8c9cd6721e418777842ed226fedcb2c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_ECDSA_RSA_RESET_REG&#160;&#160;&#160;(0xF1200040U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDSA RSA Reset register address. </p>

</div>
</div>
<a class="anchor" id="ga8095884006d0bdec587bc2e15157bf33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_ECDSA_RSA_RESET_VAL&#160;&#160;&#160;(0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDSA RSA Reset value. </p>

</div>
</div>
<a class="anchor" id="ga047cb86e4b5bd655438c68ad0979377e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_EFUSE_OBFUS_KEY&#160;&#160;&#160;(0xA5C3C5A7U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eFuse obfuscated key </p>

</div>
</div>
<a class="anchor" id="ga047cb86e4b5bd655438c68ad0979377e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_EFUSE_OBFUS_KEY&#160;&#160;&#160;(0xA5C3C5A7U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eFuse obfuscated key </p>

</div>
</div>
<a class="anchor" id="gaa836e407e0fa958e23c0a392f4eb5d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_EFUSE_ROM_RSVD_AUTH_KEYS_TO_HASH_MASK&#160;&#160;&#160;(0x00000200U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AUTH_KEYS_TO_HASH eFuse bit mask. </p>

</div>
</div>
<a class="anchor" id="ga046afb20e36313e56a14baee4f7af1cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_EFUSE_ROM_RSVD_AUTH_KEYS_TO_HASH_SHIFT&#160;&#160;&#160;(9U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AUTH_KEYS_TO_HASH eFuse bit shift. </p>

</div>
</div>
<a class="anchor" id="ga951c28272c57cf2ddd983dc451e090f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_EFUSE_ROM_RSVD_OFFSET&#160;&#160;&#160;(0xF1250090U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ROM Reserved eFuse cache offset. </p>

</div>
</div>
<a class="anchor" id="ga670aed828759635178d1bac15da2fd91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_GET_PRTN_HASH_INDEX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PdiPtr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(PdiPtr-&gt;PdiType == <a class="code" href="xloader_8h.html#a1652b4d0eb7aed02ead9dc01a2308f01">XLOADER_PDI_TYPE_FULL</a>) \</div>
<div class="line">                                                ? (PdiPtr-&gt;PrtnNum) : (PdiPtr-&gt;PrtnNum +1U)</div>
<div class="ttc" id="xloader_8h_html_a1652b4d0eb7aed02ead9dc01a2308f01"><div class="ttname"><a href="xloader_8h.html#a1652b4d0eb7aed02ead9dc01a2308f01">XLOADER_PDI_TYPE_FULL</a></div><div class="ttdeci">#define XLOADER_PDI_TYPE_FULL</div><div class="ttdoc">&amp;lt; Different PDI types </div><div class="ttdef"><b>Definition:</b> xloader.h:175</div></div>
</div><!-- fragment -->
<p>Get partition hash index depending on full/partial PDI. </p>

</div>
</div>
<a class="anchor" id="ga9b010e88b328a818eb02d24852674e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_IMAGE_INFO_LCVERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image lowest compatible version information. </p>

</div>
</div>
<a class="anchor" id="ga9b010e88b328a818eb02d24852674e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_IMAGE_INFO_LCVERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image lowest compatible version information. </p>

</div>
</div>
<a class="anchor" id="ga1e7b2ae49b2f41294ba3e4c7403df20b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_IMAGE_INFO_TBL_MAX_NUM</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(XPLMI_IMAGE_INFO_TBL_BUFFER_LEN / \</div>
<div class="line">                sizeof(XLoader_ImageInfo))</div>
</div><!-- fragment -->
<p>Maximum number of image info tables in the available buffer. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga1174525d720931317820d083d51efdd7">XLoader_GetImageInfoEntry()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b029f8eb41a438e0a2851c15a0055a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_IMAGE_INFO_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image version information. </p>

</div>
</div>
<a class="anchor" id="ga4b029f8eb41a438e0a2851c15a0055a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_IMAGE_INFO_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image version information. </p>

</div>
</div>
<a class="anchor" id="ga90289e1764cf2d23465bfe018e6b5f84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_LOG_LEVEL_MASK&#160;&#160;&#160;(0xF0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag indicates Log level mask. </p>

</div>
</div>
<a class="anchor" id="gaaeb9479f179f61feb1b1368cbe99e562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_PCR_MEASUREMENT_INDEX_MASK&#160;&#160;&#160;(0xFFFF0000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for PCR Measurement index. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga443aaeef586ee9cefe8509092d99ca17">XLoader_LoadImage()</a>.</p>

</div>
</div>
<a class="anchor" id="gacc78ce7d57074b011bd80837a7b133a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_PDI_LIST_LCVERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PDI lowest compatible version list. </p>

</div>
</div>
<a class="anchor" id="gacc78ce7d57074b011bd80837a7b133a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_PDI_LIST_LCVERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PDI lowest compatible version list. </p>

</div>
</div>
<a class="anchor" id="gaab4fbb00ecf27e811f1e6282caa21c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_PDI_LIST_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PDI version list. </p>

</div>
</div>
<a class="anchor" id="gaab4fbb00ecf27e811f1e6282caa21c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_PDI_LIST_VERSION&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PDI version list. </p>

</div>
</div>
<a class="anchor" id="gaad372ad8e543134647457ddfd18128ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_PUF_SHUT_GLB_VAR_FLTR_EN_SHIFT&#160;&#160;&#160;(31U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift for Global Variation Filter in PUF shutter value. </p>

</div>
</div>
<a class="anchor" id="gabdc35282335ca2e17f74dd302d034667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_RPU_GLBL_CNTL&#160;&#160;&#160;(0xFF9A0000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RPU global control. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga98ac029ac7965b392e6bb0097876fd94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_RSA_EM_MSB_INDEX&#160;&#160;&#160;(0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA EM MSB Index. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga1549a54ac384c080bcc344843debcf5e">XLoader_RsaPssSignVerify()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5e43af745222cb78f6a71853c891183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_RSA_PSS_MSB_PADDING_MASK&#160;&#160;&#160;(u8)(0x80U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RSA PSS MSB padding mask. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga1549a54ac384c080bcc344843debcf5e">XLoader_RsaPssSignVerify()</a>.</p>

</div>
</div>
<a class="anchor" id="ga08ffba6e00178b279c6c2e8f162408cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_SBI_DELAY_IN_MICROSEC&#160;&#160;&#160;(5000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag indicates SBI delay in micro second. </p>

</div>
</div>
<a class="anchor" id="gae1ad484f4b4344573008a1fa138ad597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_SHA3_RESET_REG&#160;&#160;&#160;(0xF1210004U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SHA3 Reset register address. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga9171035e129091fbaddbc27756381f76">XLoader_SecureClear()</a>.</p>

</div>
</div>
<a class="anchor" id="ga18a802ef19167e4a011890ac7bf61f7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_SHA3_RESET_VAL&#160;&#160;&#160;(0x1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SHA3 Reset value. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga9171035e129091fbaddbc27756381f76">XLoader_SecureClear()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2649fc63e039d0ea257ceb1706063594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_SUCCESS_NOT_PRTN_OWNER&#160;&#160;&#160;(0x100U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that PLM is not the partition owner. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gacb74ee2f2a0e0dcce9bfdae7750bbc14">XLoader_LoadImagePrtns()</a>.</p>

</div>
</div>
<a class="anchor" id="gafb8da78a452c3524858aa626b6a91797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_TCM_0&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCM 0. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="gac7aac7aa870f5c4290d6ad101dbfe39d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_TCM_1&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCM 1. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga690701a566a217bfc9daf80efdaa1602"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_TCMCOMB_MASK&#160;&#160;&#160;(0x40U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCM combine mask. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="gad403a72b35f69de5a924f73a3508d354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLOADER_TCMCOMB_SHIFT&#160;&#160;&#160;(6U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCM combine shift. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ae2a99f34bb1f1b102eaaac9ee1dd21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPLMI_ZERO&#160;&#160;&#160;(0x0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga434f49bc94a9078a86451ac5bde637cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_AddAuthJtagToScheduler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds periodic checks of the status of Auth JTAG interrupt status to the scheduler. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS otherwise error code is returned</li>
<li>XLOADER_ERR_GLITCH_DETECTED if glitch is detected.</li>
<li>XLOADER_ERR_ADD_TASK_SCHEDULER if failed to add task to scheduler. </li>
</ul>
</dd></dl>
<ul>
<li>Read auth_jtag_disable efuse bits(20:19) of Security Control register in Efuse Cache module.</li>
<li>Read PPK hash registers in Efuse Cache module and check if they are non-zero.</li>
<li>Check the preconditions for adding task to the scheduler<ul>
<li>Auth jtag disable efuse bits should not be set.</li>
<li>PPK hash registers should be non zero.</li>
</ul>
</li>
<li>If the preconditions are correct then add task to the scheduler for calling the API to check Auth JTAG interrupt status.</li>
<li>The task should not be added to the scheduler if Auth JTAG disable efuse bit is set or PPK hash is not programmed in efuse. Thus forcing the Status to be XST_SUCCESS.</li>
</ul>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gacb10f2e97fecfb15aae4fed081b02502">XLoader_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga331850d019d28f888cfa3499be80529d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_AddDeviceStateChangeToScheduler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds periodic checks of the device status change during secure boot. </p>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success. </dd>
<dd>
XLOADER_ERR_ADD_TASK_SCHEDULER if failed to add task to scheduler. </dd></dl>

<p>References <a class="el" href="group__xloader__server__apis.html#ga53a30d478b54d5ef349ca169085eb7b8">XLoader_CheckDeviceStateChange()</a>, <a class="el" href="xloader__auth__enc_8h.html#a39a0aa8b95cff74352dd8e9adc16c895">XLOADER_EFUSE_CACHE_SECURITY_CONTROL_OFFSET</a>, <a class="el" href="group__xloader__server__apis.html#ga3e99458db1239a8f1bcb70eee9025232">XLoader_GetAHWRoT()</a>, and <a class="el" href="group__xloader__server__apis.html#ga27d4a7f2cecd7b051a5418ad7586cac3">XLoader_GetSHWRoT()</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gacb10f2e97fecfb15aae4fed081b02502">XLoader_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f284fd6c101bd12f2c987bad6d3fead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_AdditionalPpkSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xloader__auth__enc_8h.html#a85aba33b166080b4874c0f5657589b3e">XLoader_PpkSel</a>&#160;</td>
          <td class="paramname"><em>PpkSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>InvalidMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>PpkOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks for the additional PPK select and returns the PPK invalid mask and PPK efuse cache start offset if PPK is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PpkSelect</td><td>PPK selection of eFUSE. </td></tr>
    <tr><td class="paramname">InvalidMask</td><td>Pointer to the PPK invalid mask </td></tr>
    <tr><td class="paramname">PpkOffset</td><td>Pointer to the efuse cache PPK start offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PpkSelect</td><td>PPK selection of eFUSE. </td></tr>
    <tr><td class="paramname">InvalidMask</td><td>Pointer to the PPK invalid mask </td></tr>
    <tr><td class="paramname">PpkOffset</td><td>Pointer to the efuse cache PPK start offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_FAILURE always return failue, as this api is not applicable for versal_net</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PpkSelect</td><td>PPK selection of eFUSE. </td></tr>
    <tr><td class="paramname">InvalidMask</td><td>Pointer to the PPK invalid mask </td></tr>
    <tr><td class="paramname">PpkOffset</td><td>Pointer to the efuse cache PPK start offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_FAILURE always return failure, as this api is not applicable for versal_net </dd></dl>

</div>
</div>
<a class="anchor" id="ga67aad6fd596b7f1b30b91ae303531984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_AesObfusKeySelect </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PdiKeySrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DecKeyMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>KeySrcPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides Obfuscated Aes Key source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiKeySrc</td><td>is the Key source given in Pdi </td></tr>
    <tr><td class="paramname">DecKeyMask</td><td>is the current DecKeyMask </td></tr>
    <tr><td class="paramname">KeySrcPtr</td><td>is the pointer to the calculated KeySrc</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiKeySrc</td><td>is the Key source given in Pdi </td></tr>
    <tr><td class="paramname">DecKeyMask</td><td>is the current DecKeyMask </td></tr>
    <tr><td class="paramname">KeySrcPtr</td><td>is the pointer to the calculated KeySrc</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga22f293db863b881993077e17fc892007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_AuthEncClear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called to clear secure critical data related to authentication and encryption in case of exceptions. </p>
<p>The function also places AES, ECDSA_RSA in reset.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XST_FAILURE on failure. </li>
</ul>
</dd></dl>
<ul>
<li>Clear keys.</li>
<li>Place AES in reset and clear AES instance</li>
<li>Release RSA from reset</li>
<li>Clear RSA or ECDSA memory</li>
<li>Place RSA or ECDSA in reset </li>
</ul>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga9171035e129091fbaddbc27756381f76">XLoader_SecureClear()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed8ea42231382fe5a5a155bd327b15ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CfiSelectiveRead </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides CFI SELECTIVE READ command execution. </p>
<pre class="fragment">            Command payload parameters are
 - Row, block type and Start frame address
    - Frame count to be read from CFU(1frame = 25Quadwords)
    - High Dest Addr
    - Low Dest Addr
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xloader__defs_8h.html#a54d872b87e11572aa56efe1aa586240e">XLOADER_CFI_SEL_READBACK_ID</a>, <a class="el" href="group__xloader__server__apis.html#ga953be1ba88ede7dedb1f86081b14f221">XLoader_CframeInit()</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a8f22bf15a01199943c9c56394992e75f">XLOADER_ERR_INVALID_BLOCK_TYPE</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a098c2962ee2547216e3a0a5243d1bae3">XLOADER_ERR_INVALID_ROW</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ac443e44ea05f2e13cb2a6335bd9dd8ce">XLOADER_FRAME_COUNT_EXCEEDS_LASTFRAME</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ab1c3eb4c397761bd85b6345dc5ac6283">XLOADER_INVALID_FRAME_ADDRESS</a>, and <a class="el" href="group__xloader__client__apis.html#gaa39ad3db38cb7d477accd3ed0534c201">XLOADER_SELREADBACK_ROW_MASK</a>.</p>

</div>
</div>
<a class="anchor" id="gac94a1020e3745f6791480bf86040a759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CframeDataClearCheck </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to check if the Cframe data is cleared or not using CRC method. </p>
<p>This function need to be called after CFI house cleaning is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command. Command payload parameters are: Block Type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_INVALID_BLOCKTYPE if block type passed is invalid. Only Type 0, Type 1, and Type 2 are supported.</li>
<li>XLOADER_CFI_CFRAME_IS_BUSY if CRAM self check fails as CFI CFrame is busy.</li>
<li>XLOADER_CFRAME_CRC_CHECK_FAILED if CFRAME CRC check fails. </li>
</ul>
</dd></dl>
<ul>
<li>Check if the block type is valid</li>
<li>Initialize Cframe driver</li>
<li>Enable CRAM Self Check</li>
<li>Reset CRC</li>
<li>Set Frame Address Register with the Block type</li>
<li>Send RDALL command</li>
<li>Check if Cframe is busy</li>
<li>Check CRC</li>
<li>Clear CRAM Self Check </li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#gaecec768f7aa5f3c9bdbb23ca2f79af31">CFRAME_BCAST_REG_FAR_BLOCKTYPE_SHIFT</a>, <a class="el" href="group__xloader__server__apis.html#gad043b6b35eb2a61501ee7d2b7d2dac35">CFRAME_BCAST_REG_FAR_OFFSET</a>, <a class="el" href="group__xloader__server__apis.html#ga4cb237f68a9fc494cb17b1e4c78a71e1">CFRAME_BCAST_REG_TESTMODE_CRAM_SELF_CHECK_MASK</a>, <a class="el" href="group__xloader__server__apis.html#gaf062051d3fb77de1a64d1c59099d39de">CFRAME_BCAST_REG_TESTMODE_OFFSET</a>, <a class="el" href="group__xloader__server__apis.html#gad74c706747e37822e8d9a5524cc341ea">CFRAME_CRC_POLL_TIMEOUT</a>, <a class="el" href="group__xloader__server__apis.html#ga17e70988fc31bef75378289d76c871ac">CFRAME_MAX_BLOCK_TYPE_COUNT</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7af2c3ff490429e7cfa77b48c77cbcd210">XLOADER_CFI_CFRAME_IS_BUSY</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a3774d290f907e812ffe4d575edeeb9ef">XLOADER_CFRAME_CRC_CHECK_FAILED</a>, <a class="el" href="group__xloader__server__apis.html#ga8baed59f0b542201eae4c147aad4e686">XLOADER_CFRAME_DATACLEAR_CHECK_CMD_ID</a>, <a class="el" href="group__xloader__server__apis.html#ga953be1ba88ede7dedb1f86081b14f221">XLoader_CframeInit()</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a7f11005f9d95e00567d2cd79fdde2f48">XLOADER_INVALID_BLOCKTYPE</a>, and <a class="el" href="group__xloader__server__apis.html#ga4ae2a99f34bb1f1b102eaaac9ee1dd21">XPLMI_ZERO</a>.</p>

</div>
</div>
<a class="anchor" id="ga389dc49f070aafe94e78fd1009de7038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLoader_CframeErrorHandler </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ImageId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to check the CFU ISR and PMC_ERR1 and PMC_ERR2 status registers to check for any errors in PL and call corresponding error recovery functions if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImageId</td><td>is Id of the image present in PDI </td></tr>
  </table>
  </dd>
</dl>
<p>CFU Driver Instance</p>
<ul>
<li>Execute CfiErrorHandler.</li>
<li>Execute CFU Error Handler.</li>
<li>Retrigger PL house clean if it's a PLD0 image.</li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga891205248039898c45e6ba5b3cce1d60">PMC_GLOBAL_PMC_ERR2_STATUS_CFI_SHIFT</a>.</p>

</div>
</div>
<a class="anchor" id="ga953be1ba88ede7dedb1f86081b14f221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CframeInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the Cframe driver. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_CFRAME_LOOKUP if CFrame lookup fails.</li>
<li>XLOADER_ERR_CFRAME_CFG if CFrame configuration fails. </li>
</ul>
</dd></dl>
<ul>
<li>Initialize the Cframe driver so that it's ready to use look up the configuration in the config table, and then initialize it.</li>
<li>Enable SLVERR for CFU. </li>
</ul>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gaed8ea42231382fe5a5a155bd327b15ff">XLoader_CfiSelectiveRead()</a>, <a class="el" href="group__xloader__server__apis.html#gac94a1020e3745f6791480bf86040a759">XLoader_CframeDataClearCheck()</a>, and <a class="el" href="group__xloader__server__apis.html#gacb10f2e97fecfb15aae4fed081b02502">XLoader_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga830f47f91bd5f3b12b41a8e80108017d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CheckAndUpdateSecureState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks and updates the secure state configuration. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>Error code on failure </li>
</ul>
</dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga53a30d478b54d5ef349ca169085eb7b8">XLoader_CheckDeviceStateChange()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ab0ef6b838c9f3d87f5f6566065938a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CheckAuthJtagIntStatus </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks the status of Auth JTAG interrupt status and it disables the Jtag as per the timeout set by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Arg</td><td>Not used in the function currently</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_DAP_TIMEOUT_DISABLED if timeout is disabled for DAP.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If Auth JTAG interrupt status is set, then XLoader_AuthJtag API will be called. </dd></dl>
<ul>
<li>Read Auth Jtag Interrupt Status register in PMC TAP module.</li>
<li>Check if Auth JTAG Lock disable efuse bits are set. If set then allow limited number of attempts to enable JTAG.</li>
<li>When AUTH_JTAG_LOCK_DIS eFuse is programmed, allow only one failed attempt for AuthJTag message. For the second failure trigger secure lock down.</li>
</ul>

<p>References <a class="el" href="xloader__auth__enc_8h.html#ad7aca18f25d8240dff6ae1f4d990c39c">XLOADER_AUTH_JTAG_LOCK_DIS_MASK</a>, <a class="el" href="xloader__auth__enc_8h.html#aff8787d6251f3a610514fadf2d015952">XLOADER_AUTH_JTAG_MAX_ATTEMPTS</a>, <a class="el" href="xloader__auth__enc_8h.html#a39a0aa8b95cff74352dd8e9adc16c895">XLOADER_EFUSE_CACHE_SECURITY_CONTROL_OFFSET</a>, <a class="el" href="xloader__auth__enc_8h.html#aaba63a6911c51f5d3989f3ad318b14e0">XLOADER_PMC_TAP_AUTH_JTAG_INT_STATUS_MASK</a>, and <a class="el" href="xloader__auth__enc_8h.html#acd652535b771e6fea9e9067c174d3273">XLOADER_PMC_TAP_AUTH_JTAG_INT_STATUS_OFFSET</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga36eeb66375a1d833608e9869ac5e8c25">XLoader_UpdateHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga53a30d478b54d5ef349ca169085eb7b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CheckDeviceStateChange </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks the JTAG device state change. </p>
<pre class="fragment">            When Secure gate is opened from close state this API raises an error,
    if the gate is closed and re-opened again this function recognizes the
    state change and performs the action configured.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Arg</td><td>is of pointer of void type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and error code on failure </dd></dl>

<p>References <a class="el" href="group__xloader__server__apis.html#ga830f47f91bd5f3b12b41a8e80108017d">XLoader_CheckAndUpdateSecureState()</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga331850d019d28f888cfa3499be80529d">XLoader_AddDeviceStateChangeToScheduler()</a>, and <a class="el" href="group__xloader__server__apis.html#ga36eeb66375a1d833608e9869ac5e8c25">XLoader_UpdateHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e5d053bbf2e5283aac4b2a1e860b44d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CheckNonZeroPpk </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if PPK is programmed. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_GLITCH_DETECTED if glitch is detected.</li>
<li>XST_FAILURE on failure. </li>
</ul>
</dd></dl>
<ul>
<li>Check if any of the PPK efuses are not programmed. </li>
</ul>

<p>References <a class="el" href="xloader__secure_8h.html#a9c37bf573525769b2821bf9c45858c08">XLOADER_EFUSE_PPK0_START_OFFSET</a>, and <a class="el" href="xloader__secure_8h.html#a37961c447b4a134f280d82ef4e8b542e">XLOADER_EFUSE_PPK2_END_OFFSET</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gab971c3f4e75170b57d1f5fdcd51cc092">XLoader_CheckSecureStateAuth()</a>.</p>

</div>
</div>
<a class="anchor" id="gacb572c209348e5ec41f2e15c92de9c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CheckSecureState </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>RegVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ExpectedValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the secure state of boot matches the expected value or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RegVal</td><td>- Value of secure state stored in register </td></tr>
    <tr><td class="paramname">Var</td><td>- Value of secure state stored in variable </td></tr>
    <tr><td class="paramname">ExpectedValue</td><td>- Expected value of secure state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and error code on failure </dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga112597ce43d11195a3d8924eb435254f">XLoader_DataAuth()</a>, <a class="el" href="group__xloader__server__apis.html#ga9df696fd17dec50576f817a1cd1f7105">XLoader_SecureEncInit()</a>, and <a class="el" href="group__xloader__server__apis.html#ga647a935c43dcde43b8f4c308764fbd6d">XLoader_UpdateCfgLimitCount()</a>.</p>

</div>
</div>
<a class="anchor" id="gab971c3f4e75170b57d1f5fdcd51cc092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_CheckSecureStateAuth </td>
          <td>(</td>
          <td class="paramtype">volatile u32 *&#160;</td>
          <td class="paramname"><em>AHWRoT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks Secure State for Authentication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AHWRoT</td><td>- Buffer to store Secure state for authentication</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_HWROT_BH_AUTH_NOT_ALLOWED if PPK is programmed and boot header authentication is enabled.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AHWRoT</td><td>- Buffer to store Secure state for authentication</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success. </dd>
<dd>
XLOADER_ERR_GLITCH_DETECTED if glitch is detected. </dd></dl>
<ul>
<li>If PPK hash is programmed in eFUSEs, then Secure State of boot is A-HWRoT.</li>
<li>If BHDR authentication is enabled, then Secure State of boot is emulated A-HWRoT.</li>
</ul>
<p>If PPK hash is programmed in eFUSEs, then Secure State of boot is A-HWRoT</p>
<p>If PPK hash is not programmed in eFUSEs and PLM is authenticated then Secure State of boot is emulated A-HWRoT</p>
<p>If PPK hash is programmed in eFUSEs, then Secure State of boot is A-HWRoT</p>
<p>If PPK hash is not programmed in eFUSEs and PLM is authenticated then Secure State of boot is emulated A-HWRoT</p>

<p>References <a class="el" href="group__xloader__server__apis.html#ga4e5d053bbf2e5283aac4b2a1e860b44d">XLoader_CheckNonZeroPpk()</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gade5fc1ce6a279c921672d5692df5cf56">XLoader_SetSecureState()</a>.</p>

</div>
</div>
<a class="anchor" id="ga399279fd63d1bed34a886c24c414ee48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ClearAesKey </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>DecKeySrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the AES keys when RedKeyClear is set in PMC RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DecKeySrc</td><td>is pointer to the Decrypt Key source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>ErrorCode on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga11a471be6e3406b3fe9d851c16619847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ClearATFHandoffParams </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears ATF Handoff parameters in case of multi-partitions in APU subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>Pointer to XilPdi instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success</li>
<li>XST_FAILURE on failure </li>
</ul>
</dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga43a415ea9b49abb198cae9ba6f9eb0b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLoader_ClearKatOnPPDI </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PlmKatMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the KAT status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to the XilPdi instance </td></tr>
    <tr><td class="paramname">PlmKatMask</td><td>is the mask of the KAT that is going to run </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63654b2e9bd794bd9dedfeadd404b109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ConfigureJtagState </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables or disable Jtag Access Command payload parameters are. </p>
<pre class="fragment">                    - Flag (enable / disable)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_INVALID_JTAG_OPERATION </li>
</ul>
</dd></dl>
<p>Invalid JTAG Operation request</p>
<p>Invalid JTAG Operation request </p>

<p>References <a class="el" href="group__xloader__server__apis.html#ga6cce691e196dc2b9637fa0d443517afa">XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_INDEX</a>, <a class="el" href="group__xloader__server__apis.html#ga57693974e707c6a48cd7fbabc088e59e">XLOADER_CMD_CONFIG_JTAG_STATE_FLAG_MASK</a>, <a class="el" href="xloader__auth__enc_8h.html#afbb5add87fe4efb808df8fcf1907206e">XLOADER_CONFIG_DAP_STATE_NONSECURE_DBG</a>, <a class="el" href="group__xloader__server__apis.html#gafd5144bf150041ae57d72cde9f8ee700">XLOADER_CONFIG_JTAG_STATE_FLAG_DISABLE</a>, <a class="el" href="group__xloader__server__apis.html#ga52d1e34b4e890bfeefe1628bfd7b23bc">XLOADER_CONFIG_JTAG_STATE_FLAG_ENABLE</a>, <a class="el" href="group__xloader__server__apis.html#ga53c758fcaf8c676a9d7fa9de03e6b535">XLoader_DisableJtag()</a>, <a class="el" href="group__xloader__server__apis.html#ga203aa0ade1430a8a53e7974c0e4eba3c">XLoader_EnableJtag()</a>, and <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7af76a9307dd97fbf0348f51b59e4ec85a">XLOADER_ERR_INVALID_JTAG_OPERATION</a>.</p>

</div>
</div>
<a class="anchor" id="ga112597ce43d11195a3d8924eb435254f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_DataAuth </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function authenticates the data with SPK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance. </td></tr>
    <tr><td class="paramname">Hash</td><td>is a Pointer to the expected hash buffer. </td></tr>
    <tr><td class="paramname">Signature</td><td>pointer points to the signature buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_SEC_GLITCH_DETECTED_ERROR if glitch is detected. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__xloader__server__apis.html#gacb572c209348e5ec41f2e15c92de9c36">XLoader_CheckSecureState()</a>, <a class="el" href="group__xloader__server__apis.html#ga3e99458db1239a8f1bcb70eee9025232">XLoader_GetAHWRoT()</a>, <a class="el" href="xloader__auth__enc_8h.html#ab00e2c93fd7efdf325c99806934c10b0">XLOADER_NOLOAD_VAL</a>, and <a class="el" href="xloader__auth__enc_8h.html#aec332f880130dc2f0d0c3a9c07261ac4">XLOADER_PPK_SIZE</a>.</p>

</div>
</div>
<a class="anchor" id="gafbdd06a059cd7970791f71533c47b8d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_DataMeasurement </td>
          <td>(</td>
          <td class="paramtype">XLoader_ImageMeasureInfo *&#160;</td>
          <td class="paramname"><em>ImageInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function measures the data by calculating SHA3 hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImageInfo</td><td>Pointer to the XLoader_ImageMeasureInfo structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_DATA_MEASUREMENT if error in data measurement. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#a27cccfb3c7b604d554371c7c5b6e8ca3">XLOADER_MEASURE_FINISH</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a52c44b2aa324f1c51bcc8faddd3f3f90">XLOADER_MEASURE_START</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a06ae41365bea45324b30988a11fb3810">XLOADER_MEASURE_UPDATE</a>, and <a class="el" href="xloader_8h.html#a261fb4f12be9886db96079709efd1608">XLOADER_SHA3_LEN</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga610d38218f6d60c5d6ad9880efa6ad35">XLoader_HdrMeasurement()</a>, <a class="el" href="group__xloader__server__apis.html#ga443aaeef586ee9cefe8509092d99ca17">XLoader_LoadImage()</a>, and <a class="el" href="group__xloader__server__apis.html#ga629ebb0c55462b5cde87f7e91037b8c0">XLoader_PrtnCopy()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa03c18623c76cf0e2f5effddd4b15415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_DdrCopy </td>
          <td>(</td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>SrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>DestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>FlagsVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to copy the data from DDR to destination address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SrcAddr</td><td>of DDR </td></tr>
    <tr><td class="paramname">DestAddr</td><td>is the address of the destination where the data needs to be copied. </td></tr>
    <tr><td class="paramname">Length</td><td>of the bytes to be copied </td></tr>
    <tr><td class="paramname">FlagsVal</td><td>that denote blocking / non-blocking dma</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_DDR_COPY_UNSUPPORTED_PARAMS on invalid params passed. </li>
</ul>
</dd></dl>
<ul>
<li>Validate the source address, destination address and length of the bytes. Otherwise return XLOADER_DDR_COPY_UNSUPPORTED_PARAMS.</li>
<li>If the flag is XPLMI_DEVICE_COPY_STATE_WAIT_DONE, then wait till the data is copied and DMA returns done.</li>
<li>If the flag is XPLMI_DEVICE_COPY_STATE_INITIATE, then start the dma transfer and don't wait for the done bit.</li>
</ul>

</div>
</div>
<a class="anchor" id="ga9df79c2616e31ed2a2060900a4222464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_DdrInit </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DeviceFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to initialize for DDR init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceFlags</td><td>Loader init prototype requires flags</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success</li>
<li>XLOADER_ERR_PM_DEV_DDR_0 on device request to DDR fail. </li>
</ul>
</dd></dl>
<ul>
<li>Initialize the device request for DDR_0.</li>
<li>Otherwise return XLOADER_ERR_PM_DEV_DDR_0.</li>
</ul>

<p>Referenced by <a class="el" href="aiepg2_2xloader__plat_8h.html#ga5c26bcc51fa70b2692ec7448a69422a0">XLoader_DumpDdrmcRegisters()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a4c313af5a0caa20fa13c561ba0f04a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_DdrRelease </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function releases control of DDR. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success</li>
<li>XLOADER_ERR_RELEASE_PM_DEV_DDR_0 on device release fail. </li>
</ul>
</dd></dl>
<ul>
<li>Initialize the DDR_0 device release request.</li>
<li>Otherwise return XLOADER_ERR_RELEASE_PM_DEV_DDR_0.</li>
</ul>

<p>References <a class="el" href="xloader__client_8h.html#af14fcbd99f3aaf94c6ecc1f3689b8485">XLOADER_PDI_SRC_DDR</a>.</p>

</div>
</div>
<a class="anchor" id="ga53c758fcaf8c676a9d7fa9de03e6b535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_DisableJtag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the Jtag. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on SUCCESS</li>
<li>Errorcode upon failure </li>
</ul>
</dd></dl>
<p>Reset DBG module</p>
<p>Enable security gate</p>
<p>Disable all the instructions</p>
<p>Disable secure/non-secure debug Disabled invasive &amp; non-invasive debug</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga63654b2e9bd794bd9dedfeadd404b109">XLoader_ConfigureJtagState()</a>.</p>

</div>
</div>
<a class="anchor" id="ga203aa0ade1430a8a53e7974c0e4eba3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_EnableJtag </td>
          <td>(</td>
          <td class="paramtype">volatile u32&#160;</td>
          <td class="paramname"><em>CfgState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the Jtag. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on SUCCESS</li>
<li>Errorcode upon failure </li>
</ul>
</dd></dl>
<p>Enable secure/non-secure debug Enabled invasive &amp; non-invasive debug</p>
<p>Enable only non-secure debug</p>
<p>Enable all the instructions</p>
<p>Disable security gate</p>
<p>Take DBG module out of reset</p>

<p>References <a class="el" href="xloader__auth__enc_8h.html#a6968b6c1250a51bd9acd39c9326a56c5">XLOADER_DAP_CFG_ENABLE_ALL_DBG_MASK</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga63654b2e9bd794bd9dedfeadd404b109">XLoader_ConfigureJtagState()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e99458db1239a8f1bcb70eee9025232"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLoader_GetAHWRoT </td>
          <td>(</td>
          <td class="paramtype">const u32 *&#160;</td>
          <td class="paramname"><em>AHWRoTPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the state of authenticated boot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AHWRoTPtr</td><td>- Always NULL except at time of initialization of SecureStateAHWRoT variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XPLMI_RTCFG_SECURESTATE_AHWROT - PPK fuses are programmed</li>
<li>XPLMI_RTCFG_SECURESTATE_EMUL_AHWROT - BHDR auth is enabled</li>
<li>XPLMI_RTCFG_SECURESTATE_NONSECURE - Neither PPK fuses are programmed nor BH auth is enabled </li>
</ul>
</dd></dl>
<ul>
<li>If AHWRoTPtr is not NULL, then set the SecureStateSHWRoT. Otherwise return the previous stored Secure state.</li>
</ul>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga331850d019d28f888cfa3499be80529d">XLoader_AddDeviceStateChangeToScheduler()</a>, <a class="el" href="group__xloader__server__apis.html#ga112597ce43d11195a3d8924eb435254f">XLoader_DataAuth()</a>, <a class="el" href="group__xloader__server__apis.html#ga9df696fd17dec50576f817a1cd1f7105">XLoader_SecureEncInit()</a>, <a class="el" href="group__xloader__server__apis.html#gade5fc1ce6a279c921672d5692df5cf56">XLoader_SetSecureState()</a>, and <a class="el" href="group__xloader__server__apis.html#ga647a935c43dcde43b8f4c308764fbd6d">XLoader_UpdateCfgLimitCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ga66559b884d7cf9ebdeb4850cc1b32a30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XilPdi_ATFHandoffParams * XLoader_GetATFHandoffParamsAddr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the ATFHandoffParams structure address to the caller. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns ATFHandoffParams structure address </dd></dl>
<p>&lt; Instance containing ATF handoff params </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gaadc121bcc59feb4ece3c40802d81987b">XLoader_PdiInit()</a>, and <a class="el" href="group__xloader__server__apis.html#ga0b1966d6afb00e55785154bac01c8228">XLoader_SetATFHandoffParameters()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c3b5e104f9dadbef8b3c59d683bd332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XilBootPdiInfo * XLoader_GetBootPdiInfo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides pointer to BootPDI Info. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to BootPDI Info </dd></dl>
<p>&lt; BootPDI info Storage</p>
<p>&lt; BootPDI info Storage</p>
<p>&lt; BootPDI info Storage </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga3dbbecc3b2545a3e076d421f086715e6">XLoader_RestartImage()</a>, and <a class="el" href="group__xloader__server__apis.html#ga7be2984f0912856671c01e2132da604d">Xloader_SaveBootPdiInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ea4300bb5e4bd5116c3d2bf72902824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_GetImageAndPrtnInfo </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ImageId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides Image number and partition number of a given ImgID in the PDI instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>Pdi instance pointer </td></tr>
    <tr><td class="paramname">ImageID</td><td>Image id of a subsystem</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- XST_SUCCESS on success<ul>
<li>XST_FAILURE on failure </li>
</ul>
</dd></dl>
<p>Check if the given ImageId matches with any Images present in PDI.</p>
<p>If not matched return error, else success. </p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gad3082e333a47e4fea07fba25bba8582e">XLoader_LoadLpdAndPsmElf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1174525d720931317820d083d51efdd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XLoader_ImageInfo* XLoader_GetImageInfoEntry </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ImgID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the ImageInfoEntry by checking if an entry exists for that particular ImgId in the ImgInfoTbl. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImgID</td><td>of the the entry that has to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of ImageInfo Entry in the table </dd></dl>
<p>Check for a existing valid image entry matching given ImgID</p>

<p>References <a class="el" href="group__xloader__server__apis.html#ga8ee855df9e0b6924472583ce2ed0edf9">XLoader_GetImageInfoTbl()</a>, <a class="el" href="group__xloader__server__apis.html#ga1e7b2ae49b2f41294ba3e4c7403df20b">XLOADER_IMAGE_INFO_TBL_MAX_NUM</a>, and <a class="el" href="xloader_8h.html#a8e7dfbd981e9ffd59d610f0966737376">XLOADER_INVALID_IMG_ID</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ee855df9e0b6924472583ce2ed0edf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XLoader_ImageInfoTbl * XLoader_GetImageInfoTbl </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides ImageInfoTbl pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to ImageInfoTbl </dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga1174525d720931317820d083d51efdd7">XLoader_GetImageInfoEntry()</a>, and <a class="el" href="group__xloader__server__apis.html#ga304b923a96834575c1fee9eed2ffb870">XLoader_LoadImageInfoTbl()</a>.</p>

</div>
</div>
<a class="anchor" id="gac8bc92d0322ebe706e0642274395c092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLoader_GetKekSrc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates KEK red key availability status from boot header. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Decryption Key source status. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xloader__auth__enc_8h.html#ade3004565717199ee57abec59c1fb18c">XLOADER_BBRAM_BLK_KEY</a>, <a class="el" href="xloader__auth__enc_8h.html#ade4d767281c0bfc8f13986d55dba83fa">XLOADER_BBRAM_RED_KEY</a>, <a class="el" href="xloader__auth__enc_8h.html#a58356b659336e4b427c4970be82d3ac1">XLOADER_BH_BLK_KEY</a>, <a class="el" href="xloader__auth__enc_8h.html#ab6ee28a571ba641e995ca7b765968cc5">XLOADER_BHDR_RED_KEY</a>, <a class="el" href="xloader__auth__enc_8h.html#a1c3ef02f873ab336be986fce84fd0cbe">XLOADER_EFUSE_BLK_KEY</a>, and <a class="el" href="xloader__auth__enc_8h.html#a9c389c98f746e41bfb5e14b5abf4a76d">XLOADER_EFUSE_RED_KEY</a>.</p>

</div>
</div>
<a class="anchor" id="gaf60991670bc1598b674f3f81d3982caf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XilPdi* XLoader_GetPdiInstance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides PdiInstance pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to PdiInstance </dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gacb10f2e97fecfb15aae4fed081b02502">XLoader_Init()</a>, <a class="el" href="group__xloader__server__apis.html#gad3082e333a47e4fea07fba25bba8582e">XLoader_LoadLpdAndPsmElf()</a>, and <a class="el" href="group__xloader__server__apis.html#ga3dbbecc3b2545a3e076d421f086715e6">XLoader_RestartImage()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c4719cd0b80cb8626bbd934db116429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XLoader_ImageStore * XLoader_GetPdiList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides pointer to PdiList. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to PdiList</dd>
<dd>
pointer to PdiList </dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga8122f50322351d61e03c5dd33cf6f635">XLoader_IsPdiAddrLookup()</a>, <a class="el" href="group__xloader__server__apis.html#gafa91a58dad6f9d08c018cbf914f7202c">XLoader_ReadImageStoreCfg()</a>, and <a class="el" href="group__xloader__server__apis.html#ga3dbbecc3b2545a3e076d421f086715e6">XLoader_RestartImage()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf53860991287c550d874547a0ca021bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_GetSDPdiSrcNAddr </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>SecBootMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>PdiSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>PdiAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get PdiSrc and PdiAddr for Secondary SD boot modes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecBootMode</td><td>is the secondary boot mode value </td></tr>
    <tr><td class="paramname">PdiPtr</td><td>Pointer to PDI instance </td></tr>
    <tr><td class="paramname">PdiSrc</td><td>Pointer to the source of PDI </td></tr>
    <tr><td class="paramname">PdiAddr</td><td>is the pointer to the address of the Pdi</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_UNSUPPORTED_SEC_BOOT_MODE on unsupported secondary bootmode.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecBootMode</td><td>is the secondary boot mode value </td></tr>
    <tr><td class="paramname">PdiPtr</td><td>Pointer to the PDI instance </td></tr>
    <tr><td class="paramname">PdiSrc</td><td>is pointer to the source of PDI </td></tr>
    <tr><td class="paramname">PdiAddr</td><td>is the pointer to the address of the Pdi</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_UNSUPPORTED_SEC_BOOT_MODE on unsupported secondary bootmode. </li>
</ul>
</dd></dl>
<ul>
<li>Get the PDI source address for the secondary boot device.</li>
<li>Get the PDI source address for the secondary boot device.</li>
<li>Get the PDI source address for the secondary boot device.</li>
</ul>

<p>References <a class="el" href="xloader_8h.html#afbc78ce060738297f457ad9f7ae07295">XLOADER_SD_RAWBOOT_MASK</a>.</p>

</div>
</div>
<a class="anchor" id="ga27d4a7f2cecd7b051a5418ad7586cac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLoader_GetSHWRoT </td>
          <td>(</td>
          <td class="paramtype">const u32 *&#160;</td>
          <td class="paramname"><em>SHWRoTPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the state of encrypted boot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SHWRoTPtr</td><td>- Always NULL except at time of initialization of SecureStateSHWRoT variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XPLMI_RTCFG_SECURESTATE_SHWROT - Any DEC only fuse is programmed</li>
<li>XPLMI_RTCFG_SECURESTATE_EMUL_SHWROT - PLM is encrypted</li>
<li>XPLMI_RTCFG_SECURESTATE_NONSECURE - Neither DEC only fuses are programmed nor PLM is encrypted </li>
</ul>
</dd></dl>
<ul>
<li>If SHWRoTPtr is not NULL, then set the SecureStateSHWRoT. Otherwise return the previous stored Secure state.</li>
</ul>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga331850d019d28f888cfa3499be80529d">XLoader_AddDeviceStateChangeToScheduler()</a>, <a class="el" href="group__xloader__server__apis.html#ga9df696fd17dec50576f817a1cd1f7105">XLoader_SecureEncInit()</a>, <a class="el" href="group__xloader__server__apis.html#gade5fc1ce6a279c921672d5692df5cf56">XLoader_SetSecureState()</a>, and <a class="el" href="group__xloader__server__apis.html#ga647a935c43dcde43b8f4c308764fbd6d">XLoader_UpdateCfgLimitCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ga31df7acaead3af0dfa1735979d3cee12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XLoader_SecureTempParams* XLoader_GetTempParams </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the pointer to XLoader_SecureTempParams. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to XLoader_SecureTempParams </dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gaa912487046c04b1c90ca418a19ac3e0d">XLoader_ProcessAuthEncPrtn()</a>, <a class="el" href="group__xloader__server__apis.html#ga629ebb0c55462b5cde87f7e91037b8c0">XLoader_PrtnCopy()</a>, <a class="el" href="group__xloader__server__apis.html#gac4b3b88f124856db12efa0ce4d6c81d0">XLoader_ReadAndVerifySecureHdrs()</a>, <a class="el" href="group__xloader__server__apis.html#ga5aef75ed3205f50c75189b7c46099856">XLoader_SecureAuthInit()</a>, <a class="el" href="group__xloader__server__apis.html#ga9df696fd17dec50576f817a1cd1f7105">XLoader_SecureEncInit()</a>, and <a class="el" href="group__xloader__server__apis.html#ga9410756c2dbe4b6bd6cdfce81a5bd7fa">XLoader_SecureInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga610d38218f6d60c5d6ad9880efa6ad35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_HdrMeasurement </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function measures the PDI's meta header data by calculating the hash using SHA3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is the pointer to PDI instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_HDR_MEASUREMENT if error in meta header measurement. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__xloader__server__apis.html#gafbdd06a059cd7970791f71533c47b8d6">XLoader_DataMeasurement()</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a27cccfb3c7b604d554371c7c5b6e8ca3">XLOADER_MEASURE_FINISH</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a52c44b2aa324f1c51bcc8faddd3f3f90">XLOADER_MEASURE_START</a>, and <a class="el" href="aiepg2_2xloader__plat_8h.html#a06ae41365bea45324b30988a11fb3810">XLOADER_MEASURE_UPDATE</a>.</p>

</div>
</div>
<a class="anchor" id="ga168d5df4c9c896833846a6fcc9693451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_IdCodeCheck </td>
          <td>(</td>
          <td class="paramtype">const XilPdi_ImgHdrTbl *&#160;</td>
          <td class="paramname"><em>ImgHdrTbl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the checks of IDCODE and EXTENDED IDCODE. </p>
<pre class="fragment">                    It also supports bypass of subset of these checks.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImgHdrTbl</td><td>pointer to the image header table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_EXT_ID_SI if extended ID code is mismatched with device.</li>
<li>XLOADER_ERR_IDCODE on ID code mismatch.</li>
<li>XLOADER_ERR_EXT_IDCODE on extended ID code mismatch. </li>
</ul>
</dd></dl>
<p>&lt; IdCode as read from IHT</p>
<p>&lt; Extended IdCode as read from IHT</p>
<p>&lt; IdCode as read from Device</p>
<p>&lt; Extended IdCode as read from Device</p>
<p>&lt; Flag to bypass checks</p>
<p>&lt; Flag to indicate IsVC1902-ES1 device</p>
<p>&lt; Flag to indicate Extended IdCode is valid</p>
<ul>
<li>check to bypass entire ID Code Check</li>
<li>Read IdCode and extended Id Code from the image header table and from PMC_TAP register</li>
<li>Determine and fetch the Extended IDCODE (out of two) for checks</li>
<li>Check if the IdCode read is VC1902 ES1</li>
<li>Check if a subset of checks to be bypassed</li>
<li>Error out for the invalid combination of Extended IDCODE - Device. Assumption is that only VC1902-ES1 device can have Extended IDCODE value 0</li>
</ul>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a5d4126f5cf2831e8bcb64e02717808ce">XLOADER_ERR_EXT_ID_SI</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a92ac9984d820ce5dcca03c01176154f6">XLOADER_ERR_EXT_IDCODE</a>, and <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a75210d4b3991b9b0018d6540bfb9644e">XLOADER_ERR_IDCODE</a>.</p>

</div>
</div>
<a class="anchor" id="ga677a618842a76cb8ee935fd0e5bd18fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ImgHdrTblAuth </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function authenticates the image header table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_IHT_GET_DMA if acquiring DMA is failed.</li>
<li>XLOADER_ERR_IHT_COPY_FAIL if IHT copy fails.</li>
<li>XLOADER_ERR_IHT_HASH_CALC_FAIL if IHT hash calculation fails.</li>
<li>XLOADER_ERR_IHT_AUTH_FAIL if IHT authentication fails. </li>
</ul>
</dd></dl>
<ul>
<li>Get DMA instance</li>
<li>Copy Authentication certificate from PDI to PMCRAM</li>
<li>Calculate SHA-3 hash of the image header table</li>
<li>Authenticate Image header table </li>
</ul>

</div>
</div>
<a class="anchor" id="gacb10f2e97fecfb15aae4fed081b02502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the loader instance and registers loader commands with PLM. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure </li>
</ul>
</dd></dl>
<ul>
<li>Initialize the Uart Logs Config</li>
<li>Initialize the loader commands</li>
<li>Initialize the loader interrupts</li>
<li>Set the secure state of boot in registers and global variables</li>
<li>Decrements the count of configuration limiter</li>
<li>Add task to the scheduler to handle Authenticated JTAG message</li>
<li>Add DAP status check task to the scheduler, this is applicable only for VersalNet.</li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga434f49bc94a9078a86451ac5bde637cc">XLoader_AddAuthJtagToScheduler()</a>, <a class="el" href="group__xloader__server__apis.html#ga331850d019d28f888cfa3499be80529d">XLoader_AddDeviceStateChangeToScheduler()</a>, <a class="el" href="xloader__secure_8h.html#a4bad464b42af8b211d6354872c0cb265">XLOADER_BBRAM_CL_DECREMENT_COUNT</a>, <a class="el" href="group__xloader__server__apis.html#ga953be1ba88ede7dedb1f86081b14f221">XLoader_CframeInit()</a>, <a class="el" href="group__xloader__server__apis.html#gaf60991670bc1598b674f3f81d3982caf">XLoader_GetPdiInstance()</a>, <a class="el" href="group__xloader__server__apis.html#ga7318d4d7ae39a9e258676bbb949341d0">XLoader_PlatInit()</a>, <a class="el" href="group__xloader__server__apis.html#gade5fc1ce6a279c921672d5692df5cf56">XLoader_SetSecureState()</a>, and <a class="el" href="group__xloader__server__apis.html#ga647a935c43dcde43b8f4c308764fbd6d">XLoader_UpdateCfgLimitCount()</a>.</p>

</div>
</div>
<a class="anchor" id="ga00abb3a6ba0436f171b8a00656d93057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_InitPdiInstanceForExtractMHAndOptData </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>SrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>DestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>DestSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes PDI Instance pointer for extracting Metaheader and OptionalData. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>Pointer to the command structure </td></tr>
    <tr><td class="paramname">PdiPtr</td><td>Pointer to PdiInstance </td></tr>
    <tr><td class="paramname">SrcAddr</td><td>Address of the PDI </td></tr>
    <tr><td class="paramname">DestAddr</td><td>Address of the destination buffer </td></tr>
    <tr><td class="paramname">DestSize</td><td>Size of the destination buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success</li>
<li>ErrorCode on failure </li>
</ul>
</dd></dl>
<p>Check if Metaheader offset is pointing to a valid location</p>
<p>Extract Metaheader using PdiInit </p>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a60a37abd511a1fae2198bc82ec8674b2">XLOADER_ERR_INVALID_METAHEADER_DEST_ADDR</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a946766aa53ac1a19763fd468418754c5">XLOADER_ERR_INVALID_METAHEADER_OFFSET</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a67012749d6ef70ff0739646dcc414ab5">XLOADER_ERR_INVALID_METAHEADER_SRC_ADDR</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ace50214c38798c1b4c205a643f1a19e6">XLOADER_ERR_INVALID_PDI_INPUT</a>, <a class="el" href="xloader__client_8h.html#af14fcbd99f3aaf94c6ecc1f3689b8485">XLOADER_PDI_SRC_DDR</a>, and <a class="el" href="group__xloader__server__apis.html#gaadc121bcc59feb4ece3c40802d81987b">XLoader_PdiInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga257b3dbbc96ac1826e77aca54f99693c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_IsAdditionalPpkValid </td>
          <td>(</td>
          <td class="paramtype">const u8 *&#160;</td>
          <td class="paramname"><em>PpkHash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function verifies whether the additional PPK is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PpkHash</td><td>is pointer to the PPK hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PpkHash</td><td>is pointer to the PPK hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_FAILURE always return failue, as this api is not applicable for versal_net</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PpkHash</td><td>is pointer to the PPK hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_FAILURE always return failure, as this api is not applicable for versal_net </dd></dl>

<p>References <a class="el" href="group__xloader__server__apis.html#ga6be961c2f80c31d661adab83f62ba790">XLoader_IsPpkValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8122f50322351d61e03c5dd33cf6f635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_IsPdiAddrLookup </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PdiId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>PdiAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the Address based-on PDI Id from Image Store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiId</td><td>Index of the PDI stored </td></tr>
    <tr><td class="paramname">PdiAddr</td><td>Pointer to the PDI address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success</li>
<li>XLOADER_ERR_PDI_LIST_EMPTY if PDI list is empty</li>
<li>XLOADER_ERR_PDI_ADDR_NOT_FOUND if PDI ID not found in list </li>
</ul>
</dd></dl>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a09678d7b7149b02768947884f053af72">XLOADER_ERR_PDI_ADDR_NOT_FOUND</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a1501e4d0f34657ef1150818df01cfba5">XLOADER_ERR_PDI_LIST_EMPTY</a>, and <a class="el" href="group__xloader__server__apis.html#ga3c4719cd0b80cb8626bbd934db116429">XLoader_GetPdiList()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6be961c2f80c31d661adab83f62ba790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_IsPpkValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="xloader__auth__enc_8h.html#a85aba33b166080b4874c0f5657589b3e">XLoader_PpkSel</a>&#160;</td>
          <td class="paramname"><em>PpkSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u8 *&#160;</td>
          <td class="paramname"><em>PpkHash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function reads PPK invalid bits. </p>
<p>If the bits are valid, it compares the provided hash value with the programed hash value. Efuse stores only 256 bits of hash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PpkSelect</td><td>PPK selection of eFUSE. </td></tr>
    <tr><td class="paramname">PpkHash</td><td>Pointer to the PPK hash to be verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_SEC_PPK_INVALID_BIT_ERR if invalid PPK bit set.</li>
<li>XLOADER_SEC_PPK_HASH_ALLZERO_INVLD if PPK hash is all zeros. </li>
</ul>
</dd></dl>
<ul>
<li>Check if lower 256 PPK bits hash is valid or not by reading the PPK EFUSE bits</li>
<li>Check if valid lower 256 bit PPK hash is all zeros </li>
</ul>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga257b3dbbc96ac1826e77aca54f99693c">XLoader_IsAdditionalPpkValid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga443aaeef586ee9cefe8509092d99ca17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_LoadImage </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used load a image in PDI. </p>
<p>PDI can have multiple images present in it. This can be used to load a single image like PL, APU, RPU. This will load all the partitions that are present in that image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is Pdi instance pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_SEM_STOP_SCAN if unable to stop SEM scan.</li>
<li>XLOADER_ERR_CONFIG_SUBSYSTEM if subsystem configuration fails.</li>
<li>XLOADER_ERR_SEM_INIT if unable to start the SEM scan. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__xloader__server__apis.html#gafbdd06a059cd7970791f71533c47b8d6">XLoader_DataMeasurement()</a>, <a class="el" href="xloader_8h.html#a8e7dfbd981e9ffd59d610f0966737376">XLOADER_INVALID_IMG_ID</a>, <a class="el" href="group__xloader__server__apis.html#gacb74ee2f2a0e0dcce9bfdae7750bbc14">XLoader_LoadImagePrtns()</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a27cccfb3c7b604d554371c7c5b6e8ca3">XLOADER_MEASURE_FINISH</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a52c44b2aa324f1c51bcc8faddd3f3f90">XLOADER_MEASURE_START</a>, <a class="el" href="group__xloader__server__apis.html#gaaeb9479f179f61feb1b1368cbe99e562">XLOADER_PCR_MEASUREMENT_INDEX_MASK</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a3678eb84184f7bd1beaa8efc5d946ed5">XLOADER_PDI_SRC_JTAG</a>, <a class="el" href="xloader_8h.html#a1652b4d0eb7aed02ead9dc01a2308f01">XLOADER_PDI_TYPE_FULL</a>, <a class="el" href="xloader__plat__client_8h.html#a32a5a2918cb9e891e72c3501ea804e6c">XLOADER_PDI_TYPE_PARTIAL</a>, and <a class="el" href="group__xloader__server__apis.html#ga3c6d50618fcc0ebd51c6790069b5c5cd">XLoader_SetJtagTapToReset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga304b923a96834575c1fee9eed2ffb870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_LoadImageInfoTbl </td>
          <td>(</td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>DestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>MaxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>NumEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads the ImageInfo table to the given memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DestAddr</td><td>is the 64 bit Destination Address </td></tr>
    <tr><td class="paramname">MaxSize</td><td>is the max size of Buffer present at Destination Address </td></tr>
    <tr><td class="paramname">NumEntries</td><td>that are loaded from the Image Info Table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_INVALID_DEST_IMGINFOTBL_SIZE if destination buffer size is less than the current length of the image info table.</li>
<li>XLOADER_ERR_IMAGE_INFO_TBL_FULL if image info table is full. </li>
</ul>
</dd></dl>
<p>Validate the available length of ImageInfoTable is in the range of Maximum buffer size available</p>
<p>Copy the ImageInfoTable for the given length of table</p>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a3f71c01fe54e37637ebe4adb1871cbba">XLOADER_ERR_IMAGE_INFO_TBL_FULL</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a6e91769f595282c02298b0e07247c470">XLOADER_ERR_INVALID_DEST_IMGINFOTBL_SIZE</a>, and <a class="el" href="group__xloader__server__apis.html#ga8ee855df9e0b6924472583ce2ed0edf9">XLoader_GetImageInfoTbl()</a>.</p>

</div>
</div>
<a class="anchor" id="gacb74ee2f2a0e0dcce9bfdae7750bbc14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_LoadImagePrtns </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads the partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to XilPdi instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_SLD_DETECTED_SKIP_PRTN_PROCESS on secure lockdown.</li>
<li>XPLMI_NPI_ERR on NPI errors. </li>
</ul>
</dd></dl>
<ul>
<li>Validate and load the image partitions.</li>
<li>Clear NPI errors before loading each partition.</li>
<li>Validate the partition header.</li>
<li>If PLM is not partition owner then skip this partition.</li>
<li>Otherwise process the partition.</li>
<li>Skip processing rest of the partitions if secure lockdown is triggered.</li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga2649fc63e039d0ea257ceb1706063594">XLOADER_SUCCESS_NOT_PRTN_OWNER</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga443aaeef586ee9cefe8509092d99ca17">XLoader_LoadImage()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3082e333a47e4fea07fba25bba8582e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_LoadLpdAndPsmElf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will load the LPD and PSM ELF file from DDR. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>Error code on failure </li>
</ul>
</dd></dl>
<p>Memset the PDI instance.</p>
<p>Initialize the PDI to load the LPD subsystem from DDR.</p>
<p>Check if LPD is present in InPlacePLM PDI and get the Image number and Partition number. If LPD is not found, return error.</p>
<p>Load the LPD image.</p>
<p>We need to reset NoOfHandOffCpus here because we don't call StartImage routine</p>
<p>Memset the PDI instance.</p>
<p>Initialize the PDI to load the LPD subsystem from DDR.</p>
<p>Check if LPD is present in InPlacePLM PDI and get the Image number and Partition number. If LPD is not found, return error.</p>
<p>Load the LPD image.</p>
<p>We need to reset NoOfHandOffCpus here because we don't call StartImage routine </p>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a5aeb811cc2167c44b33ac1186e342403">XLOADER_ERR_MEMSET_PDIPTR</a>, <a class="el" href="group__xloader__server__apis.html#ga3ea4300bb5e4bd5116c3d2bf72902824">XLoader_GetImageAndPrtnInfo()</a>, <a class="el" href="group__xloader__server__apis.html#gaf60991670bc1598b674f3f81d3982caf">XLoader_GetPdiInstance()</a>, <a class="el" href="group__xloader__client__apis.html#ga05ffa5255e46703e2b3762b3841104bc">XLoader_LoadImage()</a>, <a class="el" href="xloader__client_8h.html#af14fcbd99f3aaf94c6ecc1f3689b8485">XLOADER_PDI_SRC_DDR</a>, and <a class="el" href="group__xloader__server__apis.html#gaadc121bcc59feb4ece3c40802d81987b">XLoader_PdiInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8493673eccf135010606bf9449bc5ee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_LoadPdi </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xloader_8h.html#a1b158ce0f453a76bb3cf394a719e1828">PdiSrc_t</a>&#160;</td>
          <td class="paramname"><em>PdiSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>PdiAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides loading PDI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is the instance pointer that points to PDI details </td></tr>
    <tr><td class="paramname">PdiSrc</td><td>is source of PDI. It can be in Boot Device or DDR. </td></tr>
    <tr><td class="paramname">PdiAddr</td><td>is the address at PDI is located in the PDI source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__xloader__server__apis.html#gaadc121bcc59feb4ece3c40802d81987b">XLoader_PdiInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga12304b3fe7be1b2e0831cda984875428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_MaskGenFunc </td>
          <td>(</td>
          <td class="paramtype">XSecure_Sha3 *&#160;</td>
          <td class="paramname"><em>Sha3InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>OutLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask generation function with SHA3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Sha3InstancePtr</td><td>is pointer to the XSecure_Sha3 instance. </td></tr>
    <tr><td class="paramname">Out</td><td>is pointer in which output of this function will be stored. </td></tr>
    <tr><td class="paramname">OutLen</td><td>specifies the required length. </td></tr>
    <tr><td class="paramname">Input</td><td>is pointer which holds the input data for which mask should be calculated which should be 48 bytes length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_SEC_BUF_CLEAR_ERR if failed to clear buffer.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Sha3InstancePtr</td><td>is pointer to the XSecure_Sha3 instance. </td></tr>
    <tr><td class="paramname">Out</td><td>is pointer in which output of this function will be stored. </td></tr>
    <tr><td class="paramname">OutLen</td><td>specifies the required length. </td></tr>
    <tr><td class="paramname">Input</td><td>is pointer which holds the input data for which mask should be calculated which should be 48 bytes length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>Errorcode on failure. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xloader_8h.html#a261fb4f12be9886db96079709efd1608">XLOADER_SHA3_LEN</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga1549a54ac384c080bcc344843debcf5e">XLoader_RsaPssSignVerify()</a>.</p>

</div>
</div>
<a class="anchor" id="gab224d645e2c390ff06c8aec01babcae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_MaskGenFunc </td>
          <td>(</td>
          <td class="paramtype">XSecure_Sha *&#160;</td>
          <td class="paramname"><em>ShaInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>OutLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask generation function with SHA3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShaInstancePtr</td><td>is pointer to the XSecure_Sha3 instance. </td></tr>
    <tr><td class="paramname">Out</td><td>is pointer in which output of this function will be stored. </td></tr>
    <tr><td class="paramname">OutLen</td><td>specifies the required length. </td></tr>
    <tr><td class="paramname">Input</td><td>is pointer which holds the input data for which mask should be calculated which should be 48 bytes length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>Errorcode on failure. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="xloader_8h.html#a261fb4f12be9886db96079709efd1608">XLOADER_SHA3_LEN</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a50858612ed6ece8fff88a67b9f30ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_MbPmcI2cHandshake </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parse the handshake command request coming from MB and calls the function for handshake process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_FAILURE Always. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaadc121bcc59feb4ece3c40802d81987b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_PdiInit </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xloader_8h.html#a1b158ce0f453a76bb3cf394a719e1828">PdiSrc_t</a>&#160;</td>
          <td class="paramname"><em>PdiSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>PdiAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the PDI instance with required details and read the meta header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is instance pointer pointing to PDI details </td></tr>
    <tr><td class="paramname">PdiSource</td><td>is source of PDI. It can be any boot Device or DDR </td></tr>
    <tr><td class="paramname">PdiAddr</td><td>is the address at which PDI is located in the PDI source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_UNSUPPORTED_BOOT_MODE on unsupported boot mode. </li>
</ul>
</dd></dl>
<p>Clear the DDR Calib Check RTCA Register.</p>
<ul>
<li>Mark PDI loading is started.</li>
<li>Store address of the structure in PMC_GLOBAL.GLOBAL_GEN_STORAGE4.</li>
<li>Read the PDI source.</li>
<li>Get the PDI source type.</li>
<li>Print the PDI source type.</li>
<li>Get the device copy function for the given boot mode.</li>
<li>Read and validate all the headers in the PDI.</li>
</ul>

<p>References <a class="el" href="xloader_8h.html#a1b158ce0f453a76bb3cf394a719e1828">PdiSrc_t</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a4403f6d235119bd4078254da5fe4b71d">XLOADER_GET_PDISRC_INFO</a>, <a class="el" href="group__xloader__server__apis.html#ga66559b884d7cf9ebdeb4850cc1b32a30">XLoader_GetATFHandoffParamsAddr()</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#ac0421bea5b2e1f1a22cd09dc78488f96">XLOADER_PDI_SRC_USB</a>, <a class="el" href="xloader_8h.html#a1652b4d0eb7aed02ead9dc01a2308f01">XLOADER_PDI_TYPE_FULL</a>, <a class="el" href="xloader__plat__client_8h.html#a32a5a2918cb9e891e72c3501ea804e6c">XLOADER_PDI_TYPE_PARTIAL</a>, <a class="el" href="xloader_8h.html#ab12cb9d0e970d37bd121055708edf695">XLOADER_PDISRC_FLAGS_MASK</a>, <a class="el" href="xloader_8h.html#afbc78ce060738297f457ad9f7ae07295">XLOADER_SD_RAWBOOT_MASK</a>, and <a class="el" href="xloader_8h.html#afe7a2eabaffc84d18d84dcb5a3fc7db5">XLOADER_SSIT_MONOLITIC</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga00abb3a6ba0436f171b8a00656d93057">XLoader_InitPdiInstanceForExtractMHAndOptData()</a>, <a class="el" href="group__xloader__server__apis.html#gad3082e333a47e4fea07fba25bba8582e">XLoader_LoadLpdAndPsmElf()</a>, <a class="el" href="group__xloader__server__apis.html#ga8493673eccf135010606bf9449bc5ee4">XLoader_LoadPdi()</a>, and <a class="el" href="group__xloader__server__apis.html#ga3dbbecc3b2545a3e076d421f086715e6">XLoader_RestartImage()</a>.</p>

</div>
</div>
<a class="anchor" id="ga95eeb47f59afe0b42f06502ee0bd39f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLoader_PerformInternalPOR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function check conditions and perform internal POR for VP1802 and VP1502 device if required. </p>
<ul>
<li>If the device is not an VP1802 Or VP1502, then return without performing IPOR.</li>
<li>If the device is not an master SLR, then return without performing IPOR.</li>
<li>If the bootmode is JTAG or SMAP, then return without performing IPOR.</li>
<li>Efuse DNA_57 bit should be non-zero for IPOR.</li>
<li>Perform IPOR, if all the pre-conditions are met for VP1502/VP1802 device.</li>
</ul>

<p>References <a class="el" href="xloader_8h.html#a1b158ce0f453a76bb3cf394a719e1828">PdiSrc_t</a>, <a class="el" href="group__xloader__server__apis.html#ga01c00225c89279d31e9ee223214a95e4">PLM_VP1802_POR_SETTLE_TIME</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a3678eb84184f7bd1beaa8efc5d946ed5">XLOADER_PDI_SRC_JTAG</a>, and <a class="el" href="aiepg2_2xloader__plat_8h.html#adc24a73fc9d17d8d0d0ed90ba4554737">XLOADER_PDI_SRC_SMAP</a>.</p>

</div>
</div>
<a class="anchor" id="ga7318d4d7ae39a9e258676bbb949341d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_PlatInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the loader with platform specific initializations. </p>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and error code on failure </dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gacb10f2e97fecfb15aae4fed081b02502">XLoader_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa912487046c04b1c90ca418a19ac3e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ProcessAuthEncPrtn </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>DestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs authentication and decryption of the partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance </td></tr>
    <tr><td class="paramname">DestAddr</td><td>is the address to which data is copied </td></tr>
    <tr><td class="paramname">BlockSize</td><td>is size of the data block to be processed which doesn't include padding lengths and hash </td></tr>
    <tr><td class="paramname">Last</td><td>notifies if the block to be processed is last or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_DMA_TRANSFER if DMA transfer fails while copying.</li>
<li>XLOADER_ERR_PRTN_DECRYPT_FAIL if partition decryption fails.</li>
<li>XLOADER_SEC_BUF_CLEAR_SUCCESS if successfully cleared buffer.</li>
<li>XLOADER_SEC_BUF_CLEAR_ERR if failed to clear buffer. </li>
</ul>
</dd></dl>
<ul>
<li>Process the 1st block</li>
<li>Verify encrypted partition is revoked or not</li>
<li>Verify hash</li>
<li>If encryption is enabled, decrypt the data. </li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga31df7acaead3af0dfa1735979d3cee12">XLoader_GetTempParams()</a>, <a class="el" href="xloader__plat__client_8h.html#a32a5a2918cb9e891e72c3501ea804e6c">XLOADER_PDI_TYPE_PARTIAL</a>, <a class="el" href="xloader__auth__enc_8h.html#a691eab17fa691edd1ab22f5c550a28f4">XLOADER_SECURE_HDR_TOTAL_SIZE</a>, <a class="el" href="group__xloader__server__apis.html#ga5054d79a7dcc052ae83d997f183c8779">XLoader_SecureChunkCopy()</a>, <a class="el" href="group__xloader__server__apis.html#ga5ac253b7c53e277edd095f79563590c4">XLoader_SecureConfigMeasurement()</a>, <a class="el" href="xloader_8h.html#a261fb4f12be9886db96079709efd1608">XLOADER_SHA3_LEN</a>, and <a class="el" href="group__xloader__server__apis.html#ga88fdae4e3fe98e871dd93c7cb31ce387">XLoader_VerifyHashNUpdateNext()</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga5aef75ed3205f50c75189b7c46099856">XLoader_SecureAuthInit()</a>, and <a class="el" href="group__xloader__server__apis.html#ga9df696fd17dec50576f817a1cd1f7105">XLoader_SecureEncInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga99e1b8db2c77863361f3d8802cff6d8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ProcessDeferredError </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if MJTAG workaround is required. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XLOADER_ERR_DEFERRED_CDO_PROCESS on error while processing CDO but error is deferred till whole CDO processing is completed. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#ga5c26bcc51fa70b2692ec7448a69422a0">XLoader_DumpDdrmcRegisters()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ee480ef9152cd51e9aabb49fd0515fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ProcessElf </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XilPdi_PrtnHdr *&#160;</td>
          <td class="paramname"><em>PrtnHdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XLoader_PrtnParams *&#160;</td>
          <td class="paramname"><em>PrtnParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecureParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies the elf partitions to specified destinations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to XilPdi instance </td></tr>
    <tr><td class="paramname">PrtnHdr</td><td>is pointer to the partition header </td></tr>
    <tr><td class="paramname">PrtnParams</td><td>is pointer to the structure variable that contains parameters required to process the partition </td></tr>
    <tr><td class="paramname">SecureParams</td><td>is pointer to the instance containing security related params</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_INVALID_ELF_LOAD_ADDR if the load address of the elf is invalid.</li>
<li>XLOADER_ERR_PM_DEV_PSM_PROC if device requet for PSM is failed.</li>
<li>XLOADER_ERR_PM_DEV_IOCTL_RPU0_SPLIT if IOCTL call to set RPU0 in split mode fails.</li>
<li>XLOADER_ERR_PM_DEV_IOCTL_RPU1_SPLIT if IOCTL call to set RPU1 in split mode fails.</li>
<li>XLOADER_ERR_PM_DEV_IOCTL_RPU0_LOCKSTEP if IOCTL call to set RPU0 in lockstep mode fails.</li>
<li>XLOADER_ERR_PM_DEV_IOCTL_RPU1_LOCKSTEP if IOCTL call to set RPU1 in lockstep mode fails.</li>
<li>XLOADER_ERR_INVALID_TCM_ADDR on Invalid TCM address for A72 elfs.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to XilPdi instance </td></tr>
    <tr><td class="paramname">PrtnHdr</td><td>is pointer to the partition header </td></tr>
    <tr><td class="paramname">PrtnParams</td><td>is pointer to the structure variable that contains parameters required to process the partition </td></tr>
    <tr><td class="paramname">SecureParams</td><td>is pointer to the instance containing security related params</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_INVALID_ELF_LOAD_ADDR if load address of the elf is invalid.</li>
<li>XLOADER_ERR_PM_DEV_PSM_PROC if device request for PSM is failed.</li>
<li>XLOADER_ERR_INVALID_R52_CLUSTER if invalid R52 cluster is selected. </li>
</ul>
</dd></dl>
<ul>
<li>Verify the load address.</li>
<li>For PSM, PSM should be taken out of reset before loading. PSM RAM should be ECC initialized</li>
<li>For OCM, RAM should be ECC initialized</li>
<li>R5 should be taken out of reset before loading. R5 TCM should be ECC initialized</li>
<li>Copy the partition to the load address.</li>
<li>Populate handoff parameters to ATF. These correspond to the partitions of application which ATF will be loading.</li>
</ul>
<p>Check if TCM Boot Bit is set</p>
<ul>
<li>Verify the load address.</li>
<li>For PSM, PSM should be taken out of reset before loading. PSM RAM should be ECC initialized</li>
<li>For OCM, RAM should be ECC initialized</li>
<li>R5 should be taken out of reset before loading. R5 TCM should be ECC initialized</li>
<li>Copy the partition to the load address.</li>
<li>Populate handoff parameters to ATF. These correspond to the partitions of application which ATF will be loading.</li>
</ul>
<p>Check if TCM Boot Bit is set</p>
<ul>
<li>Verify the load address.</li>
<li>For PSM, PSM should be taken out of reset before loading. PSM RAM should be ECC initialized</li>
<li>For OCM, RAM should be ECC initialized</li>
<li>R5 should be taken out of reset before loading. R5 TCM should be ECC initialized</li>
<li>Copy the partition to the load address.</li>
<li>Populate handoff parameters to ATF. These correspond to the partitions of application which ATF will be loading.</li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga11a471be6e3406b3fe9d851c16619847">XLoader_ClearATFHandoffParams()</a>, <a class="el" href="group__xloader__server__apis.html#ga629ebb0c55462b5cde87f7e91037b8c0">XLoader_PrtnCopy()</a>, <a class="el" href="group__xloader__server__apis.html#gabdc35282335ca2e17f74dd302d034667">XLOADER_RPU_GLBL_CNTL</a>, <a class="el" href="group__xloader__server__apis.html#ga0b1966d6afb00e55785154bac01c8228">XLoader_SetATFHandoffParameters()</a>, <a class="el" href="group__xloader__server__apis.html#gafb8da78a452c3524858aa626b6a91797">XLOADER_TCM_0</a>, <a class="el" href="group__xloader__server__apis.html#gac7aac7aa870f5c4290d6ad101dbfe39d">XLOADER_TCM_1</a>, <a class="el" href="group__xloader__server__apis.html#ga690701a566a217bfc9daf80efdaa1602">XLOADER_TCMCOMB_MASK</a>, <a class="el" href="group__xloader__server__apis.html#gad403a72b35f69de5a924f73a3508d354">XLOADER_TCMCOMB_SHIFT</a>, and <a class="el" href="group__xloader__server__apis.html#gaafe5cd1245a7aaf54eb6c3d1a1146578">XLoader_UpdateHandoffParam()</a>.</p>

</div>
</div>
<a class="anchor" id="ga629ebb0c55462b5cde87f7e91037b8c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_PrtnCopy </td>
          <td>(</td>
          <td class="paramtype">const XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XLoader_DeviceCopy *&#160;</td>
          <td class="paramname"><em>DeviceCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>SecureParamsPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies partition data to respective target memories. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to XilPdi instance </td></tr>
    <tr><td class="paramname">DeviceCopy</td><td>is pointer to the structure variable with parameters required for copying </td></tr>
    <tr><td class="paramname">SecureParamsPtr</td><td>is pointer to the instance containing security related params</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure </li>
</ul>
</dd></dl>
<p>Verify the destination address range before writing</p>
<ul>
<li>Check if security is enabled and start the partition copy securely. Otherwise copy the partition in non-secure mode.</li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#gafbdd06a059cd7970791f71533c47b8d6">XLoader_DataMeasurement()</a>, <a class="el" href="group__xloader__server__apis.html#ga31df7acaead3af0dfa1735979d3cee12">XLoader_GetTempParams()</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a06ae41365bea45324b30988a11fb3810">XLOADER_MEASURE_UPDATE</a>, <a class="el" href="group__xloader__server__apis.html#ga04bdca8398a9278a9c382ef66ad42ed9">XLoader_SecureCopy()</a>, and <a class="el" href="xloader_8h.html#a261fb4f12be9886db96079709efd1608">XLOADER_SHA3_LEN</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="gac4b3b88f124856db12efa0ce4d6c81d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ReadAndVerifySecureHdrs </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XilPdi_MetaHdr *&#160;</td>
          <td class="paramname"><em>MetaHdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function authenticates and/or decrypts the image headers and partition headers and copies the contents to the corresponding structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>Pointer to the XLoader_SecureParams instance. </td></tr>
    <tr><td class="paramname">MetaHdr</td><td>Pointer to the Meta header table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_HDR_GET_DMA if acquiring DMA fails.</li>
<li>XLOADER_ERR_HDR_AES_OP_FAIL if AES initialization fails.</li>
<li>XLOADER_ERR_METAHDR_LEN_OVERFLOW on meta header length overflow.</li>
<li>XLOADER_ERR_HDR_COPY_FAIL on IH/PH header copy fail.</li>
<li>XLOADER_ERR_SEC_IH_READ_FAIL on image header read fail.</li>
<li>XLOADER_ERR_SEC_IH_VERIFY_FAIL on image header verify fail.</li>
<li>XLOADER_ERR_HDR_NOT_SECURE if neither authentication nor encryption is enabled for IH/PH.</li>
<li>XLOADER_ERR_SEC_PH_READ_FAIL if partition header read fails.</li>
<li>XLOADER_ERR_SEC_PH_VERIFY_FAIL if partition header verification fails. </li>
</ul>
</dd></dl>
<ul>
<li>Initialize AES driver</li>
<li>Validate Meta header length</li>
<li>Read headers to a buffer</li>
<li>Read IHT and PHT to buffers along with encryption overhead</li>
<li>Authenticate headers and decrypt the headers</li>
<li>Decrypt the headers</li>
<li>Read IHT and PHT to structures and verify checksum</li>
<li>Verify Meta header is revoked or not</li>
<li>Update buffer address to point to PHs</li>
<li>Authenticate Image headers and partition headers </li>
</ul>

<p>References <a class="el" href="xloader__auth__enc_8h.html#abf854bbd429c87a80e3a56f61abfd265">XLOADER_AUTH_CERT_MIN_SIZE</a>, <a class="el" href="xloader_8h.html#a732b3b1ac340dbfdb48da621a9d32071">XLOADER_CHUNK_SIZE</a>, <a class="el" href="group__xloader__server__apis.html#ga31df7acaead3af0dfa1735979d3cee12">XLoader_GetTempParams()</a>, and <a class="el" href="aiepg2_2xloader__plat_8h.html#a3944db2060fd83c89b79580dd0caa0de">XLOADER_SECURE_CHUNK_SIZE</a>.</p>

</div>
</div>
<a class="anchor" id="ga256f3577575dfc0f2b9de5df039a2f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ReadDdrCryptoPerfCounters </td>
          <td>(</td>
          <td class="paramtype">XPlmi_Cmd *&#160;</td>
          <td class="paramname"><em>Cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads DDR crypto performance counters of given DDR device id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Cmd</td><td>is pointer to the command structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
</ul>
</dd></dl>
<ul>
<li>ErrorCode on Failure. </li>
</ul>
<p>Get DDRMC UB Base address</p>
<p>Read PCSR control status</p>
<p>Read DDR crypto counters</p>
<p>Get DDRMC UB Base address</p>
<p>Read PCSR control status</p>
<p>Read DDR crypto counters </p>

<p>References <a class="el" href="group__xloader__server__apis.html#ga280195c8872446ce29567b7a5dff7486">XLOADER_CMD_GET_DDR_DEVICE_ID</a>, <a class="el" href="group__xloader__server__apis.html#gaab68989608ddaae8e60e757fe4261c06">XLOADER_DDR_CRYPTO_MAIN_OFFSET</a>, <a class="el" href="group__xloader__server__apis.html#ga08f25e90d333d2cb81e08b8b0889a9d6">XLOADER_DDR_PERF_MON_CNT0_OFFSET</a>, <a class="el" href="group__xloader__server__apis.html#ga98c71f1b4c75ad9161caecb08ef0400a">XLOADER_DDR_PERF_MON_CNT1_OFFSET</a>, <a class="el" href="group__xloader__server__apis.html#gadee2c86cf56654f376ad72d8132a08d8">XLOADER_DDR_PERF_MON_CNT2_OFFSET</a>, <a class="el" href="group__xloader__server__apis.html#ga66ee459f51efdeb7666d9e790e539d36">XLOADER_DDR_PERF_MON_CNT3_OFFSET</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a83c4396c2addb02e462194a3675ddcea">XLOADER_ERR_DDR_DEVICE_ID</a>, and <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a884fb6887a49557dc740784b436e3a01">XLOADER_ERR_PCOMPLETE_NOT_DONE</a>.</p>

</div>
</div>
<a class="anchor" id="gafa91a58dad6f9d08c018cbf914f7202c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_ReadImageStoreCfg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read the Image Store DDR Memory Addr. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure </li>
</ul>
</dd></dl>
<ul>
<li>Read &amp; Populate Image Store base address,size from RTCA area.</li>
<li>Validate if address is unaligned.</li>
</ul>
<p>Verify the image store address range</p>
<ul>
<li>Update the PDI image store address in the image list.</li>
</ul>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a2e6672ac09c793155931a0b6a2401ce3">XLOADER_ERR_INVALID_IMAGE_STORE_ADDRESS</a>, <a class="el" href="group__xloader__server__apis.html#ga3c4719cd0b80cb8626bbd934db116429">XLoader_GetPdiList()</a>, <a class="el" href="xloader_8h.html#abd92637607e4c3b9763909501b74e53d">XLOADER_IMG_STORE_INVALID_ADDR</a>, and <a class="el" href="xloader_8h.html#adbc3b9297a363fb6e4d32eae5981995e">XLOADER_IMG_STORE_INVALID_SIZE</a>.</p>

</div>
</div>
<a class="anchor" id="ga3dbbecc3b2545a3e076d421f086715e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_RestartImage </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ImageId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>FuncID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to restart the image in PDI. </p>
<p>This function will take ImageId as an input and based on the subsystem info available, it will read the image partitions, loads them and hand-off to the required CPUs as part of the image load.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ImageId</td><td>Id of the image present in PDI </td></tr>
    <tr><td class="paramname">FuncID</td><td>is verified with the FuncID present in PDI</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure </li>
</ul>
</dd></dl>
<ul>
<li>Scan through PdiList for the given ImageId and restart image from that respective PDI if ImageId is found</li>
<li>Load image from BootPdi if the image is not found or loading is unsuccessful from the PdiList</li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga6c3b5e104f9dadbef8b3c59d683bd332">XLoader_GetBootPdiInfo()</a>, <a class="el" href="group__xloader__server__apis.html#gaf60991670bc1598b674f3f81d3982caf">XLoader_GetPdiInstance()</a>, <a class="el" href="group__xloader__server__apis.html#ga3c4719cd0b80cb8626bbd934db116429">XLoader_GetPdiList()</a>, <a class="el" href="xloader_8h.html#ab2378f829282076dd8a9caaa96dbd2c6">XLOADER_PDI_LOAD_COMPLETE</a>, <a class="el" href="xloader__client_8h.html#af14fcbd99f3aaf94c6ecc1f3689b8485">XLOADER_PDI_SRC_DDR</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#a3678eb84184f7bd1beaa8efc5d946ed5">XLOADER_PDI_SRC_JTAG</a>, <a class="el" href="aiepg2_2xloader__plat_8h.html#adc24a73fc9d17d8d0d0ed90ba4554737">XLOADER_PDI_SRC_SMAP</a>, <a class="el" href="xloader_8h.html#a1652b4d0eb7aed02ead9dc01a2308f01">XLOADER_PDI_TYPE_FULL</a>, <a class="el" href="xloader__plat__client_8h.html#a32a5a2918cb9e891e72c3501ea804e6c">XLOADER_PDI_TYPE_PARTIAL</a>, <a class="el" href="group__xloader__server__apis.html#gaadc121bcc59feb4ece3c40802d81987b">XLoader_PdiInit()</a>, and <a class="el" href="group__xloader__server__apis.html#gabdd3f08598453e93f5b6ce59411c1824">XLoader_StartImage()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7aa62422fdc9b21c619499f950bc07bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_RsaKat </td>
          <td>(</td>
          <td class="paramtype">XPmcDma *&#160;</td>
          <td class="paramname"><em>PmcDmaPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function runs the KAT for RSA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PmcDmaPtr</td><td>- Pointer to DMA instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PmcDmaPtr</td><td>- Pointer to DMA instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga1549a54ac384c080bcc344843debcf5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_RsaPssSignVerify </td>
          <td>(</td>
          <td class="paramtype">XPmcDma *&#160;</td>
          <td class="paramname"><em>PmcDmaInstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>MsgHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XSecure_Rsa *&#160;</td>
          <td class="paramname"><em>RsaInstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>Signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>KeySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function encrypts the RSA signature provided and performs required PSS operations to extract salt and calculates M prime hash and compares with hash obtained from EM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PmcDmaInstPtr</td><td>Pointer to DMA instance </td></tr>
    <tr><td class="paramname">MsgHash</td><td>of the data to be authenticated. </td></tr>
    <tr><td class="paramname">RsaInstPtr</td><td>is pointer to the XSecure_Rsa instance. </td></tr>
    <tr><td class="paramname">Signature</td><td>is pointer to RSA signature for data to be authenticated. </td></tr>
    <tr><td class="paramname">KeySize</td><td>is size of RSA key in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_SEC_MEMSET_ERROR and XLOADER_SEC_RSA_MEMSET_SHA3_ARRAY_FAIL if failed to create memory for RSA SHA3.</li>
<li>XLOADER_SEC_MEMSET_ERROR and XLOADER_SEC_RSA_MEMSET_VARSCOM_FAIL if failed to create memory for RSA varscom.</li>
<li>XLOADER_SEC_RSA_PSS_ENC_BC_VALUE_NOT_MATCHED if failed to match with RSA ENC 0xbc value.</li>
<li>XLOADER_SEC_MASKED_DB_MSB_ERROR if error in RSA EM MSB.</li>
<li>XLOADER_SEC_RSA_PSS_SIGN_VERIFY_FAIL if failed to verify RSA PSS signature.</li>
<li>XLOADER_SEC_EFUSE_DB_PATTERN_MISMATCH_ERROR if failed to verify database in efuse.</li>
<li>XLOADER_SEC_RSA_PSS_HASH_COMPARE_FAILURE if RSA PSS hash is not matched.</li>
<li>XLOADER_SEC_BUF_CLEAR_ERR if failed to clear buffer. </li>
</ul>
</dd></dl>
<ul>
<li>Initialise Buffer variable to store HashMgf and DB.</li>
<li>RSA signature encryption with public key components.</li>
<li>Check for signature encrypted message.</li>
<li>Extract Salt and Generate DB from masked DB and Hash.</li>
<li>XOR MGF output with masked DB from EM to get DB.</li>
<li>Check DB = PS &lt;414 zeros&gt; || 0x01.</li>
<li>Hash on M prime</li>
<li>Compare MPrime Hash with Hash from EM </li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga12304b3fe7be1b2e0831cda984875428">XLoader_MaskGenFunc()</a>, <a class="el" href="xloader__auth__enc_8h.html#a6bcff18daf58c88499df452799e7bcd5">XLOADER_PARTITION_SIG_SIZE</a>, <a class="el" href="group__xloader__server__apis.html#ga98ac029ac7965b392e6bb0097876fd94">XLOADER_RSA_EM_MSB_INDEX</a>, <a class="el" href="group__xloader__server__apis.html#gab5e43af745222cb78f6a71853c891183">XLOADER_RSA_PSS_MSB_PADDING_MASK</a>, <a class="el" href="xloader__auth__enc_8h.html#a4d1f3cc7abae866a021988424e97f30c">XLOADER_RSA_SIG_EXP_BYTE</a>, and <a class="el" href="xloader_8h.html#a261fb4f12be9886db96079709efd1608">XLOADER_SHA3_LEN</a>.</p>

</div>
</div>
<a class="anchor" id="ga7be2984f0912856671c01e2132da604d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xloader_SaveBootPdiInfo </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>BootPdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to save the BootPDI info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BootPdiPtr</td><td>Pointer to the PDI instance </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__xloader__server__apis.html#ga6c3b5e104f9dadbef8b3c59d683bd332">XLoader_GetBootPdiInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5aef75ed3205f50c75189b7c46099856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SecureAuthInit </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XilPdi_PrtnHdr *&#160;</td>
          <td class="paramname"><em>PrtnHdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes authentication parameters of XLoader_SecureParams's instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance. </td></tr>
    <tr><td class="paramname">PrtnHdr</td><td>is pointer to XilPdi_PrtnHdr instance that has to be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_INIT_AC_COPY_FAIL if failed to copy authentication certificate from flash device. </li>
</ul>
</dd></dl>
<ul>
<li>Check if authentication is enabled and copy authentication certificate from PDI source to memory location provided in image header. Also initialize the required SecurePtr members.</li>
</ul>

<p>References <a class="el" href="xloader__auth__enc_8h.html#abf854bbd429c87a80e3a56f61abfd265">XLOADER_AUTH_CERT_MIN_SIZE</a>, <a class="el" href="group__xloader__server__apis.html#ga31df7acaead3af0dfa1735979d3cee12">XLoader_GetTempParams()</a>, and <a class="el" href="group__xloader__server__apis.html#gaa912487046c04b1c90ca418a19ac3e0d">XLoader_ProcessAuthEncPrtn()</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga9410756c2dbe4b6bd6cdfce81a5bd7fa">XLoader_SecureInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5054d79a7dcc052ae83d997f183c8779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SecureChunkCopy </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>SrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>BlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>TotalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies the data from SrcAddr to chunk memory during processing of secure partitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance </td></tr>
    <tr><td class="paramname">SrcAddr</td><td>is the source address from which the data is to be processed or copied </td></tr>
    <tr><td class="paramname">Last</td><td>notifies if the block to be processed is last or not </td></tr>
    <tr><td class="paramname">BlockSize</td><td>is size of the data block to be processed which doesn't include padding lengths and hash. </td></tr>
    <tr><td class="paramname">TotalSize</td><td>is pointer to TotalSize which has to be processed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_DATA_COPY_FAIL if failed to copy data to PMC RAM. </li>
</ul>
</dd></dl>
<ul>
<li>Copy the next chunk securely, and then wait for the process to be completed.</li>
<li>The following initialization is crucial as the authentication certificate and PUF data are now stored in the PMC RAM instead of the PPU1 RAM. During the processing of the first chunk of any partition, the second 32K chunk of the PMC RAM, starting from 0xf2008120, contains the authentication certificate and PUF data as applicable. As a result, the second chunk of the partition must be loaded at 0xf2000020, not at 0xf2008120. Therefore, double buffering is disabled when processing the first chunk, and only enabled from the second chunk onwards. The third chunk is loaded at 0xf2008120, and from then on, the chunks are loaded alternatively to the two 32KB chunks of the PMC RAM.</li>
</ul>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gaa912487046c04b1c90ca418a19ac3e0d">XLoader_ProcessAuthEncPrtn()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9171035e129091fbaddbc27756381f76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SecureClear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called to clear secure critical data in case of exceptions. </p>
<p>The function also places AES, ECDSA_RSA and SHA3 in reset.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_SECURE_CLEAR_FAIL if failed to clear AES, RSA, SHA3 engines. </li>
</ul>
</dd></dl>
<p>Place SHA3 in reset </p>

<p>References <a class="el" href="group__xloader__server__apis.html#ga22f293db863b881993077e17fc892007">XLoader_AuthEncClear()</a>, <a class="el" href="group__xloader__server__apis.html#gae1ad484f4b4344573008a1fa138ad597">XLOADER_SHA3_RESET_REG</a>, and <a class="el" href="group__xloader__server__apis.html#ga18a802ef19167e4a011890ac7bf61f7d">XLOADER_SHA3_RESET_VAL</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ac253b7c53e277edd095f79563590c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SecureConfigMeasurement </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PcrInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>DigestIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>OverWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function measures the Secure Configuration that is SPK, SPK ID and Encryption Revoke ID and extends to the specified PCR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance. </td></tr>
    <tr><td class="paramname">PcrInfo</td><td>provides the PCR number and Measurement Index to be extended. </td></tr>
    <tr><td class="paramname">DigestIndex</td><td>is pointer to the DigestIndex across the PCR </td></tr>
    <tr><td class="paramname">OverWrite</td><td>TRUE or FALSE to overwrite the extended digest or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_SECURE_CONFIG_MEASUREMENT if error in Secure config measurement. </li>
</ul>
</dd></dl>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gaa912487046c04b1c90ca418a19ac3e0d">XLoader_ProcessAuthEncPrtn()</a>.</p>

</div>
</div>
<a class="anchor" id="ga04bdca8398a9278a9c382ef66ad42ed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SecureCopy </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>DestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads secure non-cdo partitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance. </td></tr>
    <tr><td class="paramname">DestAddr</td><td>is load address of the partition. </td></tr>
    <tr><td class="paramname">Size</td><td>is unencrypted size of the partition in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success and error code on failure </li>
</ul>
</dd></dl>
<ul>
<li>Update the length for last chunk</li>
<li>Process the partition.</li>
<li>Update variables for next chunk</li>
<li>On failure clear data at destination address </li>
</ul>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#a3944db2060fd83c89b79580dd0caa0de">XLOADER_SECURE_CHUNK_SIZE</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga629ebb0c55462b5cde87f7e91037b8c0">XLoader_PrtnCopy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9df696fd17dec50576f817a1cd1f7105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SecureEncInit </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XilPdi_PrtnHdr *&#160;</td>
          <td class="paramname"><em>PrtnHdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes encryption parameters of XLoader_SecureParams's instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance. </td></tr>
    <tr><td class="paramname">PrtnHdr</td><td>is pointer to XilPdi_PrtnHdr instance that has to be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_INIT_CHECKSUM_INVLD_WITH_AUTHDEC if both checksum and authentication or encryption are enabled.</li>
<li>XLOADER_ERR_PRTN_DECRYPT_NOT_ALLOWED if Partition is not allowed to be encrypted if State of boot is non secure.</li>
<li>XLOADER_ERR_GLITCH_DETECTED if glitch is detected.</li>
<li>XLOADER_ERR_PRTN_ENC_ONLY_KEYSRC on invalid key source when only encryption is enabled. </li>
</ul>
</dd></dl>
<ul>
<li>Check if encryption is enabled</li>
<li>Error out if checksum is enabled along with authentication or encryption.</li>
<li>Run AES Kat test if the image is encrypted and metaheader is not encrypted</li>
<li>Check secure state of boot as partition is allowed to be encrypted only if Secure state of boot is S-HWRoT, Emul S-HWRoT, A-HWRoT or Emul A-HWRoT.</li>
<li>Check Secure State of the device. If S-HWRoT is enabled, then validate keysrc</li>
</ul>

<p>References <a class="el" href="xloader__auth__enc_8h.html#aa5719aab46c8fcdb925a9d488c776cc1">XLOADER_BBRAM_KEY</a>, <a class="el" href="group__xloader__server__apis.html#gacb572c209348e5ec41f2e15c92de9c36">XLoader_CheckSecureState()</a>, <a class="el" href="xloader__auth__enc_8h.html#a03ec82dda650d2b8fb4249e30ff395e2">XLOADER_EFUSE_KEY</a>, <a class="el" href="group__xloader__server__apis.html#ga3e99458db1239a8f1bcb70eee9025232">XLoader_GetAHWRoT()</a>, <a class="el" href="group__xloader__server__apis.html#ga27d4a7f2cecd7b051a5418ad7586cac3">XLoader_GetSHWRoT()</a>, <a class="el" href="group__xloader__server__apis.html#ga31df7acaead3af0dfa1735979d3cee12">XLoader_GetTempParams()</a>, <a class="el" href="group__xloader__server__apis.html#gaa912487046c04b1c90ca418a19ac3e0d">XLoader_ProcessAuthEncPrtn()</a>, and <a class="el" href="xloader_8h.html#a261fb4f12be9886db96079709efd1608">XLOADER_SHA3_LEN</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga9410756c2dbe4b6bd6cdfce81a5bd7fa">XLoader_SecureInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9410756c2dbe4b6bd6cdfce81a5bd7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SecureInit </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>PrtnNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes XLoader_SecureParams's instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance. </td></tr>
    <tr><td class="paramname">PdiPtr</td><td>is pointer to the XilPdi instance </td></tr>
    <tr><td class="paramname">PrtnNum</td><td>is the partition number to be processed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_MEMSET_SECURE_PTR if failed to set memory for secure pointer.</li>
<li>XLOADER_ERR_INIT_GET_DMA if failed to get DMA instance during initialization. </li>
</ul>
</dd></dl>
<ul>
<li>Initialize XLoader_SecureParms instance with zeros.</li>
<li>Initialize XLoader_SecureTempParams instance with zeros.</li>
<li>Read partition header from meta header.</li>
<li>The following initialization is crucial as the authentication certificate and PUF data are now stored in the PMC RAM instead of the PPU1 RAM. During the processing of the first chunk of any partition, the second 32K chunk of the PMC RAM, starting from 0xf2008120, contains the authentication certificate and PUF data as applicable. As a result, the second chunk of the partition must be loaded at 0xf2000020, not at 0xf2008120. Therefore, double buffering is disabled when processing the first chunk, and only enabled from the second chunk onwards. The third chunk is loaded at 0xf2008120, and from then on, the chunks are loaded alternatively to the two 32KB chunks of the PMC RAM.</li>
<li>Get DMA instance</li>
<li>Initialize the checksum.</li>
<li>Initialize the authentication.</li>
<li>Initialize the encryption. </li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga31df7acaead3af0dfa1735979d3cee12">XLoader_GetTempParams()</a>, <a class="el" href="group__xloader__server__apis.html#ga5aef75ed3205f50c75189b7c46099856">XLoader_SecureAuthInit()</a>, and <a class="el" href="group__xloader__server__apis.html#ga9df696fd17dec50576f817a1cd1f7105">XLoader_SecureEncInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d852b900fa863fa8719bba0e2699423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SecureValidations </td>
          <td>(</td>
          <td class="paramtype">const XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if authentication/encryption is compulsory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_GLITCH_DETECTED if glitch is detected.</li>
<li>XLOADER_ERR_AUTH_EN_PPK_HASH_ZERO if PPK not programmed and authentication is enabled</li>
<li>XLOADER_ERR_HWROT_EFUSE_AUTH_COMPULSORY if PPK Programmed but eFuse authentication is disabled.</li>
<li>XLOADER_ERR_ENCONLY_ENC_COMPULSORY if encryption is disabled.</li>
<li>XLOADER_ERR_METAHDR_KEYSRC_MISMATCH if metaheader Key Source does not match PLM Key Source. </li>
</ul>
</dd></dl>
<ul>
<li>Check Secure State of device if A-HWROT is enabled then authentication is mandatory for metaheader and BHDR authentication must be disabled.</li>
<li>Check Secure State of the device. If S-HWRoT is enabled, then metaheader must be encrypted.</li>
<li>Verify if Metaheader encryption key source for FPDI/PPDI is same as PLM Key source in Bootheader.</li>
</ul>

</div>
</div>
<a class="anchor" id="ga0b1966d6afb00e55785154bac01c8228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLoader_SetATFHandoffParameters </td>
          <td>(</td>
          <td class="paramtype">const XilPdi_PrtnHdr *&#160;</td>
          <td class="paramname"><em>PrtnHdr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the handoff parameters to the ARM Trusted Firmware(ATF). </p>
<p>Some of the inputs for this are taken from image partition header. A pointer to the structure containing these parameters is stored in the PMC_GLOBAL.GLOBAL_GEN_STORAGE4 register, which ATF reads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PrtnHdr</td><td>is pointer to Partition header details </td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Read partition header and deduce entry point and partition flags.</li>
<li>Update CPU number based on destination CPU</li>
<li>Read partition header and deduce entry point and partition flags.</li>
<li>Update cluster number based on destination cluster number.</li>
<li>Update CPU number based on destination CPU</li>
<li>Read partition header and deduce entry point and partition flags.</li>
<li>Update cluster number based on destination cluster number.</li>
<li>Update CPU number based on destination CPU </li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#ga66559b884d7cf9ebdeb4850cc1b32a30">XLoader_GetATFHandoffParamsAddr()</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c6d50618fcc0ebd51c6790069b5c5cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLoader_SetJtagTapToReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to run MJTAG solution workaround in which JTAG Tap state will be set to reset. </p>
<ul>
<li>Based on Vivado property, check whether to apply MJTAG workaround or not. By default vivado property disables MJTAG workaround.</li>
<li>Skip applying MJTAG workaround if already applied</li>
<li>Check if End of PL Startup is asserted or not</li>
<li>Enable MJTAG</li>
<li>Toggle MJTAG ISO to generate clock pulses, default 10 clock pulses</li>
<li>Disable MJTAG </li>
</ul>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga443aaeef586ee9cefe8509092d99ca17">XLoader_LoadImage()</a>.</p>

</div>
</div>
<a class="anchor" id="gade5fc1ce6a279c921672d5692df5cf56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_SetSecureState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the value of PPK efuse bits, DEC only efuse bits and fields in bootheader and accordingly sets the Secure State of boot. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on SUCCESS and error code in case of failure.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Secure State of the device will be stored in two 32-bit registers in RTC area of PMCRAM and two global variables -one for authenticated boot and other for encrypted boot, for redundancy. </dd></dl>
<ul>
<li>Check secure state for authentication</li>
<li>Set the secure state for authentication in register and global variable.</li>
<li>Check secure state for encryption.</li>
<li>Read DEC_ONLY efuse bits.</li>
<li>If more than one DEC_ONLY efuse bits are programmed, then set the SHWRoT register.</li>
<li>If none of the DEC_ONLY efuse bits are programmed and PLM is encrypted, then set the SHWRoT register.</li>
<li>If none of the DEC_ONLY efuse bits are programmed and PLM is not encrypted, then set the SHWRoT register.</li>
</ul>

<p>References <a class="el" href="group__xloader__server__apis.html#gab971c3f4e75170b57d1f5fdcd51cc092">XLoader_CheckSecureStateAuth()</a>, <a class="el" href="xloader__secure_8h.html#a483a3cd071fb861c4ce0ab0174c8b829">XLOADER_EFUSE_SEC_DEC_MASK</a>, <a class="el" href="xloader__secure_8h.html#a97c1c4a75d3823f9ecaa3d6eb2294e9c">XLOADER_EFUSE_SEC_MISC0_OFFSET</a>, <a class="el" href="group__xloader__server__apis.html#ga3e99458db1239a8f1bcb70eee9025232">XLoader_GetAHWRoT()</a>, and <a class="el" href="group__xloader__server__apis.html#ga27d4a7f2cecd7b051a5418ad7586cac3">XLoader_GetSHWRoT()</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gacb10f2e97fecfb15aae4fed081b02502">XLoader_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga98700d17bfbbf3cf29e418a784745169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XLoader_SkipMJtagWorkAround </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if MJTAG workaround partition needs to be skipped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to PDI instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if MTAG workaround partition needs to be skipped, else FALSE </dd></dl>
<p>Skip MJTAG WA2 partitions if boot mode is JTAG and Reset Reason is not external POR</p>

<p>References <a class="el" href="aiepg2_2xloader__plat_8h.html#a3678eb84184f7bd1beaa8efc5d946ed5">XLOADER_PDI_SRC_JTAG</a>.</p>

</div>
</div>
<a class="anchor" id="ga56a9ce1c4ab7abdcba0759e1165c8e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Xloader_SsitEoPdiSync </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will sync the PDI load status with master if End of PDI SYNC bit is enabled in IHT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to PDI instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-XST_SUCCESS if no issue in EoPDI sync -XPLMI_ERR_SSIT_EOPDI_SYNC if error in EoPDI Sync </dd></dl>
<ul>
<li>Validate if End of PDI SYNC enabled in Slave PDI. Otherwise return XST_SUCCESS.</li>
<li>Validate if end of PDI Sync bit set in IHT Attribute. Otherwise return XST_SUCCESS.</li>
<li>Sync with master to update slave status.</li>
</ul>

<p>References <a class="el" href="xloader_8h.html#afe7a2eabaffc84d18d84dcb5a3fc7db5">XLOADER_SSIT_MONOLITIC</a>.</p>

</div>
</div>
<a class="anchor" id="gabdd3f08598453e93f5b6ce59411c1824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_StartImage </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to start the subsystems in the PDI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>Pdi instance pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_WAKEUP_A72_0 if waking up the A72-0 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_A72_1 if waking up the A72-1 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_R5_0 if waking up the R5-0 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_R5_1 if waking up the R5-1 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_R5_L if waking up the R5-L failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_PSM if waking up the PSM failed during handoff.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>Pdi instance pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_WAKEUP_R52_0 if waking up the R52_0 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_R52_0 if waking up the R52_1 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_A78_0 if waking up the A78_0 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_A78_1 if waking up the A78_1 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_A78_2 if waking up the A78_2 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_A78_3 if waking up the A78_3 failed during handoff.</li>
<li>XLOADER_ERR_WAKEUP_PSM if waking up the PSM failed during handoff. </li>
</ul>
</dd></dl>
<ul>
<li>Start Handoff to the cpus</li>
<li>Wake up each processor</li>
<li>Start Handoff to the cpus</li>
<li>Wake up each processor</li>
<li>Make Number of handoff CPUs to zero.</li>
<li>Start Handoff to the cpus</li>
<li>Wake up each processor</li>
<li>Make Number of handoff CPUs to zero.</li>
</ul>

<p>References <a class="el" href="xloader_8h.html#a9c2c59c675ae6513a4ec1ab298f9caf1">XLoader_Printf</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga3dbbecc3b2545a3e076d421f086715e6">XLoader_RestartImage()</a>.</p>

</div>
</div>
<a class="anchor" id="ga647a935c43dcde43b8f4c308764fbd6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_UpdateCfgLimitCount </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>UpdateFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the configuration limiter count if Configuration limiter feature is enabled in case of secure boot. </p>
<pre class="fragment">    In case of eny error, secure lockdown is triggered.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UpdateFlag</td><td>- Indicates id the counter should be incremented or decremeted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success. Error code in case of failure </dd></dl>

<p>References <a class="el" href="xloader__secure_8h.html#a4bad464b42af8b211d6354872c0cb265">XLOADER_BBRAM_CL_DECREMENT_COUNT</a>, <a class="el" href="xloader__secure_8h.html#ac1a5aaf74405026b6bae569bc422bace">XLOADER_BBRAM_CL_INCREMENT_COUNT</a>, <a class="el" href="group__xloader__server__apis.html#gacb572c209348e5ec41f2e15c92de9c36">XLoader_CheckSecureState()</a>, <a class="el" href="group__xloader__server__apis.html#ga3e99458db1239a8f1bcb70eee9025232">XLoader_GetAHWRoT()</a>, and <a class="el" href="group__xloader__server__apis.html#ga27d4a7f2cecd7b051a5418ad7586cac3">XLoader_GetSHWRoT()</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gacb10f2e97fecfb15aae4fed081b02502">XLoader_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga36eeb66375a1d833608e9869ac5e8c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_UpdateHandler </td>
          <td>(</td>
          <td class="paramtype">XPlmi_ModuleOp&#160;</td>
          <td class="paramname"><em>Op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function provides update handler for xilloader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Op</td><td>is the module operation variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XST_SUCCESS on success and error code on failure </dd></dl>
<ul>
<li>Remove Scheduler tasks if they already exist.</li>
<li>Disable SBI Interrupt</li>
<li>Add Scheduler tasks if they are removed during shutdown init</li>
</ul>
<p>Enable SBI Interrupt</p>
<ul>
<li>Remove Scheduler tasks if they already exist.</li>
<li>Disable SBI Interrupt</li>
<li>Add Scheduler tasks if they are removed during shutdown init</li>
</ul>
<p>Enable SBI Interrupt </p>

<p>References <a class="el" href="xloader_8h.html#a7e018fe67fe40d7db1fee76204c70078">XLOADER_AUTH_JTAG_INT_STATUS_POLL_INTERVAL</a>, <a class="el" href="group__xloader__server__apis.html#ga5ab0ef6b838c9f3d87f5f6566065938a">XLoader_CheckAuthJtagIntStatus()</a>, and <a class="el" href="group__xloader__server__apis.html#ga53a30d478b54d5ef349ca169085eb7b8">XLoader_CheckDeviceStateChange()</a>.</p>

</div>
</div>
<a class="anchor" id="gaafe5cd1245a7aaf54eb6c3d1a1146578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_UpdateHandoffParam </td>
          <td>(</td>
          <td class="paramtype">XilPdi *&#160;</td>
          <td class="paramname"><em>PdiPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to update the handoff parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to XilPdi instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_NUM_HANDOFF_CPUS when number of CPUs exceed max count.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PdiPtr</td><td>is pointer to XilPdi instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_NUM_HANDOFF_CPUS if number of CPUs exceeds max count. </li>
</ul>
</dd></dl>
<ul>
<li>Get the destination CPU from the partition header.</li>
<li>Validate the destination CPU.</li>
<li>Update the CPU settings.</li>
<li>Assign the partition header to local variable</li>
<li>Update the CPU settings</li>
<li>Assign the partition header to local variable</li>
<li>Update the CPU settings </li>
</ul>

<p>References <a class="el" href="xloader_8h.html#ac08a01801ca8b16fa3fa2482e109bbf4">XLOADER_MAX_HANDOFF_CPUS</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#ga4ee480ef9152cd51e9aabb49fd0515fd">XLoader_ProcessElf()</a>.</p>

</div>
</div>
<a class="anchor" id="ga88fdae4e3fe98e871dd93c7cb31ce387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLoader_VerifyHashNUpdateNext </td>
          <td>(</td>
          <td class="paramtype">XLoader_SecureParams *&#160;</td>
          <td class="paramname"><em>SecurePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&#160;</td>
          <td class="paramname"><em>DataAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>Last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates hash and compares with expected hash. </p>
<pre class="fragment">                    For every block, hash of next block is updated into expected hash.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SecurePtr</td><td>is pointer to the XLoader_SecureParams instance. </td></tr>
    <tr><td class="paramname">DataAddr</td><td>is the address of the data present in the block </td></tr>
    <tr><td class="paramname">Size</td><td>is size of the data block to be processed </td></tr>
    <tr><td class="paramname">Last</td><td>notifies if the block to be processed is last or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XLOADER_ERR_PRTN_HASH_CALC_FAIL if failed to calculate hash for partition authentication.</li>
<li>XLOADER_ERR_PRTN_HASH_COMPARE_FAIL on partition comparison fail. </li>
</ul>
</dd></dl>
<p>Calculate Sha3 digest</p>
<p>Update the next expected hash and data location </p>

<p>References <a class="el" href="xloader_8h.html#a261fb4f12be9886db96079709efd1608">XLOADER_SHA3_LEN</a>.</p>

<p>Referenced by <a class="el" href="group__xloader__server__apis.html#gaa912487046c04b1c90ca418a19ac3e0d">XLoader_ProcessAuthEncPrtn()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga6102b4e4351f8aad6295633297a003a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile u8 XLoader_AuthJtagStatus::AuthFailCounter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter for failed attempts to authenticate JTAG. </p>

</div>
</div>
<a class="anchor" id="ga33cc0865fab2d4910de17341df9ee27a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile u8 XLoader_AuthJtagStatus::AuthFailCounterTmp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For temporal redundancy. </p>

</div>
</div>
<a class="anchor" id="ga1cdd4fc9cc85230700e3650a3ed49ee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLoader_AuthJtagStatus::JtagTimeOut</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timeout value set by user. </p>

</div>
</div>
<a class="anchor" id="ga369516f479da2d39dde2e936226ab71e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XLoader_AuthJtagStatus::JtagTimerEnabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable JTAG timer. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
	<p class="footer">&copy; Copyright 2015-2022 Xilinx, Inc. All Rights Reserved.</p>
	<p class="footer">&copy; Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.</p>
</div>
</body>
</html>
