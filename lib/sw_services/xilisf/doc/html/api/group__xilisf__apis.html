<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>xilisf: Library-APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="HTML_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xlogo_bg.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">xilisf
   </div>
   <div id="projectbrief">Xilinx Vitis Drivers API Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="globals.html"><span>APIs</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__xilisf__apis.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Library-APIs</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga501655dbcf851b69f07ab41b7fc3cceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga501655dbcf851b69f07ab41b7fc3cceb">XIsf_Initialize</a> (XIsf *InstancePtr, XIsf_Iface *SpiInstPtr, u8 SlaveSelect, u8 *WritePtr)</td></tr>
<tr class="memdesc:ga501655dbcf851b69f07ab41b7fc3cceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API when called initializes the SPI interface with default settings.  <a href="#ga501655dbcf851b69f07ab41b7fc3cceb"></a><br/></td></tr>
<tr class="separator:ga501655dbcf851b69f07ab41b7fc3cceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec145db288b28ebdab75b6cea5ca58b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#gaeec145db288b28ebdab75b6cea5ca58b">XIsf_GetStatus</a> (XIsf *InstancePtr, u8 *ReadPtr)</td></tr>
<tr class="memdesc:gaeec145db288b28ebdab75b6cea5ca58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the Serial Flash Status Register.  <a href="#gaeec145db288b28ebdab75b6cea5ca58b"></a><br/></td></tr>
<tr class="separator:gaeec145db288b28ebdab75b6cea5ca58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2edd016671a61c0a742870555b4465a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga2edd016671a61c0a742870555b4465a7">XIsf_GetDeviceInfo</a> (XIsf *InstancePtr, u8 *ReadPtr)</td></tr>
<tr class="memdesc:ga2edd016671a61c0a742870555b4465a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the Serial Flash Status Register 2.  <a href="#ga2edd016671a61c0a742870555b4465a7"></a><br/></td></tr>
<tr class="separator:ga2edd016671a61c0a742870555b4465a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4595fb70c718a30beea05f9874c8c594"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga4595fb70c718a30beea05f9874c8c594">GetRealAddr</a> (XIsf_Iface *QspiPtr, u32 Address)</td></tr>
<tr class="memdesc:ga4595fb70c718a30beea05f9874c8c594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the real address of flash in case dual parallel and stacked configuration.  <a href="#ga4595fb70c718a30beea05f9874c8c594"></a><br/></td></tr>
<tr class="separator:ga4595fb70c718a30beea05f9874c8c594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee23728cfef1b21f5e031ac81e8b387f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#gaee23728cfef1b21f5e031ac81e8b387f">XIsf_Write</a> (XIsf *InstancePtr, XIsf_WriteOperation Operation, void *OpParamPtr)</td></tr>
<tr class="memdesc:gaee23728cfef1b21f5e031ac81e8b387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API writes the data to the Serial Flash.  <a href="#gaee23728cfef1b21f5e031ac81e8b387f"></a><br/></td></tr>
<tr class="separator:gaee23728cfef1b21f5e031ac81e8b387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5792c32ab843ace26debcab557db5423"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga5792c32ab843ace26debcab557db5423">XIsf_Read</a> (XIsf *InstancePtr, XIsf_ReadOperation Operation, void *OpParamPtr)</td></tr>
<tr class="memdesc:ga5792c32ab843ace26debcab557db5423"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API reads the data from the Serial Flash.  <a href="#ga5792c32ab843ace26debcab557db5423"></a><br/></td></tr>
<tr class="separator:ga5792c32ab843ace26debcab557db5423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9e3398f964268a03ca4ba3372903b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga4b9e3398f964268a03ca4ba3372903b7">XIsf_Erase</a> (XIsf *InstancePtr, XIsf_EraseOperation Operation, u32 Address)</td></tr>
<tr class="memdesc:ga4b9e3398f964268a03ca4ba3372903b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API erases the contents of the specified memory in the Serial Flash.  <a href="#ga4b9e3398f964268a03ca4ba3372903b7"></a><br/></td></tr>
<tr class="separator:ga4b9e3398f964268a03ca4ba3372903b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea4c56fe65ddb7cd39e0842f3e517b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#gacea4c56fe65ddb7cd39e0842f3e517b8">XIsf_SectorProtect</a> (XIsf *InstancePtr, XIsf_SpOperation Operation, u8 *BufferPtr)</td></tr>
<tr class="memdesc:gacea4c56fe65ddb7cd39e0842f3e517b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used for performing Sector Protect related operations.  <a href="#gacea4c56fe65ddb7cd39e0842f3e517b8"></a><br/></td></tr>
<tr class="separator:gacea4c56fe65ddb7cd39e0842f3e517b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69a6725295448e81f1f93fd324887a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#gaa69a6725295448e81f1f93fd324887a1">XIsf_Ioctl</a> (XIsf *InstancePtr, XIsf_IoctlOperation Operation)</td></tr>
<tr class="memdesc:gaa69a6725295448e81f1f93fd324887a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures and controls the Intel, STM, Winbond and Spansion Serial Flash.  <a href="#gaa69a6725295448e81f1f93fd324887a1"></a><br/></td></tr>
<tr class="separator:gaa69a6725295448e81f1f93fd324887a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a762983b1b738d61316a3d95a60dfc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga9a762983b1b738d61316a3d95a60dfc6">XIsf_WriteEnable</a> (XIsf *InstancePtr, u8 WriteEnable)</td></tr>
<tr class="memdesc:ga9a762983b1b738d61316a3d95a60dfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API Enables/Disables writes to the Intel, STM, Winbond and Spansion Serial Flash.  <a href="#ga9a762983b1b738d61316a3d95a60dfc6"></a><br/></td></tr>
<tr class="separator:ga9a762983b1b738d61316a3d95a60dfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7ef14db6c7aed54633ba3a1269e570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga6c7ef14db6c7aed54633ba3a1269e570">XIsf_RegisterInterface</a> (XIsf *InstancePtr)</td></tr>
<tr class="memdesc:ga6c7ef14db6c7aed54633ba3a1269e570"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API registers the interface SPI/SPI PS/QSPI PS.  <a href="#ga6c7ef14db6c7aed54633ba3a1269e570"></a><br/></td></tr>
<tr class="separator:ga6c7ef14db6c7aed54633ba3a1269e570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d09baa6b0b3624a92fcf0804a98e3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga45d09baa6b0b3624a92fcf0804a98e3e">XIsf_SetSpiConfiguration</a> (XIsf *InstancePtr, XIsf_Iface *SpiInstPtr, u32 Options, u8 PreScaler)</td></tr>
<tr class="memdesc:ga45d09baa6b0b3624a92fcf0804a98e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API sets the configuration of SPI.  <a href="#ga45d09baa6b0b3624a92fcf0804a98e3e"></a><br/></td></tr>
<tr class="separator:ga45d09baa6b0b3624a92fcf0804a98e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b420adfdbfd092d01636cecb03ebe87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga0b420adfdbfd092d01636cecb03ebe87">XIsf_SetStatusHandler</a> (XIsf *InstancePtr, XIsf_Iface *XIfaceInstancePtr, XIsf_StatusHandler XilIsf_Handler)</td></tr>
<tr class="memdesc:ga0b420adfdbfd092d01636cecb03ebe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is to set the Status Handler when an interrupt is registered.  <a href="#ga0b420adfdbfd092d01636cecb03ebe87"></a><br/></td></tr>
<tr class="separator:ga0b420adfdbfd092d01636cecb03ebe87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2b2f839618eb2c9db8fbe73472ae79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xilisf__apis.html#ga5e2b2f839618eb2c9db8fbe73472ae79">XIsf_IfaceHandler</a> (void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)</td></tr>
<tr class="memdesc:ga5e2b2f839618eb2c9db8fbe73472ae79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is the handler which performs processing for the QSPI driver.  <a href="#ga5e2b2f839618eb2c9db8fbe73472ae79"></a><br/></td></tr>
<tr class="separator:ga5e2b2f839618eb2c9db8fbe73472ae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4595fb70c718a30beea05f9874c8c594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 GetRealAddr </td>
          <td>(</td>
          <td class="paramtype">XIsf_Iface *&#160;</td>
          <td class="paramname"><em>QspiPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the real address of flash in case dual parallel and stacked configuration. </p>
<p>Function to get the real address of flash in case dual parallel and stacked configuration.</p>
<p>This functions translates the address based on the type of interconnection. In case of stacked, this function asserts the corresponding slave select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">QspiPtr</td><td>is a pointer to XIsf_Iface instance to be worked on. </td></tr>
    <tr><td class="paramname">Address</td><td>which is to be accessed (for erase, write or read)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RealAddr is the translated address - for single it is unchanged for stacked, the lower flash size is subtracted for parallel the address is divided by 2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b9e3398f964268a03ca4ba3372903b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_Erase </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_EraseOperation&#160;</td>
          <td class="paramname"><em>Operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API erases the contents of the specified memory in the Serial Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">Operation</td><td>Type of Erase operation to be performed on the Serial Flash. The different operations are<ul>
<li>XISF_PAGE_ERASE: Page Erase</li>
<li>XISF_BLOCK_ERASE: Block Erase</li>
<li>XISF_SECTOR_ERASE: Sector Erase</li>
<li>XISF_BULK_ERASE: Bulk Erase </li>
</ul>
</td></tr>
    <tr><td class="paramname">Address</td><td>Address of the Page/Block/Sector to be erased. The address can be either Page address, Block address or Sector address based on the Erase operation to be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The erased bytes will read as 0xFF.</li>
<li>For Intel, STM, Winbond or Spansion Serial Flash the user application must call <a class="el" href="group__xilisf__apis.html#ga9a762983b1b738d61316a3d95a60dfc6" title="This API Enables/Disables writes to the Intel, STM, Winbond and Spansion Serial Flash.">XIsf_WriteEnable()</a> API by passing XISF_WRITE_ENABLE as an argument before calling <a class="el" href="group__xilisf__apis.html#ga4b9e3398f964268a03ca4ba3372903b7" title="This API erases the contents of the specified memory in the Serial Flash.">XIsf_Erase()</a> API.</li>
<li>Atmel Serial Flash support Page/Block/Sector Erase operations.</li>
<li>Intel, Winbond, Numonyx (N25QXX) and Spansion Serial Flash support Sector/Block/Bulk Erase operations.</li>
<li>STM (M25PXX) Serial Flash support Sector/Bulk Erase operations. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2edd016671a61c0a742870555b4465a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_GetDeviceInfo </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the Serial Flash Status Register 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">ReadPtr</td><td>Pointer to the memory where the Status Register content is copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The contents of the Status Register 2 is stored at the second byte pointed by the ReadPtr. This operation is available only in Winbond Serial Flash.</dd></dl>
<p>This API reads the Joint Electron Device Engineering Council (JEDEC) information of the Serial Flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">ReadPtr</td><td>Pointer to the buffer where the Device information is copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The Device information is stored at the second byte pointed by the ReadPtr. </dd></dl>

<p>References <a class="el" href="xilisf__atmel_8h.html#a3b1468d2755101d28e3b8e7a91109d2e">BYTE1</a>, <a class="el" href="xilisf__atmel_8h.html#a1cec78d40bc62e93813cc388997f654f">BYTE2</a>, <a class="el" href="xilisf__atmel_8h.html#afce866f3fde25d9e75d531b679c00213">BYTE3</a>, <a class="el" href="xilisf__atmel_8h.html#a91cb164747412f1fb75f5ab9c6c91fd2">BYTE4</a>, <a class="el" href="xilisf__atmel_8h.html#a9037d2e19fd39f4b87d7b2074050d9c1">BYTE5</a>, <a class="el" href="xilisf__atmel_8h.html#a29c6314904384a2be76ae1d2bac833e2">XISF_CMD_ISFINFO_READ</a>, <a class="el" href="xilisf__atmel_8h.html#a0e395ab356b1f0de88b97771862792b2">XISF_DUMMYBYTE</a>, and <a class="el" href="xilisf__atmel_8h.html#ad382b90e0eb14674af3e619e90b2e598">XISF_INFO_READ_BYTES</a>.</p>

<p>Referenced by <a class="el" href="group__xilisf__apis.html#ga501655dbcf851b69f07ab41b7fc3cceb">XIsf_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeec145db288b28ebdab75b6cea5ca58b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_GetStatus </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>ReadPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the Serial Flash Status Register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">ReadPtr</td><td>Pointer to the memory where the Status Register content is copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The contents of the Status Register is stored at second byte pointed by the ReadPtr. </dd></dl>

<p>References <a class="el" href="xilisf__atmel_8h.html#a3b1468d2755101d28e3b8e7a91109d2e">BYTE1</a>, <a class="el" href="xilisf__atmel_8h.html#a1cec78d40bc62e93813cc388997f654f">BYTE2</a>, <a class="el" href="xilisf__atmel_8h.html#a6b77685a687a89bdd396a60dca880b32">XISF_CMD_STATUSREG_READ</a>, <a class="el" href="xilisf__atmel_8h.html#a0e395ab356b1f0de88b97771862792b2">XISF_DUMMYBYTE</a>, and <a class="el" href="xilisf__atmel_8h.html#aebee4068fe4b374cd2ee01c57a7621b6">XISF_STATUS_RDWR_BYTES</a>.</p>

</div>
</div>
<a class="anchor" id="ga5e2b2f839618eb2c9db8fbe73472ae79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIsf_IfaceHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>StatusEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is the handler which performs processing for the QSPI driver. </p>
<p>It is called from an interrupt context such that the amount of processing performed should be minimized. It is called when a transfer of QSPI data completes or an error occurs.</p>
<p>This handler provides an example of how to handle QSPI interrupts but is application specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CallBackRef</td><td>Reference passed to the handler. </td></tr>
    <tr><td class="paramname">StatusEvent</td><td>Status of the QSPI . </td></tr>
    <tr><td class="paramname">ByteCount</td><td>Number of bytes transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="xilisf_8c.html#a10e91f1922dd5bc7da2e03c3e0e86d75">XIsf_TransferInProgress</a>.</p>

<p>Referenced by <a class="el" href="group__xilisf__apis.html#ga0b420adfdbfd092d01636cecb03ebe87">XIsf_SetStatusHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga501655dbcf851b69f07ab41b7fc3cceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_Initialize </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_Iface *&#160;</td>
          <td class="paramname"><em>SpiInstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>SlaveSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>WritePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API when called initializes the SPI interface with default settings. </p>
<p>With custom settings, user should call <a class="el" href="group__xilisf__apis.html#ga45d09baa6b0b3624a92fcf0804a98e3e" title="This API sets the configuration of SPI.">XIsf_SetSpiConfiguration()</a> and then call this API. The geometry of the underlying Serial Flash is determined by reading the Joint Electron Device Engineering Council (JEDEC) Device Information and the Status Register of the Serial Flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">SpiInstPtr</td><td>Pointer to XIsf_Iface instance to be worked on. </td></tr>
    <tr><td class="paramname">SlaveSelect</td><td>It is a 32-bit mask with a 1 in the bit position of slave being selected. Only one slave can be selected at a time. </td></tr>
    <tr><td class="paramname">WritePtr</td><td>Pointer to the buffer allocated by the user to be used by the In-system and Serial Flash Library to perform any read/write operations on the Serial Flash device. User applications must pass the address of this buffer for the Library to work.<ul>
<li>Write operations :<ul>
<li>The size of this buffer should be equal to the Number of bytes to be written to the Serial Flash + XISF_CMD_MAX_EXTRA_BYTES.</li>
<li>The size of this buffer should be large enough for usage across all the applications that use a common instance of the Serial Flash.</li>
<li>A minimum of one byte and a maximum of ISF_PAGE_SIZE bytes can be written to the Serial Flash, through a single Write operation.</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Read operations :<ul>
<li>The size of this buffer should be equal to XISF_CMD_MAX_EXTRA_BYTES, if the application only reads from the Serial Flash (no write operations).</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>- XST_SUCCESS if successful.<ul>
<li>XST_DEVICE_IS_STOPPED if the device must be started before transferring data.</li>
<li>XST_FAILURE, otherwise.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The <a class="el" href="group__xilisf__apis.html#ga501655dbcf851b69f07ab41b7fc3cceb" title="This API when called initializes the SPI interface with default settings.">XIsf_Initialize()</a> API is a blocking call (for both polled and interrupt modes of the Spi driver). It reads the JEDEC information of the device and waits till the transfer is complete before checking if the information is valid.<ul>
<li>This library can support multiple instances of Serial Flash at a time, provided they are of the same device family (either Atmel, Intel or STM, Winbond or Spansion) as the device family is selected at compile time. </li>
</ul>
</dd></dl>
<p>(((XPAR_XISF_FLASH_FAMILY==INTEL) || \ (XPAR_XISF_FLASH_FAMILY==STM) || \ (XPAR_XISF_FLASH_FAMILY == SST) || \ (XPAR_XISF_FLASH_FAMILY == WINBOND) || \ (XPAR_XISF_FLASH_FAMILY == SPANSION)) &amp;&amp; \ ((!defined(XPAR_XISF_INTERFACE_PSQSPI)) &amp;&amp; \ (!defined(XPAR_XISF_INTERFACE_QSPIPSU)) &amp;&amp; \ (!defined(XPAR_XISF_INTERFACE_OSPIPSV))))</p>
<p>(((XPAR_XISF_FLASH_FAMILY == WINBOND) || \ (XPAR_XISF_FLASH_FAMILY == SPANSION)) &amp;&amp; \ (defined(XPAR_XISF_INTERFACE_PSQSPI) || \ defined(XPAR_XISF_INTERFACE_QSPIPSU) || \ defined(XPAR_XISF_INTERFACE_OSPIPSV)))</p>

<p>References <a class="el" href="group__xilisf__apis.html#ga2edd016671a61c0a742870555b4465a7">XIsf_GetDeviceInfo()</a>, <a class="el" href="xilisf__atmel_8h.html#a12ce2c8d147eb18de52d620f9b23258a">XISF_INFO_EXTRA_BYTES</a>, <a class="el" href="xilisf__atmel_8h.html#ad382b90e0eb14674af3e619e90b2e598">XISF_INFO_READ_BYTES</a>, and <a class="el" href="group__xilisf__apis.html#ga45d09baa6b0b3624a92fcf0804a98e3e">XIsf_SetSpiConfiguration()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa69a6725295448e81f1f93fd324887a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_Ioctl </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_IoctlOperation&#160;</td>
          <td class="paramname"><em>Operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures and controls the Intel, STM, Winbond and Spansion Serial Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">Operation</td><td>Type of Control operation to be performed on the Serial Flash. The different control operations are<ul>
<li>XISF_RELEASE_DPD: Release from Deep Power Down (DPD) Mode</li>
<li>XISF_ENTER_DPD: Enter DPD Mode</li>
<li>XISF_CLEAR_SR_FAIL_FLAGS: Clear Status Register Fail Flags</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if i fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Atmel Serial Flash does not support any of these operations.</li>
<li>Intel Serial Flash support Enter/Release from DPD Mode and Clear Status Register Fail Flags.</li>
<li>STM, Winbond and Spansion Serial Flash support Enter/Release from DPD Mode.</li>
<li>Winbond (W25QXX) Serial Flash support Enable High Performance mode. </li>
</ul>
</dd></dl>
<p>((XPAR_XISF_FLASH_FAMILY==INTEL) || (XPAR_XISF_FLASH_FAMILY==STM) \ (XPAR_XISF_FLASH_FAMILY == WINBOND) || (XPAR_XISF_FLASH_FAMILY == SPANSION))</p>

<p>References <a class="el" href="xilisf__atmel_8h.html#a3b1468d2755101d28e3b8e7a91109d2e">BYTE1</a>, <a class="el" href="xilisf__intelstm_8h.html#a32650fdd1b94e902c3294c5cdede6c19">XISF_CMD_CLEAR_SRFAIL_FLAGS</a>, <a class="el" href="xilisf__intelstm_8h.html#a9d219ecf3440d15288fd18a44595b6c5">XISF_CMD_DEEP_POWER_DOWN</a>, <a class="el" href="xilisf__intelstm_8h.html#ad8fb67e203946c46d8c51661dfef4b6e">XISF_CMD_ENABLE_HPM</a>, <a class="el" href="xilisf__intelstm_8h.html#af126d304671617fe74d369cb59a26e28">XISF_CMD_RELEASE_FROM_DPD</a>, <a class="el" href="xilisf__intelstm_8h.html#ab136240beb6c6313f2f339ee77db4a69">XISF_HPM_BYTES</a>, and <a class="el" href="xilisf__intelstm_8h.html#a1008a3a37fcf48030b5d8cd92f4fec6d">XISF_IOCTL_BYTES</a>.</p>

</div>
</div>
<a class="anchor" id="ga5792c32ab843ace26debcab557db5423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_Read </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_ReadOperation&#160;</td>
          <td class="paramname"><em>Operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>OpParamPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API reads the data from the Serial Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">Operation</td><td>Type of the read operation to be performed on the Serial Flash. The different operations are<ul>
<li>XISF_READ: Normal Read</li>
<li>XISF_FAST_READ: Fast Read</li>
<li>XISF_PAGE_TO_BUF_TRANS: Page to Buffer Transfer</li>
<li>XISF_BUFFER_READ: Buffer Read</li>
<li>XISF_FAST_BUFFER_READ: Fast Buffer Read</li>
<li>XISF_OTP_READ: One Time Programmable Area (OTP) Read</li>
<li>XISF_DUAL_OP_FAST_READ: Dual Output Fast Read</li>
<li>XISF_DUAL_IO_FAST_READ: Dual Input/Output Fast Read</li>
<li>XISF_QUAD_OP_FAST_READ: Quad Output Fast Read</li>
<li>XISF_QUAD_IO_FAST_READ: Quad Input/Output Fast Read </li>
</ul>
</td></tr>
    <tr><td class="paramname">OpParamPtr</td><td>Pointer to structure variable which contains operational parameter of specified operation. This parameter type is dependent on the type of Operation to be performed.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Normal Read (XISF_READ), Fast Read (XISF_FAST_READ), One Time Programmable Area Read (XISF_OTP_READ), Dual Output Fast Read (XISF_CMD_DUAL_OP_FAST_READ), Dual Input/ Output Fast Read (XISF_CMD_DUAL_IO_FAST_READ), Quad Output Fast Read (XISF_CMD_QUAD_OP_FAST_READ) and Quad Input/ Output Fast Read (XISF_CMD_QUAD_IO_FAST_READ): The OpParamPtr must be of type struct XIsf_ReadParam. OpParamPtr-&gt;Address is start address in the Serial Flash. OpParamPtr-&gt;ReadPtr is a pointer to the memory where the data read from the Serial Flash is stored. OpParamPtr-&gt;NumBytes is number of bytes to read. OpParamPtr-&gt;NumDummyBytes is the number of dummy bytes to be transmitted for the Read command. This parameter is only used in case of Dual and Quad reads. Normal Read and Fast Read operations are supported for Atmel, Intel, STM, Winbond and Spansion Serial Flash. Dual and quad reads are supported for Winbond (W25QXX), Numonyx(N25QXX) and Spansion (S25FL129) quad flash. OTP Read operation is only supported in Intel Serial Flash.</li>
</ul>
<ul>
<li>Page To Buffer Transfer (XISF_PAGE_TO_BUF_TRANS): The OpParamPtr must be of type struct XIsf_FlashToBufTransferParam . OpParamPtr-&gt;BufferNum specifies the internal SRAM Buffer of the Serial Flash. The valid values are XISF_PAGE_BUFFER1 or XISF_PAGE_BUFFER2 XISF_PAGE_BUFFER2 is not valid in case of AT45DB011D Flash as it contains a single buffer. OpParamPtr-&gt;Address is start address in the Serial Flash. This operation is only supported in Atmel Serial Flash.</li>
</ul>
<ul>
<li>Buffer Read (XISF_BUFFER_READ) and Fast Buffer Read(XISF_FAST_BUFFER_READ): The OpParamPtr must be of type struct XIsf_BufferReadParam. OpParamPtr-&gt;BufferNum specifies the internal SRAM Buffer of the Serial Flash. The valid values are XISF_PAGE_BUFFER1 or XISF_PAGE_BUFFER2 XISF_PAGE_BUFFER2 is not valid in case of AT45DB011D Flash as it contains a single buffer. OpParamPtr-&gt;ReadPtr is pointer to the memory where data read from the SRAM buffer is to be stored. OpParamPtr-&gt;ByteOffset is byte offset in the SRAM buffer from where the first byte is read. OpParamPtr-&gt;NumBytes is the number of bytes to be read from the Buffer. These operations are supported only in Atmel Serial Flash.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Application must fill the structure elements of the third argument and pass its pointer by type casting it with void pointer.</li>
<li>The valid data is available from the fourth location pointed to by the ReadPtr for Normal Read and Buffer Read operations.</li>
<li>The valid data is available from fifth location pointed to by the ReadPtr for Fast Read, Fast Buffer Read and OTP Read operations.</li>
<li>The valid data is available from the (4 + NumDummyBytes)th location pointed to by ReadPtr for Dual/Quad Read operations. </li>
</ul>
</dd></dl>
<p>((XPAR_XISF_FLASH_FAMILY == WINBOND) || \ (XPAR_XISF_FLASH_FAMILY == STM) || \ (XPAR_XISF_FLASH_FAMILY == SPANSION))</p>

<p>References <a class="el" href="xilisf__intelstm_8h.html#afa2e1bd597d548b9105076e7b13e4848">XISF_CMD_DUAL_IO_FAST_READ</a>, <a class="el" href="xilisf__intelstm_8h.html#a95e8893ea838b79c20434f0577bd4e56">XISF_CMD_DUAL_OP_FAST_READ</a>, <a class="el" href="xilisf__atmel_8h.html#ab18fd8746b6fa6d1516fa9d552b9b6e6">XISF_CMD_FAST_READ</a>, <a class="el" href="xilisf__intelstm_8h.html#ae4f7c53176fb1726b5550a0b86ed27fb">XISF_CMD_FAST_READ_4BYTE</a>, <a class="el" href="xilisf__intelstm_8h.html#a4194c0ff05de1b351c85d695a187b91f">XISF_CMD_OCTAL_IO_FAST_READ_4B</a>, <a class="el" href="xilisf__intelstm_8h.html#a9f270982723beeb685d307530e4cf07f">XISF_CMD_QUAD_IO_FAST_READ</a>, <a class="el" href="xilisf__intelstm_8h.html#aca4e14378435ab482e16fa23ff33b414">XISF_CMD_QUAD_OP_FAST_READ</a>, and <a class="el" href="xilisf__intelstm_8h.html#a5e677c1d25e1cbaebaa4d41a2eaca219">XISF_CMD_VOLATILE_CONFIG_READ</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c7ef14db6c7aed54633ba3a1269e570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIsf_RegisterInterface </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API registers the interface SPI/SPI PS/QSPI PS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

<p>Referenced by <a class="el" href="group__xilisf__apis.html#ga45d09baa6b0b3624a92fcf0804a98e3e">XIsf_SetSpiConfiguration()</a>.</p>

</div>
</div>
<a class="anchor" id="gacea4c56fe65ddb7cd39e0842f3e517b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_SectorProtect </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_SpOperation&#160;</td>
          <td class="paramname"><em>Operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>BufferPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used for performing Sector Protect related operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">Operation</td><td>Type of Sector Protect operation to be performed on the Serial Flash. The different operations are<ul>
<li>XISF_SPR_READ: Read Sector Protection Register</li>
<li>XISF_SPR_WRITE: Write Sector Protection Register</li>
<li>XISF_SPR_ERASE: Erase Sector Protection Register</li>
<li>XISF_SP_ENABLE: Enable Sector Protection</li>
<li>XISF_SP_DISABLE: Disable Sector Protection </li>
</ul>
</td></tr>
    <tr><td class="paramname">BufferPtr</td><td>Pointer to the memory where the SPR content is read to/written from. This argument can be NULL if the Operation is SprErase, SpEnable and SpDisable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The SPR content is stored at the fourth location pointed by the BufferPtr when performing XISF_SPR_READ operation.</li>
<li>For Intel, STM, Winbond and Spansion Serial Flash, the user application must call the <a class="el" href="group__xilisf__apis.html#ga9a762983b1b738d61316a3d95a60dfc6" title="This API Enables/Disables writes to the Intel, STM, Winbond and Spansion Serial Flash.">XIsf_WriteEnable()</a> API by passing XISF_WRITE_ENABLE as an argument, before calling the <a class="el" href="group__xilisf__apis.html#gacea4c56fe65ddb7cd39e0842f3e517b8" title="This API is used for performing Sector Protect related operations.">XIsf_SectorProtect()</a> API, for Sector Protect Register Write (XISF_SPR_WRITE) operation.</li>
<li>Atmel Flash supports all these Sector Protect operations.</li>
<li>Intel, STM, Winbond and Spansion Flash support only Sector Protect Read and Sector Protect Write operations. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga45d09baa6b0b3624a92fcf0804a98e3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_SetSpiConfiguration </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_Iface *&#160;</td>
          <td class="paramname"><em>SpiInstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>Options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>PreScaler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API sets the configuration of SPI. </p>
<p>This will set the options and clock prescaler (if applicable).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">SpiInstPtr</td><td>Pointer to XIsf_Iface instance to be worked on. </td></tr>
    <tr><td class="paramname">Options</td><td>Specified options to be set. </td></tr>
    <tr><td class="paramname">PreScaler</td><td>Value of the clock prescaler to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API can be called before calling <a class="el" href="group__xilisf__apis.html#ga501655dbcf851b69f07ab41b7fc3cceb" title="This API when called initializes the SPI interface with default settings.">XIsf_Initialize()</a> to initialize the SPI interface in other than default options mode. PreScaler is only applicable to PS SPI/QSPI. </dd></dl>

<p>References <a class="el" href="group__xilisf__apis.html#ga6c7ef14db6c7aed54633ba3a1269e570">XIsf_RegisterInterface()</a>.</p>

<p>Referenced by <a class="el" href="group__xilisf__apis.html#ga501655dbcf851b69f07ab41b7fc3cceb">XIsf_Initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b420adfdbfd092d01636cecb03ebe87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIsf_SetStatusHandler </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_Iface *&#160;</td>
          <td class="paramname"><em>XIfaceInstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_StatusHandler&#160;</td>
          <td class="paramname"><em>XilIsf_Handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is to set the Status Handler when an interrupt is registered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf Instance. </td></tr>
    <tr><td class="paramname">XIfaceInstancePtr</td><td>Pointer to the XIsf_Iface instance to be worked on. </td></tr>
    <tr><td class="paramname">XilIsf_Handler</td><td>Status handler for the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__xilisf__apis.html#ga5e2b2f839618eb2c9db8fbe73472ae79">XIsf_IfaceHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="gaee23728cfef1b21f5e031ac81e8b387f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_Write </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XIsf_WriteOperation&#160;</td>
          <td class="paramname"><em>Operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>OpParamPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API writes the data to the Serial Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">Operation</td><td>Type of write operation to be performed on the Serial Flash. The different operations are<ul>
<li>XISF_WRITE: Normal Write</li>
<li>XISF_DUAL_IP_PAGE_WRITE: Dual Input Fast Program</li>
<li>XISF_DUAL_IP_EXT_PAGE_WRITE: Dual Input Extended Fast Program</li>
<li>XISF_QUAD_IP_PAGE_WRITE: Quad Input Fast Program</li>
<li>XISF_QUAD_IP_EXT_PAGE_WRITE: Quad Input Extended Fast Program</li>
<li>XISF_AUTO_PAGE_WRITE: Auto Page Write</li>
<li>XISF_BUFFER_WRITE: Buffer Write</li>
<li>XISF_BUF_TO_PAGE_WRITE_WITH_ERASE: Buffer to Page Transfer with Erase</li>
<li>XISF_BUF_TO_PAGE_WRITE_WITHOUT_ERASE: Buffer to Page Transfer without Erase</li>
<li>XISF_WRITE_STATUS_REG: Status Register Write</li>
<li>XISF_WRITE_STATUS_REG2: 2 byte Status Register Write</li>
<li>XISF_OTP_WRITE: OTP Write.</li>
</ul>
</td></tr>
    <tr><td class="paramname">OpParamPtr</td><td>Pointer to a structure variable which contains operational parameters of the specified operation. This parameter type is dependent on value of first argument(Operation).</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Normal Write(XISF_WRITE), Dual Input Fast Program (XISF_DUAL_IP_PAGE_WRITE), Dual Input Extended Fast Program(XISF_DUAL_IP_EXT_PAGE_WRITE), Quad Input Fast Program(XISF_QUAD_IP_PAGE_WRITE), Quad Input Extended Fast Program (XISF_QUAD_IP_EXT_PAGE_WRITE): The OpParamPtr must be of type struct XIsf_WriteParam. OpParamPtr-&gt;Address is the start address in the Serial Flash. OpParamPtr-&gt;WritePtr is a pointer to the data to be written to the Serial Flash. OpParamPtr-&gt;NumBytes is the number of bytes to be written to Serial Flash. This operation is supported for Atmel, Intel, STM, Winbond and Spansion Serial Flash.</li>
</ul>
<ul>
<li>Auto Page Write (XISF_AUTO_PAGE_WRITE): The OpParamPtr must be of 32 bit unsigned integer variable. This is the address of page number in the Serial Flash which is to be refreshed. This operation is only supported for Atmel Serial Flash.</li>
</ul>
<ul>
<li>Buffer Write (XISF_BUFFER_WRITE): The OpParamPtr must be of type struct XIsf_BufferToFlashWriteParam. OpParamPtr-&gt;BufferNum specifies the internal SRAM Buffer of the Serial Flash. The valid values are XISF_PAGE_BUFFER1 or XISF_PAGE_BUFFER2. XISF_PAGE_BUFFER2 is not valid in case of AT45DB011D Flash as it contains a single buffer. OpParamPtr-&gt;WritePtr is a pointer to the data to be written to the Serial Flash SRAM Buffer. OpParamPtr-&gt;ByteOffset is byte offset in the buffer from where the data is to be written. OpParamPtr-&gt;NumBytes is number of bytes to be written to the Buffer. This operation is supported only for Atmel Serial Flash.</li>
</ul>
<ul>
<li>Buffer To Memory Write With Erase (XISF_BUF_TO_PAGE_WRITE_WITH_ERASE)/ Buffer To Memory Write Without Erase (XISF_BUF_TO_PAGE_WRITE_WITHOUT_ERASE): The OpParamPtr must be of type struct XIsf_BufferToFlashWriteParam. OpParamPtr-&gt;BufferNum specifies the internal SRAM Buffer of the Serial Flash. The valid values are XISF_PAGE_BUFFER1 or XISF_PAGE_BUFFER2. XISF_PAGE_BUFFER2 is not valid in case of AT45DB011D Flash as it contains a single buffer. OpParamPtr-&gt;Address is starting address in the Serial Flash memory from where the data is to be written. These operations are only supported for Atmel Serial Flash.</li>
</ul>
<ul>
<li>Write Status Register (XISF_WRITE_STATUS_REG): The OpParamPtr must be of type of 8 bit unsigned integer variable. This is the value to be written to the Status Register. This operation is only supported for Intel, STM Winbond and Spansion Serial Flash.</li>
</ul>
<ul>
<li>Write Status Register2 (XISF_WRITE_STATUS_REG2): The OpParamPtr must be of type (u8 *) and should point to two 8 bit unsigned integer values. This is the value to be written to the 16 bit Status Register. This operation is only supported in Winbond (W25Q) Serial Flash.</li>
</ul>
<ul>
<li>One Time Programmable Area Write(XISF_OTP_WRITE): The OpParamPtr must be of type struct XIsf_WriteParam. OpParamPtr-&gt;Address is the address in the SRAM Buffer of the Serial Flash to which the data is to be written. OpParamPtr-&gt;WritePtr is a pointer to the data to be written to the Serial Flash. OpParamPtr-&gt;NumBytes should be set to 1 when performing OTPWrite operation. This operation is only supported for Intel Serial Flash.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Application must fill the structure elements of the third argument and pass its pointer by type casting it with void pointer.</li>
<li>For Intel, STM, Winbond and Spansion Serial Flash, the user application must call the <a class="el" href="group__xilisf__apis.html#ga9a762983b1b738d61316a3d95a60dfc6" title="This API Enables/Disables writes to the Intel, STM, Winbond and Spansion Serial Flash.">XIsf_WriteEnable()</a> API by passing XISF_WRITE_ENABLE as an argument, before calling the <a class="el" href="group__xilisf__apis.html#gaee23728cfef1b21f5e031ac81e8b387f" title="This API writes the data to the Serial Flash.">XIsf_Write()</a> API. </li>
</ul>
</dd></dl>
<p>(((XPAR_XISF_FLASH_FAMILY == WINBOND) || \ (XPAR_XISF_FLASH_FAMILY == STM) || \ (XPAR_XISF_FLASH_FAMILY == SPANSION)) &amp;&amp; \ (!defined(XPAR_XISF_INTERFACE_OSPIPSV)))</p>

<p>References <a class="el" href="xilisf__intelstm_8h.html#a5c5b597614a7d6ee3434c2f72dc0604c">XISF_CMD_DUAL_IP_EXT_PAGE_WRITE</a>, <a class="el" href="xilisf__intelstm_8h.html#a753d9453ec5b68a314315890d0f872f3">XISF_CMD_DUAL_IP_PAGE_WRITE</a>, <a class="el" href="xilisf__intelstm_8h.html#aa2c14a39348152dc1fd34c43cc3640e1">XISF_CMD_OCTAL_WRITE_4B</a>, <a class="el" href="xilisf__atmel_8h.html#a4f4a62cf9ce936a9045d24c3403a6f60">XISF_CMD_PAGEPROG_WRITE</a>, <a class="el" href="xilisf__intelstm_8h.html#a5580676f364b3e27d7bca2866460e63c">XISF_CMD_PAGEPROG_WRITE_4BYTE</a>, <a class="el" href="xilisf__intelstm_8h.html#a00c81ca3ed163cadec419a5b761af9b0">XISF_CMD_QUAD_IP_EXT_PAGE_WRITE</a>, <a class="el" href="xilisf__intelstm_8h.html#a7e2e075a267a575f8c4eabff0a5a3499">XISF_CMD_QUAD_IP_PAGE_WRITE</a>, and <a class="el" href="xilisf__intelstm_8h.html#adbb00d92bd7f574faacf2037e988720c">XISF_CMD_VOLATILE_CONFIG_WRITE</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a762983b1b738d61316a3d95a60dfc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIsf_WriteEnable </td>
          <td>(</td>
          <td class="paramtype">XIsf *&#160;</td>
          <td class="paramname"><em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>WriteEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API Enables/Disables writes to the Intel, STM, Winbond and Spansion Serial Flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InstancePtr</td><td>Pointer to the XIsf instance. </td></tr>
    <tr><td class="paramname">WriteEnable</td><td>Specifies whether to Enable (XISF_CMD_ENABLE_WRITE) or Disable (XISF_CMD_DISABLE_WRITE) the writes to the Serial Flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if it fails.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API works only for Intel, STM, Winbond and Spansion Serial Flash. If this API is called for Atmel Flash, XST_FAILURE is returned. </dd></dl>
<p>((XPAR_XISF_FLASH_FAMILY==INTEL) || (XPAR_XISF_FLASH_FAMILY==STM) \ (XPAR_XISF_FLASH_FAMILY == WINBOND) || \ (XPAR_XISF_FLASH_FAMILY == SPANSION) || \ (XPAR_XISF_FLASH_FAMILY == SST))</p>

<p>References <a class="el" href="xilisf__atmel_8h.html#a3b1468d2755101d28e3b8e7a91109d2e">BYTE1</a>, <a class="el" href="xilisf__intelstm_8h.html#a691790532a47bc0bab480a9c6ee42ce9">XISF_CMD_DISABLE_WRITE</a>, <a class="el" href="xilisf__intelstm_8h.html#a507146f604c78581da09c484d9c7253f">XISF_CMD_ENABLE_WRITE</a>, <a class="el" href="xilisf__intelstm_8h.html#af322b5f8672d0fd747e8ec256a07b45f">XISF_CMD_WRITE_ENABLE_DISABLE_BYTES</a>, <a class="el" href="xilisf__intelstm_8h.html#a0e1608a118503bcf703545ecb7bebc1d">XISF_WRITE_DISABLE</a>, and <a class="el" href="xilisf__intelstm_8h.html#a2d2043bd48995d8f5bb027bac06dd1fa">XISF_WRITE_ENABLE</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Copyright &copy; 2015 Xilinx Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
